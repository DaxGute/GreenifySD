var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name4 in all)
    __defProp(target, name4, { get: all[name4], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key2 of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key2) && key2 !== "default")
        __defProp(target, key2, { get: () => module2[key2], enumerable: !(desc = __getOwnPropDesc(module2, key2)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var import_node_fs, import_node_path, import_node_worker_threads, import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    import_node_fs = __toModule(require("node:fs"));
    import_node_path = __toModule(require("node:path"));
    import_node_worker_threads = __toModule(require("node:worker_threads"));
    init_install_fetch();
    import_node_http = __toModule(require("node:http"));
    import_node_https = __toModule(require("node:https"));
    import_node_zlib = __toModule(require("node:zlib"));
    import_node_stream = __toModule(require("node:stream"));
    import_node_util = __toModule(require("node:util"));
    import_node_url = __toModule(require("node:url"));
    import_net = __toModule(require("net"));
    globalThis.DOMException || (() => {
      const port2 = new import_node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port2.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name4) => {
          this[name4 + "Mark"] = i2;
        };
        const clear = (name4) => {
          delete this[name4 + "Mark"];
        };
        const callback = (callbackSymbol, start, end, ui8a) => {
          if (start === void 0 || start !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start, end));
          }
        };
        const dataCallback = (name4, clear2) => {
          const markSymbol = name4 + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name4, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name4, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index;
              if (index === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("onPartData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base643 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base643 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base643 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream2.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index, array) => {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name4, value]) => {
    try {
      validateHeaderName(name4);
      validateHeaderValue(name4, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net2.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https2.default : import_node_http2.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream2.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s3) => {
        let endedWithEventsCount;
        s3.prependListener("end", () => {
          endedWithEventsCount = s3._eventsCount;
        });
        s3.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s3._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream2.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib2.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib2.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createGunzip(zlibOptions), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream2.pipeline)(response_, new import_node_stream2.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflate(), reject) : (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createInflateRaw(), reject);
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream2.pipeline)(body, import_node_zlib2.default.createBrotliDecompress(), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
function installFetch() {
  Object.defineProperties(globalThis, {
    fetch: {
      enumerable: true,
      configurable: true,
      value: fetch2
    },
    Response: {
      enumerable: true,
      configurable: true,
      value: Response2
    },
    Request: {
      enumerable: true,
      configurable: true,
      value: Request2
    },
    Headers: {
      enumerable: true,
      configurable: true,
      value: Headers2
    }
  });
}
var import_node_http2, import_node_https2, import_node_zlib2, import_node_stream2, import_node_util2, import_node_url2, import_net2, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob3, Blob$1, _File, File, t, i, h, r, m, f2, e, x, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers2, redirectStatus, isRedirect, INTERNALS$1, Response2, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request2, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    import_node_http2 = __toModule(require("node:http"));
    import_node_https2 = __toModule(require("node:https"));
    import_node_zlib2 = __toModule(require("node:zlib"));
    import_node_stream2 = __toModule(require("node:stream"));
    import_node_util2 = __toModule(require("node:util"));
    import_node_url2 = __toModule(require("node:url"));
    import_net2 = __toModule(require("net"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports2) {
      (function(global2, factory) {
        factory(exports2);
      })(commonjsGlobal, function(exports3) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop3() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        const rethrowAssertionErrorRejection = noop3;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name4) {
          return new TypeError("Cannot " + name4 + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x2) {
          return typeof x2 === "number" && isFinite(x2);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x2) {
          return typeof x2 === "object" || typeof x2 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x2, context) {
          if (typeof x2 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject2(x2) {
          return typeof x2 === "object" && x2 !== null || typeof x2 === "function";
        }
        function assertObject(x2, context) {
          if (!isObject2(x2)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x2, position, context) {
          if (x2 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x2, field, context) {
          if (x2 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x2) {
          return x2 === 0 ? 0 : x2;
        }
        function integerPart(x2) {
          return censorNegativeZero(MathTrunc(x2));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x2 = Number(value);
          x2 = censorNegativeZero(x2);
          if (!NumberIsFinite(x2)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x2 = integerPart(x2);
          if (x2 < lowerBound || x2 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x2) || x2 === 0) {
            return 0;
          }
          return x2;
        }
        function assertReadableStream(x2, context) {
          if (!IsReadableStream(x2)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name4) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name4} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name4) {
          return new TypeError(`ReadableStreamAsyncIterator.${name4} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x2) {
          return x2 !== x2;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry4 = this._queue.shift();
              this._queueTotalSize -= entry4.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry4.buffer, entry4.byteOffset, entry4.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableByteStream")) {
            return false;
          }
          return x2 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableByteStreamControllerError(controller, e2);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              readIntoRequest._errorSteps(e2);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e2);
              throw e2;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e2) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name4) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name4} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name4) {
          return new TypeError(`ReadableByteStreamController.prototype.${name4} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e2) => rejectPromise(e2)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readIntoRequests")) {
            return false;
          }
          return x2 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name4) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name4} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x2, context) {
          if (!IsWritableStream(x2)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_writableStreamController")) {
            return false;
          }
          return x2 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_ownerWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e2 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e2);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledWritableStream")) {
            return false;
          }
          return x2 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name4) {
          return new TypeError(`WritableStream.prototype.${name4} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name4) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name4} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name4) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name4} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name4) {
          return new TypeError("Cannot " + name4 + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name4) {
            this.message = message || "";
            this.name = name4 || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop3);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e2 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e2);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledReadableStream")) {
            return false;
          }
          return x2 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e2) => {
            ReadableStreamDefaultControllerError(controller, e2);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e2) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e2);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name4) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name4} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options, context) {
          assertDictionary(options, context);
          const mode = options === null || options === void 0 ? void 0 : options.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options, context) {
          assertDictionary(options, context);
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options, context) {
          assertDictionary(options, context);
          const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
          const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
          const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
          const signal = options === null || options === void 0 ? void 0 : options.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable2 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable2, "readable", "ReadableWritablePair");
          assertReadableStream(readable2, `${context} has member 'readable' that`);
          const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable2, "writable", "ReadableWritablePair");
          assertWritableStream(writable2, `${context} has member 'writable' that`);
          return { readable: readable2, writable: writable2 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e2) {
              return promiseRejectedWith(e2);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_readableStreamController")) {
            return false;
          }
          return x2 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop3);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e2) {
          stream._state = "errored";
          stream._storedError = e2;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e2);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e2);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e2);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name4) {
          return new TypeError(`ReadableStream.prototype.${name4} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name4) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name4} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name4) {
          return new TypeError(`CountQueuingStrategy.prototype.${name4} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x2 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_transformStreamController")) {
            return false;
          }
          return x2 instanceof TransformStream;
        }
        function TransformStreamError(stream, e2) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e2);
          TransformStreamErrorWritableAndUnblockWrite(stream, e2);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e2) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e2);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x2) {
          if (!typeIsObject(x2)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x2, "_controlledTransformStream")) {
            return false;
          }
          return x2 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e2) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e2);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e2) {
          TransformStreamError(controller._controlledTransformStream, e2);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable2 = stream._writable;
              const state = writable2._state;
              if (state === "erroring") {
                throw writable2._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable2 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable2._state === "errored") {
              throw readable2._storedError;
            }
            ReadableStreamDefaultControllerClose(readable2._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable2._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name4) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name4} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name4) {
          return new TypeError(`TransformStream.prototype.${name4} can only be used on a TransformStream`);
        }
        exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports3.CountQueuingStrategy = CountQueuingStrategy;
        exports3.ReadableByteStreamController = ReadableByteStreamController;
        exports3.ReadableStream = ReadableStream2;
        exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports3.TransformStream = TransformStream;
        exports3.TransformStreamDefaultController = TransformStreamDefaultController;
        exports3.WritableStream = WritableStream;
        exports3.WritableStreamDefaultController = WritableStreamDefaultController;
        exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("node:process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("node:stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob4 } = require("buffer");
      if (Blob4 && !Blob4.prototype.stream) {
        Blob4.prototype.stream = function name4(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob2 {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options = {}) {
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && typeof options !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options === null)
          options = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob2) {
            part = element;
          } else {
            part = encoder2.encode(element);
          }
          this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          this.#parts.push(part);
        }
        const type = options.type === void 0 ? "" : String(options.type);
        this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob2([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob3 = _Blob;
    Blob$1 = Blob3;
    _File = class File2 extends Blob$1 {
      #lastModified = 0;
      #name = "";
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options);
        if (options === null)
          options = {};
        const lastModified = options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
          this.#lastModified = lastModified;
        }
        this.#name = String(fileName);
      }
      get name() {
        return this.#name;
      }
      get lastModified() {
        return this.#lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e2) => {
      if (a.length < e2) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = class FormData2 {
      #d = [];
      constructor(...a) {
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        this.#d.push(f2(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        this.#d = this.#d.filter(([b]) => b !== a);
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = this.#d, l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        this.#d.forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return this.#d.some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f2(...a);
        this.#d.forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        this.#d = b;
      }
      *entries() {
        yield* this.#d;
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    };
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return object && typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util2.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream2.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream2.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream2.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream2.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name4, value] of parameters) {
            formData.append(name4, value);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util2.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream2.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream2.PassThrough({ highWaterMark });
        p2 = new import_node_stream2.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util2.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util2.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream2.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http2.default.validateHeaderName === "function" ? import_node_http2.default.validateHeaderName : (name4) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name4)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name4}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http2.default.validateHeaderValue === "function" ? import_node_http2.default.validateHeaderValue : (name4, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name4}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers2 = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers2) {
          const raw = init2.raw();
          for (const [name4, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name4, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_node_util2.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_node_util2.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name4, value]) => {
          validateHeaderName(name4);
          validateHeaderValue(name4, String(value));
          return [String(name4).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name4, value) => {
                  validateHeaderName(name4);
                  validateHeaderValue(name4, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name4).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name4) => {
                  validateHeaderName(name4);
                  return URLSearchParams.prototype[p].call(target, String(name4).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name4) {
        const values = this.getAll(name4);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name4)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name4 of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name4), name4, this]);
        }
      }
      *values() {
        for (const name4 of this.keys()) {
          yield this.get(name4);
        }
      }
      *entries() {
        for (const name4 of this.keys()) {
          yield [name4, this.get(name4)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key2) => {
          result[key2] = this.getAll(key2);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key2) => {
          const values = this.getAll(key2);
          if (key2 === "host") {
            result[key2] = values[0];
          } else {
            result[key2] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response2 = class extends Body {
      constructor(body = null, options = {}) {
        super(body, options);
        const status = options.status != null ? options.status : 200;
        const headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter,
          highWaterMark: options.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response2(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request2 = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers2(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init2.referrer == null ? input.referrer : init2.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url2.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "node_modules/negotiator/lib/charset.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i2 = 0, j = 0; i2 < accepts.length; i2++) {
        var charset = parseCharset(accepts[i2].trim(), i2);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseCharset(str, i2) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match)
        return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i: i2
      };
    }
    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify(charset, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(charset, spec, index) {
      var s3 = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s3 |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s3
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/negotiator/lib/encoding.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i2 = 0, j = 0; i2 < accepts.length; i2++) {
        var encoding = parseEncoding(accepts[i2].trim(), i2);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i: i2
        };
      }
      accepts.length = j;
      return accepts;
    }
    function parseEncoding(str, i2) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match)
        return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i: i2
      };
    }
    function getEncodingPriority(encoding, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify(encoding, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(encoding, spec, index) {
      var s3 = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s3 |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s3
      };
    }
    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS({
  "node_modules/negotiator/lib/language.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i2 = 0, j = 0; i2 < accepts.length; i2++) {
        var language = parseLanguage(accepts[i2].trim(), i2);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseLanguage(str, i2) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match)
        return null;
      var prefix = match[1];
      var suffix = match[2];
      var full = prefix;
      if (suffix)
        full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q")
            q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i: i2,
        full
      };
    }
    function getLanguagePriority(language, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify(language, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p)
        return null;
      var s3 = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s3 |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s3 |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s3 |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s3
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "node_modules/negotiator/lib/mediaType.js"(exports2, module2) {
    "use strict";
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i2 = 0, j = 0; i2 < accepts.length; i2++) {
        var mediaType = parseMediaType(accepts[i2].trim(), i2);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    function parseMediaType(str, i2) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match)
        return null;
      var params = Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key2 = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
          if (key2 === "q") {
            q = parseFloat(value);
            break;
          }
          params[key2] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q,
        i: i2
      };
    }
    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify(type, accepted[i2], index);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s3 = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s3 |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s3 |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s3 |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s3
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType2(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string) {
      var count = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key2;
      var val;
      if (index === -1) {
        key2 = str;
      } else {
        key2 = str.substr(0, index);
        val = str.substr(index + 1);
      }
      return [key2, val];
    }
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i2 = 1, j = 0; i2 < accepts.length; i2++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i2];
        } else {
          accepts[j] += "," + accepts[i2];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i2 = 1, j = 0; i2 < parameters.length; i2++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i2];
        } else {
          parameters[j] += ";" + parameters[i2];
        }
      }
      parameters.length = j + 1;
      for (var i2 = 0; i2 < parameters.length; i2++) {
        parameters[i2] = parameters[i2].trim();
      }
      return parameters;
    }
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "node_modules/negotiator/index.js"(exports2, module2) {
    "use strict";
    var preferredCharsets = require_charset();
    var preferredEncodings = require_encoding();
    var preferredLanguages = require_language();
    var preferredMediaTypes = require_mediaType();
    module2.exports = Negotiator;
    module2.exports.Negotiator = Negotiator;
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
      this.request = request;
    }
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers["accept-charset"], available);
    };
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    Negotiator.prototype.encodings = function encodings(available) {
      return preferredEncodings(this.request.headers["accept-encoding"], available);
    };
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers["accept-language"], available);
    };
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = Object.create(null);
    exports2.lookup = lookup;
    exports2.types = Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type;
        }
      });
    }
  }
});

// node_modules/accepts/index.js
var require_accepts = __commonJS({
  "node_modules/accepts/index.js"(exports2, module2) {
    "use strict";
    var Negotiator = require_negotiator();
    var mime = require_mime_types();
    module2.exports = Accepts;
    function Accepts(req) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req);
      }
      this.headers = req.headers;
      this.negotiator = new Negotiator(req);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
      var types2 = types_;
      if (types2 && !Array.isArray(types2)) {
        types2 = new Array(arguments.length);
        for (var i2 = 0; i2 < types2.length; i2++) {
          types2[i2] = arguments[i2];
        }
      }
      if (!types2 || types2.length === 0) {
        return this.negotiator.mediaTypes();
      }
      if (!this.headers.accept) {
        return types2[0];
      }
      var mimes = types2.map(extToMime);
      var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      return first ? types2[mimes.indexOf(first)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
      var encodings = encodings_;
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (var i2 = 0; i2 < encodings.length; i2++) {
          encodings[i2] = arguments[i2];
        }
      }
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }
      return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
      var charsets = charsets_;
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (var i2 = 0; i2 < charsets.length; i2++) {
          charsets[i2] = arguments[i2];
        }
      }
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }
      return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
      var languages = languages_;
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for (var i2 = 0; i2 < languages.length; i2++) {
          languages[i2] = arguments[i2];
        }
      }
      if (!languages || languages.length === 0) {
        return this.negotiator.languages();
      }
      return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
      return typeof type === "string";
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/compression/node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/compression/node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes;
    module2.exports.format = format2;
    module2.exports.parse = parse3;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: (1 << 30) * 1024
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;
    function bytes(value, options) {
      if (typeof value === "string") {
        return parse3(value);
      }
      if (typeof value === "number") {
        return format2(value, options);
      }
      return null;
    }
    function format2(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse3(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/compressible/index.js
var require_compressible = __commonJS({
  "node_modules/compressible/index.js"(exports2, module2) {
    "use strict";
    var db = require_mime_db();
    var COMPRESSIBLE_TYPE_REGEXP = /^text\/|\+(?:json|text|xml)$/i;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    module2.exports = compressible;
    function compressible(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && match[1].toLowerCase();
      var data = db[mime];
      if (data && data.compressible !== void 0) {
        return data.compressible;
      }
      return COMPRESSIBLE_TYPE_REGEXP.test(mime) || void 0;
    }
  }
});

// node_modules/compression/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/compression/node_modules/ms/index.js"(exports2, module2) {
    var s3 = 1e3;
    var m2 = s3 * 60;
    var h2 = m2 * 60;
    var d = h2 * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (ms >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (ms >= s3) {
        return Math.round(ms / s3) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h2, "hour") || plural(ms, m2, "minute") || plural(ms, s3, "second") || ms + " ms";
    }
    function plural(ms, n, name4) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name4;
      }
      return Math.ceil(ms / n) + " " + name4 + "s";
    }
  }
});

// node_modules/compression/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/compression/node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i2;
      for (i2 in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return exports2.colors[Math.abs(hash2) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format2];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i2 = 0; i2 < len; i2++) {
        if (!split[i2])
          continue;
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name4) {
      var i2, len;
      for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
        if (exports2.skips[i2].test(name4)) {
          return false;
        }
      }
      for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
        if (exports2.names[i2].test(name4)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/compression/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/compression/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e2) {
      }
    }
    function load2() {
      var r2;
      try {
        r2 = exports2.storage.debug;
      } catch (e2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    exports2.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e2) {
      }
    }
  }
});

// node_modules/compression/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/compression/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key2) {
      return /^debug_/i.test(key2);
    }).reduce(function(obj, key2) {
      var prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name4 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name4 + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name4 + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    exports2.enable(load2());
  }
});

// node_modules/compression/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/compression/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/on-headers/index.js
var require_on_headers = __commonJS({
  "node_modules/on-headers/index.js"(exports2, module2) {
    "use strict";
    module2.exports = onHeaders;
    function createWriteHead(prevWriteHead, listener) {
      var fired = false;
      return function writeHead(statusCode) {
        var args = setWriteHeadHeaders.apply(this, arguments);
        if (!fired) {
          fired = true;
          listener.call(this);
          if (typeof args[0] === "number" && this.statusCode !== args[0]) {
            args[0] = this.statusCode;
            args.length = 1;
          }
        }
        return prevWriteHead.apply(this, args);
      };
    }
    function onHeaders(res, listener) {
      if (!res) {
        throw new TypeError("argument res is required");
      }
      if (typeof listener !== "function") {
        throw new TypeError("argument listener must be a function");
      }
      res.writeHead = createWriteHead(res.writeHead, listener);
    }
    function setHeadersFromArray(res, headers) {
      for (var i2 = 0; i2 < headers.length; i2++) {
        res.setHeader(headers[i2][0], headers[i2][1]);
      }
    }
    function setHeadersFromObject(res, headers) {
      var keys = Object.keys(headers);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var k = keys[i2];
        if (k)
          res.setHeader(k, headers[k]);
      }
    }
    function setWriteHeadHeaders(statusCode) {
      var length = arguments.length;
      var headerIndex = length > 1 && typeof arguments[1] === "string" ? 2 : 1;
      var headers = length >= headerIndex + 1 ? arguments[headerIndex] : void 0;
      this.statusCode = statusCode;
      if (Array.isArray(headers)) {
        setHeadersFromArray(this, headers);
      } else if (headers) {
        setHeadersFromObject(this, headers);
      }
      var args = new Array(Math.min(length, headerIndex));
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      return args;
    }
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS({
  "node_modules/vary/index.js"(exports2, module2) {
    "use strict";
    module2.exports = vary;
    module2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse3(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse3(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i2 = 0; i2 < fields.length; i2++) {
        var fld = fields[i2].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i2] : fields[i2];
        }
      }
      return val;
    }
    function parse3(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i2 = 0, len = header.length; i2 < len; i2++) {
        switch (header.charCodeAt(i2)) {
          case 32:
            if (start === end) {
              start = end = i2 + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i2 + 1;
            break;
          default:
            end = i2 + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// node_modules/compression/index.js
var require_compression = __commonJS({
  "node_modules/compression/index.js"(exports2, module2) {
    "use strict";
    var accepts = require_accepts();
    var Buffer2 = require_safe_buffer().Buffer;
    var bytes = require_bytes();
    var compressible = require_compressible();
    var debug = require_src()("compression");
    var onHeaders = require_on_headers();
    var vary = require_vary();
    var zlib2 = require("zlib");
    module2.exports = compression2;
    module2.exports.filter = shouldCompress;
    var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;
    function compression2(options) {
      var opts = options || {};
      var filter = opts.filter || shouldCompress;
      var threshold = bytes.parse(opts.threshold);
      if (threshold == null) {
        threshold = 1024;
      }
      return function compression3(req, res, next) {
        var ended = false;
        var length;
        var listeners = [];
        var stream;
        var _end = res.end;
        var _on = res.on;
        var _write = res.write;
        res.flush = function flush() {
          if (stream) {
            stream.flush();
          }
        };
        res.write = function write(chunk, encoding) {
          if (ended) {
            return false;
          }
          if (!this._header) {
            this._implicitHeader();
          }
          return stream ? stream.write(toBuffer(chunk, encoding)) : _write.call(this, chunk, encoding);
        };
        res.end = function end(chunk, encoding) {
          if (ended) {
            return false;
          }
          if (!this._header) {
            if (!this.getHeader("Content-Length")) {
              length = chunkLength(chunk, encoding);
            }
            this._implicitHeader();
          }
          if (!stream) {
            return _end.call(this, chunk, encoding);
          }
          ended = true;
          return chunk ? stream.end(toBuffer(chunk, encoding)) : stream.end();
        };
        res.on = function on(type, listener) {
          if (!listeners || type !== "drain") {
            return _on.call(this, type, listener);
          }
          if (stream) {
            return stream.on(type, listener);
          }
          listeners.push([type, listener]);
          return this;
        };
        function nocompress(msg) {
          debug("no compression: %s", msg);
          addListeners(res, _on, listeners);
          listeners = null;
        }
        onHeaders(res, function onResponseHeaders() {
          if (!filter(req, res)) {
            nocompress("filtered");
            return;
          }
          if (!shouldTransform(req, res)) {
            nocompress("no transform");
            return;
          }
          vary(res, "Accept-Encoding");
          if (Number(res.getHeader("Content-Length")) < threshold || length < threshold) {
            nocompress("size below threshold");
            return;
          }
          var encoding = res.getHeader("Content-Encoding") || "identity";
          if (encoding !== "identity") {
            nocompress("already encoded");
            return;
          }
          if (req.method === "HEAD") {
            nocompress("HEAD request");
            return;
          }
          var accept = accepts(req);
          var method = accept.encoding(["gzip", "deflate", "identity"]);
          if (method === "deflate" && accept.encoding(["gzip"])) {
            method = accept.encoding(["gzip", "identity"]);
          }
          if (!method || method === "identity") {
            nocompress("not acceptable");
            return;
          }
          debug("%s compression", method);
          stream = method === "gzip" ? zlib2.createGzip(opts) : zlib2.createDeflate(opts);
          addListeners(stream, stream.on, listeners);
          res.setHeader("Content-Encoding", method);
          res.removeHeader("Content-Length");
          stream.on("data", function onStreamData(chunk) {
            if (_write.call(res, chunk) === false) {
              stream.pause();
            }
          });
          stream.on("end", function onStreamEnd() {
            _end.call(res);
          });
          _on.call(res, "drain", function onResponseDrain() {
            stream.resume();
          });
        });
        next();
      };
    }
    function addListeners(stream, on, listeners) {
      for (var i2 = 0; i2 < listeners.length; i2++) {
        on.apply(stream, listeners[i2]);
      }
    }
    function chunkLength(chunk, encoding) {
      if (!chunk) {
        return 0;
      }
      return !Buffer2.isBuffer(chunk) ? Buffer2.byteLength(chunk, encoding) : chunk.length;
    }
    function shouldCompress(req, res) {
      var type = res.getHeader("Content-Type");
      if (type === void 0 || !compressible(type)) {
        debug("%s not compressible", type);
        return false;
      }
      return true;
    }
    function shouldTransform(req, res) {
      var cacheControl = res.getHeader("Cache-Control");
      return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);
    }
    function toBuffer(chunk, encoding) {
      return !Buffer2.isBuffer(chunk) ? Buffer2.from(chunk, encoding) : chunk;
    }
  }
});

// .svelte-kit/output/server/chunks/index-1e54ea6c.js
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
}
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function validate_component(component, name4) {
  if (!component || !component.$$render) {
    if (name4 === "svelte:component")
      name4 += " this={...}";
    throw new Error(`<${name4}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css5) => css5.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name4, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name4}${value === true && boolean_attributes.has(name4) ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
var current_component, boolean_attributes, escaped, missing_component, on_destroy;
var init_index_1e54ea6c = __esm({
  ".svelte-kit/output/server/chunks/index-1e54ea6c.js"() {
    Promise.resolve();
    boolean_attributes = /* @__PURE__ */ new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
  }
});

// .svelte-kit/output/server/entries/pages/__layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
var css, _layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/__layout.svelte.js"() {
    init_index_1e54ea6c();
    css = {
      code: "p{font-family:'Ubuntu', sans-serif}p.svelte-l4ql23{font-size:1 vh;font:#1f1f1f1f;position:absolute;bottom:0%;right:1%}",
      map: null
    };
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css);
      return `<link rel="${"preconnect"}" href="${"https://fonts.googleapis.com"}">
<link rel="${"preconnect"}" href="${"https://fonts.gstatic.com"}">
<link href="${"https://fonts.googleapis.com/css2?family=Ubuntu:wght@300&display=swap"}" rel="${"stylesheet"}">


<p class="${"svelte-l4ql23"}">Coded by <a href="${"https://daxton2.wixsite.com/my-site"}">Daxton Gutekunst</a></p>



${slots.default ? slots.default({}) : ` Page not loading into Layout`}`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  css: () => css2,
  entry: () => entry,
  js: () => js,
  module: () => layout_svelte_exports
});
var entry, js, css2;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_svelte();
    entry = "pages/__layout.svelte-144008e5.js";
    js = ["pages/__layout.svelte-144008e5.js", "chunks/vendor-2dff75d7.js"];
    css2 = ["assets/pages/__layout.svelte-23d404e9.css"];
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_index_1e54ea6c();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  css: () => css3,
  entry: () => entry2,
  js: () => js2,
  module: () => error_svelte_exports
});
var entry2, js2, css3;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_error_svelte();
    entry2 = "error.svelte-5c7a5af8.js";
    js2 = ["error.svelte-5c7a5af8.js", "chunks/vendor-2dff75d7.js"];
    css3 = [];
  }
});

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.mapboxgl = factory());
    })(exports2, function() {
      "use strict";
      var shared, worker, mapboxgl2;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl2 = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t2) {
        "use strict";
        var e2 = "2.7.1", r2 = n;
        function n(t3, e3, r3, n2) {
          this.cx = 3 * t3, this.bx = 3 * (r3 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e3, this.by = 3 * (n2 - e3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = n2, this.p2x = r3, this.p2y = n2;
        }
        n.prototype.sampleCurveX = function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, n.prototype.sampleCurveY = function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, n.prototype.sampleCurveDerivativeX = function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, n.prototype.solveCurveX = function(t3, e3) {
          var r3, n2, i3, s4, a2;
          for (e3 === void 0 && (e3 = 1e-6), i3 = t3, a2 = 0; a2 < 8; a2++) {
            if (s4 = this.sampleCurveX(i3) - t3, Math.abs(s4) < e3)
              return i3;
            var o2 = this.sampleCurveDerivativeX(i3);
            if (Math.abs(o2) < 1e-6)
              break;
            i3 -= s4 / o2;
          }
          if ((i3 = t3) < (r3 = 0))
            return r3;
          if (i3 > (n2 = 1))
            return n2;
          for (; r3 < n2; ) {
            if (s4 = this.sampleCurveX(i3), Math.abs(s4 - t3) < e3)
              return i3;
            t3 > s4 ? r3 = i3 : n2 = i3, i3 = 0.5 * (n2 - r3) + r3;
          }
          return i3;
        }, n.prototype.solve = function(t3, e3) {
          return this.sampleCurveY(this.solveCurveX(t3, e3));
        };
        var i2 = s3;
        function s3(t3, e3) {
          this.x = t3, this.y = e3;
        }
        s3.prototype = { clone: function() {
          return new s3(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e3) {
          return this.clone()._rotateAround(t3, e3);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e3 = t3.x - this.x, r3 = t3.y - this.y;
          return e3 * e3 + r3 * r3;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e3) {
          return Math.atan2(this.x * e3 - this.y * t3, this.x * t3 + this.y * e3);
        }, _matMult: function(t3) {
          var e3 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e3, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e3 = Math.cos(t3), r3 = Math.sin(t3), n2 = r3 * this.x + e3 * this.y;
          return this.x = e3 * this.x - r3 * this.y, this.y = n2, this;
        }, _rotateAround: function(t3, e3) {
          var r3 = Math.cos(t3), n2 = Math.sin(t3), i3 = e3.y + n2 * (this.x - e3.x) + r3 * (this.y - e3.y);
          return this.x = e3.x + r3 * (this.x - e3.x) - n2 * (this.y - e3.y), this.y = i3, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, s3.convert = function(t3) {
          return t3 instanceof s3 ? t3 : Array.isArray(t3) ? new s3(t3[0], t3[1]) : t3;
        };
        var a = typeof self != "undefined" ? self : {}, o = 1e-6, l = typeof Float32Array != "undefined" ? Float32Array : Array;
        function u() {
          var t3 = new l(9);
          return l != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
        }
        function c(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function h2(t3, e3, r3) {
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h3 = e3[8], p2 = e3[9], d2 = e3[10], f4 = e3[11], y2 = e3[12], m3 = e3[13], g2 = e3[14], x3 = e3[15], v2 = r3[0], b2 = r3[1], w2 = r3[2], _2 = r3[3];
          return t3[0] = v2 * n2 + b2 * o2 + w2 * h3 + _2 * y2, t3[1] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m3, t3[2] = v2 * s4 + b2 * u2 + w2 * d2 + _2 * g2, t3[3] = v2 * a2 + b2 * c2 + w2 * f4 + _2 * x3, t3[4] = (v2 = r3[4]) * n2 + (b2 = r3[5]) * o2 + (w2 = r3[6]) * h3 + (_2 = r3[7]) * y2, t3[5] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m3, t3[6] = v2 * s4 + b2 * u2 + w2 * d2 + _2 * g2, t3[7] = v2 * a2 + b2 * c2 + w2 * f4 + _2 * x3, t3[8] = (v2 = r3[8]) * n2 + (b2 = r3[9]) * o2 + (w2 = r3[10]) * h3 + (_2 = r3[11]) * y2, t3[9] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m3, t3[10] = v2 * s4 + b2 * u2 + w2 * d2 + _2 * g2, t3[11] = v2 * a2 + b2 * c2 + w2 * f4 + _2 * x3, t3[12] = (v2 = r3[12]) * n2 + (b2 = r3[13]) * o2 + (w2 = r3[14]) * h3 + (_2 = r3[15]) * y2, t3[13] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m3, t3[14] = v2 * s4 + b2 * u2 + w2 * d2 + _2 * g2, t3[15] = v2 * a2 + b2 * c2 + w2 * f4 + _2 * x3, t3;
        }
        function p(t3, e3, r3) {
          var n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2 = r3[0], m3 = r3[1], g2 = r3[2];
          return e3 === t3 ? (t3[12] = e3[0] * y2 + e3[4] * m3 + e3[8] * g2 + e3[12], t3[13] = e3[1] * y2 + e3[5] * m3 + e3[9] * g2 + e3[13], t3[14] = e3[2] * y2 + e3[6] * m3 + e3[10] * g2 + e3[14], t3[15] = e3[3] * y2 + e3[7] * m3 + e3[11] * g2 + e3[15]) : (i3 = e3[1], s4 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h3 = e3[8], p2 = e3[9], d2 = e3[10], f4 = e3[11], t3[0] = n2 = e3[0], t3[1] = i3, t3[2] = s4, t3[3] = a2, t3[4] = o2, t3[5] = l2, t3[6] = u2, t3[7] = c2, t3[8] = h3, t3[9] = p2, t3[10] = d2, t3[11] = f4, t3[12] = n2 * y2 + o2 * m3 + h3 * g2 + e3[12], t3[13] = i3 * y2 + l2 * m3 + p2 * g2 + e3[13], t3[14] = s4 * y2 + u2 * m3 + d2 * g2 + e3[14], t3[15] = a2 * y2 + c2 * m3 + f4 * g2 + e3[15]), t3;
        }
        function d(t3, e3, r3) {
          var n2 = r3[0], i3 = r3[1], s4 = r3[2];
          return t3[0] = e3[0] * n2, t3[1] = e3[1] * n2, t3[2] = e3[2] * n2, t3[3] = e3[3] * n2, t3[4] = e3[4] * i3, t3[5] = e3[5] * i3, t3[6] = e3[6] * i3, t3[7] = e3[7] * i3, t3[8] = e3[8] * s4, t3[9] = e3[9] * s4, t3[10] = e3[10] * s4, t3[11] = e3[11] * s4, t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
        }
        function f3(t3, e3, r3) {
          var n2 = Math.sin(r3), i3 = Math.cos(r3), s4 = e3[4], a2 = e3[5], o2 = e3[6], l2 = e3[7], u2 = e3[8], c2 = e3[9], h3 = e3[10], p2 = e3[11];
          return e3 !== t3 && (t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[4] = s4 * i3 + u2 * n2, t3[5] = a2 * i3 + c2 * n2, t3[6] = o2 * i3 + h3 * n2, t3[7] = l2 * i3 + p2 * n2, t3[8] = u2 * i3 - s4 * n2, t3[9] = c2 * i3 - a2 * n2, t3[10] = h3 * i3 - o2 * n2, t3[11] = p2 * i3 - l2 * n2, t3;
        }
        function y(t3, e3, r3) {
          var n2 = Math.sin(r3), i3 = Math.cos(r3), s4 = e3[0], a2 = e3[1], o2 = e3[2], l2 = e3[3], u2 = e3[8], c2 = e3[9], h3 = e3[10], p2 = e3[11];
          return e3 !== t3 && (t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s4 * i3 - u2 * n2, t3[1] = a2 * i3 - c2 * n2, t3[2] = o2 * i3 - h3 * n2, t3[3] = l2 * i3 - p2 * n2, t3[8] = s4 * n2 + u2 * i3, t3[9] = a2 * n2 + c2 * i3, t3[10] = o2 * n2 + h3 * i3, t3[11] = l2 * n2 + p2 * i3, t3;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t3 = 0, e3 = arguments.length; e3--; )
            t3 += arguments[e3] * arguments[e3];
          return Math.sqrt(t3);
        });
        var m2 = h2;
        function g() {
          var t3 = new l(3);
          return l != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3;
        }
        function x2(t3) {
          var e3 = new l(3);
          return e3[0] = t3[0], e3[1] = t3[1], e3[2] = t3[2], e3;
        }
        function v(t3) {
          return Math.hypot(t3[0], t3[1], t3[2]);
        }
        function b(t3, e3, r3) {
          var n2 = new l(3);
          return n2[0] = t3, n2[1] = e3, n2[2] = r3, n2;
        }
        function w(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3;
        }
        function _(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3;
        }
        function A2(t3, e3, r3) {
          return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3[2] = e3[2] * r3[2], t3;
        }
        function k(t3, e3, r3) {
          return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3[2] = Math.max(e3[2], r3[2]), t3;
        }
        function S2(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3;
        }
        function I(t3, e3, r3, n2) {
          return t3[0] = e3[0] + r3[0] * n2, t3[1] = e3[1] + r3[1] * n2, t3[2] = e3[2] + r3[2] * n2, t3;
        }
        function z(t3, e3) {
          var r3 = e3[0], n2 = e3[1], i3 = e3[2], s4 = r3 * r3 + n2 * n2 + i3 * i3;
          return s4 > 0 && (s4 = 1 / Math.sqrt(s4)), t3[0] = e3[0] * s4, t3[1] = e3[1] * s4, t3[2] = e3[2] * s4, t3;
        }
        function M(t3, e3) {
          return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2];
        }
        function T(t3, e3, r3) {
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = r3[0], o2 = r3[1], l2 = r3[2];
          return t3[0] = i3 * l2 - s4 * o2, t3[1] = s4 * a2 - n2 * l2, t3[2] = n2 * o2 - i3 * a2, t3;
        }
        function B(t3, e3, r3) {
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = r3[3] * n2 + r3[7] * i3 + r3[11] * s4 + r3[15];
          return t3[0] = (r3[0] * n2 + r3[4] * i3 + r3[8] * s4 + r3[12]) / (a2 = a2 || 1), t3[1] = (r3[1] * n2 + r3[5] * i3 + r3[9] * s4 + r3[13]) / a2, t3[2] = (r3[2] * n2 + r3[6] * i3 + r3[10] * s4 + r3[14]) / a2, t3;
        }
        function C(t3, e3, r3) {
          var n2 = r3[0], i3 = r3[1], s4 = r3[2], a2 = e3[0], o2 = e3[1], l2 = e3[2], u2 = i3 * l2 - s4 * o2, c2 = s4 * a2 - n2 * l2, h3 = n2 * o2 - i3 * a2, p2 = i3 * h3 - s4 * c2, d2 = s4 * u2 - n2 * h3, f4 = n2 * c2 - i3 * u2, y2 = 2 * r3[3];
          return c2 *= y2, h3 *= y2, d2 *= 2, f4 *= 2, t3[0] = a2 + (u2 *= y2) + (p2 *= 2), t3[1] = o2 + c2 + d2, t3[2] = l2 + h3 + f4, t3;
        }
        var P, E = _, D = A2, V = v;
        function F2(t3, e3, r3) {
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = e3[3];
          return t3[0] = r3[0] * n2 + r3[4] * i3 + r3[8] * s4 + r3[12] * a2, t3[1] = r3[1] * n2 + r3[5] * i3 + r3[9] * s4 + r3[13] * a2, t3[2] = r3[2] * n2 + r3[6] * i3 + r3[10] * s4 + r3[14] * a2, t3[3] = r3[3] * n2 + r3[7] * i3 + r3[11] * s4 + r3[15] * a2, t3;
        }
        function L() {
          var t3 = new l(4);
          return l != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3[3] = 1, t3;
        }
        function R(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
        }
        function U(t3, e3, r3) {
          r3 *= 0.5;
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = e3[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
          return t3[0] = n2 * l2 + a2 * o2, t3[1] = i3 * l2 + s4 * o2, t3[2] = s4 * l2 - i3 * o2, t3[3] = a2 * l2 - n2 * o2, t3;
        }
        function $(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1];
        }
        g(), P = new l(4), l != Float32Array && (P[0] = 0, P[1] = 0, P[2] = 0, P[3] = 0), g(), b(1, 0, 0), b(0, 1, 0), L(), L(), u(), function() {
          var t3;
          t3 = new l(2), l != Float32Array && (t3[0] = 0, t3[1] = 0);
        }();
        const O = Math.PI / 180, j = 180 / Math.PI;
        function q(t3) {
          return t3 * O;
        }
        function N(t3) {
          return t3 * j;
        }
        const G = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function Z2(t3) {
          if (t3 <= 0)
            return 0;
          if (t3 >= 1)
            return 1;
          const e3 = t3 * t3, r3 = e3 * t3;
          return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
        }
        function X(t3, e3, n2, i3) {
          const s4 = new r2(t3, e3, n2, i3);
          return function(t4) {
            return s4.solve(t4);
          };
        }
        const K = X(0.25, 0.1, 0.25, 1);
        function Y(t3, e3, r3) {
          return Math.min(r3, Math.max(e3, t3));
        }
        function H(t3, e3, r3) {
          return (r3 = Y((r3 - t3) / (e3 - t3), 0, 1)) * r3 * (3 - 2 * r3);
        }
        function J(t3, e3, r3) {
          const n2 = r3 - e3, i3 = ((t3 - e3) % n2 + n2) % n2 + e3;
          return i3 === e3 ? r3 : i3;
        }
        function W(t3, e3, r3) {
          if (!t3.length)
            return r3(null, []);
          let n2 = t3.length;
          const i3 = new Array(t3.length);
          let s4 = null;
          t3.forEach((t4, a2) => {
            e3(t4, (t5, e4) => {
              t5 && (s4 = t5), i3[a2] = e4, --n2 == 0 && r3(s4, i3);
            });
          });
        }
        function Q(t3) {
          const e3 = [];
          for (const r3 in t3)
            e3.push(t3[r3]);
          return e3;
        }
        function tt(t3, ...e3) {
          for (const r3 of e3)
            for (const e4 in r3)
              t3[e4] = r3[e4];
          return t3;
        }
        let et = 1;
        function rt() {
          return et++;
        }
        function nt() {
          return function t3(e3) {
            return e3 ? (e3 ^ 16 * Math.random() >> e3 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t3);
          }();
        }
        function it(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
        }
        function st(t3) {
          return !!t3 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t3);
        }
        function at(t3, e3) {
          t3.forEach((t4) => {
            e3[t4] && (e3[t4] = e3[t4].bind(e3));
          });
        }
        function ot(t3, e3) {
          return t3.indexOf(e3, t3.length - e3.length) !== -1;
        }
        function lt(t3, e3, r3) {
          const n2 = {};
          for (const i3 in t3)
            n2[i3] = e3.call(r3 || this, t3[i3], i3, t3);
          return n2;
        }
        function ut(t3, e3, r3) {
          const n2 = {};
          for (const i3 in t3)
            e3.call(r3 || this, t3[i3], i3, t3) && (n2[i3] = t3[i3]);
          return n2;
        }
        function ct(t3) {
          return Array.isArray(t3) ? t3.map(ct) : typeof t3 == "object" && t3 ? lt(t3, ct) : t3;
        }
        const ht = {};
        function pt(t3) {
          ht[t3] || (typeof console != "undefined" && console.warn(t3), ht[t3] = true);
        }
        function dt(t3, e3, r3) {
          return (r3.y - t3.y) * (e3.x - t3.x) > (e3.y - t3.y) * (r3.x - t3.x);
        }
        function ft(t3) {
          let e3 = 0;
          for (let r3, n2, i3 = 0, s4 = t3.length, a2 = s4 - 1; i3 < s4; a2 = i3++)
            r3 = t3[i3], n2 = t3[a2], e3 += (n2.x - r3.x) * (r3.y + n2.y);
          return e3;
        }
        function yt() {
          return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope;
        }
        function mt(t3) {
          const e3 = {};
          if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r3, n2, i3) => {
            const s4 = n2 || i3;
            return e3[r3] = !s4 || s4.toLowerCase(), "";
          }), e3["max-age"]) {
            const t4 = parseInt(e3["max-age"], 10);
            isNaN(t4) ? delete e3["max-age"] : e3["max-age"] = t4;
          }
          return e3;
        }
        let gt, xt, vt, bt = null;
        function wt(t3) {
          if (bt == null) {
            const e3 = t3.navigator ? t3.navigator.userAgent : null;
            bt = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
          }
          return bt;
        }
        function _t(t3) {
          try {
            const e3 = a[t3];
            return e3.setItem("_mapbox_test_", 1), e3.removeItem("_mapbox_test_"), true;
          } catch (t4) {
            return false;
          }
        }
        const At = { now: () => vt !== void 0 ? vt : a.performance.now(), setNow(t3) {
          vt = t3;
        }, restoreNow() {
          vt = void 0;
        }, frame(t3) {
          const e3 = a.requestAnimationFrame(t3);
          return { cancel: () => a.cancelAnimationFrame(e3) };
        }, getImageData(t3, e3 = 0) {
          const r3 = a.document.createElement("canvas"), n2 = r3.getContext("2d");
          if (!n2)
            throw new Error("failed to create canvas 2d context");
          return r3.width = t3.width, r3.height = t3.height, n2.drawImage(t3, 0, 0, t3.width, t3.height), n2.getImageData(-e3, -e3, t3.width + 2 * e3, t3.height + 2 * e3);
        }, resolveURL: (t3) => (gt || (gt = a.document.createElement("a")), gt.href = t3, gt.href), get devicePixelRatio() {
          return a.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!a.matchMedia && (xt == null && (xt = a.matchMedia("(prefers-reduced-motion: reduce)")), xt.matches);
        } };
        let kt;
        const St = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          if (kt == null) {
            const t3 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              kt = process.env.API_URL_REGEX != null ? new RegExp(process.env.API_URL_REGEX) : t3;
            } catch (e3) {
              kt = t3;
            }
          }
          return kt;
        }, get EVENTS_URL() {
          return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, It = { supported: false, testSupport: function(t3) {
          !Tt && Mt && (Bt ? Ct(t3) : zt = t3);
        } };
        let zt, Mt, Tt = false, Bt = false;
        function Ct(t3) {
          const e3 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e3);
          try {
            if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, Mt), t3.isContextLost())
              return;
            It.supported = true;
          } catch (t4) {
          }
          t3.deleteTexture(e3), Tt = true;
        }
        a.document && (Mt = a.document.createElement("img"), Mt.onload = function() {
          zt && Ct(zt), zt = null, Bt = true;
        }, Mt.onerror = function() {
          Tt = true, zt = null;
        }, Mt.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Pt = "01", Et = "NO_ACCESS_TOKEN";
        function Dt(t3) {
          return t3.indexOf("mapbox:") === 0;
        }
        function Vt(t3) {
          return St.API_URL_REGEX.test(t3);
        }
        const Ft = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function Lt(t3) {
          const e3 = t3.match(Ft);
          if (!e3)
            throw new Error("Unable to parse URL object");
          return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
        }
        function Rt(t3) {
          const e3 = t3.params.length ? `?${t3.params.join("&")}` : "";
          return `${t3.protocol}://${t3.authority}${t3.path}${e3}`;
        }
        function Ut(t3) {
          if (!t3)
            return null;
          const e3 = t3.split(".");
          if (!e3 || e3.length !== 3)
            return null;
          try {
            return JSON.parse(decodeURIComponent(a.atob(e3[1]).split("").map((t4) => "%" + ("00" + t4.charCodeAt(0).toString(16)).slice(-2)).join("")));
          } catch (t4) {
            return null;
          }
        }
        class $t {
          constructor(t3) {
            this.type = t3, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t3) {
            const e3 = Ut(St.ACCESS_TOKEN);
            let r3 = "";
            return r3 = e3 && e3.u ? a.btoa(encodeURIComponent(e3.u).replace(/%([0-9A-F]{2})/g, (t4, e4) => String.fromCharCode(Number("0x" + e4)))) : St.ACCESS_TOKEN || "", t3 ? `mapbox.eventData.${t3}:${r3}` : `mapbox.eventData:${r3}`;
          }
          fetchEventData() {
            const t3 = _t("localStorage"), e3 = this.getStorageKey(), r3 = this.getStorageKey("uuid");
            if (t3)
              try {
                const t4 = a.localStorage.getItem(e3);
                t4 && (this.eventData = JSON.parse(t4));
                const n2 = a.localStorage.getItem(r3);
                n2 && (this.anonId = n2);
              } catch (t4) {
                pt("Unable to read from LocalStorage");
              }
          }
          saveEventData() {
            const t3 = _t("localStorage"), e3 = this.getStorageKey(), r3 = this.getStorageKey("uuid");
            if (t3)
              try {
                a.localStorage.setItem(r3, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(e3, JSON.stringify(this.eventData));
              } catch (t4) {
                pt("Unable to write to LocalStorage");
              }
          }
          processRequests(t3) {
          }
          postEvent(t3, r3, n2, i3) {
            if (!St.EVENTS_URL)
              return;
            const s4 = Lt(St.EVENTS_URL);
            s4.params.push(`access_token=${i3 || St.ACCESS_TOKEN || ""}`);
            const a2 = { event: this.type, created: new Date(t3).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: e2, skuId: Pt, userId: this.anonId }, o2 = r3 ? tt(a2, r3) : a2, l2 = { url: Rt(s4), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
            this.pendingRequest = oe(l2, (t4) => {
              this.pendingRequest = null, n2(t4), this.saveEventData(), this.processRequests(i3);
            });
          }
          queueRequest(t3, e3) {
            this.queue.push(t3), this.processRequests(e3);
          }
        }
        const Ot = new class extends $t {
          constructor(t3) {
            super("appUserTurnstile"), this._customAccessToken = t3;
          }
          postTurnstileEvent(t3, e3) {
            St.EVENTS_URL && St.ACCESS_TOKEN && Array.isArray(t3) && t3.some((t4) => Dt(t4) || Vt(t4)) && this.queueRequest(Date.now(), e3);
          }
          processRequests(t3) {
            if (this.pendingRequest || this.queue.length === 0)
              return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const e3 = Ut(St.ACCESS_TOKEN), r3 = e3 ? e3.u : St.ACCESS_TOKEN;
            let n2 = r3 !== this.eventData.tokenU;
            st(this.anonId) || (this.anonId = nt(), n2 = true);
            const i3 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const t4 = new Date(this.eventData.lastSuccess), e4 = new Date(i3), r4 = (i3 - this.eventData.lastSuccess) / 864e5;
              n2 = n2 || r4 >= 1 || r4 < -1 || t4.getDate() !== e4.getDate();
            } else
              n2 = true;
            if (!n2)
              return this.processRequests();
            this.postEvent(i3, { "enabled.telemetry": false }, (t4) => {
              t4 || (this.eventData.lastSuccess = i3, this.eventData.tokenU = r3);
            }, t3);
          }
        }(), jt = Ot.postTurnstileEvent.bind(Ot), qt = new class extends $t {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t3, e3, r3, n2) {
            this.skuToken = e3, this.errorCb = n2, St.EVENTS_URL && (r3 || St.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r3) : this.errorCb(new Error(Et)));
          }
          processRequests(t3) {
            if (this.pendingRequest || this.queue.length === 0)
              return;
            const { id: e3, timestamp: r3 } = this.queue.shift();
            e3 && this.success[e3] || (this.anonId || this.fetchEventData(), st(this.anonId) || (this.anonId = nt()), this.postEvent(r3, { skuToken: this.skuToken }, (t4) => {
              t4 ? this.errorCb(t4) : e3 && (this.success[e3] = true);
            }, t3));
          }
        }(), Nt = qt.postMapLoadEvent.bind(qt), Gt = new class extends $t {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t3, e3, r3, n2) {
            if (!St.API_URL || !St.SESSION_PATH)
              return;
            const i3 = Lt(St.API_URL + St.SESSION_PATH);
            i3.params.push(`sku=${e3 || ""}`), i3.params.push(`access_token=${n2 || St.ACCESS_TOKEN || ""}`);
            const s4 = { url: Rt(i3), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = le(s4, (t4) => {
              this.pendingRequest = null, r3(t4), this.saveEventData(), this.processRequests(n2);
            });
          }
          getSessionAPI(t3, e3, r3, n2) {
            this.skuToken = e3, this.errorCb = n2, St.SESSION_PATH && St.API_URL && (r3 || St.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r3) : this.errorCb(new Error(Et)));
          }
          processRequests(t3) {
            if (this.pendingRequest || this.queue.length === 0)
              return;
            const { id: e3, timestamp: r3 } = this.queue.shift();
            e3 && this.success[e3] || this.getSession(r3, this.skuToken, (t4) => {
              t4 ? this.errorCb(t4) : e3 && (this.success[e3] = true);
            }, t3);
          }
        }(), Zt = Gt.getSessionAPI.bind(Gt), Xt = new Set(), Kt = "mapbox-tiles";
        let Yt, Ht, Jt = 500, Wt = 50;
        function Qt() {
          a.caches && !Yt && (Yt = a.caches.open(Kt));
        }
        function te(t3) {
          const e3 = t3.indexOf("?");
          return e3 < 0 ? t3 : t3.slice(0, e3);
        }
        let ee = 1 / 0;
        const re = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        typeof Object.freeze == "function" && Object.freeze(re);
        class ne extends Error {
          constructor(t3, e3, r3) {
            e3 === 401 && Vt(r3) && (t3 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), super(t3), this.status = e3, this.url = r3;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const ie = yt() ? () => self.worker && self.worker.referrer : () => (a.location.protocol === "blob:" ? a.parent : a).location.href;
        const se = function(t3, e3) {
          if (!(/^file:/.test(r3 = t3.url) || /^file:/.test(ie()) && !/^\w+:/.test(r3))) {
            if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty("signal"))
              return function(t4, e4) {
                const r4 = new a.AbortController(), n2 = new a.Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, referrer: ie(), signal: r4.signal });
                let i3 = false, s4 = false;
                const o2 = (l2 = n2.url).indexOf("sku=") > 0 && Vt(l2);
                var l2;
                t4.type === "json" && n2.headers.set("Accept", "application/json");
                const u2 = (r5, i4, l3) => {
                  if (s4)
                    return;
                  if (r5 && r5.message !== "SecurityError" && pt(r5), i4 && l3)
                    return c2(i4);
                  const u3 = Date.now();
                  a.fetch(n2).then((r6) => {
                    if (r6.ok) {
                      const t5 = o2 ? r6.clone() : null;
                      return c2(r6, t5, u3);
                    }
                    return e4(new ne(r6.statusText, r6.status, t4.url));
                  }).catch((t5) => {
                    t5.code !== 20 && e4(new Error(t5.message));
                  });
                }, c2 = (r5, o3, l3) => {
                  (t4.type === "arrayBuffer" ? r5.arrayBuffer() : t4.type === "json" ? r5.json() : r5.text()).then((t5) => {
                    s4 || (o3 && l3 && function(t6, e5, r6) {
                      if (Qt(), !Yt)
                        return;
                      const n3 = { status: e5.status, statusText: e5.statusText, headers: new a.Headers() };
                      e5.headers.forEach((t7, e6) => n3.headers.set(e6, t7));
                      const i4 = mt(e5.headers.get("Cache-Control") || "");
                      i4["no-store"] || (i4["max-age"] && n3.headers.set("Expires", new Date(r6 + 1e3 * i4["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r6 < 42e4 || function(t7, e6) {
                        if (Ht === void 0)
                          try {
                            new Response(new ReadableStream()), Ht = true;
                          } catch (t8) {
                            Ht = false;
                          }
                        Ht ? e6(t7.body) : t7.blob().then(e6);
                      }(e5, (e6) => {
                        const r7 = new a.Response(e6, n3);
                        Qt(), Yt && Yt.then((e7) => e7.put(te(t6.url), r7)).catch((t7) => pt(t7.message));
                      }));
                    }(n2, o3, l3), i3 = true, e4(null, t5, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
                  }).catch((t5) => {
                    s4 || e4(new Error(t5.message));
                  });
                };
                return o2 ? function(t5, e5) {
                  if (Qt(), !Yt)
                    return e5(null);
                  const r5 = te(t5.url);
                  Yt.then((t6) => {
                    t6.match(r5).then((n3) => {
                      const i4 = function(t7) {
                        if (!t7)
                          return false;
                        const e6 = new Date(t7.headers.get("Expires") || 0), r6 = mt(t7.headers.get("Cache-Control") || "");
                        return e6 > Date.now() && !r6["no-cache"];
                      }(n3);
                      t6.delete(r5), i4 && t6.put(r5, n3.clone()), e5(null, n3, i4);
                    }).catch(e5);
                  }).catch(e5);
                }(n2, u2) : u2(null, null), { cancel: () => {
                  s4 = true, i3 || r4.abort();
                } };
              }(t3, e3);
            if (yt() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t3, e3, void 0, true);
          }
          var r3;
          return function(t4, e4) {
            const r4 = new a.XMLHttpRequest();
            r4.open(t4.method || "GET", t4.url, true), t4.type === "arrayBuffer" && (r4.responseType = "arraybuffer");
            for (const e5 in t4.headers)
              r4.setRequestHeader(e5, t4.headers[e5]);
            return t4.type === "json" && (r4.responseType = "text", r4.setRequestHeader("Accept", "application/json")), r4.withCredentials = t4.credentials === "include", r4.onerror = () => {
              e4(new Error(r4.statusText));
            }, r4.onload = () => {
              if ((r4.status >= 200 && r4.status < 300 || r4.status === 0) && r4.response !== null) {
                let n2 = r4.response;
                if (t4.type === "json")
                  try {
                    n2 = JSON.parse(r4.response);
                  } catch (t5) {
                    return e4(t5);
                  }
                e4(null, n2, r4.getResponseHeader("Cache-Control"), r4.getResponseHeader("Expires"));
              } else
                e4(new ne(r4.statusText, r4.status, t4.url));
            }, r4.send(t4.body), { cancel: () => r4.abort() };
          }(t3, e3);
        }, ae = function(t3, e3) {
          return se(tt(t3, { type: "arrayBuffer" }), e3);
        }, oe = function(t3, e3) {
          return se(tt(t3, { method: "POST" }), e3);
        }, le = function(t3, e3) {
          return se(tt(t3, { method: "GET" }), e3);
        };
        function ue(t3) {
          const e3 = a.document.createElement("a");
          return e3.href = t3, e3.protocol === a.document.location.protocol && e3.host === a.document.location.host;
        }
        const ce = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let he, pe;
        he = [], pe = 0;
        const de = function(t3, e3) {
          if (It.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), pe >= St.MAX_PARALLEL_IMAGE_REQUESTS) {
            const r4 = { requestParameters: t3, callback: e3, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return he.push(r4), r4;
          }
          pe++;
          let r3 = false;
          const n2 = () => {
            if (!r3)
              for (r3 = true, pe--; he.length && pe < St.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const t4 = he.shift(), { requestParameters: e4, callback: r4, cancelled: n3 } = t4;
                n3 || (t4.cancel = de(e4, r4).cancel);
              }
          }, i3 = ae(t3, (t4, r4, i4, s4) => {
            n2(), t4 ? e3(t4) : r4 && (a.createImageBitmap ? function(t5, e4) {
              const r5 = new a.Blob([new Uint8Array(t5)], { type: "image/png" });
              a.createImageBitmap(r5).then((t6) => {
                e4(null, t6);
              }).catch((t6) => {
                e4(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(r4, (t5, r5) => e3(t5, r5, i4, s4)) : function(t5, e4) {
              const r5 = new a.Image(), n3 = a.URL;
              r5.onload = () => {
                e4(null, r5), n3.revokeObjectURL(r5.src), r5.onload = null, a.requestAnimationFrame(() => {
                  r5.src = ce;
                });
              }, r5.onerror = () => e4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const i5 = new a.Blob([new Uint8Array(t5)], { type: "image/png" });
              r5.src = t5.byteLength ? n3.createObjectURL(i5) : ce;
            }(r4, (t5, r5) => e3(t5, r5, i4, s4)));
          });
          return { cancel: () => {
            i3.cancel(), n2();
          } };
        };
        function fe(t3, e3, r3) {
          r3[t3] && r3[t3].indexOf(e3) !== -1 || (r3[t3] = r3[t3] || [], r3[t3].push(e3));
        }
        function ye(t3, e3, r3) {
          if (r3 && r3[t3]) {
            const n2 = r3[t3].indexOf(e3);
            n2 !== -1 && r3[t3].splice(n2, 1);
          }
        }
        class me {
          constructor(t3, e3 = {}) {
            tt(this, e3), this.type = t3;
          }
        }
        class ge extends me {
          constructor(t3, e3 = {}) {
            super("error", tt({ error: t3 }, e3));
          }
        }
        class xe {
          on(t3, e3) {
            return this._listeners = this._listeners || {}, fe(t3, e3, this._listeners), this;
          }
          off(t3, e3) {
            return ye(t3, e3, this._listeners), ye(t3, e3, this._oneTimeListeners), this;
          }
          once(t3, e3) {
            return e3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, fe(t3, e3, this._oneTimeListeners), this) : new Promise((e4) => this.once(t3, e4));
          }
          fire(t3, e3) {
            typeof t3 == "string" && (t3 = new me(t3, e3 || {}));
            const r3 = t3.type;
            if (this.listens(r3)) {
              t3.target = this;
              const e4 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
              for (const r4 of e4)
                r4.call(this, t3);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
              for (const e5 of n2)
                ye(r3, e5, this._oneTimeListeners), e5.call(this, t3);
              const i3 = this._eventedParent;
              i3 && (tt(t3, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i3.fire(t3));
            } else
              t3 instanceof ge && console.error(t3.error);
            return this;
          }
          listens(t3) {
            return !!(this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3));
          }
          setEventedParent(t3, e3) {
            return this._eventedParent = t3, this._eventedParentData = e3, this;
          }
        }
        var ve = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":0.1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"cross-faded"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"cross-faded":{"type":"property-type"},"cross-faded-data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        class be {
          constructor(t3, e3, r3, n2) {
            this.message = (t3 ? `${t3}: ` : "") + r3, n2 && (this.identifier = n2), e3 != null && e3.__line__ && (this.line = e3.__line__);
          }
        }
        function we(t3) {
          const e3 = t3.value;
          return e3 ? [new be(t3.key, e3, "constants have been deprecated as of v8")] : [];
        }
        function _e(t3, ...e3) {
          for (const r3 of e3)
            for (const e4 in r3)
              t3[e4] = r3[e4];
          return t3;
        }
        function Ae(t3) {
          return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
        }
        function ke(t3) {
          if (Array.isArray(t3))
            return t3.map(ke);
          if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
            const e3 = {};
            for (const r3 in t3)
              e3[r3] = ke(t3[r3]);
            return e3;
          }
          return Ae(t3);
        }
        class Se extends Error {
          constructor(t3, e3) {
            super(e3), this.message = e3, this.key = t3;
          }
        }
        class Ie {
          constructor(t3, e3 = []) {
            this.parent = t3, this.bindings = {};
            for (const [t4, r3] of e3)
              this.bindings[t4] = r3;
          }
          concat(t3) {
            return new Ie(this, t3);
          }
          get(t3) {
            if (this.bindings[t3])
              return this.bindings[t3];
            if (this.parent)
              return this.parent.get(t3);
            throw new Error(`${t3} not found in scope.`);
          }
          has(t3) {
            return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
          }
        }
        const ze = { kind: "null" }, Me = { kind: "number" }, Te = { kind: "string" }, Be = { kind: "boolean" }, Ce = { kind: "color" }, Pe = { kind: "object" }, Ee = { kind: "value" }, De = { kind: "collator" }, Ve = { kind: "formatted" }, Fe = { kind: "resolvedImage" };
        function Le(t3, e3) {
          return { kind: "array", itemType: t3, N: e3 };
        }
        function Re(t3) {
          if (t3.kind === "array") {
            const e3 = Re(t3.itemType);
            return typeof t3.N == "number" ? `array<${e3}, ${t3.N}>` : t3.itemType.kind === "value" ? "array" : `array<${e3}>`;
          }
          return t3.kind;
        }
        const Ue = [ze, Me, Te, Be, Ce, Ve, Pe, Le(Ee), Fe];
        function $e(t3, e3) {
          if (e3.kind === "error")
            return null;
          if (t3.kind === "array") {
            if (e3.kind === "array" && (e3.N === 0 && e3.itemType.kind === "value" || !$e(t3.itemType, e3.itemType)) && (typeof t3.N != "number" || t3.N === e3.N))
              return null;
          } else {
            if (t3.kind === e3.kind)
              return null;
            if (t3.kind === "value") {
              for (const t4 of Ue)
                if (!$e(t4, e3))
                  return null;
            }
          }
          return `Expected ${Re(t3)} but found ${Re(e3)} instead.`;
        }
        function Oe(t3, e3) {
          return e3.some((e4) => e4.kind === t3.kind);
        }
        function je(t3, e3) {
          return e3.some((e4) => e4 === "null" ? t3 === null : e4 === "array" ? Array.isArray(t3) : e4 === "object" ? t3 && !Array.isArray(t3) && typeof t3 == "object" : e4 === typeof t3);
        }
        function qe(t3) {
          var e3 = { exports: {} };
          return t3(e3, e3.exports), e3.exports;
        }
        var Ne = qe(function(t3, e3) {
          var r3 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function n2(t4) {
            return (t4 = Math.round(t4)) < 0 ? 0 : t4 > 255 ? 255 : t4;
          }
          function i3(t4) {
            return n2(t4[t4.length - 1] === "%" ? parseFloat(t4) / 100 * 255 : parseInt(t4));
          }
          function s4(t4) {
            return (e4 = t4[t4.length - 1] === "%" ? parseFloat(t4) / 100 : parseFloat(t4)) < 0 ? 0 : e4 > 1 ? 1 : e4;
            var e4;
          }
          function a2(t4, e4, r4) {
            return r4 < 0 ? r4 += 1 : r4 > 1 && (r4 -= 1), 6 * r4 < 1 ? t4 + (e4 - t4) * r4 * 6 : 2 * r4 < 1 ? e4 : 3 * r4 < 2 ? t4 + (e4 - t4) * (2 / 3 - r4) * 6 : t4;
          }
          try {
            e3.parseCSSColor = function(t4) {
              var e4, o2 = t4.replace(/ /g, "").toLowerCase();
              if (o2 in r3)
                return r3[o2].slice();
              if (o2[0] === "#")
                return o2.length === 4 ? (e4 = parseInt(o2.substr(1), 16)) >= 0 && e4 <= 4095 ? [(3840 & e4) >> 4 | (3840 & e4) >> 8, 240 & e4 | (240 & e4) >> 4, 15 & e4 | (15 & e4) << 4, 1] : null : o2.length === 7 && (e4 = parseInt(o2.substr(1), 16)) >= 0 && e4 <= 16777215 ? [(16711680 & e4) >> 16, (65280 & e4) >> 8, 255 & e4, 1] : null;
              var l2 = o2.indexOf("("), u2 = o2.indexOf(")");
              if (l2 !== -1 && u2 + 1 === o2.length) {
                var c2 = o2.substr(0, l2), h3 = o2.substr(l2 + 1, u2 - (l2 + 1)).split(","), p2 = 1;
                switch (c2) {
                  case "rgba":
                    if (h3.length !== 4)
                      return null;
                    p2 = s4(h3.pop());
                  case "rgb":
                    return h3.length !== 3 ? null : [i3(h3[0]), i3(h3[1]), i3(h3[2]), p2];
                  case "hsla":
                    if (h3.length !== 4)
                      return null;
                    p2 = s4(h3.pop());
                  case "hsl":
                    if (h3.length !== 3)
                      return null;
                    var d2 = (parseFloat(h3[0]) % 360 + 360) % 360 / 360, f4 = s4(h3[1]), y2 = s4(h3[2]), m3 = y2 <= 0.5 ? y2 * (f4 + 1) : y2 + f4 - y2 * f4, g2 = 2 * y2 - m3;
                    return [n2(255 * a2(g2, m3, d2 + 1 / 3)), n2(255 * a2(g2, m3, d2)), n2(255 * a2(g2, m3, d2 - 1 / 3)), p2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t4) {
          }
        });
        class Ge {
          constructor(t3, e3, r3, n2 = 1) {
            this.r = t3, this.g = e3, this.b = r3, this.a = n2;
          }
          static parse(t3) {
            if (!t3)
              return;
            if (t3 instanceof Ge)
              return t3;
            if (typeof t3 != "string")
              return;
            const e3 = Ne.parseCSSColor(t3);
            return e3 ? new Ge(e3[0] / 255 * e3[3], e3[1] / 255 * e3[3], e3[2] / 255 * e3[3], e3[3]) : void 0;
          }
          toString() {
            const [t3, e3, r3, n2] = this.toArray();
            return `rgba(${Math.round(t3)},${Math.round(e3)},${Math.round(r3)},${n2})`;
          }
          toArray() {
            const { r: t3, g: e3, b: r3, a: n2 } = this;
            return n2 === 0 ? [0, 0, 0, 0] : [255 * t3 / n2, 255 * e3 / n2, 255 * r3 / n2, n2];
          }
        }
        Ge.black = new Ge(0, 0, 0, 1), Ge.white = new Ge(1, 1, 1, 1), Ge.transparent = new Ge(0, 0, 0, 0), Ge.red = new Ge(1, 0, 0, 1), Ge.blue = new Ge(0, 0, 1, 1);
        class Ze {
          constructor(t3, e3, r3) {
            this.sensitivity = t3 ? e3 ? "variant" : "case" : e3 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t3, e3) {
            return this.collator.compare(t3, e3);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Xe {
          constructor(t3, e3, r3, n2, i3) {
            this.text = t3.normalize ? t3.normalize() : t3, this.image = e3, this.scale = r3, this.fontStack = n2, this.textColor = i3;
          }
        }
        class Ke {
          constructor(t3) {
            this.sections = t3;
          }
          static fromString(t3) {
            return new Ke([new Xe(t3, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t3) => t3.text.length !== 0 || t3.image && t3.image.name.length !== 0);
          }
          static factory(t3) {
            return t3 instanceof Ke ? t3 : Ke.fromString(t3);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t3) => t3.text).join("");
          }
          serialize() {
            const t3 = ["format"];
            for (const e3 of this.sections) {
              if (e3.image) {
                t3.push(["image", e3.image.name]);
                continue;
              }
              t3.push(e3.text);
              const r3 = {};
              e3.fontStack && (r3["text-font"] = ["literal", e3.fontStack.split(",")]), e3.scale && (r3["font-scale"] = e3.scale), e3.textColor && (r3["text-color"] = ["rgba"].concat(e3.textColor.toArray())), t3.push(r3);
            }
            return t3;
          }
        }
        class Ye {
          constructor(t3) {
            this.name = t3.name, this.available = t3.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t3) {
            return t3 ? new Ye({ name: t3, available: false }) : null;
          }
          serialize() {
            return ["image", this.name];
          }
        }
        function He(t3, e3, r3, n2) {
          return typeof t3 == "number" && t3 >= 0 && t3 <= 255 && typeof e3 == "number" && e3 >= 0 && e3 <= 255 && typeof r3 == "number" && r3 >= 0 && r3 <= 255 ? n2 === void 0 || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t3, e3, r3, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t3, e3, r3, n2] : [t3, e3, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Je(t3) {
          if (t3 === null)
            return true;
          if (typeof t3 == "string")
            return true;
          if (typeof t3 == "boolean")
            return true;
          if (typeof t3 == "number")
            return true;
          if (t3 instanceof Ge)
            return true;
          if (t3 instanceof Ze)
            return true;
          if (t3 instanceof Ke)
            return true;
          if (t3 instanceof Ye)
            return true;
          if (Array.isArray(t3)) {
            for (const e3 of t3)
              if (!Je(e3))
                return false;
            return true;
          }
          if (typeof t3 == "object") {
            for (const e3 in t3)
              if (!Je(t3[e3]))
                return false;
            return true;
          }
          return false;
        }
        function We(t3) {
          if (t3 === null)
            return ze;
          if (typeof t3 == "string")
            return Te;
          if (typeof t3 == "boolean")
            return Be;
          if (typeof t3 == "number")
            return Me;
          if (t3 instanceof Ge)
            return Ce;
          if (t3 instanceof Ze)
            return De;
          if (t3 instanceof Ke)
            return Ve;
          if (t3 instanceof Ye)
            return Fe;
          if (Array.isArray(t3)) {
            const e3 = t3.length;
            let r3;
            for (const e4 of t3) {
              const t4 = We(e4);
              if (r3) {
                if (r3 === t4)
                  continue;
                r3 = Ee;
                break;
              }
              r3 = t4;
            }
            return Le(r3 || Ee, e3);
          }
          return Pe;
        }
        function Qe(t3) {
          const e3 = typeof t3;
          return t3 === null ? "" : e3 === "string" || e3 === "number" || e3 === "boolean" ? String(t3) : t3 instanceof Ge || t3 instanceof Ke || t3 instanceof Ye ? t3.toString() : JSON.stringify(t3);
        }
        class tr {
          constructor(t3, e3) {
            this.type = t3, this.value = e3;
          }
          static parse(t3, e3) {
            if (t3.length !== 2)
              return e3.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (!Je(t3[1]))
              return e3.error("invalid value");
            const r3 = t3[1];
            let n2 = We(r3);
            const i3 = e3.expectedType;
            return n2.kind !== "array" || n2.N !== 0 || !i3 || i3.kind !== "array" || typeof i3.N == "number" && i3.N !== 0 || (n2 = i3), new tr(n2, r3);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Ge ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Ke ? this.value.serialize() : this.value;
          }
        }
        class er {
          constructor(t3) {
            this.name = "ExpressionEvaluationError", this.message = t3;
          }
          toJSON() {
            return this.message;
          }
        }
        const rr = { string: Te, number: Me, boolean: Be, object: Pe };
        class nr {
          constructor(t3, e3) {
            this.type = t3, this.args = e3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expected at least one argument.");
            let r3, n2 = 1;
            const i3 = t3[0];
            if (i3 === "array") {
              let i4, s5;
              if (t3.length > 2) {
                const r4 = t3[1];
                if (typeof r4 != "string" || !(r4 in rr) || r4 === "object")
                  return e3.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i4 = rr[r4], n2++;
              } else
                i4 = Ee;
              if (t3.length > 3) {
                if (t3[2] !== null && (typeof t3[2] != "number" || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
                  return e3.error('The length argument to "array" must be a positive integer literal', 2);
                s5 = t3[2], n2++;
              }
              r3 = Le(i4, s5);
            } else
              r3 = rr[i3];
            const s4 = [];
            for (; n2 < t3.length; n2++) {
              const r4 = e3.parse(t3[n2], n2, Ee);
              if (!r4)
                return null;
              s4.push(r4);
            }
            return new nr(r3, s4);
          }
          evaluate(t3) {
            for (let e3 = 0; e3 < this.args.length; e3++) {
              const r3 = this.args[e3].evaluate(t3);
              if (!$e(this.type, We(r3)))
                return r3;
              if (e3 === this.args.length - 1)
                throw new er(`Expected value to be of type ${Re(this.type)}, but found ${Re(We(r3))} instead.`);
            }
            return null;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = this.type, e3 = [t3.kind];
            if (t3.kind === "array") {
              const r3 = t3.itemType;
              if (r3.kind === "string" || r3.kind === "number" || r3.kind === "boolean") {
                e3.push(r3.kind);
                const n2 = t3.N;
                (typeof n2 == "number" || this.args.length > 1) && e3.push(n2);
              }
            }
            return e3.concat(this.args.map((t4) => t4.serialize()));
          }
        }
        class ir {
          constructor(t3) {
            this.type = Ve, this.sections = t3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expected at least one argument.");
            const r3 = t3[1];
            if (!Array.isArray(r3) && typeof r3 == "object")
              return e3.error("First argument must be an image or text section.");
            const n2 = [];
            let i3 = false;
            for (let r4 = 1; r4 <= t3.length - 1; ++r4) {
              const s4 = t3[r4];
              if (i3 && typeof s4 == "object" && !Array.isArray(s4)) {
                i3 = false;
                let t4 = null;
                if (s4["font-scale"] && (t4 = e3.parse(s4["font-scale"], 1, Me), !t4))
                  return null;
                let r5 = null;
                if (s4["text-font"] && (r5 = e3.parse(s4["text-font"], 1, Le(Te)), !r5))
                  return null;
                let a2 = null;
                if (s4["text-color"] && (a2 = e3.parse(s4["text-color"], 1, Ce), !a2))
                  return null;
                const o2 = n2[n2.length - 1];
                o2.scale = t4, o2.font = r5, o2.textColor = a2;
              } else {
                const s5 = e3.parse(t3[r4], 1, Ee);
                if (!s5)
                  return null;
                const a2 = s5.type.kind;
                if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                  return e3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i3 = true, n2.push({ content: s5, scale: null, font: null, textColor: null });
              }
            }
            return new ir(n2);
          }
          evaluate(t3) {
            return new Ke(this.sections.map((e3) => {
              const r3 = e3.content.evaluate(t3);
              return We(r3) === Fe ? new Xe("", r3, null, null, null) : new Xe(Qe(r3), null, e3.scale ? e3.scale.evaluate(t3) : null, e3.font ? e3.font.evaluate(t3).join(",") : null, e3.textColor ? e3.textColor.evaluate(t3) : null);
            }));
          }
          eachChild(t3) {
            for (const e3 of this.sections)
              t3(e3.content), e3.scale && t3(e3.scale), e3.font && t3(e3.font), e3.textColor && t3(e3.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["format"];
            for (const e3 of this.sections) {
              t3.push(e3.content.serialize());
              const r3 = {};
              e3.scale && (r3["font-scale"] = e3.scale.serialize()), e3.font && (r3["text-font"] = e3.font.serialize()), e3.textColor && (r3["text-color"] = e3.textColor.serialize()), t3.push(r3);
            }
            return t3;
          }
        }
        class sr {
          constructor(t3) {
            this.type = Fe, this.input = t3;
          }
          static parse(t3, e3) {
            if (t3.length !== 2)
              return e3.error("Expected two arguments.");
            const r3 = e3.parse(t3[1], 1, Te);
            return r3 ? new sr(r3) : e3.error("No image name provided.");
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3), r3 = Ye.fromString(e3);
            return r3 && t3.availableImages && (r3.available = t3.availableImages.indexOf(e3) > -1), r3;
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["image", this.input.serialize()];
          }
        }
        const ar = { "to-boolean": Be, "to-color": Ce, "to-number": Me, "to-string": Te };
        class or {
          constructor(t3, e3) {
            this.type = t3, this.args = e3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expected at least one argument.");
            const r3 = t3[0];
            if ((r3 === "to-boolean" || r3 === "to-string") && t3.length !== 2)
              return e3.error("Expected one argument.");
            const n2 = ar[r3], i3 = [];
            for (let r4 = 1; r4 < t3.length; r4++) {
              const n3 = e3.parse(t3[r4], r4, Ee);
              if (!n3)
                return null;
              i3.push(n3);
            }
            return new or(n2, i3);
          }
          evaluate(t3) {
            if (this.type.kind === "boolean")
              return Boolean(this.args[0].evaluate(t3));
            if (this.type.kind === "color") {
              let e3, r3;
              for (const n2 of this.args) {
                if (e3 = n2.evaluate(t3), r3 = null, e3 instanceof Ge)
                  return e3;
                if (typeof e3 == "string") {
                  const r4 = t3.parseColor(e3);
                  if (r4)
                    return r4;
                } else if (Array.isArray(e3) && (r3 = e3.length < 3 || e3.length > 4 ? `Invalid rbga value ${JSON.stringify(e3)}: expected an array containing either three or four numeric values.` : He(e3[0], e3[1], e3[2], e3[3]), !r3))
                  return new Ge(e3[0] / 255, e3[1] / 255, e3[2] / 255, e3[3]);
              }
              throw new er(r3 || `Could not parse color from value '${typeof e3 == "string" ? e3 : String(JSON.stringify(e3))}'`);
            }
            if (this.type.kind === "number") {
              let e3 = null;
              for (const r3 of this.args) {
                if (e3 = r3.evaluate(t3), e3 === null)
                  return 0;
                const n2 = Number(e3);
                if (!isNaN(n2))
                  return n2;
              }
              throw new er(`Could not convert ${JSON.stringify(e3)} to number.`);
            }
            return this.type.kind === "formatted" ? Ke.fromString(Qe(this.args[0].evaluate(t3))) : this.type.kind === "resolvedImage" ? Ye.fromString(Qe(this.args[0].evaluate(t3))) : Qe(this.args[0].evaluate(t3));
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            if (this.type.kind === "formatted")
              return new ir([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if (this.type.kind === "resolvedImage")
              return new sr(this.args[0]).serialize();
            const t3 = [`to-${this.type.kind}`];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        const lr = ["Unknown", "Point", "LineString", "Polygon"];
        class ur {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? lr[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t3 = this.featureDistanceData.center, e3 = this.featureDistanceData.scale, { x: r3, y: n2 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r3 * e3 - t3[0]) + this.featureDistanceData.bearing[1] * (n2 * e3 - t3[1]);
            }
            return 0;
          }
          parseColor(t3) {
            let e3 = this._parseColorCache[t3];
            return e3 || (e3 = this._parseColorCache[t3] = Ge.parse(t3)), e3;
          }
        }
        class cr {
          constructor(t3, e3, r3, n2) {
            this.name = t3, this.type = e3, this._evaluate = r3, this.args = n2;
          }
          evaluate(t3) {
            return this._evaluate(t3, this.args);
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t3) => t3.serialize()));
          }
          static parse(t3, e3) {
            const r3 = t3[0], n2 = cr.definitions[r3];
            if (!n2)
              return e3.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i3 = Array.isArray(n2) ? n2[0] : n2.type, s4 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s4.filter(([e4]) => !Array.isArray(e4) || e4.length === t3.length - 1);
            let o2 = null;
            for (const [n3, s5] of a2) {
              o2 = new Er(e3.registry, e3.path, null, e3.scope);
              const a3 = [];
              let l2 = false;
              for (let e4 = 1; e4 < t3.length; e4++) {
                const r4 = t3[e4], i4 = Array.isArray(n3) ? n3[e4 - 1] : n3.type, s6 = o2.parse(r4, 1 + a3.length, i4);
                if (!s6) {
                  l2 = true;
                  break;
                }
                a3.push(s6);
              }
              if (!l2)
                if (Array.isArray(n3) && n3.length !== a3.length)
                  o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                else {
                  for (let t4 = 0; t4 < a3.length; t4++) {
                    const e4 = Array.isArray(n3) ? n3[t4] : n3.type, r4 = a3[t4];
                    o2.concat(t4 + 1).checkSubtype(e4, r4.type);
                  }
                  if (o2.errors.length === 0)
                    return new cr(r3, i3, s5, a3);
                }
            }
            if (a2.length === 1)
              e3.errors.push(...o2.errors);
            else {
              const r4 = (a2.length ? a2 : s4).map(([t4]) => {
                return e4 = t4, Array.isArray(e4) ? `(${e4.map(Re).join(", ")})` : `(${Re(e4.type)}...)`;
                var e4;
              }).join(" | "), n3 = [];
              for (let r5 = 1; r5 < t3.length; r5++) {
                const i4 = e3.parse(t3[r5], 1 + n3.length);
                if (!i4)
                  return null;
                n3.push(Re(i4.type));
              }
              e3.error(`Expected arguments of type ${r4}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t3, e3) {
            cr.definitions = e3;
            for (const r3 in e3)
              t3[r3] = cr;
          }
        }
        class hr {
          constructor(t3, e3, r3) {
            this.type = De, this.locale = r3, this.caseSensitive = t3, this.diacriticSensitive = e3;
          }
          static parse(t3, e3) {
            if (t3.length !== 2)
              return e3.error("Expected one argument.");
            const r3 = t3[1];
            if (typeof r3 != "object" || Array.isArray(r3))
              return e3.error("Collator options argument must be an object.");
            const n2 = e3.parse(r3["case-sensitive"] !== void 0 && r3["case-sensitive"], 1, Be);
            if (!n2)
              return null;
            const i3 = e3.parse(r3["diacritic-sensitive"] !== void 0 && r3["diacritic-sensitive"], 1, Be);
            if (!i3)
              return null;
            let s4 = null;
            return r3.locale && (s4 = e3.parse(r3.locale, 1, Te), !s4) ? null : new hr(n2, i3, s4);
          }
          evaluate(t3) {
            return new Ze(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
          }
          eachChild(t3) {
            t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = {};
            return t3["case-sensitive"] = this.caseSensitive.serialize(), t3["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t3.locale = this.locale.serialize()), ["collator", t3];
          }
        }
        const pr = 8192;
        function dr(t3, e3) {
          t3[0] = Math.min(t3[0], e3[0]), t3[1] = Math.min(t3[1], e3[1]), t3[2] = Math.max(t3[2], e3[0]), t3[3] = Math.max(t3[3], e3[1]);
        }
        function fr(t3, e3) {
          return !(t3[0] <= e3[0] || t3[2] >= e3[2] || t3[1] <= e3[1] || t3[3] >= e3[3]);
        }
        function yr(t3, e3) {
          const r3 = (180 + t3[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e3.z);
          return [Math.round(r3 * i3 * pr), Math.round(n2 * i3 * pr)];
        }
        function mr(t3, e3, r3) {
          const n2 = t3[0] - e3[0], i3 = t3[1] - e3[1], s4 = t3[0] - r3[0], a2 = t3[1] - r3[1];
          return n2 * a2 - s4 * i3 == 0 && n2 * s4 <= 0 && i3 * a2 <= 0;
        }
        function gr(t3, e3) {
          let r3 = false;
          for (let a2 = 0, o2 = e3.length; a2 < o2; a2++) {
            const o3 = e3[a2];
            for (let e4 = 0, a3 = o3.length; e4 < a3 - 1; e4++) {
              if (mr(t3, o3[e4], o3[e4 + 1]))
                return false;
              (i3 = o3[e4])[1] > (n2 = t3)[1] != (s4 = o3[e4 + 1])[1] > n2[1] && n2[0] < (s4[0] - i3[0]) * (n2[1] - i3[1]) / (s4[1] - i3[1]) + i3[0] && (r3 = !r3);
            }
          }
          var n2, i3, s4;
          return r3;
        }
        function xr(t3, e3) {
          for (let r3 = 0; r3 < e3.length; r3++)
            if (gr(t3, e3[r3]))
              return true;
          return false;
        }
        function vr(t3, e3, r3, n2) {
          const i3 = n2[0] - r3[0], s4 = n2[1] - r3[1], a2 = (t3[0] - r3[0]) * s4 - i3 * (t3[1] - r3[1]), o2 = (e3[0] - r3[0]) * s4 - i3 * (e3[1] - r3[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function br(t3, e3, r3) {
          for (const u2 of r3)
            for (let r4 = 0; r4 < u2.length - 1; ++r4)
              if ((o2 = [(a2 = u2[r4 + 1])[0] - (s4 = u2[r4])[0], a2[1] - s4[1]])[0] * (l2 = [(i3 = e3)[0] - (n2 = t3)[0], i3[1] - n2[1]])[1] - o2[1] * l2[0] != 0 && vr(n2, i3, s4, a2) && vr(s4, a2, n2, i3))
                return true;
          var n2, i3, s4, a2, o2, l2;
          return false;
        }
        function wr(t3, e3) {
          for (let r3 = 0; r3 < t3.length; ++r3)
            if (!gr(t3[r3], e3))
              return false;
          for (let r3 = 0; r3 < t3.length - 1; ++r3)
            if (br(t3[r3], t3[r3 + 1], e3))
              return false;
          return true;
        }
        function _r(t3, e3) {
          for (let r3 = 0; r3 < e3.length; r3++)
            if (wr(t3, e3[r3]))
              return true;
          return false;
        }
        function Ar(t3, e3, r3) {
          const n2 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const s4 = [];
            for (let n3 = 0; n3 < t3[i3].length; n3++) {
              const a2 = yr(t3[i3][n3], r3);
              dr(e3, a2), s4.push(a2);
            }
            n2.push(s4);
          }
          return n2;
        }
        function kr(t3, e3, r3) {
          const n2 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const s4 = Ar(t3[i3], e3, r3);
            n2.push(s4);
          }
          return n2;
        }
        function Sr(t3, e3, r3, n2) {
          if (t3[0] < r3[0] || t3[0] > r3[2]) {
            const e4 = 0.5 * n2;
            let i3 = t3[0] - r3[0] > e4 ? -n2 : r3[0] - t3[0] > e4 ? n2 : 0;
            i3 === 0 && (i3 = t3[0] - r3[2] > e4 ? -n2 : r3[2] - t3[0] > e4 ? n2 : 0), t3[0] += i3;
          }
          dr(e3, t3);
        }
        function Ir(t3, e3, r3, n2) {
          const i3 = Math.pow(2, n2.z) * pr, s4 = [n2.x * pr, n2.y * pr], a2 = [];
          for (const n3 of t3)
            for (const t4 of n3) {
              const n4 = [t4.x + s4[0], t4.y + s4[1]];
              Sr(n4, e3, r3, i3), a2.push(n4);
            }
          return a2;
        }
        function zr(t3, e3, r3, n2) {
          const i3 = Math.pow(2, n2.z) * pr, s4 = [n2.x * pr, n2.y * pr], a2 = [];
          for (const r4 of t3) {
            const t4 = [];
            for (const n3 of r4) {
              const r5 = [n3.x + s4[0], n3.y + s4[1]];
              dr(e3, r5), t4.push(r5);
            }
            a2.push(t4);
          }
          if (e3[2] - e3[0] <= i3 / 2) {
            (o2 = e3)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t4 of a2)
              for (const n3 of t4)
                Sr(n3, e3, r3, i3);
          }
          var o2;
          return a2;
        }
        class Mr {
          constructor(t3, e3) {
            this.type = Be, this.geojson = t3, this.geometries = e3;
          }
          static parse(t3, e3) {
            if (t3.length !== 2)
              return e3.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (Je(t3[1])) {
              const e4 = t3[1];
              if (e4.type === "FeatureCollection")
                for (let t4 = 0; t4 < e4.features.length; ++t4) {
                  const r3 = e4.features[t4].geometry.type;
                  if (r3 === "Polygon" || r3 === "MultiPolygon")
                    return new Mr(e4, e4.features[t4].geometry);
                }
              else if (e4.type === "Feature") {
                const t4 = e4.geometry.type;
                if (t4 === "Polygon" || t4 === "MultiPolygon")
                  return new Mr(e4, e4.geometry);
              } else if (e4.type === "Polygon" || e4.type === "MultiPolygon")
                return new Mr(e4, e4);
            }
            return e3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t3) {
            if (t3.geometry() != null && t3.canonicalID() != null) {
              if (t3.geometryType() === "Point")
                return function(t4, e3) {
                  const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                  if (e3.type === "Polygon") {
                    const s4 = Ar(e3.coordinates, n2, i3), a2 = Ir(t4.geometry(), r3, n2, i3);
                    if (!fr(r3, n2))
                      return false;
                    for (const t5 of a2)
                      if (!gr(t5, s4))
                        return false;
                  }
                  if (e3.type === "MultiPolygon") {
                    const s4 = kr(e3.coordinates, n2, i3), a2 = Ir(t4.geometry(), r3, n2, i3);
                    if (!fr(r3, n2))
                      return false;
                    for (const t5 of a2)
                      if (!xr(t5, s4))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
              if (t3.geometryType() === "LineString")
                return function(t4, e3) {
                  const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                  if (e3.type === "Polygon") {
                    const s4 = Ar(e3.coordinates, n2, i3), a2 = zr(t4.geometry(), r3, n2, i3);
                    if (!fr(r3, n2))
                      return false;
                    for (const t5 of a2)
                      if (!wr(t5, s4))
                        return false;
                  }
                  if (e3.type === "MultiPolygon") {
                    const s4 = kr(e3.coordinates, n2, i3), a2 = zr(t4.geometry(), r3, n2, i3);
                    if (!fr(r3, n2))
                      return false;
                    for (const t5 of a2)
                      if (!_r(t5, s4))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        function Tr(t3) {
          if (t3 instanceof cr) {
            if (t3.name === "get" && t3.args.length === 1)
              return false;
            if (t3.name === "feature-state")
              return false;
            if (t3.name === "has" && t3.args.length === 1)
              return false;
            if (t3.name === "properties" || t3.name === "geometry-type" || t3.name === "id")
              return false;
            if (/^filter-/.test(t3.name))
              return false;
          }
          if (t3 instanceof Mr)
            return false;
          let e3 = true;
          return t3.eachChild((t4) => {
            e3 && !Tr(t4) && (e3 = false);
          }), e3;
        }
        function Br(t3) {
          if (t3 instanceof cr && t3.name === "feature-state")
            return false;
          let e3 = true;
          return t3.eachChild((t4) => {
            e3 && !Br(t4) && (e3 = false);
          }), e3;
        }
        function Cr(t3, e3) {
          if (t3 instanceof cr && e3.indexOf(t3.name) >= 0)
            return false;
          let r3 = true;
          return t3.eachChild((t4) => {
            r3 && !Cr(t4, e3) && (r3 = false);
          }), r3;
        }
        class Pr {
          constructor(t3, e3) {
            this.type = e3.type, this.name = t3, this.boundExpression = e3;
          }
          static parse(t3, e3) {
            if (t3.length !== 2 || typeof t3[1] != "string")
              return e3.error("'var' expression requires exactly one string literal argument.");
            const r3 = t3[1];
            return e3.scope.has(r3) ? new Pr(r3, e3.scope.get(r3)) : e3.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t3) {
            return this.boundExpression.evaluate(t3);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class Er {
          constructor(t3, e3 = [], r3, n2 = new Ie(), i3 = []) {
            this.registry = t3, this.path = e3, this.key = e3.map((t4) => `[${t4}]`).join(""), this.scope = n2, this.errors = i3, this.expectedType = r3;
          }
          parse(t3, e3, r3, n2, i3 = {}) {
            return e3 ? this.concat(e3, r3, n2)._parse(t3, i3) : this._parse(t3, i3);
          }
          _parse(t3, e3) {
            function r3(t4, e4, r4) {
              return r4 === "assert" ? new nr(e4, [t4]) : r4 === "coerce" ? new or(e4, [t4]) : t4;
            }
            if (t3 !== null && typeof t3 != "string" && typeof t3 != "boolean" && typeof t3 != "number" || (t3 = ["literal", t3]), Array.isArray(t3)) {
              if (t3.length === 0)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t3[0];
              if (typeof n2 != "string")
                return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i3 = this.registry[n2];
              if (i3) {
                let n3 = i3.parse(t3, this);
                if (!n3)
                  return null;
                if (this.expectedType) {
                  const t4 = this.expectedType, i4 = n3.type;
                  if (t4.kind !== "string" && t4.kind !== "number" && t4.kind !== "boolean" && t4.kind !== "object" && t4.kind !== "array" || i4.kind !== "value")
                    if (t4.kind !== "color" && t4.kind !== "formatted" && t4.kind !== "resolvedImage" || i4.kind !== "value" && i4.kind !== "string") {
                      if (this.checkSubtype(t4, i4))
                        return null;
                    } else
                      n3 = r3(n3, t4, e3.typeAnnotation || "coerce");
                  else
                    n3 = r3(n3, t4, e3.typeAnnotation || "assert");
                }
                if (!(n3 instanceof tr) && n3.type.kind !== "resolvedImage" && Dr(n3)) {
                  const t4 = new ur();
                  try {
                    n3 = new tr(n3.type, n3.evaluate(t4));
                  } catch (t5) {
                    return this.error(t5.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t3 === void 0 ? "'undefined' value invalid. Use null instead." : typeof t3 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
          }
          concat(t3, e3, r3) {
            const n2 = typeof t3 == "number" ? this.path.concat(t3) : this.path, i3 = r3 ? this.scope.concat(r3) : this.scope;
            return new Er(this.registry, n2, e3 || null, i3, this.errors);
          }
          error(t3, ...e3) {
            const r3 = `${this.key}${e3.map((t4) => `[${t4}]`).join("")}`;
            this.errors.push(new Se(r3, t3));
          }
          checkSubtype(t3, e3) {
            const r3 = $e(t3, e3);
            return r3 && this.error(r3), r3;
          }
        }
        function Dr(t3) {
          if (t3 instanceof Pr)
            return Dr(t3.boundExpression);
          if (t3 instanceof cr && t3.name === "error")
            return false;
          if (t3 instanceof hr)
            return false;
          if (t3 instanceof Mr)
            return false;
          const e3 = t3 instanceof or || t3 instanceof nr;
          let r3 = true;
          return t3.eachChild((t4) => {
            r3 = e3 ? r3 && Dr(t4) : r3 && t4 instanceof tr;
          }), !!r3 && Tr(t3) && Cr(t3, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
        }
        function Vr(t3, e3) {
          const r3 = t3.length - 1;
          let n2, i3, s4 = 0, a2 = r3, o2 = 0;
          for (; s4 <= a2; )
            if (o2 = Math.floor((s4 + a2) / 2), n2 = t3[o2], i3 = t3[o2 + 1], n2 <= e3) {
              if (o2 === r3 || e3 < i3)
                return o2;
              s4 = o2 + 1;
            } else {
              if (!(n2 > e3))
                throw new er("Input is not a number.");
              a2 = o2 - 1;
            }
          return 0;
        }
        class Fr {
          constructor(t3, e3, r3) {
            this.type = t3, this.input = e3, this.labels = [], this.outputs = [];
            for (const [t4, e4] of r3)
              this.labels.push(t4), this.outputs.push(e4);
          }
          static parse(t3, e3) {
            if (t3.length - 1 < 4)
              return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e3.error("Expected an even number of arguments.");
            const r3 = e3.parse(t3[1], 1, Me);
            if (!r3)
              return null;
            const n2 = [];
            let i3 = null;
            e3.expectedType && e3.expectedType.kind !== "value" && (i3 = e3.expectedType);
            for (let r4 = 1; r4 < t3.length; r4 += 2) {
              const s4 = r4 === 1 ? -1 / 0 : t3[r4], a2 = t3[r4 + 1], o2 = r4, l2 = r4 + 1;
              if (typeof s4 != "number")
                return e3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s4)
                return e3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e3.parse(a2, l2, i3);
              if (!u2)
                return null;
              i3 = i3 || u2.type, n2.push([s4, u2]);
            }
            return new Fr(i3, r3, n2);
          }
          evaluate(t3) {
            const e3 = this.labels, r3 = this.outputs;
            if (e3.length === 1)
              return r3[0].evaluate(t3);
            const n2 = this.input.evaluate(t3);
            if (n2 <= e3[0])
              return r3[0].evaluate(t3);
            const i3 = e3.length;
            return n2 >= e3[i3 - 1] ? r3[i3 - 1].evaluate(t3) : r3[Vr(e3, n2)].evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input);
            for (const e3 of this.outputs)
              t3(e3);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = ["step", this.input.serialize()];
            for (let e3 = 0; e3 < this.labels.length; e3++)
              e3 > 0 && t3.push(this.labels[e3]), t3.push(this.outputs[e3].serialize());
            return t3;
          }
        }
        function Lr(t3, e3, r3) {
          return t3 * (1 - r3) + e3 * r3;
        }
        var Rr = Object.freeze({ __proto__: null, number: Lr, color: function(t3, e3, r3) {
          return new Ge(Lr(t3.r, e3.r, r3), Lr(t3.g, e3.g, r3), Lr(t3.b, e3.b, r3), Lr(t3.a, e3.a, r3));
        }, array: function(t3, e3, r3) {
          return t3.map((t4, n2) => Lr(t4, e3[n2], r3));
        } });
        const Ur = 0.95047, $r = 1.08883, Or = 4 / 29, jr = 6 / 29, qr = 3 * jr * jr, Nr = Math.PI / 180, Gr = 180 / Math.PI;
        function Zr(t3) {
          return t3 > 0.008856451679035631 ? Math.pow(t3, 1 / 3) : t3 / qr + Or;
        }
        function Xr(t3) {
          return t3 > jr ? t3 * t3 * t3 : qr * (t3 - Or);
        }
        function Kr(t3) {
          return 255 * (t3 <= 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
        }
        function Yr(t3) {
          return (t3 /= 255) <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
        }
        function Hr(t3) {
          const e3 = Yr(t3.r), r3 = Yr(t3.g), n2 = Yr(t3.b), i3 = Zr((0.4124564 * e3 + 0.3575761 * r3 + 0.1804375 * n2) / Ur), s4 = Zr((0.2126729 * e3 + 0.7151522 * r3 + 0.072175 * n2) / 1);
          return { l: 116 * s4 - 16, a: 500 * (i3 - s4), b: 200 * (s4 - Zr((0.0193339 * e3 + 0.119192 * r3 + 0.9503041 * n2) / $r)), alpha: t3.a };
        }
        function Jr(t3) {
          let e3 = (t3.l + 16) / 116, r3 = isNaN(t3.a) ? e3 : e3 + t3.a / 500, n2 = isNaN(t3.b) ? e3 : e3 - t3.b / 200;
          return e3 = 1 * Xr(e3), r3 = Ur * Xr(r3), n2 = $r * Xr(n2), new Ge(Kr(3.2404542 * r3 - 1.5371385 * e3 - 0.4985314 * n2), Kr(-0.969266 * r3 + 1.8760108 * e3 + 0.041556 * n2), Kr(0.0556434 * r3 - 0.2040259 * e3 + 1.0572252 * n2), t3.alpha);
        }
        function Wr(t3, e3, r3) {
          const n2 = e3 - t3;
          return t3 + r3 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        const Qr = { forward: Hr, reverse: Jr, interpolate: function(t3, e3, r3) {
          return { l: Lr(t3.l, e3.l, r3), a: Lr(t3.a, e3.a, r3), b: Lr(t3.b, e3.b, r3), alpha: Lr(t3.alpha, e3.alpha, r3) };
        } }, tn = { forward: function(t3) {
          const { l: e3, a: r3, b: n2 } = Hr(t3), i3 = Math.atan2(n2, r3) * Gr;
          return { h: i3 < 0 ? i3 + 360 : i3, c: Math.sqrt(r3 * r3 + n2 * n2), l: e3, alpha: t3.a };
        }, reverse: function(t3) {
          const e3 = t3.h * Nr, r3 = t3.c;
          return Jr({ l: t3.l, a: Math.cos(e3) * r3, b: Math.sin(e3) * r3, alpha: t3.alpha });
        }, interpolate: function(t3, e3, r3) {
          return { h: Wr(t3.h, e3.h, r3), c: Lr(t3.c, e3.c, r3), l: Lr(t3.l, e3.l, r3), alpha: Lr(t3.alpha, e3.alpha, r3) };
        } };
        var en = Object.freeze({ __proto__: null, lab: Qr, hcl: tn });
        class rn {
          constructor(t3, e3, r3, n2, i3) {
            this.type = t3, this.operator = e3, this.interpolation = r3, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t4, e4] of i3)
              this.labels.push(t4), this.outputs.push(e4);
          }
          static interpolationFactor(t3, e3, n2, i3) {
            let s4 = 0;
            if (t3.name === "exponential")
              s4 = nn(e3, t3.base, n2, i3);
            else if (t3.name === "linear")
              s4 = nn(e3, 1, n2, i3);
            else if (t3.name === "cubic-bezier") {
              const a2 = t3.controlPoints;
              s4 = new r2(a2[0], a2[1], a2[2], a2[3]).solve(nn(e3, 1, n2, i3));
            }
            return s4;
          }
          static parse(t3, e3) {
            let [r3, n2, i3, ...s4] = t3;
            if (!Array.isArray(n2) || n2.length === 0)
              return e3.error("Expected an interpolation type expression.", 1);
            if (n2[0] === "linear")
              n2 = { name: "linear" };
            else if (n2[0] === "exponential") {
              const t4 = n2[1];
              if (typeof t4 != "number")
                return e3.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t4 };
            } else {
              if (n2[0] !== "cubic-bezier")
                return e3.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t4 = n2.slice(1);
                if (t4.length !== 4 || t4.some((t5) => typeof t5 != "number" || t5 < 0 || t5 > 1))
                  return e3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t4 };
              }
            }
            if (t3.length - 1 < 4)
              return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e3.error("Expected an even number of arguments.");
            if (i3 = e3.parse(i3, 2, Me), !i3)
              return null;
            const a2 = [];
            let o2 = null;
            r3 === "interpolate-hcl" || r3 === "interpolate-lab" ? o2 = Ce : e3.expectedType && e3.expectedType.kind !== "value" && (o2 = e3.expectedType);
            for (let t4 = 0; t4 < s4.length; t4 += 2) {
              const r4 = s4[t4], n3 = s4[t4 + 1], i4 = t4 + 3, l2 = t4 + 4;
              if (typeof r4 != "number")
                return e3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
              if (a2.length && a2[a2.length - 1][0] >= r4)
                return e3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
              const u2 = e3.parse(n3, l2, o2);
              if (!u2)
                return null;
              o2 = o2 || u2.type, a2.push([r4, u2]);
            }
            return o2.kind === "number" || o2.kind === "color" || o2.kind === "array" && o2.itemType.kind === "number" && typeof o2.N == "number" ? new rn(o2, r3, n2, i3, a2) : e3.error(`Type ${Re(o2)} is not interpolatable.`);
          }
          evaluate(t3) {
            const e3 = this.labels, r3 = this.outputs;
            if (e3.length === 1)
              return r3[0].evaluate(t3);
            const n2 = this.input.evaluate(t3);
            if (n2 <= e3[0])
              return r3[0].evaluate(t3);
            const i3 = e3.length;
            if (n2 >= e3[i3 - 1])
              return r3[i3 - 1].evaluate(t3);
            const s4 = Vr(e3, n2), a2 = rn.interpolationFactor(this.interpolation, n2, e3[s4], e3[s4 + 1]), o2 = r3[s4].evaluate(t3), l2 = r3[s4 + 1].evaluate(t3);
            return this.operator === "interpolate" ? Rr[this.type.kind.toLowerCase()](o2, l2, a2) : this.operator === "interpolate-hcl" ? tn.reverse(tn.interpolate(tn.forward(o2), tn.forward(l2), a2)) : Qr.reverse(Qr.interpolate(Qr.forward(o2), Qr.forward(l2), a2));
          }
          eachChild(t3) {
            t3(this.input);
            for (const e3 of this.outputs)
              t3(e3);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
          serialize() {
            let t3;
            t3 = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e3 = [this.operator, t3, this.input.serialize()];
            for (let t4 = 0; t4 < this.labels.length; t4++)
              e3.push(this.labels[t4], this.outputs[t4].serialize());
            return e3;
          }
        }
        function nn(t3, e3, r3, n2) {
          const i3 = n2 - r3, s4 = t3 - r3;
          return i3 === 0 ? 0 : e3 === 1 ? s4 / i3 : (Math.pow(e3, s4) - 1) / (Math.pow(e3, i3) - 1);
        }
        class sn {
          constructor(t3, e3) {
            this.type = t3, this.args = e3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expectected at least one argument.");
            let r3 = null;
            const n2 = e3.expectedType;
            n2 && n2.kind !== "value" && (r3 = n2);
            const i3 = [];
            for (const n3 of t3.slice(1)) {
              const t4 = e3.parse(n3, 1 + i3.length, r3, void 0, { typeAnnotation: "omit" });
              if (!t4)
                return null;
              r3 = r3 || t4.type, i3.push(t4);
            }
            const s4 = n2 && i3.some((t4) => $e(n2, t4.type));
            return new sn(s4 ? Ee : r3, i3);
          }
          evaluate(t3) {
            let e3, r3 = null, n2 = 0;
            for (const i3 of this.args) {
              if (n2++, r3 = i3.evaluate(t3), r3 && r3 instanceof Ye && !r3.available && (e3 || (e3 = r3), r3 = null, n2 === this.args.length))
                return e3;
              if (r3 !== null)
                break;
            }
            return r3;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = ["coalesce"];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        class an {
          constructor(t3, e3) {
            this.type = e3.type, this.bindings = [].concat(t3), this.result = e3;
          }
          evaluate(t3) {
            return this.result.evaluate(t3);
          }
          eachChild(t3) {
            for (const e3 of this.bindings)
              t3(e3[1]);
            t3(this.result);
          }
          static parse(t3, e3) {
            if (t3.length < 4)
              return e3.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
            const r3 = [];
            for (let n3 = 1; n3 < t3.length - 1; n3 += 2) {
              const i3 = t3[n3];
              if (typeof i3 != "string")
                return e3.error(`Expected string, but found ${typeof i3} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i3))
                return e3.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s4 = e3.parse(t3[n3 + 1], n3 + 1);
              if (!s4)
                return null;
              r3.push([i3, s4]);
            }
            const n2 = e3.parse(t3[t3.length - 1], t3.length - 1, e3.expectedType, r3);
            return n2 ? new an(r3, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t3 = ["let"];
            for (const [e3, r3] of this.bindings)
              t3.push(e3, r3.serialize());
            return t3.push(this.result.serialize()), t3;
          }
        }
        class on {
          constructor(t3, e3, r3) {
            this.type = t3, this.index = e3, this.input = r3;
          }
          static parse(t3, e3) {
            if (t3.length !== 3)
              return e3.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, Me), n2 = e3.parse(t3[2], 2, Le(e3.expectedType || Ee));
            return r3 && n2 ? new on(n2.type.itemType, r3, n2) : null;
          }
          evaluate(t3) {
            const e3 = this.index.evaluate(t3), r3 = this.input.evaluate(t3);
            if (e3 < 0)
              throw new er(`Array index out of bounds: ${e3} < 0.`);
            if (e3 >= r3.length)
              throw new er(`Array index out of bounds: ${e3} > ${r3.length - 1}.`);
            if (e3 !== Math.floor(e3))
              throw new er(`Array index must be an integer, but found ${e3} instead.`);
            return r3[e3];
          }
          eachChild(t3) {
            t3(this.index), t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class ln {
          constructor(t3, e3) {
            this.type = Be, this.needle = t3, this.haystack = e3;
          }
          static parse(t3, e3) {
            if (t3.length !== 3)
              return e3.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, Ee), n2 = e3.parse(t3[2], 2, Ee);
            return r3 && n2 ? Oe(r3.type, [Be, Te, Me, ze, Ee]) ? new ln(r3, n2) : e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${Re(r3.type)} instead`) : null;
          }
          evaluate(t3) {
            const e3 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
            if (!r3)
              return false;
            if (!je(e3, ["boolean", "string", "number", "null"]))
              throw new er(`Expected first argument to be of type boolean, string, number or null, but found ${Re(We(e3))} instead.`);
            if (!je(r3, ["string", "array"]))
              throw new er(`Expected second argument to be of type array or string, but found ${Re(We(r3))} instead.`);
            return r3.indexOf(e3) >= 0;
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class un {
          constructor(t3, e3, r3) {
            this.type = Me, this.needle = t3, this.haystack = e3, this.fromIndex = r3;
          }
          static parse(t3, e3) {
            if (t3.length <= 2 || t3.length >= 5)
              return e3.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, Ee), n2 = e3.parse(t3[2], 2, Ee);
            if (!r3 || !n2)
              return null;
            if (!Oe(r3.type, [Be, Te, Me, ze, Ee]))
              return e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${Re(r3.type)} instead`);
            if (t3.length === 4) {
              const i3 = e3.parse(t3[3], 3, Me);
              return i3 ? new un(r3, n2, i3) : null;
            }
            return new un(r3, n2);
          }
          evaluate(t3) {
            const e3 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
            if (!je(e3, ["boolean", "string", "number", "null"]))
              throw new er(`Expected first argument to be of type boolean, string, number or null, but found ${Re(We(e3))} instead.`);
            if (!je(r3, ["string", "array"]))
              throw new er(`Expected second argument to be of type array or string, but found ${Re(We(r3))} instead.`);
            if (this.fromIndex) {
              const n2 = this.fromIndex.evaluate(t3);
              return r3.indexOf(e3, n2);
            }
            return r3.indexOf(e3);
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (this.fromIndex != null && this.fromIndex !== void 0) {
              const t3 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t3];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class cn {
          constructor(t3, e3, r3, n2, i3, s4) {
            this.inputType = t3, this.type = e3, this.input = r3, this.cases = n2, this.outputs = i3, this.otherwise = s4;
          }
          static parse(t3, e3) {
            if (t3.length < 5)
              return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 1)
              return e3.error("Expected an even number of arguments.");
            let r3, n2;
            e3.expectedType && e3.expectedType.kind !== "value" && (n2 = e3.expectedType);
            const i3 = {}, s4 = [];
            for (let a3 = 2; a3 < t3.length - 1; a3 += 2) {
              let o3 = t3[a3];
              const l2 = t3[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e3.concat(a3);
              if (o3.length === 0)
                return u2.error("Expected at least one branch label.");
              for (const t4 of o3) {
                if (typeof t4 != "number" && typeof t4 != "string")
                  return u2.error("Branch labels must be numbers or strings.");
                if (typeof t4 == "number" && Math.abs(t4) > Number.MAX_SAFE_INTEGER)
                  return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof t4 == "number" && Math.floor(t4) !== t4)
                  return u2.error("Numeric branch labels must be integer values.");
                if (r3) {
                  if (u2.checkSubtype(r3, We(t4)))
                    return null;
                } else
                  r3 = We(t4);
                if (i3[String(t4)] !== void 0)
                  return u2.error("Branch labels must be unique.");
                i3[String(t4)] = s4.length;
              }
              const c2 = e3.parse(l2, a3, n2);
              if (!c2)
                return null;
              n2 = n2 || c2.type, s4.push(c2);
            }
            const a2 = e3.parse(t3[1], 1, Ee);
            if (!a2)
              return null;
            const o2 = e3.parse(t3[t3.length - 1], t3.length - 1, n2);
            return o2 ? a2.type.kind !== "value" && e3.concat(1).checkSubtype(r3, a2.type) ? null : new cn(r3, n2, a2, i3, s4, o2) : null;
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3);
            return (We(e3) === this.inputType && this.outputs[this.cases[e3]] || this.otherwise).evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t3 = ["match", this.input.serialize()], e3 = Object.keys(this.cases).sort(), r3 = [], n2 = {};
            for (const t4 of e3) {
              const e4 = n2[this.cases[t4]];
              e4 === void 0 ? (n2[this.cases[t4]] = r3.length, r3.push([this.cases[t4], [t4]])) : r3[e4][1].push(t4);
            }
            const i3 = (t4) => this.inputType.kind === "number" ? Number(t4) : t4;
            for (const [e4, n3] of r3)
              t3.push(n3.length === 1 ? i3(n3[0]) : n3.map(i3)), t3.push(this.outputs[e4].serialize());
            return t3.push(this.otherwise.serialize()), t3;
          }
        }
        class hn {
          constructor(t3, e3, r3) {
            this.type = t3, this.branches = e3, this.otherwise = r3;
          }
          static parse(t3, e3) {
            if (t3.length < 4)
              return e3.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 0)
              return e3.error("Expected an odd number of arguments.");
            let r3;
            e3.expectedType && e3.expectedType.kind !== "value" && (r3 = e3.expectedType);
            const n2 = [];
            for (let i4 = 1; i4 < t3.length - 1; i4 += 2) {
              const s4 = e3.parse(t3[i4], i4, Be);
              if (!s4)
                return null;
              const a2 = e3.parse(t3[i4 + 1], i4 + 1, r3);
              if (!a2)
                return null;
              n2.push([s4, a2]), r3 = r3 || a2.type;
            }
            const i3 = e3.parse(t3[t3.length - 1], t3.length - 1, r3);
            return i3 ? new hn(r3, n2, i3) : null;
          }
          evaluate(t3) {
            for (const [e3, r3] of this.branches)
              if (e3.evaluate(t3))
                return r3.evaluate(t3);
            return this.otherwise.evaluate(t3);
          }
          eachChild(t3) {
            for (const [e3, r3] of this.branches)
              t3(e3), t3(r3);
            t3(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t3, e3]) => e3.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t3 = ["case"];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        class pn {
          constructor(t3, e3, r3, n2) {
            this.type = t3, this.input = e3, this.beginIndex = r3, this.endIndex = n2;
          }
          static parse(t3, e3) {
            if (t3.length <= 2 || t3.length >= 5)
              return e3.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, Ee), n2 = e3.parse(t3[2], 2, Me);
            if (!r3 || !n2)
              return null;
            if (!Oe(r3.type, [Le(Ee), Te, Ee]))
              return e3.error(`Expected first argument to be of type array or string, but found ${Re(r3.type)} instead`);
            if (t3.length === 4) {
              const i3 = e3.parse(t3[3], 3, Me);
              return i3 ? new pn(r3.type, r3, n2, i3) : null;
            }
            return new pn(r3.type, r3, n2);
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3), r3 = this.beginIndex.evaluate(t3);
            if (!je(e3, ["string", "array"]))
              throw new er(`Expected first argument to be of type array or string, but found ${Re(We(e3))} instead.`);
            if (this.endIndex) {
              const n2 = this.endIndex.evaluate(t3);
              return e3.slice(r3, n2);
            }
            return e3.slice(r3);
          }
          eachChild(t3) {
            t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (this.endIndex != null && this.endIndex !== void 0) {
              const t3 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t3];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        function dn(t3, e3) {
          return t3 === "==" || t3 === "!=" ? e3.kind === "boolean" || e3.kind === "string" || e3.kind === "number" || e3.kind === "null" || e3.kind === "value" : e3.kind === "string" || e3.kind === "number" || e3.kind === "value";
        }
        function fn(t3, e3, r3, n2) {
          return n2.compare(e3, r3) === 0;
        }
        function yn(t3, e3, r3) {
          const n2 = t3 !== "==" && t3 !== "!=";
          return class i3 {
            constructor(t4, e4, r4) {
              this.type = Be, this.lhs = t4, this.rhs = e4, this.collator = r4, this.hasUntypedArgument = t4.type.kind === "value" || e4.type.kind === "value";
            }
            static parse(t4, e4) {
              if (t4.length !== 3 && t4.length !== 4)
                return e4.error("Expected two or three arguments.");
              const r4 = t4[0];
              let s4 = e4.parse(t4[1], 1, Ee);
              if (!s4)
                return null;
              if (!dn(r4, s4.type))
                return e4.concat(1).error(`"${r4}" comparisons are not supported for type '${Re(s4.type)}'.`);
              let a2 = e4.parse(t4[2], 2, Ee);
              if (!a2)
                return null;
              if (!dn(r4, a2.type))
                return e4.concat(2).error(`"${r4}" comparisons are not supported for type '${Re(a2.type)}'.`);
              if (s4.type.kind !== a2.type.kind && s4.type.kind !== "value" && a2.type.kind !== "value")
                return e4.error(`Cannot compare types '${Re(s4.type)}' and '${Re(a2.type)}'.`);
              n2 && (s4.type.kind === "value" && a2.type.kind !== "value" ? s4 = new nr(a2.type, [s4]) : s4.type.kind !== "value" && a2.type.kind === "value" && (a2 = new nr(s4.type, [a2])));
              let o2 = null;
              if (t4.length === 4) {
                if (s4.type.kind !== "string" && a2.type.kind !== "string" && s4.type.kind !== "value" && a2.type.kind !== "value")
                  return e4.error("Cannot use collator to compare non-string types.");
                if (o2 = e4.parse(t4[3], 3, De), !o2)
                  return null;
              }
              return new i3(s4, a2, o2);
            }
            evaluate(i4) {
              const s4 = this.lhs.evaluate(i4), a2 = this.rhs.evaluate(i4);
              if (n2 && this.hasUntypedArgument) {
                const e4 = We(s4), r4 = We(a2);
                if (e4.kind !== r4.kind || e4.kind !== "string" && e4.kind !== "number")
                  throw new er(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e4.kind}, ${r4.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t4 = We(s4), r4 = We(a2);
                if (t4.kind !== "string" || r4.kind !== "string")
                  return e3(i4, s4, a2);
              }
              return this.collator ? r3(i4, s4, a2, this.collator.evaluate(i4)) : e3(i4, s4, a2);
            }
            eachChild(t4) {
              t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e4 = [t3];
              return this.eachChild((t4) => {
                e4.push(t4.serialize());
              }), e4;
            }
          };
        }
        const mn = yn("==", function(t3, e3, r3) {
          return e3 === r3;
        }, fn), gn = yn("!=", function(t3, e3, r3) {
          return e3 !== r3;
        }, function(t3, e3, r3, n2) {
          return !fn(0, e3, r3, n2);
        }), xn = yn("<", function(t3, e3, r3) {
          return e3 < r3;
        }, function(t3, e3, r3, n2) {
          return n2.compare(e3, r3) < 0;
        }), vn = yn(">", function(t3, e3, r3) {
          return e3 > r3;
        }, function(t3, e3, r3, n2) {
          return n2.compare(e3, r3) > 0;
        }), bn = yn("<=", function(t3, e3, r3) {
          return e3 <= r3;
        }, function(t3, e3, r3, n2) {
          return n2.compare(e3, r3) <= 0;
        }), wn = yn(">=", function(t3, e3, r3) {
          return e3 >= r3;
        }, function(t3, e3, r3, n2) {
          return n2.compare(e3, r3) >= 0;
        });
        class _n {
          constructor(t3, e3, r3, n2, i3) {
            this.type = Te, this.number = t3, this.locale = e3, this.currency = r3, this.minFractionDigits = n2, this.maxFractionDigits = i3;
          }
          static parse(t3, e3) {
            if (t3.length !== 3)
              return e3.error("Expected two arguments.");
            const r3 = e3.parse(t3[1], 1, Me);
            if (!r3)
              return null;
            const n2 = t3[2];
            if (typeof n2 != "object" || Array.isArray(n2))
              return e3.error("NumberFormat options argument must be an object.");
            let i3 = null;
            if (n2.locale && (i3 = e3.parse(n2.locale, 1, Te), !i3))
              return null;
            let s4 = null;
            if (n2.currency && (s4 = e3.parse(n2.currency, 1, Te), !s4))
              return null;
            let a2 = null;
            if (n2["min-fraction-digits"] && (a2 = e3.parse(n2["min-fraction-digits"], 1, Me), !a2))
              return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e3.parse(n2["max-fraction-digits"], 1, Me), !o2) ? null : new _n(r3, i3, s4, a2, o2);
          }
          evaluate(t3) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
          }
          eachChild(t3) {
            t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = {};
            return this.locale && (t3.locale = this.locale.serialize()), this.currency && (t3.currency = this.currency.serialize()), this.minFractionDigits && (t3["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t3["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t3];
          }
        }
        class An {
          constructor(t3) {
            this.type = Me, this.input = t3;
          }
          static parse(t3, e3) {
            if (t3.length !== 2)
              return e3.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1);
            return r3 ? r3.type.kind !== "array" && r3.type.kind !== "string" && r3.type.kind !== "value" ? e3.error(`Expected argument of type string or array, but found ${Re(r3.type)} instead.`) : new An(r3) : null;
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3);
            if (typeof e3 == "string")
              return e3.length;
            if (Array.isArray(e3))
              return e3.length;
            throw new er(`Expected value to be of type string or array, but found ${Re(We(e3))} instead.`);
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["length"];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        const kn = { "==": mn, "!=": gn, ">": vn, "<": xn, ">=": wn, "<=": bn, array: nr, at: on, boolean: nr, case: hn, coalesce: sn, collator: hr, format: ir, image: sr, in: ln, "index-of": un, interpolate: rn, "interpolate-hcl": rn, "interpolate-lab": rn, length: An, let: an, literal: tr, match: cn, number: nr, "number-format": _n, object: nr, slice: pn, step: Fr, string: nr, "to-boolean": or, "to-color": or, "to-number": or, "to-string": or, var: Pr, within: Mr };
        function Sn(t3, [e3, r3, n2, i3]) {
          e3 = e3.evaluate(t3), r3 = r3.evaluate(t3), n2 = n2.evaluate(t3);
          const s4 = i3 ? i3.evaluate(t3) : 1, a2 = He(e3, r3, n2, s4);
          if (a2)
            throw new er(a2);
          return new Ge(e3 / 255 * s4, r3 / 255 * s4, n2 / 255 * s4, s4);
        }
        function In(t3, e3) {
          return t3 in e3;
        }
        function zn(t3, e3) {
          const r3 = e3[t3];
          return r3 === void 0 ? null : r3;
        }
        function Mn(t3) {
          return { type: t3 };
        }
        function Tn(t3) {
          return { result: "success", value: t3 };
        }
        function Bn(t3) {
          return { result: "error", value: t3 };
        }
        function Cn(t3) {
          return t3["property-type"] === "data-driven" || t3["property-type"] === "cross-faded-data-driven";
        }
        function Pn(t3) {
          return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
        }
        function En(t3) {
          return !!t3.expression && t3.expression.interpolated;
        }
        function Dn(t3) {
          return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : t3 === null ? "null" : typeof t3;
        }
        function Vn(t3) {
          return typeof t3 == "object" && t3 !== null && !Array.isArray(t3);
        }
        function Fn(t3) {
          return t3;
        }
        function Ln(t3, e3) {
          const r3 = e3.type === "color", n2 = t3.stops && typeof t3.stops[0][0] == "object", i3 = n2 || !(n2 || t3.property !== void 0), s4 = t3.type || (En(e3) ? "exponential" : "interval");
          if (r3 && ((t3 = _e({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], Ge.parse(t4[1])])), t3.default = Ge.parse(t3.default ? t3.default : e3.default)), t3.colorSpace && t3.colorSpace !== "rgb" && !en[t3.colorSpace])
            throw new Error(`Unknown color space: ${t3.colorSpace}`);
          let a2, o2, l2;
          if (s4 === "exponential")
            a2 = On;
          else if (s4 === "interval")
            a2 = $n;
          else if (s4 === "categorical") {
            a2 = Un, o2 = Object.create(null);
            for (const e4 of t3.stops)
              o2[e4[0]] = e4[1];
            l2 = typeof t3.stops[0][0];
          } else {
            if (s4 !== "identity")
              throw new Error(`Unknown function type "${s4}"`);
            a2 = jn;
          }
          if (n2) {
            const r4 = {}, n3 = [];
            for (let e4 = 0; e4 < t3.stops.length; e4++) {
              const i5 = t3.stops[e4], s6 = i5[0].zoom;
              r4[s6] === void 0 && (r4[s6] = { zoom: s6, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n3.push(s6)), r4[s6].stops.push([i5[0].value, i5[1]]);
            }
            const i4 = [];
            for (const t4 of n3)
              i4.push([r4[t4].zoom, Ln(r4[t4], e3)]);
            const s5 = { name: "linear" };
            return { kind: "composite", interpolationType: s5, interpolationFactor: rn.interpolationFactor.bind(void 0, s5), zoomStops: i4.map((t4) => t4[0]), evaluate: ({ zoom: r5 }, n4) => On({ stops: i4, base: t3.base }, e3, r5).evaluate(r5, n4) };
          }
          if (i3) {
            const r4 = s4 === "exponential" ? { name: "exponential", base: t3.base !== void 0 ? t3.base : 1 } : null;
            return { kind: "camera", interpolationType: r4, interpolationFactor: rn.interpolationFactor.bind(void 0, r4), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r5 }) => a2(t3, e3, r5, o2, l2) };
          }
          return { kind: "source", evaluate(r4, n3) {
            const i4 = n3 && n3.properties ? n3.properties[t3.property] : void 0;
            return i4 === void 0 ? Rn(t3.default, e3.default) : a2(t3, e3, i4, o2, l2);
          } };
        }
        function Rn(t3, e3, r3) {
          return t3 !== void 0 ? t3 : e3 !== void 0 ? e3 : r3 !== void 0 ? r3 : void 0;
        }
        function Un(t3, e3, r3, n2, i3) {
          return Rn(typeof r3 === i3 ? n2[r3] : void 0, t3.default, e3.default);
        }
        function $n(t3, e3, r3) {
          if (Dn(r3) !== "number")
            return Rn(t3.default, e3.default);
          const n2 = t3.stops.length;
          if (n2 === 1)
            return t3.stops[0][1];
          if (r3 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r3 >= t3.stops[n2 - 1][0])
            return t3.stops[n2 - 1][1];
          const i3 = Vr(t3.stops.map((t4) => t4[0]), r3);
          return t3.stops[i3][1];
        }
        function On(t3, e3, r3) {
          const n2 = t3.base !== void 0 ? t3.base : 1;
          if (Dn(r3) !== "number")
            return Rn(t3.default, e3.default);
          const i3 = t3.stops.length;
          if (i3 === 1)
            return t3.stops[0][1];
          if (r3 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r3 >= t3.stops[i3 - 1][0])
            return t3.stops[i3 - 1][1];
          const s4 = Vr(t3.stops.map((t4) => t4[0]), r3), a2 = function(t4, e4, r4, n3) {
            const i4 = n3 - r4, s5 = t4 - r4;
            return i4 === 0 ? 0 : e4 === 1 ? s5 / i4 : (Math.pow(e4, s5) - 1) / (Math.pow(e4, i4) - 1);
          }(r3, n2, t3.stops[s4][0], t3.stops[s4 + 1][0]), o2 = t3.stops[s4][1], l2 = t3.stops[s4 + 1][1];
          let u2 = Rr[e3.type] || Fn;
          if (t3.colorSpace && t3.colorSpace !== "rgb") {
            const e4 = en[t3.colorSpace];
            u2 = (t4, r4) => e4.reverse(e4.interpolate(e4.forward(t4), e4.forward(r4), a2));
          }
          return typeof o2.evaluate == "function" ? { evaluate(...t4) {
            const e4 = o2.evaluate.apply(void 0, t4), r4 = l2.evaluate.apply(void 0, t4);
            if (e4 !== void 0 && r4 !== void 0)
              return u2(e4, r4, a2);
          } } : u2(o2, l2, a2);
        }
        function jn(t3, e3, r3) {
          return e3.type === "color" ? r3 = Ge.parse(r3) : e3.type === "formatted" ? r3 = Ke.fromString(r3.toString()) : e3.type === "resolvedImage" ? r3 = Ye.fromString(r3.toString()) : Dn(r3) === e3.type || e3.type === "enum" && e3.values[r3] || (r3 = void 0), Rn(r3, t3.default, e3.default);
        }
        cr.register(kn, { error: [{ kind: "error" }, [Te], (t3, [e3]) => {
          throw new er(e3.evaluate(t3));
        }], typeof: [Te, [Ee], (t3, [e3]) => Re(We(e3.evaluate(t3)))], "to-rgba": [Le(Me, 4), [Ce], (t3, [e3]) => e3.evaluate(t3).toArray()], rgb: [Ce, [Me, Me, Me], Sn], rgba: [Ce, [Me, Me, Me, Me], Sn], has: { type: Be, overloads: [[[Te], (t3, [e3]) => In(e3.evaluate(t3), t3.properties())], [[Te, Pe], (t3, [e3, r3]) => In(e3.evaluate(t3), r3.evaluate(t3))]] }, get: { type: Ee, overloads: [[[Te], (t3, [e3]) => zn(e3.evaluate(t3), t3.properties())], [[Te, Pe], (t3, [e3, r3]) => zn(e3.evaluate(t3), r3.evaluate(t3))]] }, "feature-state": [Ee, [Te], (t3, [e3]) => zn(e3.evaluate(t3), t3.featureState || {})], properties: [Pe, [], (t3) => t3.properties()], "geometry-type": [Te, [], (t3) => t3.geometryType()], id: [Ee, [], (t3) => t3.id()], zoom: [Me, [], (t3) => t3.globals.zoom], pitch: [Me, [], (t3) => t3.globals.pitch || 0], "distance-from-center": [Me, [], (t3) => t3.distanceFromCenter()], "heatmap-density": [Me, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [Me, [], (t3) => t3.globals.lineProgress || 0], "sky-radial-progress": [Me, [], (t3) => t3.globals.skyRadialProgress || 0], accumulated: [Ee, [], (t3) => t3.globals.accumulated === void 0 ? null : t3.globals.accumulated], "+": [Me, Mn(Me), (t3, e3) => {
          let r3 = 0;
          for (const n2 of e3)
            r3 += n2.evaluate(t3);
          return r3;
        }], "*": [Me, Mn(Me), (t3, e3) => {
          let r3 = 1;
          for (const n2 of e3)
            r3 *= n2.evaluate(t3);
          return r3;
        }], "-": { type: Me, overloads: [[[Me, Me], (t3, [e3, r3]) => e3.evaluate(t3) - r3.evaluate(t3)], [[Me], (t3, [e3]) => -e3.evaluate(t3)]] }, "/": [Me, [Me, Me], (t3, [e3, r3]) => e3.evaluate(t3) / r3.evaluate(t3)], "%": [Me, [Me, Me], (t3, [e3, r3]) => e3.evaluate(t3) % r3.evaluate(t3)], ln2: [Me, [], () => Math.LN2], pi: [Me, [], () => Math.PI], e: [Me, [], () => Math.E], "^": [Me, [Me, Me], (t3, [e3, r3]) => Math.pow(e3.evaluate(t3), r3.evaluate(t3))], sqrt: [Me, [Me], (t3, [e3]) => Math.sqrt(e3.evaluate(t3))], log10: [Me, [Me], (t3, [e3]) => Math.log(e3.evaluate(t3)) / Math.LN10], ln: [Me, [Me], (t3, [e3]) => Math.log(e3.evaluate(t3))], log2: [Me, [Me], (t3, [e3]) => Math.log(e3.evaluate(t3)) / Math.LN2], sin: [Me, [Me], (t3, [e3]) => Math.sin(e3.evaluate(t3))], cos: [Me, [Me], (t3, [e3]) => Math.cos(e3.evaluate(t3))], tan: [Me, [Me], (t3, [e3]) => Math.tan(e3.evaluate(t3))], asin: [Me, [Me], (t3, [e3]) => Math.asin(e3.evaluate(t3))], acos: [Me, [Me], (t3, [e3]) => Math.acos(e3.evaluate(t3))], atan: [Me, [Me], (t3, [e3]) => Math.atan(e3.evaluate(t3))], min: [Me, Mn(Me), (t3, e3) => Math.min(...e3.map((e4) => e4.evaluate(t3)))], max: [Me, Mn(Me), (t3, e3) => Math.max(...e3.map((e4) => e4.evaluate(t3)))], abs: [Me, [Me], (t3, [e3]) => Math.abs(e3.evaluate(t3))], round: [Me, [Me], (t3, [e3]) => {
          const r3 = e3.evaluate(t3);
          return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
        }], floor: [Me, [Me], (t3, [e3]) => Math.floor(e3.evaluate(t3))], ceil: [Me, [Me], (t3, [e3]) => Math.ceil(e3.evaluate(t3))], "filter-==": [Be, [Te, Ee], (t3, [e3, r3]) => t3.properties()[e3.value] === r3.value], "filter-id-==": [Be, [Ee], (t3, [e3]) => t3.id() === e3.value], "filter-type-==": [Be, [Te], (t3, [e3]) => t3.geometryType() === e3.value], "filter-<": [Be, [Te, Ee], (t3, [e3, r3]) => {
          const n2 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n2 == typeof i3 && n2 < i3;
        }], "filter-id-<": [Be, [Ee], (t3, [e3]) => {
          const r3 = t3.id(), n2 = e3.value;
          return typeof r3 == typeof n2 && r3 < n2;
        }], "filter->": [Be, [Te, Ee], (t3, [e3, r3]) => {
          const n2 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n2 == typeof i3 && n2 > i3;
        }], "filter-id->": [Be, [Ee], (t3, [e3]) => {
          const r3 = t3.id(), n2 = e3.value;
          return typeof r3 == typeof n2 && r3 > n2;
        }], "filter-<=": [Be, [Te, Ee], (t3, [e3, r3]) => {
          const n2 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n2 == typeof i3 && n2 <= i3;
        }], "filter-id-<=": [Be, [Ee], (t3, [e3]) => {
          const r3 = t3.id(), n2 = e3.value;
          return typeof r3 == typeof n2 && r3 <= n2;
        }], "filter->=": [Be, [Te, Ee], (t3, [e3, r3]) => {
          const n2 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n2 == typeof i3 && n2 >= i3;
        }], "filter-id->=": [Be, [Ee], (t3, [e3]) => {
          const r3 = t3.id(), n2 = e3.value;
          return typeof r3 == typeof n2 && r3 >= n2;
        }], "filter-has": [Be, [Ee], (t3, [e3]) => e3.value in t3.properties()], "filter-has-id": [Be, [], (t3) => t3.id() !== null && t3.id() !== void 0], "filter-type-in": [Be, [Le(Te)], (t3, [e3]) => e3.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [Be, [Le(Ee)], (t3, [e3]) => e3.value.indexOf(t3.id()) >= 0], "filter-in-small": [Be, [Te, Le(Ee)], (t3, [e3, r3]) => r3.value.indexOf(t3.properties()[e3.value]) >= 0], "filter-in-large": [Be, [Te, Le(Ee)], (t3, [e3, r3]) => function(t4, e4, r4, n2) {
          for (; r4 <= n2; ) {
            const i3 = r4 + n2 >> 1;
            if (e4[i3] === t4)
              return true;
            e4[i3] > t4 ? n2 = i3 - 1 : r4 = i3 + 1;
          }
          return false;
        }(t3.properties()[e3.value], r3.value, 0, r3.value.length - 1)], all: { type: Be, overloads: [[[Be, Be], (t3, [e3, r3]) => e3.evaluate(t3) && r3.evaluate(t3)], [Mn(Be), (t3, e3) => {
          for (const r3 of e3)
            if (!r3.evaluate(t3))
              return false;
          return true;
        }]] }, any: { type: Be, overloads: [[[Be, Be], (t3, [e3, r3]) => e3.evaluate(t3) || r3.evaluate(t3)], [Mn(Be), (t3, e3) => {
          for (const r3 of e3)
            if (r3.evaluate(t3))
              return true;
          return false;
        }]] }, "!": [Be, [Be], (t3, [e3]) => !e3.evaluate(t3)], "is-supported-script": [Be, [Te], (t3, [e3]) => {
          const r3 = t3.globals && t3.globals.isSupportedScript;
          return !r3 || r3(e3.evaluate(t3));
        }], upcase: [Te, [Te], (t3, [e3]) => e3.evaluate(t3).toUpperCase()], downcase: [Te, [Te], (t3, [e3]) => e3.evaluate(t3).toLowerCase()], concat: [Te, Mn(Ee), (t3, e3) => e3.map((e4) => Qe(e4.evaluate(t3))).join("")], "resolved-locale": [Te, [De], (t3, [e3]) => e3.evaluate(t3).resolvedLocale()] });
        class qn {
          constructor(t3, e3) {
            this.expression = t3, this._warningHistory = {}, this._evaluator = new ur(), this._defaultValue = e3 ? function(t4) {
              return t4.type === "color" && Vn(t4.default) ? new Ge(0, 0, 0, 0) : t4.type === "color" ? Ge.parse(t4.default) || null : t4.default === void 0 ? null : t4.default;
            }(e3) : null, this._enumValues = e3 && e3.type === "enum" ? e3.values : null;
          }
          evaluateWithoutErrorHandling(t3, e3, r3, n2, i3, s4, a2, o2) {
            return this._evaluator.globals = t3, this._evaluator.feature = e3, this._evaluator.featureState = r3, this._evaluator.canonical = n2, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = s4, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t3, e3, r3, n2, i3, s4, a2, o2) {
            this._evaluator.globals = t3, this._evaluator.feature = e3 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = s4 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
            try {
              const t4 = this.expression.evaluate(this._evaluator);
              if (t4 == null || typeof t4 == "number" && t4 != t4)
                return this._defaultValue;
              if (this._enumValues && !(t4 in this._enumValues))
                throw new er(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
              return t4;
            } catch (t4) {
              return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, typeof console != "undefined" && console.warn(t4.message)), this._defaultValue;
            }
          }
        }
        function Nn(t3) {
          return Array.isArray(t3) && t3.length > 0 && typeof t3[0] == "string" && t3[0] in kn;
        }
        function Gn(t3, e3) {
          const r3 = new Er(kn, [], e3 ? function(t4) {
            const e4 = { color: Ce, string: Te, number: Me, enum: Te, boolean: Be, formatted: Ve, resolvedImage: Fe };
            return t4.type === "array" ? Le(e4[t4.value] || Ee, t4.length) : e4[t4.type];
          }(e3) : void 0), n2 = r3.parse(t3, void 0, void 0, void 0, e3 && e3.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? Tn(new qn(n2, e3)) : Bn(r3.errors);
        }
        class Zn {
          constructor(t3, e3) {
            this.kind = t3, this._styleExpression = e3, this.isStateDependent = t3 !== "constant" && !Br(e3.expression);
          }
          evaluateWithoutErrorHandling(t3, e3, r3, n2, i3, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e3, r3, n2, i3, s4);
          }
          evaluate(t3, e3, r3, n2, i3, s4) {
            return this._styleExpression.evaluate(t3, e3, r3, n2, i3, s4);
          }
        }
        class Xn {
          constructor(t3, e3, r3, n2) {
            this.kind = t3, this.zoomStops = r3, this._styleExpression = e3, this.isStateDependent = t3 !== "camera" && !Br(e3.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t3, e3, r3, n2, i3, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e3, r3, n2, i3, s4);
          }
          evaluate(t3, e3, r3, n2, i3, s4) {
            return this._styleExpression.evaluate(t3, e3, r3, n2, i3, s4);
          }
          interpolationFactor(t3, e3, r3) {
            return this.interpolationType ? rn.interpolationFactor(this.interpolationType, t3, e3, r3) : 0;
          }
        }
        function Kn(t3, e3) {
          if ((t3 = Gn(t3, e3)).result === "error")
            return t3;
          const r3 = t3.value.expression, n2 = Tr(r3);
          if (!n2 && !Cn(e3))
            return Bn([new Se("", "data expressions not supported")]);
          const i3 = Cr(r3, ["zoom", "pitch", "distance-from-center"]);
          if (!i3 && !Pn(e3))
            return Bn([new Se("", "zoom expressions not supported")]);
          const s4 = Hn(r3);
          return s4 || i3 ? s4 instanceof Se ? Bn([s4]) : s4 instanceof rn && !En(e3) ? Bn([new Se("", '"interpolate" expressions cannot be used with this property')]) : Tn(s4 ? new Xn(n2 ? "camera" : "composite", t3.value, s4.labels, s4 instanceof rn ? s4.interpolation : void 0) : new Zn(n2 ? "constant" : "source", t3.value)) : Bn([new Se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Yn {
          constructor(t3, e3) {
            this._parameters = t3, this._specification = e3, _e(this, Ln(this._parameters, this._specification));
          }
          static deserialize(t3) {
            return new Yn(t3._parameters, t3._specification);
          }
          static serialize(t3) {
            return { _parameters: t3._parameters, _specification: t3._specification };
          }
        }
        function Hn(t3) {
          let e3 = null;
          if (t3 instanceof an)
            e3 = Hn(t3.result);
          else if (t3 instanceof sn) {
            for (const r3 of t3.args)
              if (e3 = Hn(r3), e3)
                break;
          } else
            (t3 instanceof Fr || t3 instanceof rn) && t3.input instanceof cr && t3.input.name === "zoom" && (e3 = t3);
          return e3 instanceof Se || t3.eachChild((t4) => {
            const r3 = Hn(t4);
            r3 instanceof Se ? e3 = r3 : !e3 && r3 ? e3 = new Se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e3 && r3 && e3 !== r3 && (e3 = new Se("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e3;
        }
        function Jn(t3) {
          const e3 = t3.key, r3 = t3.value, n2 = t3.valueSpec || {}, i3 = t3.objectElementValidators || {}, s4 = t3.style, a2 = t3.styleSpec;
          let o2 = [];
          const l2 = Dn(r3);
          if (l2 !== "object")
            return [new be(e3, r3, `object expected, ${l2} found`)];
          for (const t4 in r3) {
            const l3 = t4.split(".")[0], u2 = n2[l3] || n2["*"];
            let c2;
            if (i3[l3])
              c2 = i3[l3];
            else if (n2[l3])
              c2 = Bi;
            else if (i3["*"])
              c2 = i3["*"];
            else {
              if (!n2["*"]) {
                o2.push(new be(e3, r3[t4], `unknown property "${t4}"`));
                continue;
              }
              c2 = Bi;
            }
            o2 = o2.concat(c2({ key: (e3 ? `${e3}.` : e3) + t4, value: r3[t4], valueSpec: u2, style: s4, styleSpec: a2, object: r3, objectKey: t4 }, r3));
          }
          for (const t4 in n2)
            i3[t4] || n2[t4].required && n2[t4].default === void 0 && r3[t4] === void 0 && o2.push(new be(e3, r3, `missing required property "${t4}"`));
          return o2;
        }
        function Wn(t3) {
          const e3 = t3.value, r3 = t3.valueSpec, n2 = t3.style, i3 = t3.styleSpec, s4 = t3.key, a2 = t3.arrayElementValidator || Bi;
          if (Dn(e3) !== "array")
            return [new be(s4, e3, `array expected, ${Dn(e3)} found`)];
          if (r3.length && e3.length !== r3.length)
            return [new be(s4, e3, `array length ${r3.length} expected, length ${e3.length} found`)];
          if (r3["min-length"] && e3.length < r3["min-length"])
            return [new be(s4, e3, `array length at least ${r3["min-length"]} expected, length ${e3.length} found`)];
          let o2 = { type: r3.value, values: r3.values, minimum: r3.minimum, maximum: r3.maximum };
          i3.$version < 7 && (o2.function = r3.function), Dn(r3.value) === "object" && (o2 = r3.value);
          let l2 = [];
          for (let t4 = 0; t4 < e3.length; t4++)
            l2 = l2.concat(a2({ array: e3, arrayIndex: t4, value: e3[t4], valueSpec: o2, style: n2, styleSpec: i3, key: `${s4}[${t4}]` }));
          return l2;
        }
        function Qn(t3) {
          const e3 = t3.key, r3 = t3.value, n2 = t3.valueSpec;
          let i3 = Dn(r3);
          if (i3 === "number" && r3 != r3 && (i3 = "NaN"), i3 !== "number")
            return [new be(e3, r3, `number expected, ${i3} found`)];
          if ("minimum" in n2) {
            let i4 = n2.minimum;
            if (Dn(n2.minimum) === "array" && (i4 = n2.minimum[t3.arrayIndex]), r3 < i4)
              return [new be(e3, r3, `${r3} is less than the minimum value ${i4}`)];
          }
          if ("maximum" in n2) {
            let i4 = n2.maximum;
            if (Dn(n2.maximum) === "array" && (i4 = n2.maximum[t3.arrayIndex]), r3 > i4)
              return [new be(e3, r3, `${r3} is greater than the maximum value ${i4}`)];
          }
          return [];
        }
        function ti(t3) {
          const e3 = t3.valueSpec, r3 = Ae(t3.value.type);
          let n2, i3, s4, a2 = {};
          const o2 = r3 !== "categorical" && t3.value.property === void 0, l2 = !o2, u2 = Dn(t3.value.stops) === "array" && Dn(t3.value.stops[0]) === "array" && Dn(t3.value.stops[0][0]) === "object", c2 = Jn({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
            if (r3 === "identity")
              return [new be(t4.key, t4.value, 'identity function may not have a "stops" property')];
            let e4 = [];
            const n3 = t4.value;
            return e4 = e4.concat(Wn({ key: t4.key, value: n3, valueSpec: t4.valueSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h3 })), Dn(n3) === "array" && n3.length === 0 && e4.push(new be(t4.key, n3, "array must have at least one stop")), e4;
          }, default: function(t4) {
            return Bi({ key: t4.key, value: t4.value, valueSpec: e3, style: t4.style, styleSpec: t4.styleSpec });
          } } });
          return r3 === "identity" && o2 && c2.push(new be(t3.key, t3.value, 'missing required property "property"')), r3 === "identity" || t3.value.stops || c2.push(new be(t3.key, t3.value, 'missing required property "stops"')), r3 === "exponential" && t3.valueSpec.expression && !En(t3.valueSpec) && c2.push(new be(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l2 && !Cn(t3.valueSpec) ? c2.push(new be(t3.key, t3.value, "property functions not supported")) : o2 && !Pn(t3.valueSpec) && c2.push(new be(t3.key, t3.value, "zoom functions not supported"))), r3 !== "categorical" && !u2 || t3.value.property !== void 0 || c2.push(new be(t3.key, t3.value, '"property" property is required')), c2;
          function h3(t4) {
            let r4 = [];
            const n3 = t4.value, o3 = t4.key;
            if (Dn(n3) !== "array")
              return [new be(o3, n3, `array expected, ${Dn(n3)} found`)];
            if (n3.length !== 2)
              return [new be(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if (Dn(n3[0]) !== "object")
                return [new be(o3, n3, `object expected, ${Dn(n3[0])} found`)];
              if (n3[0].zoom === void 0)
                return [new be(o3, n3, "object stop key must have zoom")];
              if (n3[0].value === void 0)
                return [new be(o3, n3, "object stop key must have value")];
              if (s4 && s4 > Ae(n3[0].zoom))
                return [new be(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              Ae(n3[0].zoom) !== s4 && (s4 = Ae(n3[0].zoom), i3 = void 0, a2 = {}), r4 = r4.concat(Jn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: Qn, value: p2 } }));
            } else
              r4 = r4.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec }, n3));
            return Nn(ke(n3[1])) ? r4.concat([new be(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r4.concat(Bi({ key: `${o3}[1]`, value: n3[1], valueSpec: e3, style: t4.style, styleSpec: t4.styleSpec }));
          }
          function p2(t4, s5) {
            const o3 = Dn(t4.value), l3 = Ae(t4.value), u3 = t4.value !== null ? t4.value : s5;
            if (n2) {
              if (o3 !== n2)
                return [new be(t4.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else
              n2 = o3;
            if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
              return [new be(t4.key, u3, "stop domain value must be a number, string, or boolean")];
            if (o3 !== "number" && r3 !== "categorical") {
              let n3 = `number expected, ${o3} found`;
              return Cn(e3) && r3 === void 0 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new be(t4.key, u3, n3)];
            }
            return r3 !== "categorical" || o3 !== "number" || isFinite(l3) && Math.floor(l3) === l3 ? r3 !== "categorical" && o3 === "number" && i3 !== void 0 && l3 < i3 ? [new be(t4.key, u3, "stop domain values must appear in ascending order")] : (i3 = l3, r3 === "categorical" && l3 in a2 ? [new be(t4.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new be(t4.key, u3, `integer expected, found ${l3}`)];
          }
        }
        function ei(t3) {
          const e3 = (t3.expressionContext === "property" ? Kn : Gn)(ke(t3.value), t3.valueSpec);
          if (e3.result === "error")
            return e3.value.map((e4) => new be(`${t3.key}${e4.key}`, t3.value, e4.message));
          const r3 = e3.value.expression || e3.value._styleExpression.expression;
          if (t3.expressionContext === "property" && t3.propertyKey === "text-font" && !r3.outputDefined())
            return [new be(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (t3.expressionContext === "property" && t3.propertyType === "layout" && !Br(r3))
            return [new be(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (t3.expressionContext === "filter")
            return ri(r3, t3);
          if (t3.expressionContext && t3.expressionContext.indexOf("cluster") === 0) {
            if (!Cr(r3, ["zoom", "feature-state"]))
              return [new be(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (t3.expressionContext === "cluster-initial" && !Tr(r3))
              return [new be(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ri(t3, e3) {
          const r3 = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          for (const t4 of e3.valueSpec.expression.parameters)
            r3.delete(t4);
          if (r3.size === 0)
            return [];
          const n2 = [];
          return t3 instanceof cr && r3.has(t3.name) ? [new be(e3.key, e3.value, `["${t3.name}"] expression is not supported in a filter for a ${e3.object.type} layer with id: ${e3.object.id}`)] : (t3.eachChild((t4) => {
            n2.push(...ri(t4, e3));
          }), n2);
        }
        function ni(t3) {
          const e3 = t3.key, r3 = t3.value, n2 = t3.valueSpec, i3 = [];
          return Array.isArray(n2.values) ? n2.values.indexOf(Ae(r3)) === -1 && i3.push(new be(e3, r3, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r3)} found`)) : Object.keys(n2.values).indexOf(Ae(r3)) === -1 && i3.push(new be(e3, r3, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r3)} found`)), i3;
        }
        function ii(t3) {
          if (t3 === true || t3 === false)
            return true;
          if (!Array.isArray(t3) || t3.length === 0)
            return false;
          switch (t3[0]) {
            case "has":
              return t3.length >= 2 && t3[1] !== "$id" && t3[1] !== "$type";
            case "in":
              return t3.length >= 3 && (typeof t3[1] != "string" || Array.isArray(t3[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return t3.length !== 3 || Array.isArray(t3[1]) || Array.isArray(t3[2]);
            case "any":
            case "all":
              for (const e3 of t3.slice(1))
                if (!ii(e3) && typeof e3 != "boolean")
                  return false;
              return true;
            default:
              return true;
          }
        }
        function si(t3, e3 = "fill") {
          if (t3 == null)
            return { filter: () => true, needGeometry: false, needFeature: false };
          ii(t3) || (t3 = pi(t3));
          const r3 = t3;
          let n2 = true;
          try {
            n2 = function(t4) {
              if (!li(t4))
                return t4;
              let e4 = ke(t4);
              return oi(e4), e4 = ai(e4), e4;
            }(r3);
          } catch (t4) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r3, null, 2)}
        `);
          }
          const i3 = ve[`filter_${e3}`], s4 = Gn(n2, i3);
          let a2 = null;
          if (s4.result === "error")
            throw new Error(s4.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          a2 = (t4, e4, r4) => s4.value.evaluate(t4, e4, {}, r4);
          let o2 = null, l2 = null;
          if (n2 !== r3) {
            const t4 = Gn(r3, i3);
            if (t4.result === "error")
              throw new Error(t4.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
            o2 = (e4, r4, n3, i4, s5) => t4.value.evaluate(e4, r4, {}, n3, void 0, void 0, i4, s5), l2 = !Tr(t4.value.expression);
          }
          return a2 = a2, { filter: a2, dynamicFilter: o2 || void 0, needGeometry: hi(n2), needFeature: !!l2 };
        }
        function ai(t3) {
          if (!Array.isArray(t3))
            return t3;
          const e3 = function(t4) {
            if (ui.has(t4[0])) {
              for (let e4 = 1; e4 < t4.length; e4++)
                if (li(t4[e4]))
                  return true;
            }
            return t4;
          }(t3);
          return e3 === true ? e3 : e3.map((t4) => ai(t4));
        }
        function oi(t3) {
          let e3 = false;
          const r3 = [];
          if (t3[0] === "case") {
            for (let n2 = 1; n2 < t3.length - 1; n2 += 2)
              e3 = e3 || li(t3[n2]), r3.push(t3[n2 + 1]);
            r3.push(t3[t3.length - 1]);
          } else if (t3[0] === "match") {
            e3 = e3 || li(t3[1]);
            for (let e4 = 2; e4 < t3.length - 1; e4 += 2)
              r3.push(t3[e4 + 1]);
            r3.push(t3[t3.length - 1]);
          } else if (t3[0] === "step") {
            e3 = e3 || li(t3[1]);
            for (let e4 = 1; e4 < t3.length - 1; e4 += 2)
              r3.push(t3[e4 + 1]);
          }
          e3 && (t3.length = 0, t3.push("any", ...r3));
          for (let e4 = 1; e4 < t3.length; e4++)
            oi(t3[e4]);
        }
        function li(t3) {
          if (!Array.isArray(t3))
            return false;
          if ((e3 = t3[0]) === "pitch" || e3 === "distance-from-center")
            return true;
          var e3;
          for (let e4 = 1; e4 < t3.length; e4++)
            if (li(t3[e4]))
              return true;
          return false;
        }
        const ui = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function ci(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        function hi(t3) {
          if (!Array.isArray(t3))
            return false;
          if (t3[0] === "within")
            return true;
          for (let e3 = 1; e3 < t3.length; e3++)
            if (hi(t3[e3]))
              return true;
          return false;
        }
        function pi(t3) {
          if (!t3)
            return true;
          const e3 = t3[0];
          return t3.length <= 1 ? e3 !== "any" : e3 === "==" ? di(t3[1], t3[2], "==") : e3 === "!=" ? mi(di(t3[1], t3[2], "==")) : e3 === "<" || e3 === ">" || e3 === "<=" || e3 === ">=" ? di(t3[1], t3[2], e3) : e3 === "any" ? (r3 = t3.slice(1), ["any"].concat(r3.map(pi))) : e3 === "all" ? ["all"].concat(t3.slice(1).map(pi)) : e3 === "none" ? ["all"].concat(t3.slice(1).map(pi).map(mi)) : e3 === "in" ? fi(t3[1], t3.slice(2)) : e3 === "!in" ? mi(fi(t3[1], t3.slice(2))) : e3 === "has" ? yi(t3[1]) : e3 === "!has" ? mi(yi(t3[1])) : e3 !== "within" || t3;
          var r3;
        }
        function di(t3, e3, r3) {
          switch (t3) {
            case "$type":
              return [`filter-type-${r3}`, e3];
            case "$id":
              return [`filter-id-${r3}`, e3];
            default:
              return [`filter-${r3}`, t3, e3];
          }
        }
        function fi(t3, e3) {
          if (e3.length === 0)
            return false;
          switch (t3) {
            case "$type":
              return ["filter-type-in", ["literal", e3]];
            case "$id":
              return ["filter-id-in", ["literal", e3]];
            default:
              return e3.length > 200 && !e3.some((t4) => typeof t4 != typeof e3[0]) ? ["filter-in-large", t3, ["literal", e3.sort(ci)]] : ["filter-in-small", t3, ["literal", e3]];
          }
        }
        function yi(t3) {
          switch (t3) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t3];
          }
        }
        function mi(t3) {
          return ["!", t3];
        }
        function gi(t3) {
          if (ii(ke(t3.value))) {
            const e3 = ke(t3.layerType);
            return ei(_e({}, t3, { expressionContext: "filter", valueSpec: t3.styleSpec[`filter_${e3 || "fill"}`] }));
          }
          return xi(t3);
        }
        function xi(t3) {
          const e3 = t3.value, r3 = t3.key;
          if (Dn(e3) !== "array")
            return [new be(r3, e3, `array expected, ${Dn(e3)} found`)];
          const n2 = t3.styleSpec;
          let i3, s4 = [];
          if (e3.length < 1)
            return [new be(r3, e3, "filter array must have at least 1 element")];
          switch (s4 = s4.concat(ni({ key: `${r3}[0]`, value: e3[0], valueSpec: n2.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), Ae(e3[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e3.length >= 2 && Ae(e3[1]) === "$type" && s4.push(new be(r3, e3, `"$type" cannot be use with operator "${e3[0]}"`));
            case "==":
            case "!=":
              e3.length !== 3 && s4.push(new be(r3, e3, `filter array for operator "${e3[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e3.length >= 2 && (i3 = Dn(e3[1]), i3 !== "string" && s4.push(new be(`${r3}[1]`, e3[1], `string expected, ${i3} found`)));
              for (let a2 = 2; a2 < e3.length; a2++)
                i3 = Dn(e3[a2]), Ae(e3[1]) === "$type" ? s4 = s4.concat(ni({ key: `${r3}[${a2}]`, value: e3[a2], valueSpec: n2.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : i3 !== "string" && i3 !== "number" && i3 !== "boolean" && s4.push(new be(`${r3}[${a2}]`, e3[a2], `string, number, or boolean expected, ${i3} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e3.length; n3++)
                s4 = s4.concat(xi({ key: `${r3}[${n3}]`, value: e3[n3], style: t3.style, styleSpec: t3.styleSpec }));
              break;
            case "has":
            case "!has":
              i3 = Dn(e3[1]), e3.length !== 2 ? s4.push(new be(r3, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : i3 !== "string" && s4.push(new be(`${r3}[1]`, e3[1], `string expected, ${i3} found`));
              break;
            case "within":
              i3 = Dn(e3[1]), e3.length !== 2 ? s4.push(new be(r3, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : i3 !== "object" && s4.push(new be(`${r3}[1]`, e3[1], `object expected, ${i3} found`));
          }
          return s4;
        }
        function vi(t3, e3) {
          const r3 = t3.key, n2 = t3.style, i3 = t3.styleSpec, s4 = t3.value, a2 = t3.objectKey, o2 = i3[`${e3}_${t3.layerType}`];
          if (!o2)
            return [];
          const l2 = a2.match(/^(.*)-transition$/);
          if (e3 === "paint" && l2 && o2[l2[1]] && o2[l2[1]].transition)
            return Bi({ key: r3, value: s4, valueSpec: i3.transition, style: n2, styleSpec: i3 });
          const u2 = t3.valueSpec || o2[a2];
          if (!u2)
            return [new be(r3, s4, `unknown property "${a2}"`)];
          let c2;
          if (Dn(s4) === "string" && Cn(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s4)))
            return [new be(r3, s4, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
          const h3 = [];
          return t3.layerType === "symbol" && (a2 === "text-field" && n2 && !n2.glyphs && h3.push(new be(r3, s4, 'use of "text-field" requires a style "glyphs" property')), a2 === "text-font" && Vn(ke(s4)) && Ae(s4.type) === "identity" && h3.push(new be(r3, s4, '"text-font" does not support identity functions'))), h3.concat(Bi({ key: t3.key, value: s4, valueSpec: u2, style: n2, styleSpec: i3, expressionContext: "property", propertyType: e3, propertyKey: a2 }));
        }
        function bi(t3) {
          return vi(t3, "paint");
        }
        function wi(t3) {
          return vi(t3, "layout");
        }
        function _i(t3) {
          let e3 = [];
          const r3 = t3.value, n2 = t3.key, i3 = t3.style, s4 = t3.styleSpec;
          r3.type || r3.ref || e3.push(new be(n2, r3, 'either "type" or "ref" is required'));
          let a2 = Ae(r3.type);
          const o2 = Ae(r3.ref);
          if (r3.id) {
            const s5 = Ae(r3.id);
            for (let a3 = 0; a3 < t3.arrayIndex; a3++) {
              const t4 = i3.layers[a3];
              Ae(t4.id) === s5 && e3.push(new be(n2, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t4.id.__line__}`));
            }
          }
          if ("ref" in r3) {
            let t4;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
              t5 in r3 && e3.push(new be(n2, r3[t5], `"${t5}" is prohibited for ref layers`));
            }), i3.layers.forEach((e4) => {
              Ae(e4.id) === o2 && (t4 = e4);
            }), t4 ? t4.ref ? e3.push(new be(n2, r3.ref, "ref cannot reference another ref layer")) : a2 = Ae(t4.type) : e3.push(new be(n2, r3.ref, `ref layer "${o2}" not found`));
          } else if (a2 !== "background" && a2 !== "sky")
            if (r3.source) {
              const t4 = i3.sources && i3.sources[r3.source], s5 = t4 && Ae(t4.type);
              t4 ? s5 === "vector" && a2 === "raster" ? e3.push(new be(n2, r3.source, `layer "${r3.id}" requires a raster source`)) : s5 === "raster" && a2 !== "raster" ? e3.push(new be(n2, r3.source, `layer "${r3.id}" requires a vector source`)) : s5 !== "vector" || r3["source-layer"] ? s5 === "raster-dem" && a2 !== "hillshade" ? e3.push(new be(n2, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r3.paint || !r3.paint["line-gradient"] || s5 === "geojson" && t4.lineMetrics || e3.push(new be(n2, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e3.push(new be(n2, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e3.push(new be(n2, r3.source, `source "${r3.source}" not found`));
            } else
              e3.push(new be(n2, r3, 'missing required property "source"'));
          return e3 = e3.concat(Jn({ key: n2, value: r3, valueSpec: s4.layer, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": () => [], type: () => Bi({ key: `${n2}.type`, value: r3.type, valueSpec: s4.layer.type, style: t3.style, styleSpec: t3.styleSpec, object: r3, objectKey: "type" }), filter: (t4) => gi(_e({ layerType: a2 }, t4)), layout: (t4) => Jn({ layer: r3, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => wi(_e({ layerType: a2 }, t5)) } }), paint: (t4) => Jn({ layer: r3, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => bi(_e({ layerType: a2 }, t5)) } }) } })), e3;
        }
        function Ai(t3) {
          const e3 = t3.value, r3 = t3.key, n2 = Dn(e3);
          return n2 !== "string" ? [new be(r3, e3, `string expected, ${n2} found`)] : [];
        }
        const ki = { promoteId: function({ key: t3, value: e3 }) {
          if (Dn(e3) === "string")
            return Ai({ key: t3, value: e3 });
          {
            const r3 = [];
            for (const n2 in e3)
              r3.push(...Ai({ key: `${t3}.${n2}`, value: e3[n2] }));
            return r3;
          }
        } };
        function Si(t3) {
          const e3 = t3.value, r3 = t3.key, n2 = t3.styleSpec, i3 = t3.style;
          if (!e3.type)
            return [new be(r3, e3, '"type" is required')];
          const s4 = Ae(e3.type);
          let a2;
          switch (s4) {
            case "vector":
            case "raster":
            case "raster-dem":
              return a2 = Jn({ key: r3, value: e3, valueSpec: n2[`source_${s4.replace("-", "_")}`], style: t3.style, styleSpec: n2, objectElementValidators: ki }), a2;
            case "geojson":
              if (a2 = Jn({ key: r3, value: e3, valueSpec: n2.source_geojson, style: i3, styleSpec: n2, objectElementValidators: ki }), e3.cluster)
                for (const t4 in e3.clusterProperties) {
                  const [n3, i4] = e3.clusterProperties[t4], s5 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t4]] : n3;
                  a2.push(...ei({ key: `${r3}.${t4}.map`, value: i4, expressionContext: "cluster-map" })), a2.push(...ei({ key: `${r3}.${t4}.reduce`, value: s5, expressionContext: "cluster-reduce" }));
                }
              return a2;
            case "video":
              return Jn({ key: r3, value: e3, valueSpec: n2.source_video, style: i3, styleSpec: n2 });
            case "image":
              return Jn({ key: r3, value: e3, valueSpec: n2.source_image, style: i3, styleSpec: n2 });
            case "canvas":
              return [new be(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ni({ key: `${r3}.type`, value: e3.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i3, styleSpec: n2 });
          }
        }
        function Ii(t3) {
          const e3 = t3.value, r3 = t3.styleSpec, n2 = r3.light, i3 = t3.style;
          let s4 = [];
          const a2 = Dn(e3);
          if (e3 === void 0)
            return s4;
          if (a2 !== "object")
            return s4 = s4.concat([new be("light", e3, `object expected, ${a2} found`)]), s4;
          for (const t4 in e3) {
            const a3 = t4.match(/^(.*)-transition$/);
            s4 = s4.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Bi({ key: t4, value: e3[t4], valueSpec: r3.transition, style: i3, styleSpec: r3 }) : n2[t4] ? Bi({ key: t4, value: e3[t4], valueSpec: n2[t4], style: i3, styleSpec: r3 }) : [new be(t4, e3[t4], `unknown property "${t4}"`)]);
          }
          return s4;
        }
        function zi(t3) {
          const e3 = t3.value, r3 = t3.key, n2 = t3.style, i3 = t3.styleSpec, s4 = i3.terrain;
          let a2 = [];
          const o2 = Dn(e3);
          if (e3 === void 0)
            return a2;
          if (o2 !== "object")
            return a2 = a2.concat([new be("terrain", e3, `object expected, ${o2} found`)]), a2;
          for (const t4 in e3) {
            const r4 = t4.match(/^(.*)-transition$/);
            a2 = a2.concat(r4 && s4[r4[1]] && s4[r4[1]].transition ? Bi({ key: t4, value: e3[t4], valueSpec: i3.transition, style: n2, styleSpec: i3 }) : s4[t4] ? Bi({ key: t4, value: e3[t4], valueSpec: s4[t4], style: n2, styleSpec: i3 }) : [new be(t4, e3[t4], `unknown property "${t4}"`)]);
          }
          if (e3.source) {
            const t4 = n2.sources && n2.sources[e3.source], i4 = t4 && Ae(t4.type);
            t4 ? i4 !== "raster-dem" && a2.push(new be(r3, e3.source, `terrain cannot be used with a source of type ${i4}, it only be used with a "raster-dem" source type`)) : a2.push(new be(r3, e3.source, `source "${e3.source}" not found`));
          } else
            a2.push(new be(r3, e3, 'terrain is missing required property "source"'));
          return a2;
        }
        function Mi(t3) {
          const e3 = t3.value, r3 = t3.style, n2 = t3.styleSpec, i3 = n2.fog;
          let s4 = [];
          const a2 = Dn(e3);
          if (e3 === void 0)
            return s4;
          if (a2 !== "object")
            return s4 = s4.concat([new be("fog", e3, `object expected, ${a2} found`)]), s4;
          for (const t4 in e3) {
            const a3 = t4.match(/^(.*)-transition$/);
            s4 = s4.concat(a3 && i3[a3[1]] && i3[a3[1]].transition ? Bi({ key: t4, value: e3[t4], valueSpec: n2.transition, style: r3, styleSpec: n2 }) : i3[t4] ? Bi({ key: t4, value: e3[t4], valueSpec: i3[t4], style: r3, styleSpec: n2 }) : [new be(t4, e3[t4], `unknown property "${t4}"`)]);
          }
          return s4;
        }
        const Ti = { "*": () => [], array: Wn, boolean: function(t3) {
          const e3 = t3.value, r3 = t3.key, n2 = Dn(e3);
          return n2 !== "boolean" ? [new be(r3, e3, `boolean expected, ${n2} found`)] : [];
        }, number: Qn, color: function(t3) {
          const e3 = t3.key, r3 = t3.value, n2 = Dn(r3);
          return n2 !== "string" ? [new be(e3, r3, `color expected, ${n2} found`)] : Ne.parseCSSColor(r3) === null ? [new be(e3, r3, `color expected, "${r3}" found`)] : [];
        }, constants: we, enum: ni, filter: gi, function: ti, layer: _i, object: Jn, source: Si, light: Ii, terrain: zi, fog: Mi, string: Ai, formatted: function(t3) {
          return Ai(t3).length === 0 ? [] : ei(t3);
        }, resolvedImage: function(t3) {
          return Ai(t3).length === 0 ? [] : ei(t3);
        }, projection: function(t3) {
          const e3 = t3.value, r3 = t3.styleSpec, n2 = r3.projection, i3 = t3.style;
          let s4 = [];
          const a2 = Dn(e3);
          if (a2 === "object")
            for (const t4 in e3)
              s4 = s4.concat(Bi({ key: t4, value: e3[t4], valueSpec: n2[t4], style: i3, styleSpec: r3 }));
          else
            a2 !== "string" && (s4 = s4.concat([new be("projection", e3, `object or string expected, ${a2} found`)]));
          return s4;
        } };
        function Bi(t3) {
          const e3 = t3.value, r3 = t3.valueSpec, n2 = t3.styleSpec;
          return r3.expression && Vn(Ae(e3)) ? ti(t3) : r3.expression && Nn(ke(e3)) ? ei(t3) : r3.type && Ti[r3.type] ? Ti[r3.type](t3) : Jn(_e({}, t3, { valueSpec: r3.type ? n2[r3.type] : r3 }));
        }
        function Ci(t3) {
          const e3 = t3.value, r3 = t3.key, n2 = Ai(t3);
          return n2.length || (e3.indexOf("{fontstack}") === -1 && n2.push(new be(r3, e3, '"glyphs" url must include a "{fontstack}" token')), e3.indexOf("{range}") === -1 && n2.push(new be(r3, e3, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function Pi(t3, e3 = ve) {
          let r3 = [];
          return r3 = r3.concat(Bi({ key: "", value: t3, valueSpec: e3.$root, styleSpec: e3, style: t3, objectElementValidators: { glyphs: Ci, "*": () => [] } })), t3.constants && (r3 = r3.concat(we({ key: "constants", value: t3.constants, style: t3, styleSpec: e3 }))), Ei(r3);
        }
        function Ei(t3) {
          return [].concat(t3).sort((t4, e3) => t4.line - e3.line);
        }
        function Di(t3) {
          return function(...e3) {
            return Ei(t3.apply(this, e3));
          };
        }
        Pi.source = Di(Si), Pi.light = Di(Ii), Pi.terrain = Di(zi), Pi.fog = Di(Mi), Pi.layer = Di(_i), Pi.filter = Di(gi), Pi.paintProperty = Di(bi), Pi.layoutProperty = Di(wi);
        const Vi = Pi, Fi = Vi.light, Li = Vi.fog, Ri = Vi.paintProperty, Ui2 = Vi.layoutProperty;
        function $i(t3, e3) {
          let r3 = false;
          if (e3 && e3.length)
            for (const n2 of e3)
              t3.fire(new ge(new Error(n2.message))), r3 = true;
          return r3;
        }
        var Oi = ji;
        function ji(t3, e3, r3) {
          var n2 = this.cells = [];
          if (t3 instanceof ArrayBuffer) {
            this.arrayBuffer = t3;
            var i3 = new Int32Array(this.arrayBuffer);
            t3 = i3[0], this.d = (e3 = i3[1]) + 2 * (r3 = i3[2]);
            for (var s4 = 0; s4 < this.d * this.d; s4++) {
              var a2 = i3[3 + s4], o2 = i3[3 + s4 + 1];
              n2.push(a2 === o2 ? null : i3.subarray(a2, o2));
            }
            var l2 = i3[3 + n2.length + 1];
            this.keys = i3.subarray(i3[3 + n2.length], l2), this.bboxes = i3.subarray(l2), this.insert = this._insertReadonly;
          } else {
            this.d = e3 + 2 * r3;
            for (var u2 = 0; u2 < this.d * this.d; u2++)
              n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e3, this.extent = t3, this.padding = r3, this.scale = e3 / t3, this.uid = 0;
          var c2 = r3 / e3 * t3;
          this.min = -c2, this.max = t3 + c2;
        }
        ji.prototype.insert = function(t3, e3, r3, n2, i3) {
          this._forEachCell(e3, r3, n2, i3, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r3), this.bboxes.push(n2), this.bboxes.push(i3);
        }, ji.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, ji.prototype._insertCell = function(t3, e3, r3, n2, i3, s4) {
          this.cells[i3].push(s4);
        }, ji.prototype.query = function(t3, e3, r3, n2, i3) {
          var s4 = this.min, a2 = this.max;
          if (t3 <= s4 && e3 <= s4 && a2 <= r3 && a2 <= n2 && !i3)
            return Array.prototype.slice.call(this.keys);
          var o2 = [];
          return this._forEachCell(t3, e3, r3, n2, this._queryCell, o2, {}, i3), o2;
        }, ji.prototype._queryCell = function(t3, e3, r3, n2, i3, s4, a2, o2) {
          var l2 = this.cells[i3];
          if (l2 !== null)
            for (var u2 = this.keys, c2 = this.bboxes, h3 = 0; h3 < l2.length; h3++) {
              var p2 = l2[h3];
              if (a2[p2] === void 0) {
                var d2 = 4 * p2;
                (o2 ? o2(c2[d2 + 0], c2[d2 + 1], c2[d2 + 2], c2[d2 + 3]) : t3 <= c2[d2 + 2] && e3 <= c2[d2 + 3] && r3 >= c2[d2 + 0] && n2 >= c2[d2 + 1]) ? (a2[p2] = true, s4.push(u2[p2])) : a2[p2] = false;
              }
            }
        }, ji.prototype._forEachCell = function(t3, e3, r3, n2, i3, s4, a2, o2) {
          for (var l2 = this._convertToCellCoord(t3), u2 = this._convertToCellCoord(e3), c2 = this._convertToCellCoord(r3), h3 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
            for (var d2 = u2; d2 <= h3; d2++) {
              var f4 = this.d * d2 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(d2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(d2 + 1))) && i3.call(this, t3, e3, r3, n2, f4, s4, a2, o2))
                return;
            }
        }, ji.prototype._convertFromCellCoord = function(t3) {
          return (t3 - this.padding) / this.scale;
        }, ji.prototype._convertToCellCoord = function(t3) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
        }, ji.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var t3 = this.cells, e3 = 3 + this.cells.length + 1 + 1, r3 = 0, n2 = 0; n2 < this.cells.length; n2++)
            r3 += this.cells[n2].length;
          var i3 = new Int32Array(e3 + r3 + this.keys.length + this.bboxes.length);
          i3[0] = this.extent, i3[1] = this.n, i3[2] = this.padding;
          for (var s4 = e3, a2 = 0; a2 < t3.length; a2++) {
            var o2 = t3[a2];
            i3[3 + a2] = s4, i3.set(o2, s4), s4 += o2.length;
          }
          return i3[3 + t3.length] = s4, i3.set(this.keys, s4), i3[3 + t3.length + 1] = s4 += this.keys.length, i3.set(this.bboxes, s4), s4 += this.bboxes.length, i3.buffer;
        };
        const { ImageData: qi, ImageBitmap: Ni } = a, Gi = {};
        function Zi(t3, e3, r3 = {}) {
          Object.defineProperty(e3, "_classRegistryKey", { value: t3, writeable: false }), Gi[t3] = { klass: e3, omit: r3.omit || [], shallow: r3.shallow || [] };
        }
        Zi("Object", Object), Oi.serialize = function(t3, e3) {
          const r3 = t3.toArrayBuffer();
          return e3 && e3.push(r3), { buffer: r3 };
        }, Oi.deserialize = function(t3) {
          return new Oi(t3.buffer);
        }, Zi("Grid", Oi), Zi("Color", Ge), Zi("Error", Error), Zi("ResolvedImage", Ye), Zi("StylePropertyFunction", Yn), Zi("StyleExpression", qn, { omit: ["_evaluator"] }), Zi("ZoomDependentExpression", Xn), Zi("ZoomConstantExpression", Zn), Zi("CompoundExpression", cr, { omit: ["_evaluate"] });
        for (const t3 in kn)
          kn[t3]._classRegistryKey || Zi(`Expression_${t3}`, kn[t3]);
        function Xi(t3) {
          return t3 && typeof ArrayBuffer != "undefined" && (t3 instanceof ArrayBuffer || t3.constructor && t3.constructor.name === "ArrayBuffer");
        }
        function Ki(t3) {
          return Ni && t3 instanceof Ni;
        }
        function Yi(t3, e3) {
          if (t3 == null || typeof t3 == "boolean" || typeof t3 == "number" || typeof t3 == "string" || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp)
            return t3;
          if (Xi(t3) || Ki(t3))
            return e3 && e3.push(t3), t3;
          if (ArrayBuffer.isView(t3)) {
            const r3 = t3;
            return e3 && e3.push(r3.buffer), r3;
          }
          if (t3 instanceof qi)
            return e3 && e3.push(t3.data.buffer), t3;
          if (Array.isArray(t3)) {
            const r3 = [];
            for (const n2 of t3)
              r3.push(Yi(n2, e3));
            return r3;
          }
          if (typeof t3 == "object") {
            const r3 = t3.constructor, n2 = r3._classRegistryKey;
            if (!n2)
              throw new Error("can't serialize object of unregistered class");
            const i3 = r3.serialize ? r3.serialize(t3, e3) : {};
            if (!r3.serialize) {
              for (const r4 in t3) {
                if (!t3.hasOwnProperty(r4))
                  continue;
                if (Gi[n2].omit.indexOf(r4) >= 0)
                  continue;
                const s4 = t3[r4];
                i3[r4] = Gi[n2].shallow.indexOf(r4) >= 0 ? s4 : Yi(s4, e3);
              }
              t3 instanceof Error && (i3.message = t3.message);
            }
            if (i3.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return n2 !== "Object" && (i3.$name = n2), i3;
          }
          throw new Error("can't serialize object of type " + typeof t3);
        }
        function Hi(t3) {
          if (t3 == null || typeof t3 == "boolean" || typeof t3 == "number" || typeof t3 == "string" || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || Xi(t3) || Ki(t3) || ArrayBuffer.isView(t3) || t3 instanceof qi)
            return t3;
          if (Array.isArray(t3))
            return t3.map(Hi);
          if (typeof t3 == "object") {
            const e3 = t3.$name || "Object", { klass: r3 } = Gi[e3];
            if (!r3)
              throw new Error(`can't deserialize unregistered class ${e3}`);
            if (r3.deserialize)
              return r3.deserialize(t3);
            const n2 = Object.create(r3.prototype);
            for (const r4 of Object.keys(t3)) {
              if (r4 === "$name")
                continue;
              const i3 = t3[r4];
              n2[r4] = Gi[e3].shallow.indexOf(r4) >= 0 ? i3 : Hi(i3);
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t3);
        }
        class Ji {
          constructor() {
            this.first = true;
          }
          update(t3, e3) {
            const r3 = Math.floor(t3);
            return this.first ? (this.first = false, this.lastIntegerZoom = r3, this.lastIntegerZoomTime = 0, this.lastZoom = t3, this.lastFloorZoom = r3, true) : (this.lastFloorZoom > r3 ? (this.lastIntegerZoom = r3 + 1, this.lastIntegerZoomTime = e3) : this.lastFloorZoom < r3 && (this.lastIntegerZoom = r3, this.lastIntegerZoomTime = e3), t3 !== this.lastZoom && (this.lastZoom = t3, this.lastFloorZoom = r3, true));
          }
        }
        const Wi = (t3) => t3 >= 1536 && t3 <= 1791, Qi = (t3) => t3 >= 1872 && t3 <= 1919, ts = (t3) => t3 >= 2208 && t3 <= 2303, es = (t3) => t3 >= 11904 && t3 <= 12031, rs = (t3) => t3 >= 12032 && t3 <= 12255, ns = (t3) => t3 >= 12272 && t3 <= 12287, is = (t3) => t3 >= 12288 && t3 <= 12351, ss = (t3) => t3 >= 12352 && t3 <= 12447, as = (t3) => t3 >= 12448 && t3 <= 12543, os = (t3) => t3 >= 12544 && t3 <= 12591, ls = (t3) => t3 >= 12704 && t3 <= 12735, us = (t3) => t3 >= 12736 && t3 <= 12783, cs = (t3) => t3 >= 12784 && t3 <= 12799, hs = (t3) => t3 >= 12800 && t3 <= 13055, ps = (t3) => t3 >= 13056 && t3 <= 13311, ds = (t3) => t3 >= 13312 && t3 <= 19903, fs = (t3) => t3 >= 19968 && t3 <= 40959, ys = (t3) => t3 >= 40960 && t3 <= 42127, ms = (t3) => t3 >= 42128 && t3 <= 42191, gs = (t3) => t3 >= 44032 && t3 <= 55215, xs = (t3) => t3 >= 63744 && t3 <= 64255, vs = (t3) => t3 >= 64336 && t3 <= 65023, bs = (t3) => t3 >= 65040 && t3 <= 65055, ws = (t3) => t3 >= 65072 && t3 <= 65103, _s = (t3) => t3 >= 65104 && t3 <= 65135, As = (t3) => t3 >= 65136 && t3 <= 65279, ks = (t3) => t3 >= 65280 && t3 <= 65519;
        function Ss(t3) {
          for (const e3 of t3)
            if (Ms(e3.charCodeAt(0)))
              return true;
          return false;
        }
        function Is(t3) {
          for (const e3 of t3)
            if (!zs(e3.charCodeAt(0)))
              return false;
          return true;
        }
        function zs(t3) {
          return !(Wi(t3) || Qi(t3) || ts(t3) || vs(t3) || As(t3));
        }
        function Ms(t3) {
          return !(t3 !== 746 && t3 !== 747 && (t3 < 4352 || !(ls(t3) || os(t3) || ws(t3) && !(t3 >= 65097 && t3 <= 65103) || xs(t3) || ps(t3) || es(t3) || us(t3) || !(!is(t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || t3 === 12336) || ds(t3) || fs(t3) || hs(t3) || ((t4) => t4 >= 12592 && t4 <= 12687)(t3) || ((t4) => t4 >= 43360 && t4 <= 43391)(t3) || ((t4) => t4 >= 55216 && t4 <= 55295)(t3) || ((t4) => t4 >= 4352 && t4 <= 4607)(t3) || gs(t3) || ss(t3) || ns(t3) || ((t4) => t4 >= 12688 && t4 <= 12703)(t3) || rs(t3) || cs(t3) || as(t3) && t3 !== 12540 || !(!ks(t3) || t3 === 65288 || t3 === 65289 || t3 === 65293 || t3 >= 65306 && t3 <= 65310 || t3 === 65339 || t3 === 65341 || t3 === 65343 || t3 >= 65371 && t3 <= 65503 || t3 === 65507 || t3 >= 65512 && t3 <= 65519) || !(!_s(t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || ((t4) => t4 >= 5120 && t4 <= 5759)(t3) || ((t4) => t4 >= 6320 && t4 <= 6399)(t3) || bs(t3) || ((t4) => t4 >= 19904 && t4 <= 19967)(t3) || ys(t3) || ms(t3))));
        }
        function Ts(t3) {
          return !(Ms(t3) || function(t4) {
            return !!(((t5) => t5 >= 128 && t5 <= 255)(t4) && (t4 === 167 || t4 === 169 || t4 === 174 || t4 === 177 || t4 === 188 || t4 === 189 || t4 === 190 || t4 === 215 || t4 === 247) || ((t5) => t5 >= 8192 && t5 <= 8303)(t4) && (t4 === 8214 || t4 === 8224 || t4 === 8225 || t4 === 8240 || t4 === 8241 || t4 === 8251 || t4 === 8252 || t4 === 8258 || t4 === 8263 || t4 === 8264 || t4 === 8265 || t4 === 8273) || ((t5) => t5 >= 8448 && t5 <= 8527)(t4) || ((t5) => t5 >= 8528 && t5 <= 8591)(t4) || ((t5) => t5 >= 8960 && t5 <= 9215)(t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || t4 === 9003 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || t4 === 9167 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || ((t5) => t5 >= 9216 && t5 <= 9279)(t4) && t4 !== 9251 || ((t5) => t5 >= 9280 && t5 <= 9311)(t4) || ((t5) => t5 >= 9312 && t5 <= 9471)(t4) || ((t5) => t5 >= 9632 && t5 <= 9727)(t4) || ((t5) => t5 >= 9728 && t5 <= 9983)(t4) && !(t4 >= 9754 && t4 <= 9759) || ((t5) => t5 >= 11008 && t5 <= 11263)(t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || is(t4) || as(t4) || ((t5) => t5 >= 57344 && t5 <= 63743)(t4) || ws(t4) || _s(t4) || ks(t4) || t4 === 8734 || t4 === 8756 || t4 === 8757 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || t4 === 65532 || t4 === 65533);
          }(t3));
        }
        function Bs(t3) {
          return t3 >= 1424 && t3 <= 2303 || vs(t3) || As(t3);
        }
        function Cs(t3, e3) {
          return !(!e3 && Bs(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || ((t4) => t4 >= 6016 && t4 <= 6143)(t3));
        }
        function Ps(t3) {
          for (const e3 of t3)
            if (Bs(e3.charCodeAt(0)))
              return true;
          return false;
        }
        const Es = "deferred", Ds = "loading", Vs = "loaded";
        let Fs = null, Ls = "unavailable", Rs = null;
        const Us = function(t3) {
          t3 && typeof t3 == "string" && t3.indexOf("NetworkError") > -1 && (Ls = "error"), Fs && Fs(t3);
        };
        function $s() {
          Os.fire(new me("pluginStateChange", { pluginStatus: Ls, pluginURL: Rs }));
        }
        const Os = new xe(), js4 = function() {
          return Ls;
        }, qs2 = function() {
          if (Ls !== Es || !Rs)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Ls = Ds, $s(), Rs && ae({ url: Rs }, (t3) => {
            t3 ? Us(t3) : (Ls = Vs, $s());
          });
        }, Ns = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ls === Vs || Ns.applyArabicShaping != null, isLoading: () => Ls === Ds, setState(t3) {
          Ls = t3.pluginStatus, Rs = t3.pluginURL;
        }, isParsed: () => Ns.applyArabicShaping != null && Ns.processBidirectionalText != null && Ns.processStyledBidirectionalText != null, getPluginURL: () => Rs };
        class Gs {
          constructor(t3, e3) {
            this.zoom = t3, e3 ? (this.now = e3.now, this.fadeDuration = e3.fadeDuration, this.zoomHistory = e3.zoomHistory, this.transition = e3.transition, this.pitch = e3.pitch) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ji(), this.transition = {}, this.pitch = 0);
          }
          isSupportedScript(t3) {
            return function(t4, e3) {
              for (const r3 of t4)
                if (!Cs(r3.charCodeAt(0), e3))
                  return false;
              return true;
            }(t3, Ns.isLoaded());
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t3 = this.zoom, e3 = t3 - Math.floor(t3), r3 = this.crossFadingFactor();
            return t3 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e3 + (1 - e3) * r3 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r3) * e3 };
          }
        }
        class Zs {
          constructor(t3, e3) {
            this.property = t3, this.value = e3, this.expression = function(t4, e4) {
              if (Vn(t4))
                return new Yn(t4, e4);
              if (Nn(t4)) {
                const r3 = Kn(t4, e4);
                if (r3.result === "error")
                  throw new Error(r3.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
                return r3.value;
              }
              {
                let r3 = t4;
                return typeof t4 == "string" && e4.type === "color" && (r3 = Ge.parse(t4)), { kind: "constant", evaluate: () => r3 };
              }
            }(e3 === void 0 ? t3.specification.default : e3, t3.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          possiblyEvaluate(t3, e3, r3) {
            return this.property.possiblyEvaluate(this, t3, e3, r3);
          }
        }
        class Xs {
          constructor(t3) {
            this.property = t3, this.value = new Zs(t3, void 0);
          }
          transitioned(t3, e3) {
            return new Ys(this.property, this.value, e3, tt({}, t3.transition, this.transition), t3.now);
          }
          untransitioned() {
            return new Ys(this.property, this.value, null, {}, 0);
          }
        }
        class Ks {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
          }
          getValue(t3) {
            return ct(this._values[t3].value.value);
          }
          setValue(t3, e3) {
            this._values.hasOwnProperty(t3) || (this._values[t3] = new Xs(this._values[t3].property)), this._values[t3].value = new Zs(this._values[t3].property, e3 === null ? void 0 : ct(e3));
          }
          getTransition(t3) {
            return ct(this._values[t3].transition);
          }
          setTransition(t3, e3) {
            this._values.hasOwnProperty(t3) || (this._values[t3] = new Xs(this._values[t3].property)), this._values[t3].transition = ct(e3) || void 0;
          }
          serialize() {
            const t3 = {};
            for (const e3 of Object.keys(this._values)) {
              const r3 = this.getValue(e3);
              r3 !== void 0 && (t3[e3] = r3);
              const n2 = this.getTransition(e3);
              n2 !== void 0 && (t3[`${e3}-transition`] = n2);
            }
            return t3;
          }
          transitioned(t3, e3) {
            const r3 = new Hs(this._properties);
            for (const n2 of Object.keys(this._values))
              r3._values[n2] = this._values[n2].transitioned(t3, e3._values[n2]);
            return r3;
          }
          untransitioned() {
            const t3 = new Hs(this._properties);
            for (const e3 of Object.keys(this._values))
              t3._values[e3] = this._values[e3].untransitioned();
            return t3;
          }
        }
        class Ys {
          constructor(t3, e3, r3, n2, i3) {
            const s4 = n2.delay || 0, a2 = n2.duration || 0;
            i3 = i3 || 0, this.property = t3, this.value = e3, this.begin = i3 + s4, this.end = this.begin + a2, t3.specification.transition && (n2.delay || n2.duration) && (this.prior = r3);
          }
          possiblyEvaluate(t3, e3, r3) {
            const n2 = t3.now || 0, i3 = this.value.possiblyEvaluate(t3, e3, r3), s4 = this.prior;
            if (s4) {
              if (n2 > this.end)
                return this.prior = null, i3;
              if (this.value.isDataDriven())
                return this.prior = null, i3;
              if (n2 < this.begin)
                return s4.possiblyEvaluate(t3, e3, r3);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s4.possiblyEvaluate(t3, e3, r3), i3, Z2(a2));
              }
            }
            return i3;
          }
        }
        class Hs {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t3, e3, r3) {
            const n2 = new Qs(this._properties);
            for (const i3 of Object.keys(this._values))
              n2._values[i3] = this._values[i3].possiblyEvaluate(t3, e3, r3);
            return n2;
          }
          hasTransition() {
            for (const t3 of Object.keys(this._values))
              if (this._values[t3].prior)
                return true;
            return false;
          }
        }
        class Js {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
          }
          getValue(t3) {
            return ct(this._values[t3].value);
          }
          setValue(t3, e3) {
            this._values[t3] = new Zs(this._values[t3].property, e3 === null ? void 0 : ct(e3));
          }
          serialize() {
            const t3 = {};
            for (const e3 of Object.keys(this._values)) {
              const r3 = this.getValue(e3);
              r3 !== void 0 && (t3[e3] = r3);
            }
            return t3;
          }
          possiblyEvaluate(t3, e3, r3) {
            const n2 = new Qs(this._properties);
            for (const i3 of Object.keys(this._values))
              n2._values[i3] = this._values[i3].possiblyEvaluate(t3, e3, r3);
            return n2;
          }
        }
        class Ws {
          constructor(t3, e3, r3) {
            this.property = t3, this.value = e3, this.parameters = r3;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t3) {
            return this.value.kind === "constant" ? this.value.value : t3;
          }
          evaluate(t3, e3, r3, n2) {
            return this.property.evaluate(this.value, this.parameters, t3, e3, r3, n2);
          }
        }
        class Qs {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
          }
          get(t3) {
            return this._values[t3];
          }
        }
        class ta {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e3) {
            return t3.expression.evaluate(e3);
          }
          interpolate(t3, e3, r3) {
            const n2 = Rr[this.specification.type];
            return n2 ? n2(t3, e3, r3) : t3;
          }
        }
        class ea {
          constructor(t3, e3) {
            this.specification = t3, this.overrides = e3;
          }
          possiblyEvaluate(t3, e3, r3, n2) {
            return new Ws(this, t3.expression.kind === "constant" || t3.expression.kind === "camera" ? { kind: "constant", value: t3.expression.evaluate(e3, null, {}, r3, n2) } : t3.expression, e3);
          }
          interpolate(t3, e3, r3) {
            if (t3.value.kind !== "constant" || e3.value.kind !== "constant")
              return t3;
            if (t3.value.value === void 0 || e3.value.value === void 0)
              return new Ws(this, { kind: "constant", value: void 0 }, t3.parameters);
            const n2 = Rr[this.specification.type];
            return n2 ? new Ws(this, { kind: "constant", value: n2(t3.value.value, e3.value.value, r3) }, t3.parameters) : t3;
          }
          evaluate(t3, e3, r3, n2, i3, s4) {
            return t3.kind === "constant" ? t3.value : t3.evaluate(e3, r3, n2, i3, s4);
          }
        }
        class ra extends ea {
          possiblyEvaluate(t3, e3, r3, n2) {
            if (t3.value === void 0)
              return new Ws(this, { kind: "constant", value: void 0 }, e3);
            if (t3.expression.kind === "constant") {
              const i3 = t3.expression.evaluate(e3, null, {}, r3, n2), s4 = t3.property.specification.type === "resolvedImage" && typeof i3 != "string" ? i3.name : i3, a2 = this._calculate(s4, s4, s4, e3);
              return new Ws(this, { kind: "constant", value: a2 }, e3);
            }
            if (t3.expression.kind === "camera") {
              const r4 = this._calculate(t3.expression.evaluate({ zoom: e3.zoom - 1 }), t3.expression.evaluate({ zoom: e3.zoom }), t3.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
              return new Ws(this, { kind: "constant", value: r4 }, e3);
            }
            return new Ws(this, t3.expression, e3);
          }
          evaluate(t3, e3, r3, n2, i3, s4) {
            if (t3.kind === "source") {
              const a2 = t3.evaluate(e3, r3, n2, i3, s4);
              return this._calculate(a2, a2, a2, e3);
            }
            return t3.kind === "composite" ? this._calculate(t3.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r3, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) }, r3, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r3, n2), e3) : t3.value;
          }
          _calculate(t3, e3, r3, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t3, to: e3, other: r3 } : { from: r3, to: e3, other: t3 };
          }
          interpolate(t3) {
            return t3;
          }
        }
        class na {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e3, r3, n2) {
            if (t3.value !== void 0) {
              if (t3.expression.kind === "constant") {
                const i3 = t3.expression.evaluate(e3, null, {}, r3, n2);
                return this._calculate(i3, i3, i3, e3);
              }
              return this._calculate(t3.expression.evaluate(new Gs(Math.floor(e3.zoom - 1), e3)), t3.expression.evaluate(new Gs(Math.floor(e3.zoom), e3)), t3.expression.evaluate(new Gs(Math.floor(e3.zoom + 1), e3)), e3);
            }
          }
          _calculate(t3, e3, r3, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t3, to: e3 } : { from: r3, to: e3 };
          }
          interpolate(t3) {
            return t3;
          }
        }
        class ia {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e3, r3, n2) {
            return !!t3.expression.evaluate(e3, null, {}, r3, n2);
          }
          interpolate() {
            return false;
          }
        }
        class sa {
          constructor(t3) {
            this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e3 in t3) {
              const r3 = t3[e3];
              r3.specification.overridable && this.overridableProperties.push(e3);
              const n2 = this.defaultPropertyValues[e3] = new Zs(r3, void 0), i3 = this.defaultTransitionablePropertyValues[e3] = new Xs(r3);
              this.defaultTransitioningPropertyValues[e3] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[e3] = n2.possiblyEvaluate({});
            }
          }
        }
        function aa(t3, e3) {
          return 256 * (t3 = Y(Math.floor(t3), 0, 255)) + Y(Math.floor(e3), 0, 255);
        }
        Zi("DataDrivenProperty", ea), Zi("DataConstantProperty", ta), Zi("CrossFadedDataDrivenProperty", ra), Zi("CrossFadedProperty", na), Zi("ColorRampProperty", ia);
        const oa = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class la {
          constructor(t3, e3) {
            this._structArray = t3, this._pos1 = e3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class ua {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t3, e3) {
            return t3._trim(), e3 && (t3.isTransferred = true, e3.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
          }
          static deserialize(t3) {
            const e3 = Object.create(this.prototype);
            return e3.arrayBuffer = t3.arrayBuffer, e3.length = t3.length, e3.capacity = t3.arrayBuffer.byteLength / e3.bytesPerElement, e3._refreshViews(), e3;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t3) {
            this.reserve(t3), this.length = t3;
          }
          reserve(t3) {
            if (t3 > this.capacity) {
              this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e3 = this.uint8;
              this._refreshViews(), e3 && this.uint8.set(e3);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function ca(t3, e3 = 1) {
          let r3 = 0, n2 = 0;
          return { members: t3.map((t4) => {
            const i3 = oa[t4.type].BYTES_PER_ELEMENT, s4 = r3 = ha(r3, Math.max(e3, i3)), a2 = t4.components || 1;
            return n2 = Math.max(n2, i3), r3 += i3 * a2, { name: t4.name, type: t4.type, components: a2, offset: s4 };
          }), size: ha(r3, Math.max(n2, e3)), alignment: e3 };
        }
        function ha(t3, e3) {
          return Math.ceil(t3 / e3) * e3;
        }
        class pa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e3);
          }
          emplace(t3, e3, r3) {
            const n2 = 2 * t3;
            return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r3, t3;
          }
        }
        pa.prototype.bytesPerElement = 4, Zi("StructArrayLayout2i4", pa);
        class da extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n2);
          }
          emplace(t3, e3, r3, n2, i3) {
            const s4 = 4 * t3;
            return this.int16[s4 + 0] = e3, this.int16[s4 + 1] = r3, this.int16[s4 + 2] = n2, this.int16[s4 + 3] = i3, t3;
          }
        }
        da.prototype.bytesPerElement = 8, Zi("StructArrayLayout4i8", da);
        class fa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t3, e3, r3, n2, i3, s4, a2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2) {
            const l2 = 6 * t3, u2 = 12 * t3, c2 = 3 * t3;
            return this.int16[l2 + 0] = e3, this.int16[l2 + 1] = r3, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i3, this.uint8[u2 + 6] = s4, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t3;
          }
        }
        fa.prototype.bytesPerElement = 12, Zi("StructArrayLayout2i4ub1f12", fa);
        class ya extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r3);
          }
          emplace(t3, e3, r3, n2) {
            const i3 = 3 * t3;
            return this.float32[i3 + 0] = e3, this.float32[i3 + 1] = r3, this.float32[i3 + 2] = n2, t3;
          }
        }
        ya.prototype.bytesPerElement = 12, Zi("StructArrayLayout3f12", ya);
        class ma extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2) {
            const c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t3, e3, r3, n2, i3, s4, a2, o2, l2, u2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2) {
            const h3 = 10 * t3;
            return this.uint16[h3 + 0] = e3, this.uint16[h3 + 1] = r3, this.uint16[h3 + 2] = n2, this.uint16[h3 + 3] = i3, this.uint16[h3 + 4] = s4, this.uint16[h3 + 5] = a2, this.uint16[h3 + 6] = o2, this.uint16[h3 + 7] = l2, this.uint16[h3 + 8] = u2, this.uint16[h3 + 9] = c2, t3;
          }
        }
        ma.prototype.bytesPerElement = 20, Zi("StructArrayLayout10ui20", ma);
        class ga extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2, o2) {
            const l2 = this.length;
            return this.resize(l2 + 1), this.emplace(l2, t3, e3, r3, n2, i3, s4, a2, o2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
            const u2 = 8 * t3;
            return this.uint16[u2 + 0] = e3, this.uint16[u2 + 1] = r3, this.uint16[u2 + 2] = n2, this.uint16[u2 + 3] = i3, this.uint16[u2 + 4] = s4, this.uint16[u2 + 5] = a2, this.uint16[u2 + 6] = o2, this.uint16[u2 + 7] = l2, t3;
          }
        }
        ga.prototype.bytesPerElement = 16, Zi("StructArrayLayout8ui16", ga);
        class xa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2) {
            const m3 = this.length;
            return this.resize(m3 + 1), this.emplace(m3, t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3) {
            const g2 = 16 * t3;
            return this.int16[g2 + 0] = e3, this.int16[g2 + 1] = r3, this.int16[g2 + 2] = n2, this.int16[g2 + 3] = i3, this.uint16[g2 + 4] = s4, this.uint16[g2 + 5] = a2, this.uint16[g2 + 6] = o2, this.uint16[g2 + 7] = l2, this.int16[g2 + 8] = u2, this.int16[g2 + 9] = c2, this.int16[g2 + 10] = h3, this.int16[g2 + 11] = p2, this.int16[g2 + 12] = d2, this.int16[g2 + 13] = f4, this.int16[g2 + 14] = y2, this.int16[g2 + 15] = m3, t3;
          }
        }
        xa.prototype.bytesPerElement = 32, Zi("StructArrayLayout4i4ui4i4i32", xa);
        class va extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }
          emplace(t3, e3) {
            return this.uint32[1 * t3 + 0] = e3, t3;
          }
        }
        va.prototype.bytesPerElement = 4, Zi("StructArrayLayout1ul4", va);
        class ba extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2) {
            const d2 = this.length;
            return this.resize(d2 + 1), this.emplace(d2, t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2) {
            const f4 = 20 * t3, y2 = 10 * t3;
            return this.int16[f4 + 0] = e3, this.int16[f4 + 1] = r3, this.int16[f4 + 2] = n2, this.int16[f4 + 3] = i3, this.int16[f4 + 4] = s4, this.float32[y2 + 3] = a2, this.float32[y2 + 4] = o2, this.float32[y2 + 5] = l2, this.float32[y2 + 6] = u2, this.int16[f4 + 14] = c2, this.uint32[y2 + 8] = h3, this.uint16[f4 + 18] = p2, this.uint16[f4 + 19] = d2, t3;
          }
        }
        ba.prototype.bytesPerElement = 40, Zi("StructArrayLayout5i4f1i1ul2ui40", ba);
        class wa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t3, e3, r3, n2, i3, s4, a2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2) {
            const l2 = 8 * t3;
            return this.int16[l2 + 0] = e3, this.int16[l2 + 1] = r3, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i3, this.int16[l2 + 5] = s4, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t3;
          }
        }
        wa.prototype.bytesPerElement = 16, Zi("StructArrayLayout3i2i2i16", wa);
        class _a extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t3, e3, r3, n2, i3);
          }
          emplace(t3, e3, r3, n2, i3, s4) {
            const a2 = 4 * t3, o2 = 8 * t3;
            return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r3, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i3, this.int16[o2 + 7] = s4, t3;
          }
        }
        _a.prototype.bytesPerElement = 16, Zi("StructArrayLayout2f1f2i16", _a);
        class Aa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n2);
          }
          emplace(t3, e3, r3, n2, i3) {
            const s4 = 12 * t3, a2 = 3 * t3;
            return this.uint8[s4 + 0] = e3, this.uint8[s4 + 1] = r3, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i3, t3;
          }
        }
        Aa.prototype.bytesPerElement = 12, Zi("StructArrayLayout2ub2f12", Aa);
        class ka extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r3);
          }
          emplace(t3, e3, r3, n2) {
            const i3 = 3 * t3;
            return this.uint16[i3 + 0] = e3, this.uint16[i3 + 1] = r3, this.uint16[i3 + 2] = n2, t3;
          }
        }
        ka.prototype.bytesPerElement = 6, Zi("StructArrayLayout3ui6", ka);
        class Sa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2, x3, v2, b2) {
            const w2 = this.length;
            return this.resize(w2 + 1), this.emplace(w2, t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2, x3, v2, b2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2, x3, v2, b2, w2) {
            const _2 = 30 * t3, A3 = 15 * t3, k2 = 60 * t3;
            return this.int16[_2 + 0] = e3, this.int16[_2 + 1] = r3, this.int16[_2 + 2] = n2, this.float32[A3 + 2] = i3, this.float32[A3 + 3] = s4, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A3 + 5] = l2, this.uint32[A3 + 6] = u2, this.uint32[A3 + 7] = c2, this.uint16[_2 + 16] = h3, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = d2, this.float32[A3 + 10] = f4, this.float32[A3 + 11] = y2, this.uint8[k2 + 48] = m3, this.uint8[k2 + 49] = g2, this.uint8[k2 + 50] = x3, this.uint32[A3 + 13] = v2, this.int16[_2 + 28] = b2, this.uint8[k2 + 58] = w2, t3;
          }
        }
        Sa.prototype.bytesPerElement = 60, Zi("StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60", Sa);
        class Ia extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2, x3, v2, b2, w2, _2, A3, k2, S3, I2, z2, M2, T2) {
            const B2 = this.length;
            return this.resize(B2 + 1), this.emplace(B2, t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2, x3, v2, b2, w2, _2, A3, k2, S3, I2, z2, M2, T2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2, x3, v2, b2, w2, _2, A3, k2, S3, I2, z2, M2, T2, B2) {
            const C2 = 38 * t3, P2 = 19 * t3;
            return this.int16[C2 + 0] = e3, this.int16[C2 + 1] = r3, this.int16[C2 + 2] = n2, this.float32[P2 + 2] = i3, this.float32[P2 + 3] = s4, this.int16[C2 + 8] = a2, this.int16[C2 + 9] = o2, this.int16[C2 + 10] = l2, this.int16[C2 + 11] = u2, this.int16[C2 + 12] = c2, this.int16[C2 + 13] = h3, this.uint16[C2 + 14] = p2, this.uint16[C2 + 15] = d2, this.uint16[C2 + 16] = f4, this.uint16[C2 + 17] = y2, this.uint16[C2 + 18] = m3, this.uint16[C2 + 19] = g2, this.uint16[C2 + 20] = x3, this.uint16[C2 + 21] = v2, this.uint16[C2 + 22] = b2, this.uint16[C2 + 23] = w2, this.uint16[C2 + 24] = _2, this.uint16[C2 + 25] = A3, this.uint16[C2 + 26] = k2, this.uint16[C2 + 27] = S3, this.uint16[C2 + 28] = I2, this.uint32[P2 + 15] = z2, this.float32[P2 + 16] = M2, this.float32[P2 + 17] = T2, this.float32[P2 + 18] = B2, t3;
          }
        }
        Ia.prototype.bytesPerElement = 76, Zi("StructArrayLayout3i2f6i15ui1ul3f76", Ia);
        class za extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }
          emplace(t3, e3) {
            return this.float32[1 * t3 + 0] = e3, t3;
          }
        }
        za.prototype.bytesPerElement = 4, Zi("StructArrayLayout1f4", za);
        class Ma extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t3, e3, r3);
          }
          emplace(t3, e3, r3, n2) {
            const i3 = 3 * t3;
            return this.int16[i3 + 0] = e3, this.int16[i3 + 1] = r3, this.int16[i3 + 2] = n2, t3;
          }
        }
        Ma.prototype.bytesPerElement = 6, Zi("StructArrayLayout3i6", Ma);
        class Ta extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2, i3, s4, a2) {
            const o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t3, e3, r3, n2, i3, s4, a2);
          }
          emplace(t3, e3, r3, n2, i3, s4, a2, o2) {
            const l2 = 7 * t3;
            return this.float32[l2 + 0] = e3, this.float32[l2 + 1] = r3, this.float32[l2 + 2] = n2, this.float32[l2 + 3] = i3, this.float32[l2 + 4] = s4, this.float32[l2 + 5] = a2, this.float32[l2 + 6] = o2, t3;
          }
        }
        Ta.prototype.bytesPerElement = 28, Zi("StructArrayLayout7f28", Ta);
        class Ba extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n2);
          }
          emplace(t3, e3, r3, n2, i3) {
            const s4 = 6 * t3;
            return this.uint32[3 * t3 + 0] = e3, this.uint16[s4 + 2] = r3, this.uint16[s4 + 3] = n2, this.uint16[s4 + 4] = i3, t3;
          }
        }
        Ba.prototype.bytesPerElement = 12, Zi("StructArrayLayout1ul3ui12", Ba);
        class Ca extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e3);
          }
          emplace(t3, e3, r3) {
            const n2 = 2 * t3;
            return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r3, t3;
          }
        }
        Ca.prototype.bytesPerElement = 4, Zi("StructArrayLayout2ui4", Ca);
        class Pa extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }
          emplace(t3, e3) {
            return this.uint16[1 * t3 + 0] = e3, t3;
          }
        }
        Pa.prototype.bytesPerElement = 2, Zi("StructArrayLayout1ui2", Pa);
        class Ea extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e3);
          }
          emplace(t3, e3, r3) {
            const n2 = 2 * t3;
            return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r3, t3;
          }
        }
        Ea.prototype.bytesPerElement = 8, Zi("StructArrayLayout2f8", Ea);
        class Da extends ua {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n2);
          }
          emplace(t3, e3, r3, n2, i3) {
            const s4 = 4 * t3;
            return this.float32[s4 + 0] = e3, this.float32[s4 + 1] = r3, this.float32[s4 + 2] = n2, this.float32[s4 + 3] = i3, t3;
          }
        }
        Da.prototype.bytesPerElement = 16, Zi("StructArrayLayout4f16", Da);
        class Va extends la {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        Va.prototype.size = 40;
        class Fa extends ba {
          get(t3) {
            return new Va(this, t3);
          }
        }
        Zi("CollisionBoxArray", Fa);
        class La extends la {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t3) {
            this._structArray.uint8[this._pos1 + 49] = t3;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t3) {
            this._structArray.uint8[this._pos1 + 50] = t3;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 13] = t3;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t3) {
            this._structArray.uint8[this._pos1 + 58] = t3;
          }
        }
        La.prototype.size = 60;
        class Ra extends Sa {
          get(t3) {
            return new La(this, t3);
          }
        }
        Zi("PlacedSymbolArray", Ra);
        class Ua extends la {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 13];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 28];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 15];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 15] = t3;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 18];
          }
        }
        Ua.prototype.size = 76;
        class $a extends Ia {
          get(t3) {
            return new Ua(this, t3);
          }
        }
        Zi("SymbolInstanceArray", $a);
        class Oa extends za {
          getoffsetX(t3) {
            return this.float32[1 * t3 + 0];
          }
        }
        Zi("GlyphOffsetArray", Oa);
        class ja extends Ma {
          getx(t3) {
            return this.int16[3 * t3 + 0];
          }
          gety(t3) {
            return this.int16[3 * t3 + 1];
          }
          gettileUnitDistanceFromAnchor(t3) {
            return this.int16[3 * t3 + 2];
          }
        }
        Zi("SymbolLineVertexArray", ja);
        class qa extends la {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        qa.prototype.size = 12;
        class Na extends Ba {
          get(t3) {
            return new qa(this, t3);
          }
        }
        Zi("FeatureIndexArray", Na);
        class Ga extends la {
          get a_centroid_pos0() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get a_centroid_pos1() {
            return this._structArray.uint16[this._pos2 + 1];
          }
        }
        Ga.prototype.size = 4;
        class Za extends Ca {
          get(t3) {
            return new Ga(this, t3);
          }
        }
        Zi("FillExtrusionCentroidArray", Za);
        const Xa = ca([{ name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }]), Ka = ca([{ name: "a_dash_to", components: 4, type: "Uint16" }, { name: "a_dash_from", components: 4, type: "Uint16" }]);
        var Ya = qe(function(t3) {
          t3.exports = function(t4, e3) {
            var r3, n2, i3, s4, a2, o2, l2, u2;
            for (n2 = t4.length - (r3 = 3 & t4.length), i3 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
              l2 = 255 & t4.charCodeAt(u2) | (255 & t4.charCodeAt(++u2)) << 8 | (255 & t4.charCodeAt(++u2)) << 16 | (255 & t4.charCodeAt(++u2)) << 24, ++u2, i3 = 27492 + (65535 & (s4 = 5 * (65535 & (i3 = (i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s4 >>> 16) & 65535) << 16);
            switch (l2 = 0, r3) {
              case 3:
                l2 ^= (255 & t4.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t4.charCodeAt(u2 + 1)) << 8;
              case 1:
                i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t4.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i3 ^= t4.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
          };
        }), Ha = qe(function(t3) {
          t3.exports = function(t4, e3) {
            for (var r3, n2 = t4.length, i3 = e3 ^ n2, s4 = 0; n2 >= 4; )
              r3 = 1540483477 * (65535 & (r3 = 255 & t4.charCodeAt(s4) | (255 & t4.charCodeAt(++s4)) << 8 | (255 & t4.charCodeAt(++s4)) << 16 | (255 & t4.charCodeAt(++s4)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n2 -= 4, ++s4;
            switch (n2) {
              case 3:
                i3 ^= (255 & t4.charCodeAt(s4 + 2)) << 16;
              case 2:
                i3 ^= (255 & t4.charCodeAt(s4 + 1)) << 8;
              case 1:
                i3 = 1540483477 * (65535 & (i3 ^= 255 & t4.charCodeAt(s4))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
            }
            return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
          };
        }), Ja = Ya, Wa = Ha;
        Ja.murmur3 = Ya, Ja.murmur2 = Wa;
        class Qa {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t3, e3, r3, n2) {
            this.ids.push(to(t3)), this.positions.push(e3, r3, n2);
          }
          getPositions(t3) {
            const e3 = to(t3);
            let r3 = 0, n2 = this.ids.length - 1;
            for (; r3 < n2; ) {
              const t4 = r3 + n2 >> 1;
              this.ids[t4] >= e3 ? n2 = t4 : r3 = t4 + 1;
            }
            const i3 = [];
            for (; this.ids[r3] === e3; )
              i3.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
            return i3;
          }
          static serialize(t3, e3) {
            const r3 = new Float64Array(t3.ids), n2 = new Uint32Array(t3.positions);
            return eo(r3, n2, 0, r3.length - 1), e3 && e3.push(r3.buffer, n2.buffer), { ids: r3, positions: n2 };
          }
          static deserialize(t3) {
            const e3 = new Qa();
            return e3.ids = t3.ids, e3.positions = t3.positions, e3.indexed = true, e3;
          }
        }
        function to(t3) {
          const e3 = +t3;
          return !isNaN(e3) && Number.MIN_SAFE_INTEGER <= e3 && e3 <= Number.MAX_SAFE_INTEGER ? e3 : Ja(String(t3));
        }
        function eo(t3, e3, r3, n2) {
          for (; r3 < n2; ) {
            const i3 = t3[r3 + n2 >> 1];
            let s4 = r3 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s4++;
              } while (t3[s4] < i3);
              do {
                a2--;
              } while (t3[a2] > i3);
              if (s4 >= a2)
                break;
              ro(t3, s4, a2), ro(e3, 3 * s4, 3 * a2), ro(e3, 3 * s4 + 1, 3 * a2 + 1), ro(e3, 3 * s4 + 2, 3 * a2 + 2);
            }
            a2 - r3 < n2 - a2 ? (eo(t3, e3, r3, a2), r3 = a2 + 1) : (eo(t3, e3, a2 + 1, n2), n2 = a2);
          }
        }
        function ro(t3, e3, r3) {
          const n2 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n2;
        }
        Zi("FeaturePositionMap", Qa);
        class no {
          constructor(t3, e3) {
            this.gl = t3.gl, this.location = e3;
          }
        }
        class io extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = 0;
          }
          set(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
          }
        }
        class so extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = [0, 0, 0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
          }
        }
        class ao extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = Ge.transparent;
          }
          set(t3) {
            t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
          }
        }
        const oo = new Float32Array(16), lo = new Float32Array(9), uo = new Float32Array(4);
        function co(t3) {
          return [aa(255 * t3.r, 255 * t3.g), aa(255 * t3.b, 255 * t3.a)];
        }
        class ho {
          constructor(t3, e3, r3) {
            this.value = t3, this.uniformNames = e3.map((t4) => `u_${t4}`), this.type = r3;
          }
          setUniform(t3, e3, r3) {
            t3.set(r3.constantOr(this.value));
          }
          getBinding(t3, e3, r3) {
            return this.type === "color" ? new ao(t3, e3) : new io(t3, e3);
          }
        }
        class po {
          constructor(t3, e3) {
            this.uniformNames = e3.map((t4) => `u_${t4}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t3, e3) {
            this.pixelRatioFrom = e3.pixelRatio, this.pixelRatioTo = t3.pixelRatio, this.patternFrom = e3.tl.concat(e3.br), this.patternTo = t3.tl.concat(t3.br);
          }
          setUniform(t3, e3, r3, n2) {
            const i3 = n2 === "u_pattern_to" || n2 === "u_dash_to" ? this.patternTo : n2 === "u_pattern_from" || n2 === "u_dash_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            i3 && t3.set(i3);
          }
          getBinding(t3, e3, r3) {
            return r3 === "u_pattern_from" || r3 === "u_pattern_to" || r3 === "u_dash_from" || r3 === "u_dash_to" ? new so(t3, e3) : new io(t3, e3);
          }
        }
        class fo {
          constructor(t3, e3, r3, n2) {
            this.expression = t3, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e3.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: r3 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t3, e3, r3, n2, i3, s4) {
            const a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new Gs(0), e3, {}, i3, n2, s4);
            this.paintVertexArray.resize(t3), this._setPaintValue(a2, t3, o2);
          }
          updatePaintArray(t3, e3, r3, n2, i3) {
            const s4 = this.expression.evaluate({ zoom: 0 }, r3, n2, void 0, i3);
            this._setPaintValue(t3, e3, s4);
          }
          _setPaintValue(t3, e3, r3) {
            if (this.type === "color") {
              const n2 = co(r3);
              for (let r4 = t3; r4 < e3; r4++)
                this.paintVertexArray.emplace(r4, n2[0], n2[1]);
            } else {
              for (let n2 = t3; n2 < e3; n2++)
                this.paintVertexArray.emplace(n2, r3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class yo {
          constructor(t3, e3, r3, n2, i3, s4) {
            this.expression = t3, this.uniformNames = e3.map((t4) => `u_${t4}_t`), this.type = r3, this.useIntegerZoom = n2, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e3.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: r3 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s4();
          }
          populatePaintArray(t3, e3, r3, n2, i3, s4) {
            const a2 = this.expression.evaluate(new Gs(this.zoom), e3, {}, i3, n2, s4), o2 = this.expression.evaluate(new Gs(this.zoom + 1), e3, {}, i3, n2, s4), l2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValue(l2, t3, a2, o2);
          }
          updatePaintArray(t3, e3, r3, n2, i3) {
            const s4 = this.expression.evaluate({ zoom: this.zoom }, r3, n2, void 0, i3), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n2, void 0, i3);
            this._setPaintValue(t3, e3, s4, a2);
          }
          _setPaintValue(t3, e3, r3, n2) {
            if (this.type === "color") {
              const i3 = co(r3), s4 = co(n2);
              for (let r4 = t3; r4 < e3; r4++)
                this.paintVertexArray.emplace(r4, i3[0], i3[1], s4[0], s4[1]);
            } else {
              for (let i3 = t3; i3 < e3; i3++)
                this.paintVertexArray.emplace(i3, r3, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n2));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t3, e3) {
            const r3 = this.useIntegerZoom ? Math.floor(e3.zoom) : e3.zoom, n2 = Y(this.expression.interpolationFactor(r3, this.zoom, this.zoom + 1), 0, 1);
            t3.set(n2);
          }
          getBinding(t3, e3, r3) {
            return new io(t3, e3);
          }
        }
        class mo {
          constructor(t3, e3, r3, n2, i3, s4, a2) {
            this.expression = t3, this.type = r3, this.useIntegerZoom = n2, this.zoom = i3, this.layerId = a2, this.paintVertexAttributes = (r3 === "array" ? Ka : Xa).members;
            for (let t4 = 0; t4 < e3.length; ++t4)
              ;
            this.zoomInPaintVertexArray = new s4(), this.zoomOutPaintVertexArray = new s4();
          }
          populatePaintArray(t3, e3, r3) {
            const n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t3), this.zoomOutPaintVertexArray.resize(t3), this._setPaintValues(n2, t3, e3.patterns && e3.patterns[this.layerId], r3);
          }
          updatePaintArray(t3, e3, r3, n2, i3, s4) {
            this._setPaintValues(t3, e3, r3.patterns && r3.patterns[this.layerId], s4);
          }
          _setPaintValues(t3, e3, r3, n2) {
            if (!n2 || !r3)
              return;
            const { min: i3, mid: s4, max: a2 } = r3, o2 = n2[i3], l2 = n2[s4], u2 = n2[a2];
            if (o2 && l2 && u2)
              for (let r4 = t3; r4 < e3; r4++)
                this._setPaintValue(this.zoomInPaintVertexArray, r4, l2, o2), this._setPaintValue(this.zoomOutPaintVertexArray, r4, l2, u2);
          }
          _setPaintValue(t3, e3, r3, n2) {
            t3.emplace(e3, r3.tl[0], r3.tl[1], r3.br[0], r3.br[1], n2.tl[0], n2.tl[1], n2.br[0], n2.br[1], r3.pixelRatio, n2.pixelRatio);
          }
          upload(t3) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t3.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t3.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class go {
          constructor(t3, e3, r3 = () => true) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i3 in t3.paint._values) {
              if (!r3(i3))
                continue;
              const s4 = t3.paint.get(i3);
              if (!(s4 instanceof Ws && Cn(s4.property.specification)))
                continue;
              const a2 = bo(i3, t3.type), o2 = s4.value, l2 = s4.property.specification.type, u2 = s4.property.useIntegerZoom, c2 = s4.property.specification["property-type"], h3 = c2 === "cross-faded" || c2 === "cross-faded-data-driven", p2 = String(i3) === "line-dasharray" && t3.layout.get("line-cap").value.kind !== "constant";
              if (o2.kind !== "constant" || p2)
                if (o2.kind === "source" || p2 || h3) {
                  const r4 = Ao(i3, l2, "source");
                  this.binders[i3] = h3 ? new mo(o2, a2, l2, u2, e3, r4, t3.id) : new fo(o2, a2, l2, r4), n2.push(`/a_${i3}`);
                } else {
                  const t4 = Ao(i3, l2, "composite");
                  this.binders[i3] = new yo(o2, a2, l2, u2, e3, t4), n2.push(`/z_${i3}`);
                }
              else
                this.binders[i3] = h3 ? new po(o2.value, a2) : new ho(o2.value, a2, l2), n2.push(`/u_${i3}`);
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t3) {
            const e3 = this.binders[t3];
            return e3 instanceof fo || e3 instanceof yo ? e3.maxValue : 0;
          }
          populatePaintArrays(t3, e3, r3, n2, i3, s4) {
            for (const a2 in this.binders) {
              const o2 = this.binders[a2];
              (o2 instanceof fo || o2 instanceof yo || o2 instanceof mo) && o2.populatePaintArray(t3, e3, r3, n2, i3, s4);
            }
          }
          setConstantPatternPositions(t3, e3) {
            for (const r3 in this.binders) {
              const n2 = this.binders[r3];
              n2 instanceof po && n2.setConstantPatternPositions(t3, e3);
            }
          }
          updatePaintArrays(t3, e3, r3, n2, i3, s4) {
            let a2 = false;
            for (const o2 in t3) {
              const l2 = e3.getPositions(o2);
              for (const e4 of l2) {
                const l3 = r3.feature(e4.index);
                for (const r4 in this.binders) {
                  const u2 = this.binders[r4];
                  if ((u2 instanceof fo || u2 instanceof yo || u2 instanceof mo) && u2.expression.isStateDependent === true) {
                    const c2 = n2.paint.get(r4);
                    u2.expression = c2.value, u2.updatePaintArray(e4.start, e4.end, l3, t3[o2], i3, s4), a2 = true;
                  }
                }
              }
            }
            return a2;
          }
          defines() {
            const t3 = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              (r3 instanceof ho || r3 instanceof po) && t3.push(...r3.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
            }
            return t3;
          }
          getBinderAttributes() {
            const t3 = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              if (r3 instanceof fo || r3 instanceof yo || r3 instanceof mo)
                for (let e4 = 0; e4 < r3.paintVertexAttributes.length; e4++)
                  t3.push(r3.paintVertexAttributes[e4].name);
            }
            return t3;
          }
          getBinderUniforms() {
            const t3 = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              if (r3 instanceof ho || r3 instanceof po || r3 instanceof yo)
                for (const e4 of r3.uniformNames)
                  t3.push(e4);
            }
            return t3;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t3, e3) {
            const r3 = [];
            for (const n2 in this.binders) {
              const i3 = this.binders[n2];
              if (i3 instanceof ho || i3 instanceof po || i3 instanceof yo) {
                for (const s4 of i3.uniformNames)
                  if (e3[s4]) {
                    const a2 = i3.getBinding(t3, e3[s4], s4);
                    r3.push({ name: s4, property: n2, binding: a2 });
                  }
              }
            }
            return r3;
          }
          setUniforms(t3, e3, r3, n2) {
            for (const { name: t4, property: i3, binding: s4 } of e3)
              this.binders[i3].setUniform(s4, n2, r3.get(i3), t4);
          }
          updatePaintBuffers(t3) {
            this._buffers = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              if (t3 && r3 instanceof mo) {
                const e4 = t3.fromScale === 2 ? r3.zoomInPaintVertexBuffer : r3.zoomOutPaintVertexBuffer;
                e4 && this._buffers.push(e4);
              } else
                (r3 instanceof fo || r3 instanceof yo) && r3.paintVertexBuffer && this._buffers.push(r3.paintVertexBuffer);
            }
          }
          upload(t3) {
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              (r3 instanceof fo || r3 instanceof yo || r3 instanceof mo) && r3.upload(t3);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t3 in this.binders) {
              const e3 = this.binders[t3];
              (e3 instanceof fo || e3 instanceof yo || e3 instanceof mo) && e3.destroy();
            }
          }
        }
        class xo {
          constructor(t3, e3, r3 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t3)
              this.programConfigurations[n2.id] = new go(n2, e3, r3);
            this.needsUpload = false, this._featureMap = new Qa(), this._bufferOffset = 0;
          }
          populatePaintArrays(t3, e3, r3, n2, i3, s4, a2) {
            for (const r4 in this.programConfigurations)
              this.programConfigurations[r4].populatePaintArrays(t3, e3, n2, i3, s4, a2);
            e3.id !== void 0 && this._featureMap.add(e3.id, r3, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
          }
          updatePaintArrays(t3, e3, r3, n2, i3) {
            for (const s4 of r3)
              this.needsUpload = this.programConfigurations[s4.id].updatePaintArrays(t3, this._featureMap, e3, s4, n2, i3) || this.needsUpload;
          }
          get(t3) {
            return this.programConfigurations[t3];
          }
          upload(t3) {
            if (this.needsUpload) {
              for (const e3 in this.programConfigurations)
                this.programConfigurations[e3].upload(t3);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t3 in this.programConfigurations)
              this.programConfigurations[t3].destroy();
          }
        }
        const vo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "line-dasharray": ["dash_to", "dash_from"] };
        function bo(t3, e3) {
          return vo[t3] || [t3.replace(`${e3}-`, "").replace(/-/g, "_")];
        }
        const wo = { "line-pattern": { source: ma, composite: ma }, "fill-pattern": { source: ma, composite: ma }, "fill-extrusion-pattern": { source: ma, composite: ma }, "line-dasharray": { source: ga, composite: ga } }, _o = { color: { source: Ea, composite: Da }, number: { source: za, composite: Ea } };
        function Ao(t3, e3, r3) {
          const n2 = wo[t3];
          return n2 && n2[r3] || _o[e3][r3];
        }
        Zi("ConstantBinder", ho), Zi("CrossFadedConstantBinder", po), Zi("SourceExpressionBinder", fo), Zi("CrossFadedCompositeBinder", mo), Zi("CompositeExpressionBinder", yo), Zi("ProgramConfiguration", go, { omit: ["_buffers"] }), Zi("ProgramConfigurationSet", xo);
        const ko = "-transition";
        class So extends xe {
          constructor(t3, e3) {
            if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, t3.type !== "custom" && (this.metadata = (t3 = t3).metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, t3.type !== "background" && t3.type !== "sky" && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e3.layout && (this._unevaluatedLayout = new Js(e3.layout)), e3.paint)) {
              this._transitionablePaint = new Ks(e3.paint);
              for (const e4 in t3.paint)
                this.setPaintProperty(e4, t3.paint[e4], { validate: false });
              for (const e4 in t3.layout)
                this.setLayoutProperty(e4, t3.layout[e4], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Qs(e3.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t3) {
            return t3 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t3);
          }
          setLayoutProperty(t3, e3, r3 = {}) {
            e3 != null && this._validate(Ui2, `layers.${this.id}.layout.${t3}`, t3, e3, r3) || (t3 !== "visibility" ? this._unevaluatedLayout.setValue(t3, e3) : this.visibility = e3);
          }
          getPaintProperty(t3) {
            return ot(t3, ko) ? this._transitionablePaint.getTransition(t3.slice(0, -ko.length)) : this._transitionablePaint.getValue(t3);
          }
          setPaintProperty(t3, e3, r3 = {}) {
            if (e3 != null && this._validate(Ri, `layers.${this.id}.paint.${t3}`, t3, e3, r3))
              return false;
            if (ot(t3, ko))
              return this._transitionablePaint.setTransition(t3.slice(0, -ko.length), e3 || void 0), false;
            {
              const r4 = this._transitionablePaint._values[t3], n2 = r4.property.specification["property-type"] === "cross-faded-data-driven", i3 = r4.value.isDataDriven(), s4 = r4.value;
              this._transitionablePaint.setValue(t3, e3), this._handleSpecialPaintPropertyUpdate(t3);
              const a2 = this._transitionablePaint._values[t3].value;
              return a2.isDataDriven() || i3 || n2 || this._handleOverridablePaintPropertyUpdate(t3, s4, a2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t3) {
          }
          getProgramIds() {
            return null;
          }
          getProgramConfiguration(t3) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t3, e3, r3) {
            return false;
          }
          isHidden(t3) {
            return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t3) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t3, e3) {
            t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e3);
          }
          serialize() {
            const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), ut(t3, (t4, e3) => !(t4 === void 0 || e3 === "layout" && !Object.keys(t4).length || e3 === "paint" && !Object.keys(t4).length));
          }
          _validate(t3, e3, r3, n2, i3 = {}) {
            return (!i3 || i3.validate !== false) && $i(this, t3.call(Vi, { key: e3, layerType: this.type, objectKey: r3, value: n2, styleSpec: ve, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t3 in this.paint._values) {
              const e3 = this.paint.get(t3);
              if (e3 instanceof Ws && Cn(e3.property.specification) && (e3.value.kind === "source" || e3.value.kind === "composite") && e3.value.isStateDependent)
                return true;
            }
            return false;
          }
          compileFilter() {
            this._filterCompiled || (this._featureFilter = si(this.filter), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
        }
        const Io = ca([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: zo } = Io;
        class Mo {
          constructor(t3 = []) {
            this.segments = t3;
          }
          prepareSegment(t3, e3, r3, n2) {
            let i3 = this.segments[this.segments.length - 1];
            return t3 > Mo.MAX_VERTEX_ARRAY_LENGTH && pt(`Max vertices per segment is ${Mo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i3 || i3.vertexLength + t3 > Mo.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n2) && (i3 = { vertexOffset: e3.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, n2 !== void 0 && (i3.sortKey = n2), this.segments.push(i3)), i3;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t3 of this.segments)
              for (const e3 in t3.vaos)
                t3.vaos[e3].destroy();
          }
          static simpleSegment(t3, e3, r3, n2) {
            return new Mo([{ vertexOffset: t3, primitiveOffset: e3, vertexLength: r3, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        Mo.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Zi("SegmentVector", Mo);
        var To = 8192;
        class Bo {
          constructor(t3, e3) {
            t3 && (e3 ? this.setSouthWest(t3).setNorthEast(e3) : t3.length === 4 ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1]));
          }
          setNorthEast(t3) {
            return this._ne = t3 instanceof Po ? new Po(t3.lng, t3.lat) : Po.convert(t3), this;
          }
          setSouthWest(t3) {
            return this._sw = t3 instanceof Po ? new Po(t3.lng, t3.lat) : Po.convert(t3), this;
          }
          extend(t3) {
            const e3 = this._sw, r3 = this._ne;
            let n2, i3;
            if (t3 instanceof Po)
              n2 = t3, i3 = t3;
            else {
              if (!(t3 instanceof Bo))
                return Array.isArray(t3) ? t3.length === 4 || t3.every(Array.isArray) ? this.extend(Bo.convert(t3)) : this.extend(Po.convert(t3)) : this;
              if (n2 = t3._sw, i3 = t3._ne, !n2 || !i3)
                return this;
            }
            return e3 || r3 ? (e3.lng = Math.min(n2.lng, e3.lng), e3.lat = Math.min(n2.lat, e3.lat), r3.lng = Math.max(i3.lng, r3.lng), r3.lat = Math.max(i3.lat, r3.lat)) : (this._sw = new Po(n2.lng, n2.lat), this._ne = new Po(i3.lng, i3.lat)), this;
          }
          getCenter() {
            return new Po((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new Po(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new Po(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t3) {
            const { lng: e3, lat: r3 } = Po.convert(t3);
            let n2 = this._sw.lng <= e3 && e3 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e3 && e3 >= this._ne.lng), this._sw.lat <= r3 && r3 <= this._ne.lat && n2;
          }
          static convert(t3) {
            return !t3 || t3 instanceof Bo ? t3 : new Bo(t3);
          }
        }
        const Co = 63710088e-1;
        class Po {
          constructor(t3, e3) {
            if (isNaN(t3) || isNaN(e3))
              throw new Error(`Invalid LngLat object: (${t3}, ${e3})`);
            if (this.lng = +t3, this.lat = +e3, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Po(J(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t3) {
            const e3 = Math.PI / 180, r3 = this.lat * e3, n2 = t3.lat * e3, i3 = Math.sin(r3) * Math.sin(n2) + Math.cos(r3) * Math.cos(n2) * Math.cos((t3.lng - this.lng) * e3);
            return Co * Math.acos(Math.min(i3, 1));
          }
          toBounds(t3 = 0) {
            const e3 = 360 * t3 / 40075017, r3 = e3 / Math.cos(Math.PI / 180 * this.lat);
            return new Bo(new Po(this.lng - r3, this.lat - e3), new Po(this.lng + r3, this.lat + e3));
          }
          static convert(t3) {
            if (t3 instanceof Po)
              return t3;
            if (Array.isArray(t3) && (t3.length === 2 || t3.length === 3))
              return new Po(Number(t3[0]), Number(t3[1]));
            if (!Array.isArray(t3) && typeof t3 == "object" && t3 !== null)
              return new Po(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Eo = 2 * Math.PI * Co;
        function Do(t3) {
          return Eo * Math.cos(t3 * Math.PI / 180);
        }
        function Vo(t3) {
          return (180 + t3) / 360;
        }
        function Fo(t3) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
        }
        function Lo(t3, e3) {
          return t3 / Do(e3);
        }
        function Ro(t3) {
          return 360 * t3 - 180;
        }
        function Uo(t3) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
        }
        function $o(t3, e3) {
          return t3 * Do(Uo(e3));
        }
        const Oo = 85.051129;
        class jo {
          constructor(t3, e3, r3 = 0) {
            this.x = +t3, this.y = +e3, this.z = +r3;
          }
          static fromLngLat(t3, e3 = 0) {
            const r3 = Po.convert(t3);
            return new jo(Vo(r3.lng), Fo(r3.lat), Lo(e3, r3.lat));
          }
          toLngLat() {
            return new Po(Ro(this.x), Uo(this.y));
          }
          toAltitude() {
            return $o(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Eo * (t3 = Uo(this.y), 1 / Math.cos(t3 * Math.PI / 180));
            var t3;
          }
        }
        function qo(t3, e3, r3, n2, s4, a2, o2, l2, u2) {
          const c2 = (e3 + n2) / 2, h3 = (r3 + s4) / 2, p2 = new i2(c2, h3);
          l2(p2), function(t4, e4, r4, n3, i3, s5) {
            const a3 = r4 - i3, o3 = n3 - s5;
            return Math.abs((n3 - e4) * a3 - (r4 - t4) * o3) / Math.hypot(a3, o3);
          }(p2.x, p2.y, a2.x, a2.y, o2.x, o2.y) >= u2 ? (qo(t3, e3, r3, c2, h3, a2, p2, l2, u2), qo(t3, c2, h3, n2, s4, p2, o2, l2, u2)) : t3.push(o2);
        }
        function No(t3, e3, r3) {
          const n2 = [];
          let i3, s4, a2;
          for (const o2 of t3) {
            const { x: t4, y: l2 } = o2;
            e3(o2), a2 ? qo(n2, i3, s4, t4, l2, a2, o2, e3, r3) : n2.push(o2), i3 = t4, s4 = l2, a2 = o2;
          }
          return n2;
        }
        const Go = Math.pow(2, 14) - 1, Zo = -Go - 1;
        function Xo(t3, e3) {
          const r3 = Math.round(t3.x * e3), n2 = Math.round(t3.y * e3);
          return t3.x = Y(r3, Zo, Go), t3.y = Y(n2, Zo, Go), (r3 < t3.x || r3 > t3.x + 1 || n2 < t3.y || n2 > t3.y + 1) && pt("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t3;
        }
        function Ko(t3, e3, r3) {
          const n2 = t3.loadGeometry(), i3 = t3.extent, s4 = To / i3;
          if (e3 && r3 && r3.projection.isReprojectedInTileSpace) {
            const s5 = 1 << e3.z, { scale: a2, x: o2, y: l2, projection: u2 } = r3, c2 = (t4) => {
              const r4 = Ro((e3.x + t4.x / i3) / s5), n3 = Uo((e3.y + t4.y / i3) / s5), c3 = u2.project(r4, n3);
              t4.x = (c3.x * a2 - o2) * i3, t4.y = (c3.y * a2 - l2) * i3;
            };
            for (let e4 = 0; e4 < n2.length; e4++)
              if (t3.type !== 1)
                n2[e4] = No(n2[e4], c2, 1);
              else {
                const t4 = [];
                for (const r4 of n2[e4])
                  r4.x < 0 || r4.x >= i3 || r4.y < 0 || r4.y >= i3 || (c2(r4), t4.push(r4));
                n2[e4] = t4;
              }
          }
          for (const t4 of n2)
            for (const e4 of t4)
              Xo(e4, s4);
          return n2;
        }
        function Yo(t3, e3) {
          return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e3 ? Ko(t3) : [] };
        }
        function Ho(t3, e3, r3, n2, i3) {
          t3.emplaceBack(2 * e3 + (n2 + 1) / 2, 2 * r3 + (i3 + 1) / 2);
        }
        class Jo {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new pa(), this.indexArray = new ka(), this.segments = new Mo(), this.programConfigurations = new xo(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e3, r3, n2) {
            const i3 = this.layers[0], s4 = [];
            let a2 = null;
            i3.type === "circle" && (a2 = i3.layout.get("circle-sort-key"));
            for (const { feature: e4, id: i4, index: o2, sourceLayerIndex: l2 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u2 = Yo(e4, t4);
              if (!this.layers[0]._featureFilter.filter(new Gs(this.zoom), u2, r3))
                continue;
              const c2 = a2 ? a2.evaluate(u2, {}, r3) : void 0, h3 = { id: i4, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t4 ? u2.geometry : Ko(e4, r3, n2), patterns: {}, sortKey: c2 };
              s4.push(h3);
            }
            a2 && s4.sort((t4, e4) => t4.sortKey - e4.sortKey);
            for (const n3 of s4) {
              const { geometry: i4, index: s5, sourceLayerIndex: a3 } = n3, o2 = t3[s5].feature;
              this.addFeature(n3, i4, s5, e3.availableImages, r3), e3.featureIndex.insert(o2, i4, s5, a3, this.index);
            }
          }
          update(t3, e3, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, zo), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t3, e3, r3, n2, i3) {
            for (const r4 of e3)
              for (const e4 of r4) {
                const r5 = e4.x, n3 = e4.y;
                if (r5 < 0 || r5 >= To || n3 < 0 || n3 >= To)
                  continue;
                const i4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), s4 = i4.vertexLength;
                Ho(this.layoutVertexArray, r5, n3, -1, -1), Ho(this.layoutVertexArray, r5, n3, 1, -1), Ho(this.layoutVertexArray, r5, n3, 1, 1), Ho(this.layoutVertexArray, r5, n3, -1, 1), this.indexArray.emplaceBack(s4, s4 + 1, s4 + 2), this.indexArray.emplaceBack(s4, s4 + 3, s4 + 2), i4.vertexLength += 4, i4.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, {}, n2, i3);
          }
        }
        function Wo(t3, e3) {
          for (let r3 = 0; r3 < t3.length; r3++)
            if (ol(e3, t3[r3]))
              return true;
          for (let r3 = 0; r3 < e3.length; r3++)
            if (ol(t3, e3[r3]))
              return true;
          return !!rl(t3, e3);
        }
        function Qo(t3, e3, r3) {
          return !!ol(t3, e3) || !!il(e3, t3, r3);
        }
        function tl(t3, e3) {
          if (t3.length === 1)
            return al(e3, t3[0]);
          for (let r3 = 0; r3 < e3.length; r3++) {
            const n2 = e3[r3];
            for (let e4 = 0; e4 < n2.length; e4++)
              if (ol(t3, n2[e4]))
                return true;
          }
          for (let r3 = 0; r3 < t3.length; r3++)
            if (al(e3, t3[r3]))
              return true;
          for (let r3 = 0; r3 < e3.length; r3++)
            if (rl(t3, e3[r3]))
              return true;
          return false;
        }
        function el(t3, e3, r3) {
          if (t3.length > 1) {
            if (rl(t3, e3))
              return true;
            for (let n2 = 0; n2 < e3.length; n2++)
              if (il(e3[n2], t3, r3))
                return true;
          }
          for (let n2 = 0; n2 < t3.length; n2++)
            if (il(t3[n2], e3, r3))
              return true;
          return false;
        }
        function rl(t3, e3) {
          if (t3.length === 0 || e3.length === 0)
            return false;
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n2 = t3[r3], i3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              if (nl(n2, i3, e3[t4], e3[t4 + 1]))
                return true;
          }
          return false;
        }
        function nl(t3, e3, r3, n2) {
          return dt(t3, r3, n2) !== dt(e3, r3, n2) && dt(t3, e3, r3) !== dt(t3, e3, n2);
        }
        function il(t3, e3, r3) {
          const n2 = r3 * r3;
          if (e3.length === 1)
            return t3.distSqr(e3[0]) < n2;
          for (let r4 = 1; r4 < e3.length; r4++)
            if (sl(t3, e3[r4 - 1], e3[r4]) < n2)
              return true;
          return false;
        }
        function sl(t3, e3, r3) {
          const n2 = e3.distSqr(r3);
          if (n2 === 0)
            return t3.distSqr(e3);
          const i3 = ((t3.x - e3.x) * (r3.x - e3.x) + (t3.y - e3.y) * (r3.y - e3.y)) / n2;
          return t3.distSqr(i3 < 0 ? e3 : i3 > 1 ? r3 : r3.sub(e3)._mult(i3)._add(e3));
        }
        function al(t3, e3) {
          let r3, n2, i3, s4 = false;
          for (let a2 = 0; a2 < t3.length; a2++) {
            r3 = t3[a2];
            for (let t4 = 0, a3 = r3.length - 1; t4 < r3.length; a3 = t4++)
              n2 = r3[t4], i3 = r3[a3], n2.y > e3.y != i3.y > e3.y && e3.x < (i3.x - n2.x) * (e3.y - n2.y) / (i3.y - n2.y) + n2.x && (s4 = !s4);
          }
          return s4;
        }
        function ol(t3, e3) {
          let r3 = false;
          for (let n2 = 0, i3 = t3.length - 1; n2 < t3.length; i3 = n2++) {
            const s4 = t3[n2], a2 = t3[i3];
            s4.y > e3.y != a2.y > e3.y && e3.x < (a2.x - s4.x) * (e3.y - s4.y) / (a2.y - s4.y) + s4.x && (r3 = !r3);
          }
          return r3;
        }
        function ll(t3, e3, r3, n2, s4) {
          for (const i3 of t3)
            if (e3 <= i3.x && r3 <= i3.y && n2 >= i3.x && s4 >= i3.y)
              return true;
          const a2 = [new i2(e3, r3), new i2(e3, s4), new i2(n2, s4), new i2(n2, r3)];
          if (t3.length > 2) {
            for (const e4 of a2)
              if (ol(t3, e4))
                return true;
          }
          for (let e4 = 0; e4 < t3.length - 1; e4++)
            if (ul(t3[e4], t3[e4 + 1], a2))
              return true;
          return false;
        }
        function ul(t3, e3, r3) {
          const n2 = r3[0], i3 = r3[2];
          if (t3.x < n2.x && e3.x < n2.x || t3.x > i3.x && e3.x > i3.x || t3.y < n2.y && e3.y < n2.y || t3.y > i3.y && e3.y > i3.y)
            return false;
          const s4 = dt(t3, e3, r3[0]);
          return s4 !== dt(t3, e3, r3[1]) || s4 !== dt(t3, e3, r3[2]) || s4 !== dt(t3, e3, r3[3]);
        }
        function cl(t3, e3, r3) {
          const n2 = e3.paint.get(t3).value;
          return n2.kind === "constant" ? n2.value : r3.programConfigurations.get(e3.id).getMaxValue(t3);
        }
        function hl(t3) {
          return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
        }
        function pl(t3, e3, r3, n2, s4) {
          if (!e3[0] && !e3[1])
            return t3;
          const a2 = i2.convert(e3)._mult(s4);
          r3 === "viewport" && a2._rotate(-n2);
          const o2 = [];
          for (let e4 = 0; e4 < t3.length; e4++)
            o2.push(t3[e4].sub(a2));
          return o2;
        }
        function dl(t3, e3, r3, n2) {
          const s4 = i2.convert(t3)._mult(n2);
          return e3 === "viewport" && s4._rotate(-r3), s4;
        }
        Zi("CircleBucket", Jo, { omit: ["layers"] });
        const fl = new sa({ "circle-sort-key": new ea(ve.layout_circle["circle-sort-key"]) });
        var yl = { paint: new sa({ "circle-radius": new ea(ve.paint_circle["circle-radius"]), "circle-color": new ea(ve.paint_circle["circle-color"]), "circle-blur": new ea(ve.paint_circle["circle-blur"]), "circle-opacity": new ea(ve.paint_circle["circle-opacity"]), "circle-translate": new ta(ve.paint_circle["circle-translate"]), "circle-translate-anchor": new ta(ve.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ta(ve.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ta(ve.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ea(ve.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ea(ve.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ea(ve.paint_circle["circle-stroke-opacity"]) }), layout: fl };
        class ml {
          constructor(t3, e3) {
            this.points = t3, this.planes = e3;
          }
          static fromInvProjectionMatrix(t3, e3, r3, n2) {
            const i3 = Math.pow(2, r3), s4 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r4) => {
              const s5 = F2([], r4, t3), a3 = 1 / s5[3] / e3 * i3;
              return function(t4, e4, r5) {
                return t4[0] = e4[0] * r5[0], t4[1] = e4[1] * r5[1], t4[2] = e4[2] * r5[2], t4[3] = e4[3] * r5[3], t4;
              }(s5, s5, [a3, a3, n2 ? 1 / s5[3] : a3, a3]);
            }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t4) => {
              const e4 = z([], T([], E([], s4[t4[0]], s4[t4[1]]), E([], s4[t4[2]], s4[t4[1]]))), r4 = -M(e4, s4[t4[1]]);
              return e4.concat(r4);
            });
            return new ml(s4, a2);
          }
        }
        class gl {
          constructor(t3, e3) {
            this.min = t3, this.max = e3, this.center = S2([], w([], this.min, this.max), 0.5);
          }
          quadrant(t3) {
            const e3 = [t3 % 2 == 0, t3 < 2], r3 = x2(this.min), n2 = x2(this.max);
            for (let t4 = 0; t4 < e3.length; t4++)
              r3[t4] = e3[t4] ? this.min[t4] : this.center[t4], n2[t4] = e3[t4] ? this.center[t4] : this.max[t4];
            return n2[2] = this.max[2], new gl(r3, n2);
          }
          distanceX(t3) {
            return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
          }
          distanceY(t3) {
            return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
          }
          distanceZ(t3) {
            return Math.max(Math.min(this.max[2], t3[2]), this.min[2]) - t3[2];
          }
          getCorners() {
            const t3 = this.min, e3 = this.max;
            return [[t3[0], t3[1], t3[2]], [e3[0], t3[1], t3[2]], [e3[0], e3[1], t3[2]], [t3[0], e3[1], t3[2]], [t3[0], t3[1], e3[2]], [e3[0], t3[1], e3[2]], [e3[0], e3[1], e3[2]], [t3[0], e3[1], e3[2]]];
          }
          intersects(t3) {
            const e3 = this.getCorners();
            let r3 = true;
            for (let n2 = 0; n2 < t3.planes.length; n2++) {
              const i3 = t3.planes[n2];
              let s4 = 0;
              for (let t4 = 0; t4 < e3.length; t4++)
                s4 += M(i3, e3[t4]) + i3[3] >= 0;
              if (s4 === 0)
                return 0;
              s4 !== e3.length && (r3 = false);
            }
            if (r3)
              return 2;
            for (let e4 = 0; e4 < 3; e4++) {
              let r4 = Number.MAX_VALUE, n2 = -Number.MAX_VALUE;
              for (let i3 = 0; i3 < t3.points.length; i3++) {
                const s4 = t3.points[i3][e4] - this.min[e4];
                r4 = Math.min(r4, s4), n2 = Math.max(n2, s4);
              }
              if (n2 < 0 || r4 > this.max[e4] - this.min[e4])
                return 0;
            }
            return 1;
          }
        }
        function xl(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
          if (s4 && t3.queryGeometry.isAboveHorizon)
            return false;
          s4 && (l2 *= t3.pixelToTileUnitsFactor);
          for (const u2 of e3)
            for (const e4 of u2) {
              const u3 = e4.add(o2), c2 = i3 && r3.elevation ? r3.elevation.exaggeration() * i3.getElevationAt(u3.x, u3.y, true) : 0, h3 = s4 ? u3 : vl(u3, c2, n2), p2 = s4 ? t3.tilespaceRays.map((t4) => _l(t4, c2)) : t3.queryGeometry.screenGeometry, d2 = F2([], [e4.x, e4.y, c2, 1], n2);
              if (!a2 && s4 ? l2 *= d2[3] / r3.cameraToCenterDistance : a2 && !s4 && (l2 *= r3.cameraToCenterDistance / d2[3]), Qo(p2, h3, l2))
                return true;
            }
          return false;
        }
        function vl(t3, e3, r3) {
          const n2 = F2([], [t3.x, t3.y, e3, 1], r3);
          return new i2(n2[0] / n2[3], n2[1] / n2[3]);
        }
        const bl = b(0, 0, 0), wl = b(0, 0, 1);
        function _l(t3, e3) {
          const r3 = g();
          return bl[2] = e3, t3.intersectsPlane(bl, wl, r3), new i2(r3[0], r3[1]);
        }
        class Al extends Jo {
        }
        function kl(t3, { width: e3, height: r3 }, n2, i3) {
          if (i3) {
            if (i3 instanceof Uint8ClampedArray)
              i3 = new Uint8Array(i3.buffer);
            else if (i3.length !== e3 * r3 * n2)
              throw new RangeError("mismatched image size");
          } else
            i3 = new Uint8Array(e3 * r3 * n2);
          return t3.width = e3, t3.height = r3, t3.data = i3, t3;
        }
        function Sl(t3, { width: e3, height: r3 }, n2) {
          if (e3 === t3.width && r3 === t3.height)
            return;
          const i3 = kl({}, { width: e3, height: r3 }, n2);
          Il(t3, i3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, e3), height: Math.min(t3.height, r3) }, n2), t3.width = e3, t3.height = r3, t3.data = i3.data;
        }
        function Il(t3, e3, r3, n2, i3, s4) {
          if (i3.width === 0 || i3.height === 0)
            return e3;
          if (i3.width > t3.width || i3.height > t3.height || r3.x > t3.width - i3.width || r3.y > t3.height - i3.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i3.width > e3.width || i3.height > e3.height || n2.x > e3.width - i3.width || n2.y > e3.height - i3.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t3.data, o2 = e3.data;
          for (let l2 = 0; l2 < i3.height; l2++) {
            const u2 = ((r3.y + l2) * t3.width + r3.x) * s4, c2 = ((n2.y + l2) * e3.width + n2.x) * s4;
            for (let t4 = 0; t4 < i3.width * s4; t4++)
              o2[c2 + t4] = a2[u2 + t4];
          }
          return e3;
        }
        Zi("HeatmapBucket", Al, { omit: ["layers"] });
        class zl {
          constructor(t3, e3) {
            kl(this, t3, 1, e3);
          }
          resize(t3) {
            Sl(this, t3, 1);
          }
          clone() {
            return new zl({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e3, r3, n2, i3) {
            Il(t3, e3, r3, n2, i3, 1);
          }
        }
        class Ml {
          constructor(t3, e3) {
            kl(this, t3, 4, e3);
          }
          resize(t3) {
            Sl(this, t3, 4);
          }
          replace(t3, e3) {
            e3 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
          }
          clone() {
            return new Ml({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e3, r3, n2, i3) {
            Il(t3, e3, r3, n2, i3, 4);
          }
        }
        Zi("AlphaImage", zl), Zi("RGBAImage", Ml);
        var Tl = { paint: new sa({ "heatmap-radius": new ea(ve.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ea(ve.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ta(ve.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ia(ve.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ta(ve.paint_heatmap["heatmap-opacity"]) }) };
        function Bl(t3) {
          const e3 = {}, r3 = t3.resolution || 256, n2 = t3.clips ? t3.clips.length : 1, i3 = t3.image || new Ml({ width: r3, height: n2 }), s4 = (r4, n3, s5) => {
            e3[t3.evaluationKey] = s5;
            const a2 = t3.expression.evaluate(e3);
            i3.data[r4 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i3.data[r4 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i3.data[r4 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i3.data[r4 + n3 + 3] = Math.floor(255 * a2.a);
          };
          if (t3.clips)
            for (let e4 = 0, i4 = 0; e4 < n2; ++e4, i4 += 4 * r3)
              for (let n3 = 0, a2 = 0; n3 < r3; n3++, a2 += 4) {
                const o2 = n3 / (r3 - 1), { start: l2, end: u2 } = t3.clips[e4];
                s4(i4, a2, l2 * (1 - o2) + u2 * o2);
              }
          else
            for (let t4 = 0, e4 = 0; t4 < r3; t4++, e4 += 4)
              s4(0, e4, t4 / (r3 - 1));
          return i3;
        }
        var Cl = { paint: new sa({ "hillshade-illumination-direction": new ta(ve.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ta(ve.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ta(ve.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ta(ve.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ta(ve.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ta(ve.paint_hillshade["hillshade-accent-color"]) }) };
        const Pl = ca([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: El } = Pl;
        var Dl = Fl, Vl = Fl;
        function Fl(t3, e3, r3) {
          r3 = r3 || 2;
          var n2, i3, s4, a2, o2, l2, u2, c2 = e3 && e3.length, h3 = c2 ? e3[0] * r3 : t3.length, p2 = Ll(t3, 0, h3, r3, true), d2 = [];
          if (!p2 || p2.next === p2.prev)
            return d2;
          if (c2 && (p2 = function(t4, e4, r4, n3) {
            var i4, s5, a3, o3 = [];
            for (i4 = 0, s5 = e4.length; i4 < s5; i4++)
              (a3 = Ll(t4, e4[i4] * n3, i4 < s5 - 1 ? e4[i4 + 1] * n3 : t4.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(Kl(a3));
            for (o3.sort(Nl), i4 = 0; i4 < o3.length; i4++)
              r4 = Rl(r4 = Gl(o3[i4], r4), r4.next);
            return r4;
          }(t3, e3, p2, r3)), t3.length > 80 * r3) {
            n2 = s4 = t3[0], i3 = a2 = t3[1];
            for (var f4 = r3; f4 < h3; f4 += r3)
              (o2 = t3[f4]) < n2 && (n2 = o2), (l2 = t3[f4 + 1]) < i3 && (i3 = l2), o2 > s4 && (s4 = o2), l2 > a2 && (a2 = l2);
            u2 = (u2 = Math.max(s4 - n2, a2 - i3)) !== 0 ? 1 / u2 : 0;
          }
          return Ul(p2, d2, r3, n2, i3, u2), d2;
        }
        function Ll(t3, e3, r3, n2, i3) {
          var s4, a2;
          if (i3 === ou(t3, e3, r3, n2) > 0)
            for (s4 = e3; s4 < r3; s4 += n2)
              a2 = iu(s4, t3[s4], t3[s4 + 1], a2);
          else
            for (s4 = r3 - n2; s4 >= e3; s4 -= n2)
              a2 = iu(s4, t3[s4], t3[s4 + 1], a2);
          return a2 && Wl(a2, a2.next) && (su(a2), a2 = a2.next), a2;
        }
        function Rl(t3, e3) {
          if (!t3)
            return t3;
          e3 || (e3 = t3);
          var r3, n2 = t3;
          do {
            if (r3 = false, n2.steiner || !Wl(n2, n2.next) && Jl(n2.prev, n2, n2.next) !== 0)
              n2 = n2.next;
            else {
              if (su(n2), (n2 = e3 = n2.prev) === n2.next)
                break;
              r3 = true;
            }
          } while (r3 || n2 !== e3);
          return e3;
        }
        function Ul(t3, e3, r3, n2, i3, s4, a2) {
          if (t3) {
            !a2 && s4 && function(t4, e4, r4, n3) {
              var i4 = t4;
              do {
                i4.z === null && (i4.z = Xl(i4.x, i4.y, e4, r4, n3)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t4);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
                var e5, r5, n4, i5, s5, a3, o3, l3, u3 = 1;
                do {
                  for (r5 = t5, t5 = null, s5 = null, a3 = 0; r5; ) {
                    for (a3++, n4 = r5, o3 = 0, e5 = 0; e5 < u3 && (o3++, n4 = n4.nextZ); e5++)
                      ;
                    for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                      o3 !== 0 && (l3 === 0 || !n4 || r5.z <= n4.z) ? (i5 = r5, r5 = r5.nextZ, o3--) : (i5 = n4, n4 = n4.nextZ, l3--), s5 ? s5.nextZ = i5 : t5 = i5, i5.prevZ = s5, s5 = i5;
                    r5 = n4;
                  }
                  s5.nextZ = null, u3 *= 2;
                } while (a3 > 1);
              }(i4);
            }(t3, n2, i3, s4);
            for (var o2, l2, u2 = t3; t3.prev !== t3.next; )
              if (o2 = t3.prev, l2 = t3.next, s4 ? Ol(t3, n2, i3, s4) : $l(t3))
                e3.push(o2.i / r3), e3.push(t3.i / r3), e3.push(l2.i / r3), su(t3), t3 = l2.next, u2 = l2.next;
              else if ((t3 = l2) === u2) {
                a2 ? a2 === 1 ? Ul(t3 = jl(Rl(t3), e3, r3), e3, r3, n2, i3, s4, 2) : a2 === 2 && ql(t3, e3, r3, n2, i3, s4) : Ul(Rl(t3), e3, r3, n2, i3, s4, 1);
                break;
              }
          }
        }
        function $l(t3) {
          var e3 = t3.prev, r3 = t3, n2 = t3.next;
          if (Jl(e3, r3, n2) >= 0)
            return false;
          for (var i3 = t3.next.next; i3 !== t3.prev; ) {
            if (Yl(e3.x, e3.y, r3.x, r3.y, n2.x, n2.y, i3.x, i3.y) && Jl(i3.prev, i3, i3.next) >= 0)
              return false;
            i3 = i3.next;
          }
          return true;
        }
        function Ol(t3, e3, r3, n2) {
          var i3 = t3.prev, s4 = t3, a2 = t3.next;
          if (Jl(i3, s4, a2) >= 0)
            return false;
          for (var o2 = i3.x > s4.x ? i3.x > a2.x ? i3.x : a2.x : s4.x > a2.x ? s4.x : a2.x, l2 = i3.y > s4.y ? i3.y > a2.y ? i3.y : a2.y : s4.y > a2.y ? s4.y : a2.y, u2 = Xl(i3.x < s4.x ? i3.x < a2.x ? i3.x : a2.x : s4.x < a2.x ? s4.x : a2.x, i3.y < s4.y ? i3.y < a2.y ? i3.y : a2.y : s4.y < a2.y ? s4.y : a2.y, e3, r3, n2), c2 = Xl(o2, l2, e3, r3, n2), h3 = t3.prevZ, p2 = t3.nextZ; h3 && h3.z >= u2 && p2 && p2.z <= c2; ) {
            if (h3 !== t3.prev && h3 !== t3.next && Yl(i3.x, i3.y, s4.x, s4.y, a2.x, a2.y, h3.x, h3.y) && Jl(h3.prev, h3, h3.next) >= 0)
              return false;
            if (h3 = h3.prevZ, p2 !== t3.prev && p2 !== t3.next && Yl(i3.x, i3.y, s4.x, s4.y, a2.x, a2.y, p2.x, p2.y) && Jl(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.nextZ;
          }
          for (; h3 && h3.z >= u2; ) {
            if (h3 !== t3.prev && h3 !== t3.next && Yl(i3.x, i3.y, s4.x, s4.y, a2.x, a2.y, h3.x, h3.y) && Jl(h3.prev, h3, h3.next) >= 0)
              return false;
            h3 = h3.prevZ;
          }
          for (; p2 && p2.z <= c2; ) {
            if (p2 !== t3.prev && p2 !== t3.next && Yl(i3.x, i3.y, s4.x, s4.y, a2.x, a2.y, p2.x, p2.y) && Jl(p2.prev, p2, p2.next) >= 0)
              return false;
            p2 = p2.nextZ;
          }
          return true;
        }
        function jl(t3, e3, r3) {
          var n2 = t3;
          do {
            var i3 = n2.prev, s4 = n2.next.next;
            !Wl(i3, s4) && Ql(i3, n2, n2.next, s4) && ru(i3, s4) && ru(s4, i3) && (e3.push(i3.i / r3), e3.push(n2.i / r3), e3.push(s4.i / r3), su(n2), su(n2.next), n2 = t3 = s4), n2 = n2.next;
          } while (n2 !== t3);
          return Rl(n2);
        }
        function ql(t3, e3, r3, n2, i3, s4) {
          var a2 = t3;
          do {
            for (var o2 = a2.next.next; o2 !== a2.prev; ) {
              if (a2.i !== o2.i && Hl(a2, o2)) {
                var l2 = nu(a2, o2);
                return a2 = Rl(a2, a2.next), l2 = Rl(l2, l2.next), Ul(a2, e3, r3, n2, i3, s4), void Ul(l2, e3, r3, n2, i3, s4);
              }
              o2 = o2.next;
            }
            a2 = a2.next;
          } while (a2 !== t3);
        }
        function Nl(t3, e3) {
          return t3.x - e3.x;
        }
        function Gl(t3, e3) {
          var r3 = function(t4, e4) {
            var r4, n3 = e4, i4 = t4.x, s4 = t4.y, a2 = -1 / 0;
            do {
              if (s4 <= n3.y && s4 >= n3.next.y && n3.next.y !== n3.y) {
                var o2 = n3.x + (s4 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (o2 <= i4 && o2 > a2) {
                  if (a2 = o2, o2 === i4) {
                    if (s4 === n3.y)
                      return n3;
                    if (s4 === n3.next.y)
                      return n3.next;
                  }
                  r4 = n3.x < n3.next.x ? n3 : n3.next;
                }
              }
              n3 = n3.next;
            } while (n3 !== e4);
            if (!r4)
              return null;
            if (i4 === a2)
              return r4;
            var l2, u2 = r4, c2 = r4.x, h3 = r4.y, p2 = 1 / 0;
            n3 = r4;
            do {
              i4 >= n3.x && n3.x >= c2 && i4 !== n3.x && Yl(s4 < h3 ? i4 : a2, s4, c2, h3, s4 < h3 ? a2 : i4, s4, n3.x, n3.y) && (l2 = Math.abs(s4 - n3.y) / (i4 - n3.x), ru(n3, t4) && (l2 < p2 || l2 === p2 && (n3.x > r4.x || n3.x === r4.x && Zl(r4, n3))) && (r4 = n3, p2 = l2)), n3 = n3.next;
            } while (n3 !== u2);
            return r4;
          }(t3, e3);
          if (!r3)
            return e3;
          var n2 = nu(r3, t3), i3 = Rl(r3, r3.next);
          return Rl(n2, n2.next), e3 === r3 ? i3 : e3;
        }
        function Zl(t3, e3) {
          return Jl(t3.prev, t3, e3.prev) < 0 && Jl(e3.next, t3, t3.next) < 0;
        }
        function Xl(t3, e3, r3, n2, i3) {
          return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = 32767 * (t3 - r3) * i3) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = 32767 * (e3 - n2) * i3) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
        }
        function Kl(t3) {
          var e3 = t3, r3 = t3;
          do {
            (e3.x < r3.x || e3.x === r3.x && e3.y < r3.y) && (r3 = e3), e3 = e3.next;
          } while (e3 !== t3);
          return r3;
        }
        function Yl(t3, e3, r3, n2, i3, s4, a2, o2) {
          return (i3 - a2) * (e3 - o2) - (t3 - a2) * (s4 - o2) >= 0 && (t3 - a2) * (n2 - o2) - (r3 - a2) * (e3 - o2) >= 0 && (r3 - a2) * (s4 - o2) - (i3 - a2) * (n2 - o2) >= 0;
        }
        function Hl(t3, e3) {
          return t3.next.i !== e3.i && t3.prev.i !== e3.i && !function(t4, e4) {
            var r3 = t4;
            do {
              if (r3.i !== t4.i && r3.next.i !== t4.i && r3.i !== e4.i && r3.next.i !== e4.i && Ql(r3, r3.next, t4, e4))
                return true;
              r3 = r3.next;
            } while (r3 !== t4);
            return false;
          }(t3, e3) && (ru(t3, e3) && ru(e3, t3) && function(t4, e4) {
            var r3 = t4, n2 = false, i3 = (t4.x + e4.x) / 2, s4 = (t4.y + e4.y) / 2;
            do {
              r3.y > s4 != r3.next.y > s4 && r3.next.y !== r3.y && i3 < (r3.next.x - r3.x) * (s4 - r3.y) / (r3.next.y - r3.y) + r3.x && (n2 = !n2), r3 = r3.next;
            } while (r3 !== t4);
            return n2;
          }(t3, e3) && (Jl(t3.prev, t3, e3.prev) || Jl(t3, e3.prev, e3)) || Wl(t3, e3) && Jl(t3.prev, t3, t3.next) > 0 && Jl(e3.prev, e3, e3.next) > 0);
        }
        function Jl(t3, e3, r3) {
          return (e3.y - t3.y) * (r3.x - e3.x) - (e3.x - t3.x) * (r3.y - e3.y);
        }
        function Wl(t3, e3) {
          return t3.x === e3.x && t3.y === e3.y;
        }
        function Ql(t3, e3, r3, n2) {
          var i3 = eu(Jl(t3, e3, r3)), s4 = eu(Jl(t3, e3, n2)), a2 = eu(Jl(r3, n2, t3)), o2 = eu(Jl(r3, n2, e3));
          return i3 !== s4 && a2 !== o2 || !(i3 !== 0 || !tu(t3, r3, e3)) || !(s4 !== 0 || !tu(t3, n2, e3)) || !(a2 !== 0 || !tu(r3, t3, n2)) || !(o2 !== 0 || !tu(r3, e3, n2));
        }
        function tu(t3, e3, r3) {
          return e3.x <= Math.max(t3.x, r3.x) && e3.x >= Math.min(t3.x, r3.x) && e3.y <= Math.max(t3.y, r3.y) && e3.y >= Math.min(t3.y, r3.y);
        }
        function eu(t3) {
          return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
        }
        function ru(t3, e3) {
          return Jl(t3.prev, t3, t3.next) < 0 ? Jl(t3, e3, t3.next) >= 0 && Jl(t3, t3.prev, e3) >= 0 : Jl(t3, e3, t3.prev) < 0 || Jl(t3, t3.next, e3) < 0;
        }
        function nu(t3, e3) {
          var r3 = new au(t3.i, t3.x, t3.y), n2 = new au(e3.i, e3.x, e3.y), i3 = t3.next, s4 = e3.prev;
          return t3.next = e3, e3.prev = t3, r3.next = i3, i3.prev = r3, n2.next = r3, r3.prev = n2, s4.next = n2, n2.prev = s4, n2;
        }
        function iu(t3, e3, r3, n2) {
          var i3 = new au(t3, e3, r3);
          return n2 ? (i3.next = n2.next, i3.prev = n2, n2.next.prev = i3, n2.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function su(t3) {
          t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
        }
        function au(t3, e3, r3) {
          this.i = t3, this.x = e3, this.y = r3, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function ou(t3, e3, r3, n2) {
          for (var i3 = 0, s4 = e3, a2 = r3 - n2; s4 < r3; s4 += n2)
            i3 += (t3[a2] - t3[s4]) * (t3[s4 + 1] + t3[a2 + 1]), a2 = s4;
          return i3;
        }
        function lu(t3, e3, r3, n2, i3) {
          uu(t3, e3, r3 || 0, n2 || t3.length - 1, i3 || hu);
        }
        function uu(t3, e3, r3, n2, i3) {
          for (; n2 > r3; ) {
            if (n2 - r3 > 600) {
              var s4 = n2 - r3 + 1, a2 = e3 - r3 + 1, o2 = Math.log(s4), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s4 - l2) / s4) * (a2 - s4 / 2 < 0 ? -1 : 1);
              uu(t3, e3, Math.max(r3, Math.floor(e3 - a2 * l2 / s4 + u2)), Math.min(n2, Math.floor(e3 + (s4 - a2) * l2 / s4 + u2)), i3);
            }
            var c2 = t3[e3], h3 = r3, p2 = n2;
            for (cu(t3, r3, e3), i3(t3[n2], c2) > 0 && cu(t3, r3, n2); h3 < p2; ) {
              for (cu(t3, h3, p2), h3++, p2--; i3(t3[h3], c2) < 0; )
                h3++;
              for (; i3(t3[p2], c2) > 0; )
                p2--;
            }
            i3(t3[r3], c2) === 0 ? cu(t3, r3, p2) : cu(t3, ++p2, n2), p2 <= e3 && (r3 = p2 + 1), e3 <= p2 && (n2 = p2 - 1);
          }
        }
        function cu(t3, e3, r3) {
          var n2 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n2;
        }
        function hu(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        function pu(t3, e3) {
          const r3 = t3.length;
          if (r3 <= 1)
            return [t3];
          const n2 = [];
          let i3, s4;
          for (let e4 = 0; e4 < r3; e4++) {
            const r4 = ft(t3[e4]);
            r4 !== 0 && (t3[e4].area = Math.abs(r4), s4 === void 0 && (s4 = r4 < 0), s4 === r4 < 0 ? (i3 && n2.push(i3), i3 = [t3[e4]]) : i3.push(t3[e4]));
          }
          if (i3 && n2.push(i3), e3 > 1)
            for (let t4 = 0; t4 < n2.length; t4++)
              n2[t4].length <= e3 || (lu(n2[t4], e3, 1, n2[t4].length - 1, du), n2[t4] = n2[t4].slice(0, e3));
          return n2;
        }
        function du(t3, e3) {
          return e3.area - t3.area;
        }
        function fu(t3, e3, r3) {
          const n2 = r3.patternDependencies;
          let i3 = false;
          for (const r4 of e3) {
            const e4 = r4.paint.get(`${t3}-pattern`);
            e4.isConstant() || (i3 = true);
            const s4 = e4.constantOr(null);
            s4 && (i3 = true, n2[s4.to] = true, n2[s4.from] = true);
          }
          return i3;
        }
        function yu(t3, e3, r3, n2, i3) {
          const s4 = i3.patternDependencies;
          for (const a2 of e3) {
            const e4 = a2.paint.get(`${t3}-pattern`).value;
            if (e4.kind !== "constant") {
              let t4 = e4.evaluate({ zoom: n2 - 1 }, r3, {}, i3.availableImages), o2 = e4.evaluate({ zoom: n2 }, r3, {}, i3.availableImages), l2 = e4.evaluate({ zoom: n2 + 1 }, r3, {}, i3.availableImages);
              t4 = t4 && t4.name ? t4.name : t4, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s4[t4] = true, s4[o2] = true, s4[l2] = true, r3.patterns[a2.id] = { min: t4, mid: o2, max: l2 };
            }
          }
          return r3;
        }
        Fl.deviation = function(t3, e3, r3, n2) {
          var i3 = e3 && e3.length, s4 = Math.abs(ou(t3, 0, i3 ? e3[0] * r3 : t3.length, r3));
          if (i3)
            for (var a2 = 0, o2 = e3.length; a2 < o2; a2++)
              s4 -= Math.abs(ou(t3, e3[a2] * r3, a2 < o2 - 1 ? e3[a2 + 1] * r3 : t3.length, r3));
          var l2 = 0;
          for (a2 = 0; a2 < n2.length; a2 += 3) {
            var u2 = n2[a2] * r3, c2 = n2[a2 + 1] * r3, h3 = n2[a2 + 2] * r3;
            l2 += Math.abs((t3[u2] - t3[h3]) * (t3[c2 + 1] - t3[u2 + 1]) - (t3[u2] - t3[c2]) * (t3[h3 + 1] - t3[u2 + 1]));
          }
          return s4 === 0 && l2 === 0 ? 0 : Math.abs((l2 - s4) / s4);
        }, Fl.flatten = function(t3) {
          for (var e3 = t3[0][0].length, r3 = { vertices: [], holes: [], dimensions: e3 }, n2 = 0, i3 = 0; i3 < t3.length; i3++) {
            for (var s4 = 0; s4 < t3[i3].length; s4++)
              for (var a2 = 0; a2 < e3; a2++)
                r3.vertices.push(t3[i3][s4][a2]);
            i3 > 0 && r3.holes.push(n2 += t3[i3 - 1].length);
          }
          return r3;
        }, Dl.default = Vl;
        class mu {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new pa(), this.indexArray = new ka(), this.indexArray2 = new Ca(), this.programConfigurations = new xo(t3.layers, t3.zoom), this.segments = new Mo(), this.segments2 = new Mo(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e3, r3, n2) {
            this.hasPattern = fu("fill", this.layers, e3);
            const i3 = this.layers[0].layout.get("fill-sort-key"), s4 = [];
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, c2 = Yo(a2, t4);
              if (!this.layers[0]._featureFilter.filter(new Gs(this.zoom), c2, r3))
                continue;
              const h3 = i3 ? i3.evaluate(c2, {}, r3, e3.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t4 ? c2.geometry : Ko(a2, r3, n2), patterns: {}, sortKey: h3 };
              s4.push(p2);
            }
            i3 && s4.sort((t4, e4) => t4.sortKey - e4.sortKey);
            for (const n3 of s4) {
              const { geometry: i4, index: s5, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t4 = yu("fill", this.layers, n3, this.zoom, e3);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n3, i4, s5, r3, {}, e3.availableImages);
              e3.featureIndex.insert(t3[s5].feature, i4, s5, a2, this.index);
            }
          }
          update(t3, e3, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n2);
          }
          addFeatures(t3, e3, r3, n2) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e3, r3, n2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, El), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t3, e3, r3, n2, i3, s4 = []) {
            for (const t4 of pu(e3, 500)) {
              let e4 = 0;
              for (const r5 of t4)
                e4 += r5.length;
              const r4 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray), n3 = r4.vertexLength, i4 = [], s5 = [];
              for (const e5 of t4) {
                if (e5.length === 0)
                  continue;
                e5 !== t4[0] && s5.push(i4.length / 2);
                const r5 = this.segments2.prepareSegment(e5.length, this.layoutVertexArray, this.indexArray2), n4 = r5.vertexLength;
                this.layoutVertexArray.emplaceBack(e5[0].x, e5[0].y), this.indexArray2.emplaceBack(n4 + e5.length - 1, n4), i4.push(e5[0].x), i4.push(e5[0].y);
                for (let t5 = 1; t5 < e5.length; t5++)
                  this.layoutVertexArray.emplaceBack(e5[t5].x, e5[t5].y), this.indexArray2.emplaceBack(n4 + t5 - 1, n4 + t5), i4.push(e5[t5].x), i4.push(e5[t5].y);
                r5.vertexLength += e5.length, r5.primitiveLength += e5.length;
              }
              const a2 = Dl(i4, s5);
              for (let t5 = 0; t5 < a2.length; t5 += 3)
                this.indexArray.emplaceBack(n3 + a2[t5], n3 + a2[t5 + 1], n3 + a2[t5 + 2]);
              r4.vertexLength += e4, r4.primitiveLength += a2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, s4, n2);
          }
        }
        Zi("FillBucket", mu, { omit: ["layers", "patternFeatures"] });
        const gu = new sa({ "fill-sort-key": new ea(ve.layout_fill["fill-sort-key"]) });
        var xu = { paint: new sa({ "fill-antialias": new ta(ve.paint_fill["fill-antialias"]), "fill-opacity": new ea(ve.paint_fill["fill-opacity"]), "fill-color": new ea(ve.paint_fill["fill-color"]), "fill-outline-color": new ea(ve.paint_fill["fill-outline-color"]), "fill-translate": new ta(ve.paint_fill["fill-translate"]), "fill-translate-anchor": new ta(ve.paint_fill["fill-translate-anchor"]), "fill-pattern": new ra(ve.paint_fill["fill-pattern"]) }), layout: gu };
        const vu = ca([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), bu = ca([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), { members: wu } = vu;
        var _u = Au;
        function Au(t3, e3, r3, n2, i3) {
          this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n2, this._values = i3, t3.readFields(ku, this, e3);
        }
        function ku(t3, e3, r3) {
          t3 == 1 ? e3.id = r3.readVarint() : t3 == 2 ? function(t4, e4) {
            for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n2 = e4._keys[t4.readVarint()], i3 = e4._values[t4.readVarint()];
              e4.properties[n2] = i3;
            }
          }(r3, e3) : t3 == 3 ? e3.type = r3.readVarint() : t3 == 4 && (e3._geometry = r3.pos);
        }
        function Su(t3) {
          for (var e3, r3, n2 = 0, i3 = 0, s4 = t3.length, a2 = s4 - 1; i3 < s4; a2 = i3++)
            n2 += ((r3 = t3[a2]).x - (e3 = t3[i3]).x) * (e3.y + r3.y);
          return n2;
        }
        Au.types = ["Unknown", "Point", "LineString", "Polygon"], Au.prototype.loadGeometry = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3, r3 = t3.readVarint() + t3.pos, n2 = 1, s4 = 0, a2 = 0, o2 = 0, l2 = []; t3.pos < r3; ) {
            if (s4 <= 0) {
              var u2 = t3.readVarint();
              n2 = 7 & u2, s4 = u2 >> 3;
            }
            if (s4--, n2 === 1 || n2 === 2)
              a2 += t3.readSVarint(), o2 += t3.readSVarint(), n2 === 1 && (e3 && l2.push(e3), e3 = []), e3.push(new i2(a2, o2));
            else {
              if (n2 !== 7)
                throw new Error("unknown command " + n2);
              e3 && e3.push(e3[0].clone());
            }
          }
          return e3 && l2.push(e3), l2;
        }, Au.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n2 = 0, i3 = 0, s4 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t3.pos < e3; ) {
            if (n2 <= 0) {
              var c2 = t3.readVarint();
              r3 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, r3 === 1 || r3 === 2)
              (i3 += t3.readSVarint()) < a2 && (a2 = i3), i3 > o2 && (o2 = i3), (s4 += t3.readSVarint()) < l2 && (l2 = s4), s4 > u2 && (u2 = s4);
            else if (r3 !== 7)
              throw new Error("unknown command " + r3);
          }
          return [a2, l2, o2, u2];
        }, Au.prototype.toGeoJSON = function(t3, e3, r3) {
          var n2, i3, s4 = this.extent * Math.pow(2, r3), a2 = this.extent * t3, o2 = this.extent * e3, l2 = this.loadGeometry(), u2 = Au.types[this.type];
          function c2(t4) {
            for (var e4 = 0; e4 < t4.length; e4++) {
              var r4 = t4[e4];
              t4[e4] = [360 * (r4.x + a2) / s4 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o2) / s4) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h3 = [];
              for (n2 = 0; n2 < l2.length; n2++)
                h3[n2] = l2[n2][0];
              c2(l2 = h3);
              break;
            case 2:
              for (n2 = 0; n2 < l2.length; n2++)
                c2(l2[n2]);
              break;
            case 3:
              for (l2 = function(t4) {
                var e4 = t4.length;
                if (e4 <= 1)
                  return [t4];
                for (var r4, n3, i4 = [], s5 = 0; s5 < e4; s5++) {
                  var a3 = Su(t4[s5]);
                  a3 !== 0 && (n3 === void 0 && (n3 = a3 < 0), n3 === a3 < 0 ? (r4 && i4.push(r4), r4 = [t4[s5]]) : r4.push(t4[s5]));
                }
                return r4 && i4.push(r4), i4;
              }(l2), n2 = 0; n2 < l2.length; n2++)
                for (i3 = 0; i3 < l2[n2].length; i3++)
                  c2(l2[n2][i3]);
          }
          l2.length === 1 ? l2 = l2[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var Iu = zu;
        function zu(t3, e3) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(Mu, this, e3), this.length = this._features.length;
        }
        function Mu(t3, e3, r3) {
          t3 === 15 ? e3.version = r3.readVarint() : t3 === 1 ? e3.name = r3.readString() : t3 === 5 ? e3.extent = r3.readVarint() : t3 === 2 ? e3._features.push(r3.pos) : t3 === 3 ? e3._keys.push(r3.readString()) : t3 === 4 && e3._values.push(function(t4) {
            for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n2 = t4.readVarint() >> 3;
              e4 = n2 === 1 ? t4.readString() : n2 === 2 ? t4.readFloat() : n2 === 3 ? t4.readDouble() : n2 === 4 ? t4.readVarint64() : n2 === 5 ? t4.readVarint() : n2 === 6 ? t4.readSVarint() : n2 === 7 ? t4.readBoolean() : null;
            }
            return e4;
          }(r3));
        }
        function Tu(t3, e3, r3) {
          if (t3 === 3) {
            var n2 = new Iu(r3, r3.readVarint() + r3.pos);
            n2.length && (e3[n2.name] = n2);
          }
        }
        zu.prototype.feature = function(t3) {
          if (t3 < 0 || t3 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t3];
          var e3 = this._pbf.readVarint() + this._pbf.pos;
          return new _u(this._pbf, e3, this.extent, this._keys, this._values);
        };
        var Bu = { VectorTile: function(t3, e3) {
          this.layers = t3.readFields(Tu, {}, e3);
        }, VectorTileFeature: _u, VectorTileLayer: Iu };
        const Cu = Bu.VectorTileFeature.types, Pu = Math.pow(2, 13);
        function Eu(t3, e3, r3, n2, i3, s4, a2, o2) {
          t3.emplaceBack((e3 << 1) + a2, (r3 << 1) + s4, (Math.floor(n2 * Pu) << 1) + i3, Math.round(o2));
        }
        class Du {
          constructor() {
            this.acc = new i2(0, 0), this.polyCount = [];
          }
          startRing(t3) {
            this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new i2(t3.x, t3.y), this.max = new i2(t3.x, t3.y));
          }
          append(t3, e3) {
            this.currentPolyCount.edges++, this.acc._add(t3);
            let r3 = !!this.borders;
            const n2 = this.min, i3 = this.max;
            t3.x < n2.x ? (n2.x = t3.x, r3 = true) : t3.x > i3.x && (i3.x = t3.x, r3 = true), t3.y < n2.y ? (n2.y = t3.y, r3 = true) : t3.y > i3.y && (i3.y = t3.y, r3 = true), ((t3.x === 0 || t3.x === To) && t3.x === e3.x) != ((t3.y === 0 || t3.y === To) && t3.y === e3.y) && this.processBorderOverlap(t3, e3), r3 && this.checkBorderIntersection(t3, e3);
          }
          checkBorderIntersection(t3, e3) {
            e3.x < 0 != t3.x < 0 && this.addBorderIntersection(0, Lr(e3.y, t3.y, (0 - e3.x) / (t3.x - e3.x))), e3.x > To != t3.x > To && this.addBorderIntersection(1, Lr(e3.y, t3.y, (To - e3.x) / (t3.x - e3.x))), e3.y < 0 != t3.y < 0 && this.addBorderIntersection(2, Lr(e3.x, t3.x, (0 - e3.y) / (t3.y - e3.y))), e3.y > To != t3.y > To && this.addBorderIntersection(3, Lr(e3.x, t3.x, (To - e3.y) / (t3.y - e3.y)));
          }
          addBorderIntersection(t3, e3) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r3 = this.borders[t3];
            e3 < r3[0] && (r3[0] = e3), e3 > r3[1] && (r3[1] = e3);
          }
          processBorderOverlap(t3, e3) {
            if (t3.x === e3.x) {
              if (t3.y === e3.y)
                return;
              const r3 = t3.x === 0 ? 0 : 1;
              this.addBorderIntersection(r3, e3.y), this.addBorderIntersection(r3, t3.y);
            } else {
              const r3 = t3.y === 0 ? 2 : 3;
              this.addBorderIntersection(r3, e3.x), this.addBorderIntersection(r3, t3.x);
            }
          }
          centroid() {
            const t3 = this.polyCount.reduce((t4, e3) => t4 + e3.edges, 0);
            return t3 !== 0 ? this.acc.div(t3)._round() : new i2(0, 0);
          }
          span() {
            return new i2(this.max.x - this.min.x, this.max.y - this.min.y);
          }
          intersectsCount() {
            return this.borders.reduce((t3, e3) => t3 + +(e3[0] !== Number.MAX_VALUE), 0);
          }
        }
        class Vu {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new da(), this.centroidVertexArray = new Za(), this.indexArray = new ka(), this.programConfigurations = new xo(t3.layers, t3.zoom), this.segments = new Mo(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.enableTerrain = t3.enableTerrain;
          }
          populate(t3, e3, r3, n2) {
            this.features = [], this.hasPattern = fu("fill-extrusion", this.layers, e3), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDone = [false, false, false, false], this.tileToMeter = function(t4) {
              const e4 = Math.exp(Math.PI * (1 - t4.y / (1 << t4.z) * 2));
              return 80150034 * e4 / (e4 * e4 + 1) / To / (1 << t4.z);
            }(r3);
            for (const { feature: i3, id: s4, index: a2, sourceLayerIndex: o2 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, l2 = Yo(i3, t4);
              if (!this.layers[0]._featureFilter.filter(new Gs(this.zoom), l2, r3))
                continue;
              const u2 = { id: s4, sourceLayerIndex: o2, index: a2, geometry: t4 ? l2.geometry : Ko(i3, r3, n2), properties: i3.properties, type: i3.type, patterns: {} }, c2 = this.layoutVertexArray.length;
              this.hasPattern ? this.features.push(yu("fill-extrusion", this.layers, u2, this.zoom, e3)) : this.addFeature(u2, u2.geometry, a2, r3, {}, e3.availableImages), e3.featureIndex.insert(i3, u2.geometry, a2, o2, this.index, c2);
            }
            this.sortBorders();
          }
          addFeatures(t3, e3, r3, n2) {
            for (const t4 of this.features) {
              const { geometry: i3 } = t4;
              this.addFeature(t4, i3, t4.index, e3, r3, n2);
            }
            this.sortBorders();
          }
          update(t3, e3, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, wu), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          uploadCentroid(t3) {
            this.centroidVertexArray.length !== 0 && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, bu.members, true), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t3, e3, r3, n2, i3, s4) {
            const a2 = this.enableTerrain ? new Du() : null;
            for (const r4 of pu(e3, 500)) {
              let e4 = 0, n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              if (r4.length === 0 || (o2 = r4[0]).every((t4) => t4.x <= 0) || o2.every((t4) => t4.x >= To) || o2.every((t4) => t4.y <= 0) || o2.every((t4) => t4.y >= To))
                continue;
              for (let t4 = 0; t4 < r4.length; t4++) {
                const i5 = r4[t4];
                if (i5.length === 0)
                  continue;
                e4 += i5.length;
                let s6 = 0;
                a2 && a2.startRing(i5[0]);
                for (let t5 = 0; t5 < i5.length; t5++) {
                  const e5 = i5[t5];
                  if (t5 >= 1) {
                    const r5 = i5[t5 - 1];
                    if (!Fu(e5, r5)) {
                      a2 && a2.append(e5, r5), n3.vertexLength + 4 > Mo.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t6 = e5.sub(r5)._perp(), i6 = t6.x / (Math.abs(t6.x) + Math.abs(t6.y)), o3 = t6.y > 0 ? 1 : 0, l3 = r5.dist(e5);
                      s6 + l3 > 32768 && (s6 = 0), Eu(this.layoutVertexArray, e5.x, e5.y, i6, o3, 0, 0, s6), Eu(this.layoutVertexArray, e5.x, e5.y, i6, o3, 0, 1, s6), s6 += l3, Eu(this.layoutVertexArray, r5.x, r5.y, i6, o3, 0, 0, s6), Eu(this.layoutVertexArray, r5.x, r5.y, i6, o3, 0, 1, s6);
                      const u3 = n3.vertexLength;
                      this.indexArray.emplaceBack(u3, u3 + 2, u3 + 1), this.indexArray.emplaceBack(u3 + 1, u3 + 2, u3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n3.vertexLength + e4 > Mo.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray)), Cu[t3.type] !== "Polygon")
                continue;
              const i4 = [], s5 = [], l2 = n3.vertexLength;
              for (let t4 = 0; t4 < r4.length; t4++) {
                const e5 = r4[t4];
                if (e5.length !== 0) {
                  e5 !== r4[0] && s5.push(i4.length / 2);
                  for (let t5 = 0; t5 < e5.length; t5++) {
                    const r5 = e5[t5];
                    Eu(this.layoutVertexArray, r5.x, r5.y, 0, 0, 1, 1, 0), i4.push(r5.x), i4.push(r5.y), a2 && a2.currentPolyCount.top++;
                  }
                }
              }
              const u2 = Dl(i4, s5);
              for (let t4 = 0; t4 < u2.length; t4 += 3)
                this.indexArray.emplaceBack(l2 + u2[t4], l2 + u2[t4 + 2], l2 + u2[t4 + 1]);
              n3.primitiveLength += u2.length / 3, n3.vertexLength += e4;
            }
            var o2;
            if (a2 && a2.polyCount.length > 0) {
              if (a2.borders) {
                a2.vertexArrayOffset = this.centroidVertexArray.length;
                const t4 = a2.borders, e4 = this.featuresOnBorder.push(a2) - 1;
                for (let r4 = 0; r4 < 4; r4++)
                  t4[r4][0] !== Number.MAX_VALUE && this.borders[r4].push(e4);
              }
              this.encodeCentroid(a2.borders ? void 0 : a2.centroid(), a2);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, s4, n2);
          }
          sortBorders() {
            for (let t3 = 0; t3 < 4; t3++)
              this.borders[t3].sort((e3, r3) => this.featuresOnBorder[e3].borders[t3][0] - this.featuresOnBorder[r3].borders[t3][0]);
          }
          encodeCentroid(t3, e3, r3 = true) {
            let n2, i3;
            if (t3)
              if (t3.y !== 0) {
                const r4 = e3.span()._mult(this.tileToMeter);
                n2 = (Math.max(t3.x, 1) << 3) + Math.min(7, Math.round(r4.x / 10)), i3 = (Math.max(t3.y, 1) << 3) + Math.min(7, Math.round(r4.y / 10));
              } else
                n2 = Math.ceil(7 * (t3.x + 450)), i3 = 0;
            else
              n2 = 0, i3 = +r3;
            let s4 = r3 ? this.centroidVertexArray.length : e3.vertexArrayOffset;
            for (const t4 of e3.polyCount) {
              r3 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t4.edges + t4.top);
              for (let e4 = 0; e4 < 2 * t4.edges; e4++)
                this.centroidVertexArray.emplace(s4++, 0, i3), this.centroidVertexArray.emplace(s4++, n2, i3);
              for (let e4 = 0; e4 < t4.top; e4++)
                this.centroidVertexArray.emplace(s4++, n2, i3);
            }
          }
        }
        function Fu(t3, e3) {
          return t3.x === e3.x && (t3.x < 0 || t3.x > To) || t3.y === e3.y && (t3.y < 0 || t3.y > To);
        }
        Zi("FillExtrusionBucket", Vu, { omit: ["layers", "features"] }), Zi("PartMetadata", Du);
        var Lu = { paint: new sa({ "fill-extrusion-opacity": new ta(ve["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ea(ve["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ta(ve["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ta(ve["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ra(ve["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ea(ve["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ea(ve["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ta(ve["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
        function Ru(t3, e3) {
          return t3.x * e3.x + t3.y * e3.y;
        }
        function Uu(t3, e3) {
          if (t3.length === 1) {
            let r3 = 0;
            const n2 = e3[r3++];
            let i3;
            for (; !i3 || n2.equals(i3); )
              if (i3 = e3[r3++], !i3)
                return 1 / 0;
            for (; r3 < e3.length; r3++) {
              const s4 = e3[r3], a2 = t3[0], o2 = i3.sub(n2), l2 = s4.sub(n2), u2 = a2.sub(n2), c2 = Ru(o2, o2), h3 = Ru(o2, l2), p2 = Ru(l2, l2), d2 = Ru(u2, o2), f4 = Ru(u2, l2), y2 = c2 * p2 - h3 * h3, m3 = (p2 * d2 - h3 * f4) / y2, g2 = (c2 * f4 - h3 * d2) / y2, x3 = n2.z * (1 - m3 - g2) + i3.z * m3 + s4.z * g2;
              if (isFinite(x3))
                return x3;
            }
            return 1 / 0;
          }
          {
            let t4 = 1 / 0;
            for (const r3 of e3)
              t4 = Math.min(t4, r3.z);
            return t4;
          }
        }
        function $u(t3) {
          const e3 = new i2(t3[0], t3[1]);
          return e3.z = t3[2], e3;
        }
        function Ou(t3, e3, r3, n2, i3, s4, a2, o2) {
          const l2 = a2 * i3.getElevationAt(t3, e3, true, true), u2 = s4[0] !== 0, c2 = u2 ? s4[1] === 0 ? a2 * (s4[0] / 7 - 450) : a2 * function(t4, e4, r4) {
            const n3 = Math.floor(e4[0] / 8), i4 = Math.floor(e4[1] / 8), s5 = 10 * (e4[0] - 8 * n3), a3 = 10 * (e4[1] - 8 * i4), o3 = t4.getElevationAt(n3, i4, true, true), l3 = t4.getMeterToDEM(r4), u3 = Math.floor(0.5 * (s5 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h3 = t4.tileCoordToPixel(n3, i4), p2 = 2 * u3 + 1, d2 = 2 * c3 + 1, f4 = function(t5, e5, r5, n4, i5) {
              return [t5.getElevationAtPixel(e5, r5, true), t5.getElevationAtPixel(e5 + i5, r5, true), t5.getElevationAtPixel(e5, r5 + i5, true), t5.getElevationAtPixel(e5 + n4, r5 + i5, true)];
            }(t4, h3.x - u3, h3.y - c3, p2, d2), y2 = Math.abs(f4[0] - f4[1]), m3 = Math.abs(f4[2] - f4[3]), g2 = Math.abs(f4[0] - f4[2]) + Math.abs(f4[1] - f4[3]), x3 = Math.min(0.25, 0.5 * l3 * (y2 + m3) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / d2);
            return o3 + Math.max(x3 * s5, v2 * a3);
          }(i3, s4, o2) : l2;
          return { base: l2 + (r3 === 0) ? -1 : r3, top: u2 ? Math.max(c2 + n2, l2 + r3 + 2) : l2 + n2 };
        }
        const ju = ca([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: qu } = ju, Nu = ca([{ name: "a_packed", components: 3, type: "Float32" }]), { members: Gu } = Nu, Zu = Bu.VectorTileFeature.types, Xu = Math.cos(Math.PI / 180 * 37.5);
        class Ku {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
              this.gradients[t4.id] = {};
            }), this.layoutVertexArray = new fa(), this.layoutVertexArray2 = new ya(), this.indexArray = new ka(), this.programConfigurations = new xo(t3.layers, t3.zoom), this.segments = new Mo(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e3, r3, n2) {
            this.hasPattern = fu("line", this.layers, e3);
            const i3 = this.layers[0].layout.get("line-sort-key"), s4 = [];
            for (const { feature: e4, id: a3, index: o3, sourceLayerIndex: l3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u2 = Yo(e4, t4);
              if (!this.layers[0]._featureFilter.filter(new Gs(this.zoom), u2, r3))
                continue;
              const c2 = i3 ? i3.evaluate(u2, {}, r3) : void 0, h3 = { id: a3, properties: e4.properties, type: e4.type, sourceLayerIndex: l3, index: o3, geometry: t4 ? u2.geometry : Ko(e4, r3, n2), patterns: {}, sortKey: c2 };
              s4.push(h3);
            }
            i3 && s4.sort((t4, e4) => t4.sortKey - e4.sortKey);
            const { lineAtlas: a2, featureIndex: o2 } = e3, l2 = this.addConstantDashes(a2);
            for (const n3 of s4) {
              const { geometry: i4, index: s5, sourceLayerIndex: u2 } = n3;
              if (l2 && this.addFeatureDashes(n3, a2), this.hasPattern) {
                const t4 = yu("line", this.layers, n3, this.zoom, e3);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n3, i4, s5, r3, a2.positions, e3.availableImages);
              o2.insert(t3[s5].feature, i4, s5, u2, this.index);
            }
          }
          addConstantDashes(t3) {
            let e3 = false;
            for (const r3 of this.layers) {
              const n2 = r3.paint.get("line-dasharray").value, i3 = r3.layout.get("line-cap").value;
              if (n2.kind !== "constant" || i3.kind !== "constant")
                e3 = true;
              else {
                const e4 = i3.value, r4 = n2.value;
                if (!r4)
                  continue;
                t3.addDash(r4.from, e4), t3.addDash(r4.to, e4), r4.other && t3.addDash(r4.other, e4);
              }
            }
            return e3;
          }
          addFeatureDashes(t3, e3) {
            const r3 = this.zoom;
            for (const n2 of this.layers) {
              const i3 = n2.paint.get("line-dasharray").value, s4 = n2.layout.get("line-cap").value;
              if (i3.kind === "constant" && s4.kind === "constant")
                continue;
              let a2, o2, l2, u2, c2, h3;
              if (i3.kind === "constant") {
                const t4 = i3.value;
                if (!t4)
                  continue;
                a2 = t4.other || t4.to, o2 = t4.to, l2 = t4.from;
              } else
                a2 = i3.evaluate({ zoom: r3 - 1 }, t3), o2 = i3.evaluate({ zoom: r3 }, t3), l2 = i3.evaluate({ zoom: r3 + 1 }, t3);
              s4.kind === "constant" ? u2 = c2 = h3 = s4.value : (u2 = s4.evaluate({ zoom: r3 - 1 }, t3), c2 = s4.evaluate({ zoom: r3 }, t3), h3 = s4.evaluate({ zoom: r3 + 1 }, t3)), e3.addDash(a2, u2), e3.addDash(o2, c2), e3.addDash(l2, h3);
              const p2 = e3.getKey(a2, u2), d2 = e3.getKey(o2, c2), f4 = e3.getKey(l2, h3);
              t3.patterns[n2.id] = { min: p2, mid: d2, max: f4 };
            }
          }
          update(t3, e3, r3, n2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n2);
          }
          addFeatures(t3, e3, r3, n2) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e3, r3, n2);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, Gu)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, qu), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t3) {
            if (t3.properties && t3.properties.hasOwnProperty("mapbox_clip_start") && t3.properties.hasOwnProperty("mapbox_clip_end"))
              return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
          }
          addFeature(t3, e3, r3, n2, i3, s4) {
            const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t3, {}), l2 = a2.get("line-cap").evaluate(t3, {}), u2 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t3);
            for (const r4 of e3)
              this.addLine(r4, t3, o2, l2, u2, c2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, s4, n2);
          }
          addLine(t3, e3, r3, n2, i3, s4) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e4 = 0; e4 < t3.length - 1; e4++)
                this.totalDistance += t3[e4].dist(t3[e4 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a2 = Zu[e3.type] === "Polygon";
            let o2 = t3.length;
            for (; o2 >= 2 && t3[o2 - 1].equals(t3[o2 - 2]); )
              o2--;
            let l2 = 0;
            for (; l2 < o2 - 1 && t3[l2].equals(t3[l2 + 1]); )
              l2++;
            if (o2 < (a2 ? 3 : 2))
              return;
            r3 === "bevel" && (i3 = 1.05);
            const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h3, p2, d2, f4, y2;
            this.e1 = this.e2 = -1, a2 && (h3 = t3[o2 - 2], y2 = t3[l2].sub(h3)._unit()._perp());
            for (let e4 = l2; e4 < o2; e4++) {
              if (d2 = e4 === o2 - 1 ? a2 ? t3[l2 + 1] : void 0 : t3[e4 + 1], d2 && t3[e4].equals(d2))
                continue;
              y2 && (f4 = y2), h3 && (p2 = h3), h3 = t3[e4], y2 = d2 ? d2.sub(h3)._unit()._perp() : f4, f4 = f4 || y2;
              let m3 = f4.add(y2);
              m3.x === 0 && m3.y === 0 || m3._unit();
              const g2 = f4.x * y2.x + f4.y * y2.y, x3 = m3.x * y2.x + m3.y * y2.y, v2 = x3 !== 0 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), w2 = x3 < Xu && p2 && d2, _2 = f4.x * y2.y - f4.y * y2.x > 0;
              if (w2 && e4 > l2) {
                const t4 = h3.dist(p2);
                if (t4 > 2 * u2) {
                  const e5 = h3.sub(h3.sub(p2)._mult(u2 / t4)._round());
                  this.updateDistance(p2, e5), this.addCurrentVertex(e5, f4, 0, 0, c2), p2 = e5;
                }
              }
              const A3 = p2 && d2;
              let k2 = A3 ? r3 : a2 ? "butt" : n2;
              if (A3 && k2 === "round" && (v2 < s4 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), k2 === "miter" && v2 > i3 && (k2 = "bevel"), k2 === "bevel" && (v2 > 2 && (k2 = "flipbevel"), v2 < i3 && (k2 = "miter")), p2 && this.updateDistance(p2, h3), k2 === "miter")
                m3._mult(v2), this.addCurrentVertex(h3, m3, 0, 0, c2);
              else if (k2 === "flipbevel") {
                if (v2 > 100)
                  m3 = y2.mult(-1);
                else {
                  const t4 = v2 * f4.add(y2).mag() / f4.sub(y2).mag();
                  m3._perp()._mult(t4 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h3, m3, 0, 0, c2), this.addCurrentVertex(h3, m3.mult(-1), 0, 0, c2);
              } else if (k2 === "bevel" || k2 === "fakeround") {
                const t4 = -Math.sqrt(v2 * v2 - 1), e5 = _2 ? t4 : 0, r4 = _2 ? 0 : t4;
                if (p2 && this.addCurrentVertex(h3, f4, e5, r4, c2), k2 === "fakeround") {
                  const t5 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e6 = 1; e6 < t5; e6++) {
                    let r5 = e6 / t5;
                    if (r5 !== 0.5) {
                      const t6 = r5 - 0.5;
                      r5 += r5 * t6 * (r5 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t6 * t6 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n3 = y2.sub(f4)._mult(r5)._add(f4)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h3, n3.x, n3.y, false, _2, 0, c2);
                  }
                }
                d2 && this.addCurrentVertex(h3, y2, -e5, -r4, c2);
              } else if (k2 === "butt")
                this.addCurrentVertex(h3, m3, 0, 0, c2);
              else if (k2 === "square") {
                const t4 = p2 ? 1 : -1;
                p2 || this.addCurrentVertex(h3, m3, t4, t4, c2), this.addCurrentVertex(h3, m3, 0, 0, c2), p2 && this.addCurrentVertex(h3, m3, t4, t4, c2);
              } else
                k2 === "round" && (p2 && (this.addCurrentVertex(h3, f4, 0, 0, c2), this.addCurrentVertex(h3, f4, 1, 1, c2, true)), d2 && (this.addCurrentVertex(h3, y2, -1, -1, c2, true), this.addCurrentVertex(h3, y2, 0, 0, c2)));
              if (w2 && e4 < o2 - 1) {
                const t4 = h3.dist(d2);
                if (t4 > 2 * u2) {
                  const e5 = h3.add(d2.sub(h3)._mult(u2 / t4)._round());
                  this.updateDistance(h3, e5), this.addCurrentVertex(e5, y2, 0, 0, c2), h3 = e5;
                }
              }
            }
          }
          addCurrentVertex(t3, e3, r3, n2, i3, s4 = false) {
            const a2 = e3.y * n2 - e3.x, o2 = -e3.y - e3.x * n2;
            this.addHalfVertex(t3, e3.x + e3.y * r3, e3.y - e3.x * r3, s4, false, r3, i3), this.addHalfVertex(t3, a2, o2, s4, true, -n2, i3);
          }
          addHalfVertex({ x: t3, y: e3 }, r3, n2, i3, s4, a2, o2) {
            this.layoutVertexArray.emplaceBack((t3 << 1) + (i3 ? 1 : 0), (e3 << 1) + (s4 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineSoFar);
            const l2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s4 ? this.e2 = l2 : this.e1 = l2;
          }
          updateScaledDistance() {
            if (this.lineClips) {
              const t3 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
              this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3 * this.lineClips.start + this.distance;
            } else
              this.lineSoFar = this.distance;
          }
          updateDistance(t3, e3) {
            this.distance += t3.dist(e3), this.updateScaledDistance();
          }
        }
        Zi("LineBucket", Ku, { omit: ["layers", "patternFeatures"] });
        const Yu = new sa({ "line-cap": new ea(ve.layout_line["line-cap"]), "line-join": new ea(ve.layout_line["line-join"]), "line-miter-limit": new ta(ve.layout_line["line-miter-limit"]), "line-round-limit": new ta(ve.layout_line["line-round-limit"]), "line-sort-key": new ea(ve.layout_line["line-sort-key"]) });
        var Hu = { paint: new sa({ "line-opacity": new ea(ve.paint_line["line-opacity"]), "line-color": new ea(ve.paint_line["line-color"]), "line-translate": new ta(ve.paint_line["line-translate"]), "line-translate-anchor": new ta(ve.paint_line["line-translate-anchor"]), "line-width": new ea(ve.paint_line["line-width"]), "line-gap-width": new ea(ve.paint_line["line-gap-width"]), "line-offset": new ea(ve.paint_line["line-offset"]), "line-blur": new ea(ve.paint_line["line-blur"]), "line-dasharray": new ra(ve.paint_line["line-dasharray"]), "line-pattern": new ra(ve.paint_line["line-pattern"]), "line-gradient": new ia(ve.paint_line["line-gradient"]) }), layout: Yu };
        const Ju = new class extends ea {
          possiblyEvaluate(t3, e3) {
            return e3 = new Gs(Math.floor(e3.zoom), { now: e3.now, fadeDuration: e3.fadeDuration, zoomHistory: e3.zoomHistory, transition: e3.transition }), super.possiblyEvaluate(t3, e3);
          }
          evaluate(t3, e3, r3, n2) {
            return e3 = tt({}, e3, { zoom: Math.floor(e3.zoom) }), super.evaluate(t3, e3, r3, n2);
          }
        }(Hu.paint.properties["line-width"].specification);
        function Wu(t3, e3) {
          return e3 > 0 ? e3 + 2 * t3 : t3;
        }
        Ju.useIntegerZoom = true;
        const Qu = ca([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }, { name: "a_z_tile_anchor", components: 4, type: "Int16" }], 4), tc = ca([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        ca([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const ec = ca([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), rc = ca([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
        ca([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const nc = ca([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), ic = ca([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        ca([{ name: "triangle", components: 3, type: "Uint16" }]), ca([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), ca([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), ca([{ type: "Float32", name: "offsetX" }]), ca([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
        var sc = 24;
        const ac = 128;
        function oc(t3, e3) {
          const { expression: r3 } = e3;
          if (r3.kind === "constant")
            return { kind: "constant", layoutSize: r3.evaluate(new Gs(t3 + 1)) };
          if (r3.kind === "source")
            return { kind: "source" };
          {
            const { zoomStops: e4, interpolationType: n2 } = r3;
            let i3 = 0;
            for (; i3 < e4.length && e4[i3] <= t3; )
              i3++;
            i3 = Math.max(0, i3 - 1);
            let s4 = i3;
            for (; s4 < e4.length && e4[s4] < t3 + 1; )
              s4++;
            s4 = Math.min(e4.length - 1, s4);
            const a2 = e4[i3], o2 = e4[s4];
            return r3.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r3.evaluate(new Gs(a2)), maxSize: r3.evaluate(new Gs(o2)), interpolationType: n2 };
          }
        }
        function lc(t3, { uSize: e3, uSizeT: r3 }, { lowerSize: n2, upperSize: i3 }) {
          return t3.kind === "source" ? n2 / ac : t3.kind === "composite" ? Lr(n2 / ac, i3 / ac, r3) : e3;
        }
        function uc(t3, e3) {
          let r3 = 0, n2 = 0;
          if (t3.kind === "constant")
            n2 = t3.layoutSize;
          else if (t3.kind !== "source") {
            const { interpolationType: i3, minZoom: s4, maxZoom: a2 } = t3, o2 = i3 ? Y(rn.interpolationFactor(i3, e3, s4, a2), 0, 1) : 0;
            t3.kind === "camera" ? n2 = Lr(t3.minSize, t3.maxSize, o2) : r3 = o2;
          }
          return { uSizeT: r3, uSize: n2 };
        }
        var cc = Object.freeze({ __proto__: null, getSizeData: oc, evaluateSizeForFeature: lc, evaluateSizeForZoom: uc, SIZE_PACK_FACTOR: ac });
        function hc(t3, e3, r3) {
          return t3.sections.forEach((t4) => {
            t4.text = function(t5, e4, r4) {
              const n2 = e4.layout.get("text-transform").evaluate(r4, {});
              return n2 === "uppercase" ? t5 = t5.toLocaleUpperCase() : n2 === "lowercase" && (t5 = t5.toLocaleLowerCase()), Ns.applyArabicShaping && (t5 = Ns.applyArabicShaping(t5)), t5;
            }(t4.text, e3, r3);
          }), t3;
        }
        const pc = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        function dc(t3) {
          return t3 === "\uFE36" || t3 === "\uFE48" || t3 === "\uFE38" || t3 === "\uFE44" || t3 === "\uFE42" || t3 === "\uFE3E" || t3 === "\uFE3C" || t3 === "\uFE3A" || t3 === "\uFE18" || t3 === "\uFE40" || t3 === "\uFE10" || t3 === "\uFE13" || t3 === "\uFE14" || t3 === "\uFF40" || t3 === "\uFFE3" || t3 === "\uFE11" || t3 === "\uFE12";
        }
        function fc(t3) {
          return t3 === "\uFE35" || t3 === "\uFE47" || t3 === "\uFE37" || t3 === "\uFE43" || t3 === "\uFE41" || t3 === "\uFE3D" || t3 === "\uFE3B" || t3 === "\uFE39" || t3 === "\uFE17" || t3 === "\uFE3F";
        }
        var yc = function(t3, e3, r3, n2, i3) {
          var s4, a2, o2 = 8 * i3 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h3 = r3 ? i3 - 1 : 0, p2 = r3 ? -1 : 1, d2 = t3[e3 + h3];
          for (h3 += p2, s4 = d2 & (1 << -c2) - 1, d2 >>= -c2, c2 += o2; c2 > 0; s4 = 256 * s4 + t3[e3 + h3], h3 += p2, c2 -= 8)
            ;
          for (a2 = s4 & (1 << -c2) - 1, s4 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t3[e3 + h3], h3 += p2, c2 -= 8)
            ;
          if (s4 === 0)
            s4 = 1 - u2;
          else {
            if (s4 === l2)
              return a2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
            a2 += Math.pow(2, n2), s4 -= u2;
          }
          return (d2 ? -1 : 1) * a2 * Math.pow(2, s4 - n2);
        }, mc = function(t3, e3, r3, n2, i3, s4) {
          var a2, o2, l2, u2 = 8 * s4 - i3 - 1, c2 = (1 << u2) - 1, h3 = c2 >> 1, p2 = i3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = n2 ? 0 : s4 - 1, f4 = n2 ? 1 : -1, y2 = e3 < 0 || e3 === 0 && 1 / e3 < 0 ? 1 : 0;
          for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (o2 = isNaN(e3) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e3 += a2 + h3 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h3)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h3 >= c2 ? (o2 = 0, a2 = c2) : a2 + h3 >= 1 ? (o2 = (e3 * l2 - 1) * Math.pow(2, i3), a2 += h3) : (o2 = e3 * Math.pow(2, h3 - 1) * Math.pow(2, i3), a2 = 0)); i3 >= 8; t3[r3 + d2] = 255 & o2, d2 += f4, o2 /= 256, i3 -= 8)
            ;
          for (a2 = a2 << i3 | o2, u2 += i3; u2 > 0; t3[r3 + d2] = 255 & a2, d2 += f4, a2 /= 256, u2 -= 8)
            ;
          t3[r3 + d2 - f4] |= 128 * y2;
        }, gc = xc;
        function xc(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        xc.Varint = 0, xc.Fixed64 = 1, xc.Bytes = 2, xc.Fixed32 = 5;
        var vc = 4294967296, bc = 1 / vc, wc = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");
        function _c(t3) {
          return t3.type === xc.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function Ac(t3, e3, r3) {
          return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
        }
        function kc(t3, e3, r3) {
          var n2 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
          r3.realloc(n2);
          for (var i3 = r3.pos - 1; i3 >= t3; i3--)
            r3.buf[i3 + n2] = r3.buf[i3];
        }
        function Sc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeVarint(t3[r3]);
        }
        function Ic(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSVarint(t3[r3]);
        }
        function zc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFloat(t3[r3]);
        }
        function Mc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeDouble(t3[r3]);
        }
        function Tc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeBoolean(t3[r3]);
        }
        function Bc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFixed32(t3[r3]);
        }
        function Cc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSFixed32(t3[r3]);
        }
        function Pc(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFixed64(t3[r3]);
        }
        function Ec(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSFixed64(t3[r3]);
        }
        function Dc(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
        }
        function Vc(t3, e3, r3) {
          t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
        }
        function Fc(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
        }
        function Lc(t3, e3, r3) {
          e3.glyphs = [], t3 === 1 && r3.readMessage(Rc, e3);
        }
        function Rc(t3, e3, r3) {
          if (t3 === 3) {
            const { id: t4, bitmap: n2, width: i3, height: s4, left: a2, top: o2, advance: l2 } = r3.readMessage(Uc, {});
            e3.glyphs.push({ id: t4, bitmap: new zl({ width: i3 + 6, height: s4 + 6 }, n2), metrics: { width: i3, height: s4, left: a2, top: o2, advance: l2 } });
          } else
            t3 === 4 ? e3.ascender = r3.readSVarint() : t3 === 5 && (e3.descender = r3.readSVarint());
        }
        function Uc(t3, e3, r3) {
          t3 === 1 ? e3.id = r3.readVarint() : t3 === 2 ? e3.bitmap = r3.readBytes() : t3 === 3 ? e3.width = r3.readVarint() : t3 === 4 ? e3.height = r3.readVarint() : t3 === 5 ? e3.left = r3.readSVarint() : t3 === 6 ? e3.top = r3.readSVarint() : t3 === 7 && (e3.advance = r3.readVarint());
        }
        function $c(t3) {
          let e3 = 0, r3 = 0;
          for (const n3 of t3)
            e3 += n3.w * n3.h, r3 = Math.max(r3, n3.w);
          t3.sort((t4, e4) => e4.h - t4.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e3 / 0.95)), r3), h: 1 / 0 }];
          let i3 = 0, s4 = 0;
          for (const e4 of t3)
            for (let t4 = n2.length - 1; t4 >= 0; t4--) {
              const r4 = n2[t4];
              if (!(e4.w > r4.w || e4.h > r4.h)) {
                if (e4.x = r4.x, e4.y = r4.y, s4 = Math.max(s4, e4.y + e4.h), i3 = Math.max(i3, e4.x + e4.w), e4.w === r4.w && e4.h === r4.h) {
                  const e5 = n2.pop();
                  t4 < n2.length && (n2[t4] = e5);
                } else
                  e4.h === r4.h ? (r4.x += e4.w, r4.w -= e4.w) : e4.w === r4.w ? (r4.y += e4.h, r4.h -= e4.h) : (n2.push({ x: r4.x + e4.w, y: r4.y, w: r4.w - e4.w, h: e4.h }), r4.y += e4.h, r4.h -= e4.h);
                break;
              }
            }
          return { w: i3, h: s4, fill: e3 / (i3 * s4) || 0 };
        }
        xc.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e3, r3) {
          for (r3 = r3 || this.length; this.pos < r3; ) {
            var n2 = this.readVarint(), i3 = n2 >> 3, s4 = this.pos;
            this.type = 7 & n2, t3(i3, e3, this), this.pos === s4 && this.skip(n2);
          }
          return e3;
        }, readMessage: function(t3, e3) {
          return this.readFields(t3, e3, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = Dc(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = Fc(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = Dc(this.buf, this.pos) + Dc(this.buf, this.pos + 4) * vc;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = Dc(this.buf, this.pos) + Fc(this.buf, this.pos + 4) * vc;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var t3 = yc(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t3;
        }, readDouble: function() {
          var t3 = yc(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t3;
        }, readVarint: function(t3) {
          var e3, r3, n2 = this.buf;
          return e3 = 127 & (r3 = n2[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n2[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n2[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n2[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
            var n3, i3, s4 = r4.buf;
            if (n3 = (112 & (i3 = s4[r4.pos++])) >> 4, i3 < 128)
              return Ac(t4, n3, e4);
            if (n3 |= (127 & (i3 = s4[r4.pos++])) << 3, i3 < 128)
              return Ac(t4, n3, e4);
            if (n3 |= (127 & (i3 = s4[r4.pos++])) << 10, i3 < 128)
              return Ac(t4, n3, e4);
            if (n3 |= (127 & (i3 = s4[r4.pos++])) << 17, i3 < 128)
              return Ac(t4, n3, e4);
            if (n3 |= (127 & (i3 = s4[r4.pos++])) << 24, i3 < 128)
              return Ac(t4, n3, e4);
            if (n3 |= (1 & (i3 = s4[r4.pos++])) << 31, i3 < 128)
              return Ac(t4, n3, e4);
            throw new Error("Expected varint not more than 10 bytes");
          }(e3 |= (15 & (r3 = n2[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.pos;
          return this.pos = t3, t3 - e3 >= 12 && wc ? function(t4, e4, r3) {
            return wc.decode(t4.subarray(e4, r3));
          }(this.buf, e3, t3) : function(t4, e4, r3) {
            for (var n2 = "", i3 = e4; i3 < r3; ) {
              var s4, a2, o2, l2 = t4[i3], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i3 + c2 > r3)
                break;
              c2 === 1 ? l2 < 128 && (u2 = l2) : c2 === 2 ? (192 & (s4 = t4[i3 + 1])) == 128 && (u2 = (31 & l2) << 6 | 63 & s4) <= 127 && (u2 = null) : c2 === 3 ? (a2 = t4[i3 + 2], (192 & (s4 = t4[i3 + 1])) == 128 && (192 & a2) == 128 && ((u2 = (15 & l2) << 12 | (63 & s4) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : c2 === 4 && (a2 = t4[i3 + 2], o2 = t4[i3 + 3], (192 & (s4 = t4[i3 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u2 = (15 & l2) << 18 | (63 & s4) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), u2 === null ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i3 += c2;
            }
            return n2;
          }(this.buf, e3, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e3;
        }, readPackedVarint: function(t3, e3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readVarint(e3));
          var r3 = _c(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readVarint(e3));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readSVarint());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readBoolean());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readFloat());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readDouble());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readFixed32());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readSFixed32());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readFixed64());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== xc.Bytes)
            return t3.push(this.readSFixed64());
          var e3 = _c(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var e3 = 7 & t3;
          if (e3 === xc.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e3 === xc.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e3 === xc.Fixed32)
            this.pos += 4;
          else {
            if (e3 !== xc.Fixed64)
              throw new Error("Unimplemented type: " + e3);
            this.pos += 8;
          }
        }, writeTag: function(t3, e3) {
          this.writeVarint(t3 << 3 | e3);
        }, realloc: function(t3) {
          for (var e3 = this.length || 16; e3 < this.pos + t3; )
            e3 *= 2;
          if (e3 !== this.length) {
            var r3 = new Uint8Array(e3);
            r3.set(this.buf), this.buf = r3, this.length = e3;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), Vc(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), Vc(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), Vc(this.buf, -1 & t3, this.pos), Vc(this.buf, Math.floor(t3 * bc), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), Vc(this.buf, -1 & t3, this.pos), Vc(this.buf, Math.floor(t3 * bc), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
            var r3, n2;
            if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n2 = t4 / 4294967296 | 0) : (n2 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n2 = n2 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e3.realloc(10), function(t5, e4, r4) {
              r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
            }(r3, 0, e3), function(t5, e4) {
              var r4 = (7 & t5) << 4;
              e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
            }(n2, e3);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e3 = this.pos;
          this.pos = function(t4, e4, r4) {
            for (var n2, i3, s4 = 0; s4 < e4.length; s4++) {
              if ((n2 = e4.charCodeAt(s4)) > 55295 && n2 < 57344) {
                if (!i3) {
                  n2 > 56319 || s4 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n2;
                  continue;
                }
                n2 = i3 - 55296 << 10 | n2 - 56320 | 65536, i3 = null;
              } else
                i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
              n2 < 128 ? t4[r4++] = n2 : (n2 < 2048 ? t4[r4++] = n2 >> 6 | 192 : (n2 < 65536 ? t4[r4++] = n2 >> 12 | 224 : (t4[r4++] = n2 >> 18 | 240, t4[r4++] = n2 >> 12 & 63 | 128), t4[r4++] = n2 >> 6 & 63 | 128), t4[r4++] = 63 & n2 | 128);
            }
            return r4;
          }(this.buf, t3, this.pos);
          var r3 = this.pos - e3;
          r3 >= 128 && kc(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(t3) {
          this.realloc(4), mc(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t3) {
          this.realloc(8), mc(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e3 = t3.length;
          this.writeVarint(e3), this.realloc(e3);
          for (var r3 = 0; r3 < e3; r3++)
            this.buf[this.pos++] = t3[r3];
        }, writeRawMessage: function(t3, e3) {
          this.pos++;
          var r3 = this.pos;
          t3(e3, this);
          var n2 = this.pos - r3;
          n2 >= 128 && kc(r3, n2, this), this.pos = r3 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t3, e3, r3) {
          this.writeTag(t3, xc.Bytes), this.writeRawMessage(e3, r3);
        }, writePackedVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, Sc, e3);
        }, writePackedSVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, Ic, e3);
        }, writePackedBoolean: function(t3, e3) {
          e3.length && this.writeMessage(t3, Tc, e3);
        }, writePackedFloat: function(t3, e3) {
          e3.length && this.writeMessage(t3, zc, e3);
        }, writePackedDouble: function(t3, e3) {
          e3.length && this.writeMessage(t3, Mc, e3);
        }, writePackedFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, Bc, e3);
        }, writePackedSFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, Cc, e3);
        }, writePackedFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, Pc, e3);
        }, writePackedSFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, Ec, e3);
        }, writeBytesField: function(t3, e3) {
          this.writeTag(t3, xc.Bytes), this.writeBytes(e3);
        }, writeFixed32Field: function(t3, e3) {
          this.writeTag(t3, xc.Fixed32), this.writeFixed32(e3);
        }, writeSFixed32Field: function(t3, e3) {
          this.writeTag(t3, xc.Fixed32), this.writeSFixed32(e3);
        }, writeFixed64Field: function(t3, e3) {
          this.writeTag(t3, xc.Fixed64), this.writeFixed64(e3);
        }, writeSFixed64Field: function(t3, e3) {
          this.writeTag(t3, xc.Fixed64), this.writeSFixed64(e3);
        }, writeVarintField: function(t3, e3) {
          this.writeTag(t3, xc.Varint), this.writeVarint(e3);
        }, writeSVarintField: function(t3, e3) {
          this.writeTag(t3, xc.Varint), this.writeSVarint(e3);
        }, writeStringField: function(t3, e3) {
          this.writeTag(t3, xc.Bytes), this.writeString(e3);
        }, writeFloatField: function(t3, e3) {
          this.writeTag(t3, xc.Fixed32), this.writeFloat(e3);
        }, writeDoubleField: function(t3, e3) {
          this.writeTag(t3, xc.Fixed64), this.writeDouble(e3);
        }, writeBooleanField: function(t3, e3) {
          this.writeVarintField(t3, Boolean(e3));
        } };
        class Oc {
          constructor(t3, { pixelRatio: e3, version: r3, stretchX: n2, stretchY: i3, content: s4 }) {
            this.paddedRect = t3, this.pixelRatio = e3, this.stretchX = n2, this.stretchY = i3, this.content = s4, this.version = r3;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class jc {
          constructor(t3, e3) {
            const r3 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i3 = [];
            this.addImages(t3, r3, i3), this.addImages(e3, n2, i3);
            const { w: s4, h: a2 } = $c(i3), o2 = new Ml({ width: s4 || 1, height: a2 || 1 });
            for (const e4 in t3) {
              const n3 = t3[e4], i4 = r3[e4].paddedRect;
              Ml.copy(n3.data, o2, { x: 0, y: 0 }, { x: i4.x + 1, y: i4.y + 1 }, n3.data);
            }
            for (const t4 in e3) {
              const r4 = e3[t4], i4 = n2[t4].paddedRect, s5 = i4.x + 1, a3 = i4.y + 1, l2 = r4.data.width, u2 = r4.data.height;
              Ml.copy(r4.data, o2, { x: 0, y: 0 }, { x: s5, y: a3 }, r4.data), Ml.copy(r4.data, o2, { x: 0, y: u2 - 1 }, { x: s5, y: a3 - 1 }, { width: l2, height: 1 }), Ml.copy(r4.data, o2, { x: 0, y: 0 }, { x: s5, y: a3 + u2 }, { width: l2, height: 1 }), Ml.copy(r4.data, o2, { x: l2 - 1, y: 0 }, { x: s5 - 1, y: a3 }, { width: 1, height: u2 }), Ml.copy(r4.data, o2, { x: 0, y: 0 }, { x: s5 + l2, y: a3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r3, this.patternPositions = n2;
          }
          addImages(t3, e3, r3) {
            for (const n2 in t3) {
              const i3 = t3[n2], s4 = { x: 0, y: 0, w: i3.data.width + 2, h: i3.data.height + 2 };
              r3.push(s4), e3[n2] = new Oc(s4, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t3, e3) {
            t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r3 in t3.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r3], t3.getImage(r3), e3), this.patchUpdatedImage(this.patternPositions[r3], t3.getImage(r3), e3);
          }
          patchUpdatedImage(t3, e3, r3) {
            if (!t3 || !e3)
              return;
            if (t3.version === e3.version)
              return;
            t3.version = e3.version;
            const [n2, i3] = t3.tl;
            r3.update(e3.data, void 0, { x: n2, y: i3 });
          }
        }
        Zi("ImagePosition", Oc), Zi("ImageAtlas", jc);
        const qc = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Nc {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t3, e3) {
            const r3 = new Nc();
            return r3.scale = t3 || 1, r3.fontStack = e3, r3;
          }
          static forImage(t3) {
            const e3 = new Nc();
            return e3.imageName = t3, e3;
          }
        }
        class Gc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t3, e3) {
            const r3 = new Gc();
            for (let n2 = 0; n2 < t3.sections.length; n2++) {
              const i3 = t3.sections[n2];
              i3.image ? r3.addImageSection(i3) : r3.addTextSection(i3, e3);
            }
            return r3;
          }
          length() {
            return this.text.length;
          }
          getSection(t3) {
            return this.sections[this.sectionIndex[t3]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t3) {
            return this.sectionIndex[t3];
          }
          getCharCode(t3) {
            return this.text.charCodeAt(t3);
          }
          verticalizePunctuation(t3) {
            this.text = function(t4, e3) {
              let r3 = "";
              for (let n2 = 0; n2 < t4.length; n2++) {
                const i3 = t4.charCodeAt(n2 + 1) || null, s4 = t4.charCodeAt(n2 - 1) || null;
                r3 += !e3 && (i3 && Ts(i3) && !pc[t4[n2 + 1]] || s4 && Ts(s4) && !pc[t4[n2 - 1]]) || !pc[t4[n2]] ? t4[n2] : pc[t4[n2]];
              }
              return r3;
            }(this.text, t3);
          }
          trim() {
            let t3 = 0;
            for (let e4 = 0; e4 < this.text.length && Xc[this.text.charCodeAt(e4)]; e4++)
              t3++;
            let e3 = this.text.length;
            for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t3 && Xc[this.text.charCodeAt(r3)]; r3--)
              e3--;
            this.text = this.text.substring(t3, e3), this.sectionIndex = this.sectionIndex.slice(t3, e3);
          }
          substring(t3, e3) {
            const r3 = new Gc();
            return r3.text = this.text.substring(t3, e3), r3.sectionIndex = this.sectionIndex.slice(t3, e3), r3.sections = this.sections, r3;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t3, e3) => Math.max(t3, this.sections[e3].scale), 0);
          }
          addTextSection(t3, e3) {
            this.text += t3.text, this.sections.push(Nc.forText(t3.scale, t3.fontStack || e3));
            const r3 = this.sections.length - 1;
            for (let e4 = 0; e4 < t3.text.length; ++e4)
              this.sectionIndex.push(r3);
          }
          addImageSection(t3) {
            const e3 = t3.image ? t3.image.name : "";
            if (e3.length === 0)
              return void pt("Can't add FormattedSection with an empty image.");
            const r3 = this.getNextImageSectionCharCode();
            r3 ? (this.text += String.fromCharCode(r3), this.sections.push(Nc.forImage(e3)), this.sectionIndex.push(this.sections.length - 1)) : pt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Zc(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2) {
          const m3 = Gc.fromFeature(t3, i3);
          let g2;
          h3 === qc.vertical && m3.verticalizePunctuation(p2);
          const { processBidirectionalText: x3, processStyledBidirectionalText: v2 } = Ns;
          if (x3 && m3.sections.length === 1) {
            g2 = [];
            const t4 = x3(m3.toString(), th(m3, u2, s4, e3, n2, d2, f4));
            for (const e4 of t4) {
              const t5 = new Gc();
              t5.text = e4, t5.sections = m3.sections;
              for (let r4 = 0; r4 < e4.length; r4++)
                t5.sectionIndex.push(0);
              g2.push(t5);
            }
          } else if (v2) {
            g2 = [];
            const t4 = v2(m3.text, m3.sectionIndex, th(m3, u2, s4, e3, n2, d2, f4));
            for (const e4 of t4) {
              const t5 = new Gc();
              t5.text = e4[0], t5.sectionIndex = e4[1], t5.sections = m3.sections, g2.push(t5);
            }
          } else
            g2 = function(t4, e4) {
              const r4 = [], n3 = t4.text;
              let i4 = 0;
              for (const n4 of e4)
                r4.push(t4.substring(i4, n4)), i4 = n4;
              return i4 < n3.length && r4.push(t4.substring(i4, n3.length)), r4;
            }(m3, th(m3, u2, s4, e3, n2, d2, f4));
          const b2 = [], w2 = { positionedLines: b2, text: m3.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h3, iconsInText: false, verticalizable: false, hasBaseline: false };
          return function(t4, e4, r4, n3, i4, s5, a3, o3, l3, u3, c3, h4) {
            let p3 = 0, d3 = 0, f5 = 0;
            const y3 = o3 === "right" ? 1 : o3 === "left" ? 0 : 0.5;
            let m4 = false;
            for (const t5 of i4) {
              const r5 = t5.getSections();
              for (const t6 of r5) {
                if (t6.imageName)
                  continue;
                const r6 = e4[t6.fontStack];
                if (r6 && (m4 = r6.ascender !== void 0 && r6.descender !== void 0, !m4))
                  break;
              }
              if (!m4)
                break;
            }
            let g3 = 0;
            for (const a4 of i4) {
              a4.trim();
              const i5 = a4.getMaxScale(), o4 = (i5 - 1) * sc, v4 = { positionedGlyphs: [], lineOffset: 0 };
              t4.positionedLines[g3] = v4;
              const b4 = v4.positionedGlyphs;
              let w4 = 0;
              if (!a4.length()) {
                d3 += s5, ++g3;
                continue;
              }
              let _2 = 0, A3 = 0;
              for (let s6 = 0; s6 < a4.length(); s6++) {
                const o5 = a4.getSection(s6), f6 = a4.getSectionIndex(s6), y4 = a4.getCharCode(s6);
                let g4 = o5.scale, v5 = null, k3 = null, S3 = null, I2 = sc, z2 = 0;
                const M2 = !(l3 === qc.horizontal || !c3 && !Ms(y4) || c3 && (Xc[y4] || (x4 = y4, Wi(x4) || Qi(x4) || ts(x4) || vs(x4) || As(x4))));
                if (o5.imageName) {
                  const e5 = n3[o5.imageName];
                  if (!e5)
                    continue;
                  S3 = o5.imageName, t4.iconsInText = t4.iconsInText || true, k3 = e5.paddedRect;
                  const r5 = e5.displaySize;
                  g4 = g4 * sc / h4, v5 = { width: r5[0], height: r5[1], left: 1, top: -3, advance: M2 ? r5[1] : r5[0], localGlyph: false }, z2 = m4 ? -v5.height * g4 : i5 * sc - 17 - r5[1] * g4, I2 = v5.advance;
                  const s7 = (M2 ? r5[0] : r5[1]) * g4 - sc * i5;
                  s7 > 0 && s7 > w4 && (w4 = s7);
                } else {
                  const t5 = r4[o5.fontStack];
                  if (!t5)
                    continue;
                  t5[y4] && (k3 = t5[y4]);
                  const n4 = e4[o5.fontStack];
                  if (!n4)
                    continue;
                  const s7 = n4.glyphs[y4];
                  if (!s7)
                    continue;
                  if (v5 = s7.metrics, I2 = y4 !== 8203 ? sc : 0, m4) {
                    const t6 = n4.ascender !== void 0 ? Math.abs(n4.ascender) : 0, e5 = n4.descender !== void 0 ? Math.abs(n4.descender) : 0, r5 = (t6 + e5) * g4;
                    _2 < r5 && (_2 = r5, A3 = (t6 - e5) / 2 * g4), z2 = -t6 * g4;
                  } else
                    z2 = (i5 - g4) * sc - 17;
                }
                M2 ? (t4.verticalizable = true, b4.push({ glyph: y4, imageName: S3, x: p3, y: d3 + z2, vertical: M2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: f6, metrics: v5, rect: k3 }), p3 += I2 * g4 + u3) : (b4.push({ glyph: y4, imageName: S3, x: p3, y: d3 + z2, vertical: M2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: f6, metrics: v5, rect: k3 }), p3 += v5.advance * g4 + u3);
              }
              b4.length !== 0 && (f5 = Math.max(p3 - u3, f5), m4 ? rh(b4, y3, w4, A3, s5 * i5 / 2) : rh(b4, y3, w4, 0, s5 / 2)), p3 = 0;
              const k2 = s5 * i5 + w4;
              v4.lineOffset = Math.max(w4, o4), d3 += k2, ++g3;
            }
            var x4;
            const v3 = d3, { horizontalAlign: b3, verticalAlign: w3 } = eh(a3);
            (function(t5, e5, r5, n4, i5, s6) {
              const a4 = (e5 - r5) * i5, o4 = -s6 * n4;
              for (const e6 of t5)
                for (const t6 of e6.positionedGlyphs)
                  t6.x += a4, t6.y += o4;
            })(t4.positionedLines, y3, b3, w3, f5, v3), t4.top += -w3 * v3, t4.bottom = t4.top + v3, t4.left += -b3 * f5, t4.right = t4.left + f5, t4.hasBaseline = m4;
          }(w2, e3, r3, n2, g2, a2, o2, l2, h3, u2, p2, y2), !function(t4) {
            for (const e4 of t4)
              if (e4.positionedGlyphs.length !== 0)
                return false;
            return true;
          }(b2) && w2;
        }
        const Xc = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Kc = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Yc(t3, e3, r3, n2, i3, s4) {
          if (e3.imageName) {
            const t4 = n2[e3.imageName];
            return t4 ? t4.displaySize[0] * e3.scale * sc / s4 + i3 : 0;
          }
          {
            const n3 = r3[e3.fontStack], s5 = n3 && n3.glyphs[t3];
            return s5 ? s5.metrics.advance * e3.scale + i3 : 0;
          }
        }
        function Hc(t3, e3, r3, n2) {
          const i3 = Math.pow(t3 - e3, 2);
          return n2 ? t3 < e3 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r3) * r3;
        }
        function Jc(t3, e3, r3) {
          let n2 = 0;
          return t3 === 10 && (n2 -= 1e4), r3 && (n2 += 150), t3 !== 40 && t3 !== 65288 || (n2 += 50), e3 !== 41 && e3 !== 65289 || (n2 += 50), n2;
        }
        function Wc(t3, e3, r3, n2, i3, s4) {
          let a2 = null, o2 = Hc(e3, r3, i3, s4);
          for (const t4 of n2) {
            const n3 = Hc(e3 - t4.x, r3, i3, s4) + t4.badness;
            n3 <= o2 && (a2 = t4, o2 = n3);
          }
          return { index: t3, x: e3, priorBreak: a2, badness: o2 };
        }
        function Qc(t3) {
          return t3 ? Qc(t3.priorBreak).concat(t3.index) : [];
        }
        function th(t3, e3, r3, n2, i3, s4, a2) {
          if (s4 !== "point")
            return [];
          if (!t3)
            return [];
          const o2 = [], l2 = function(t4, e4, r4, n3, i4, s5) {
            let a3 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const o3 = t4.getSection(r5);
              a3 += Yc(t4.getCharCode(r5), o3, n3, i4, e4, s5);
            }
            return a3 / Math.max(1, Math.ceil(a3 / r4));
          }(t3, e3, r3, n2, i3, a2), u2 = t3.text.indexOf("\u200B") >= 0;
          let c2 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const s5 = t3.getSection(r4), p2 = t3.getCharCode(r4);
            if (Xc[p2] || (c2 += Yc(p2, s5, n2, i3, e3, a2)), r4 < t3.length() - 1) {
              const e4 = !((h3 = p2) < 11904 || !(ls(h3) || os(h3) || ws(h3) || xs(h3) || ps(h3) || es(h3) || us(h3) || is(h3) || ds(h3) || fs(h3) || hs(h3) || ks(h3) || ss(h3) || ns(h3) || rs(h3) || cs(h3) || as(h3) || bs(h3) || ms(h3) || ys(h3)));
              (Kc[p2] || e4 || s5.imageName) && o2.push(Wc(r4 + 1, c2, l2, o2, Jc(p2, t3.getCharCode(r4 + 1), e4 && u2), false));
            }
          }
          var h3;
          return Qc(Wc(t3.length(), c2, l2, o2, 0, true));
        }
        function eh(t3) {
          let e3 = 0.5, r3 = 0.5;
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              e3 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e3 = 0;
          }
          switch (t3) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r3 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r3 = 0;
          }
          return { horizontalAlign: e3, verticalAlign: r3 };
        }
        function rh(t3, e3, r3, n2, i3) {
          if (!(e3 || r3 || n2 || i3))
            return;
          const s4 = t3.length - 1, a2 = t3[s4], o2 = (a2.x + a2.metrics.advance * a2.scale) * e3;
          for (let e4 = 0; e4 <= s4; e4++)
            t3[e4].x -= o2, t3[e4].y += r3 + n2 + i3;
        }
        function nh(t3, e3, r3) {
          const { horizontalAlign: n2, verticalAlign: i3 } = eh(r3), s4 = e3[0] - t3.displaySize[0] * n2, a2 = e3[1] - t3.displaySize[1] * i3;
          return { image: t3, top: a2, bottom: a2 + t3.displaySize[1], left: s4, right: s4 + t3.displaySize[0] };
        }
        function ih(t3, e3, r3, n2, i3, s4) {
          const a2 = t3.image;
          let o2;
          if (a2.content) {
            const t4 = a2.content, e4 = a2.pixelRatio || 1;
            o2 = [t4[0] / e4, t4[1] / e4, a2.displaySize[0] - t4[2] / e4, a2.displaySize[1] - t4[3] / e4];
          }
          const l2 = e3.left * s4, u2 = e3.right * s4;
          let c2, h3, p2, d2;
          r3 === "width" || r3 === "both" ? (d2 = i3[0] + l2 - n2[3], h3 = i3[0] + u2 + n2[1]) : (d2 = i3[0] + (l2 + u2 - a2.displaySize[0]) / 2, h3 = d2 + a2.displaySize[0]);
          const f4 = e3.top * s4, y2 = e3.bottom * s4;
          return r3 === "height" || r3 === "both" ? (c2 = i3[1] + f4 - n2[0], p2 = i3[1] + y2 + n2[2]) : (c2 = i3[1] + (f4 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h3, bottom: p2, left: d2, collisionPadding: o2 };
        }
        class sh extends i2 {
          constructor(t3, e3, r3, n2, i3) {
            super(t3, e3), this.angle = n2, this.z = r3, i3 !== void 0 && (this.segment = i3);
          }
          clone() {
            return new sh(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function ah(t3, e3, r3, n2, i3) {
          if (e3.segment === void 0)
            return true;
          let s4 = e3, a2 = e3.segment + 1, o2 = 0;
          for (; o2 > -r3 / 2; ) {
            if (a2--, a2 < 0)
              return false;
            o2 -= t3[a2].dist(s4), s4 = t3[a2];
          }
          o2 += t3[a2].dist(t3[a2 + 1]), a2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r3 / 2; ) {
            const e4 = t3[a2], r4 = t3[a2 + 1];
            if (!r4)
              return false;
            let s5 = t3[a2 - 1].angleTo(e4) - e4.angleTo(r4);
            for (s5 = Math.abs((s5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s5 }), u2 += s5; o2 - l2[0].distance > n2; )
              u2 -= l2.shift().angleDelta;
            if (u2 > i3)
              return false;
            a2++, o2 += e4.dist(r4);
          }
          return true;
        }
        function oh(t3) {
          let e3 = 0;
          for (let r3 = 0; r3 < t3.length - 1; r3++)
            e3 += t3[r3].dist(t3[r3 + 1]);
          return e3;
        }
        function lh(t3, e3, r3) {
          return t3 ? 0.6 * e3 * r3 : 0;
        }
        function uh(t3, e3) {
          return Math.max(t3 ? t3.right - t3.left : 0, e3 ? e3.right - e3.left : 0);
        }
        function ch(t3, e3, r3, n2, i3, s4) {
          const a2 = lh(r3, i3, s4), o2 = uh(r3, n2) * s4;
          let l2 = 0;
          const u2 = oh(t3) / 2;
          for (let r4 = 0; r4 < t3.length - 1; r4++) {
            const n3 = t3[r4], i4 = t3[r4 + 1], s5 = n3.dist(i4);
            if (l2 + s5 > u2) {
              const c2 = (u2 - l2) / s5, h3 = Lr(n3.x, i4.x, c2), p2 = Lr(n3.y, i4.y, c2), d2 = new sh(h3, p2, 0, i4.angleTo(n3), r4);
              return !a2 || ah(t3, d2, o2, a2, e3) ? d2 : void 0;
            }
            l2 += s5;
          }
        }
        function hh(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
          const u2 = lh(n2, s4, a2), c2 = uh(n2, i3), h3 = c2 * a2, p2 = t3[0].x === 0 || t3[0].x === l2 || t3[0].y === 0 || t3[0].y === l2;
          return e3 - h3 < e3 / 4 && (e3 = h3 + e3 / 4), ph(t3, p2 ? e3 / 2 * o2 % e3 : (c2 / 2 + 2 * s4) * a2 * o2 % e3, e3, u2, r3, h3, p2, false, l2);
        }
        function ph(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
          const u2 = s4 / 2, c2 = oh(t3);
          let h3 = 0, p2 = e3 - r3, d2 = [];
          for (let e4 = 0; e4 < t3.length - 1; e4++) {
            const a3 = t3[e4], o3 = t3[e4 + 1], f4 = a3.dist(o3), y2 = o3.angleTo(a3);
            for (; p2 + r3 < h3 + f4; ) {
              p2 += r3;
              const m3 = (p2 - h3) / f4, g2 = Lr(a3.x, o3.x, m3), x3 = Lr(a3.y, o3.y, m3);
              if (g2 >= 0 && g2 < l2 && x3 >= 0 && x3 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r4 = new sh(g2, x3, 0, y2, e4);
                r4._round(), n2 && !ah(t3, r4, s4, n2, i3) || d2.push(r4);
              }
            }
            h3 += f4;
          }
          return o2 || d2.length || a2 || (d2 = ph(t3, h3 / 2, r3, n2, i3, s4, a2, true, l2)), d2;
        }
        function dh(t3, e3, r3, n2, s4) {
          const a2 = [];
          for (let o2 = 0; o2 < t3.length; o2++) {
            const l2 = t3[o2];
            let u2;
            for (let t4 = 0; t4 < l2.length - 1; t4++) {
              let o3 = l2[t4], c2 = l2[t4 + 1];
              o3.x < e3 && c2.x < e3 || (o3.x < e3 ? o3 = new i2(e3, o3.y + (e3 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e3 && (c2 = new i2(e3, o3.y + (e3 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r3 && c2.y < r3 || (o3.y < r3 ? o3 = new i2(o3.x + (r3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r3)._round() : c2.y < r3 && (c2 = new i2(o3.x + (r3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r3)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new i2(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new i2(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= s4 && c2.y >= s4 || (o3.y >= s4 ? o3 = new i2(o3.x + (s4 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s4)._round() : c2.y >= s4 && (c2 = new i2(o3.x + (s4 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s4)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
            }
          }
          return a2;
        }
        Zi("Anchor", sh);
        const fh = 1e20;
        function yh(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
          for (let u2 = e3; u2 < e3 + n2; u2++)
            mh(t3, r3 * s4 + u2, s4, i3, a2, o2, l2);
          for (let u2 = r3; u2 < r3 + i3; u2++)
            mh(t3, u2 * s4 + e3, 1, n2, a2, o2, l2);
        }
        function mh(t3, e3, r3, n2, i3, s4, a2) {
          s4[0] = 0, a2[0] = -fh, a2[1] = fh, i3[0] = t3[e3];
          for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
            i3[o2] = t3[e3 + o2 * r3];
            const n3 = o2 * o2;
            do {
              const t4 = s4[l2];
              u2 = (i3[o2] - i3[t4] + n3 - t4 * t4) / (o2 - t4) / 2;
            } while (u2 <= a2[l2] && --l2 > -1);
            l2++, s4[l2] = o2, a2[l2] = u2, a2[l2 + 1] = fh;
          }
          for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
            for (; a2[l2 + 1] < o2; )
              l2++;
            const n3 = s4[l2], u2 = o2 - n3;
            t3[e3 + o2 * r3] = i3[n3] + u2 * u2;
          }
        }
        const gh = { none: 0, ideographs: 1, all: 2 };
        class xh {
          constructor(t3, e3, r3) {
            this.requestManager = t3, this.localGlyphMode = e3, this.localFontFamily = r3, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t3) {
            this.url = t3;
          }
          getGlyphs(t3, e3) {
            const r3 = [];
            for (const e4 in t3)
              for (const n2 of t3[e4])
                r3.push({ stack: e4, id: n2 });
            W(r3, ({ stack: t4, id: e4 }, r4) => {
              let n2 = this.entries[t4];
              n2 || (n2 = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let i3 = n2.glyphs[e4];
              if (i3 !== void 0)
                return void r4(null, { stack: t4, id: e4, glyph: i3 });
              if (i3 = this._tinySDF(n2, t4, e4), i3)
                return n2.glyphs[e4] = i3, void r4(null, { stack: t4, id: e4, glyph: i3 });
              const s4 = Math.floor(e4 / 256);
              if (256 * s4 > 65535)
                return void r4(new Error("glyphs > 65535 not supported"));
              if (n2.ranges[s4])
                return void r4(null, { stack: t4, id: e4, glyph: i3 });
              let a2 = n2.requests[s4];
              a2 || (a2 = n2.requests[s4] = [], xh.loadGlyphRange(t4, s4, this.url, this.requestManager, (t5, e5) => {
                if (e5) {
                  n2.ascender = e5.ascender, n2.descender = e5.descender;
                  for (const t6 in e5.glyphs)
                    this._doesCharSupportLocalGlyph(+t6) || (n2.glyphs[+t6] = e5.glyphs[+t6]);
                  n2.ranges[s4] = true;
                }
                for (const r5 of a2)
                  r5(t5, e5);
                delete n2.requests[s4];
              })), a2.push((n3, i4) => {
                n3 ? r4(n3) : i4 && r4(null, { stack: t4, id: e4, glyph: i4.glyphs[e4] || null });
              });
            }, (t4, r4) => {
              if (t4)
                e3(t4);
              else if (r4) {
                const t5 = {};
                for (const { stack: e4, id: n2, glyph: i3 } of r4)
                  t5[e4] === void 0 && (t5[e4] = {}), t5[e4].glyphs === void 0 && (t5[e4].glyphs = {}), t5[e4].glyphs[n2] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t5[e4].ascender = this.entries[e4].ascender, t5[e4].descender = this.entries[e4].descender;
                e3(null, t5);
              }
            });
          }
          _doesCharSupportLocalGlyph(t3) {
            return this.localGlyphMode !== gh.none && (this.localGlyphMode === gh.all ? !!this.localFontFamily : !!this.localFontFamily && (fs(t3) || gs(t3) || ss(t3) || as(t3)) || is(t3));
          }
          _tinySDF(t3, e3, r3) {
            const n2 = this.localFontFamily;
            if (!n2 || !this._doesCharSupportLocalGlyph(r3))
              return;
            let i3 = t3.tinySDF;
            if (!i3) {
              let r4 = "400";
              /bold/i.test(e3) ? r4 = "900" : /medium/i.test(e3) ? r4 = "500" : /light/i.test(e3) && (r4 = "200"), i3 = t3.tinySDF = new xh.TinySDF({ fontFamily: n2, fontWeight: r4, fontSize: 48, buffer: 6, radius: 16 }), i3.fontWeight = r4;
            }
            if (this.localGlyphs[i3.fontWeight][r3])
              return this.localGlyphs[i3.fontWeight][r3];
            const s4 = String.fromCharCode(r3), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h3, glyphTop: p2, glyphAdvance: d2 } = i3.draw(s4);
            return this.localGlyphs[i3.fontWeight][r3] = { id: r3, bitmap: new zl({ width: o2, height: l2 }, a2), metrics: { width: u2 / 2, height: c2 / 2, left: h3 / 2, top: p2 / 2 - 27, advance: d2 / 2, localGlyph: true } };
          }
        }
        function vh(t3, e3, r3, n2) {
          const s4 = [], a2 = t3.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2, u2 = a2.paddedRect.h - 2, c2 = t3.right - t3.left, h3 = t3.bottom - t3.top, p2 = a2.stretchX || [[0, l2]], d2 = a2.stretchY || [[0, u2]], f4 = (t4, e4) => t4 + e4[1] - e4[0], y2 = p2.reduce(f4, 0), m3 = d2.reduce(f4, 0), g2 = l2 - y2, x3 = u2 - m3;
          let v2 = 0, b2 = y2, w2 = 0, _2 = m3, A3 = 0, k2 = g2, S3 = 0, I2 = x3;
          if (a2.content && n2) {
            const t4 = a2.content;
            v2 = bh(p2, 0, t4[0]), w2 = bh(d2, 0, t4[1]), b2 = bh(p2, t4[0], t4[2]), _2 = bh(d2, t4[1], t4[3]), A3 = t4[0] - v2, S3 = t4[1] - w2, k2 = t4[2] - t4[0] - b2, I2 = t4[3] - t4[1] - _2;
          }
          const z2 = (n3, s5, l3, u3) => {
            const p3 = _h(n3.stretch - v2, b2, c2, t3.left), d3 = Ah(n3.fixed - A3, k2, n3.stretch, y2), f5 = _h(s5.stretch - w2, _2, h3, t3.top), g3 = Ah(s5.fixed - S3, I2, s5.stretch, m3), x4 = _h(l3.stretch - v2, b2, c2, t3.left), z3 = Ah(l3.fixed - A3, k2, l3.stretch, y2), M2 = _h(u3.stretch - w2, _2, h3, t3.top), T2 = Ah(u3.fixed - S3, I2, u3.stretch, m3), B2 = new i2(p3, f5), C2 = new i2(x4, f5), P2 = new i2(x4, M2), E2 = new i2(p3, M2), D2 = new i2(d3 / o2, g3 / o2), V2 = new i2(z3 / o2, T2 / o2), F3 = e3 * Math.PI / 180;
            if (F3) {
              const t4 = Math.sin(F3), e4 = Math.cos(F3), r4 = [e4, -t4, t4, e4];
              B2._matMult(r4), C2._matMult(r4), E2._matMult(r4), P2._matMult(r4);
            }
            const L2 = n3.stretch + n3.fixed, R2 = s5.stretch + s5.fixed;
            return { tl: B2, tr: C2, bl: E2, br: P2, tex: { x: a2.paddedRect.x + 1 + L2, y: a2.paddedRect.y + 1 + R2, w: l3.stretch + l3.fixed - L2, h: u3.stretch + u3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: k2 / o2 / c2, minFontScaleY: I2 / o2 / h3, isSDF: r3 };
          };
          if (n2 && (a2.stretchX || a2.stretchY)) {
            const t4 = wh(p2, g2, y2), e4 = wh(d2, x3, m3);
            for (let r4 = 0; r4 < t4.length - 1; r4++) {
              const n3 = t4[r4], i3 = t4[r4 + 1];
              for (let t5 = 0; t5 < e4.length - 1; t5++)
                s4.push(z2(n3, e4[t5], i3, e4[t5 + 1]));
            }
          } else
            s4.push(z2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
          return s4;
        }
        function bh(t3, e3, r3) {
          let n2 = 0;
          for (const i3 of t3)
            n2 += Math.max(e3, Math.min(r3, i3[1])) - Math.max(e3, Math.min(r3, i3[0]));
          return n2;
        }
        function wh(t3, e3, r3) {
          const n2 = [{ fixed: -1, stretch: 0 }];
          for (const [e4, r4] of t3) {
            const t4 = n2[n2.length - 1];
            n2.push({ fixed: e4 - t4.stretch, stretch: t4.stretch }), n2.push({ fixed: e4 - t4.stretch, stretch: t4.stretch + (r4 - e4) });
          }
          return n2.push({ fixed: e3 + 1, stretch: r3 }), n2;
        }
        function _h(t3, e3, r3, n2) {
          return t3 / e3 * r3 + n2;
        }
        function Ah(t3, e3, r3, n2) {
          return t3 - e3 * r3 / n2;
        }
        function kh(t3, e3, r3, n2) {
          const i3 = e3 + t3.positionedLines[n2].lineOffset;
          return n2 === 0 ? r3 + i3 / 2 : r3 + (i3 + (e3 + t3.positionedLines[n2 - 1].lineOffset)) / 2;
        }
        xh.loadGlyphRange = function(t3, e3, r3, n2, i3) {
          const s4 = 256 * e3, a2 = s4 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r3).replace("{fontstack}", t3).replace("{range}", `${s4}-${a2}`), re.Glyphs);
          ae(o2, (t4, e4) => {
            if (t4)
              i3(t4);
            else if (e4) {
              const t5 = {}, r4 = function(t6) {
                return new gc(t6).readFields(Lc, {});
              }(e4);
              for (const e5 of r4.glyphs)
                t5[e5.id] = e5;
              i3(null, { glyphs: t5, ascender: r4.ascender, descender: r4.descender });
            }
          });
        }, xh.TinySDF = class {
          constructor({ fontSize: t3 = 24, buffer: e3 = 3, radius: r3 = 8, cutoff: n2 = 0.25, fontFamily: i3 = "sans-serif", fontWeight: s4 = "normal", fontStyle: a2 = "normal" }) {
            this.buffer = e3, this.cutoff = n2, this.radius = r3;
            const o2 = this.size = t3 + 4 * e3, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
            u2.font = `${a2} ${s4} ${t3}px ${i3}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
          }
          _createCanvas(t3) {
            const e3 = document.createElement("canvas");
            return e3.width = e3.height = t3, e3;
          }
          draw(t3) {
            const { width: e3, actualBoundingBoxAscent: r3, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i3, actualBoundingBoxRight: s4 } = this.ctx.measureText(t3), a2 = Math.floor(r3), o2 = Math.min(this.size - this.buffer, Math.ceil(s4 - i3)), l2 = Math.min(this.size - this.buffer, Math.ceil(r3) + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h3 = u2 * c2, p2 = new Uint8ClampedArray(h3), d2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e3 };
            if (o2 === 0 || l2 === 0)
              return d2;
            const { ctx: f4, buffer: y2, gridInner: m3, gridOuter: g2 } = this;
            f4.clearRect(y2, y2, o2, l2), f4.fillText(t3, y2, y2 + a2 + 1);
            const x3 = f4.getImageData(y2, y2, o2, l2);
            g2.fill(fh, 0, h3), m3.fill(0, 0, h3);
            for (let t4 = 0; t4 < l2; t4++)
              for (let e4 = 0; e4 < o2; e4++) {
                const r4 = x3.data[4 * (t4 * o2 + e4) + 3] / 255;
                if (r4 === 0)
                  continue;
                const n3 = (t4 + y2) * u2 + e4 + y2;
                if (r4 === 1)
                  g2[n3] = 0, m3[n3] = fh;
                else {
                  const t5 = 0.5 - r4;
                  g2[n3] = t5 > 0 ? t5 * t5 : 0, m3[n3] = t5 < 0 ? t5 * t5 : 0;
                }
              }
            yh(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), yh(m3, y2, y2, o2, l2, u2, this.f, this.v, this.z);
            for (let t4 = 0; t4 < h3; t4++) {
              const e4 = Math.sqrt(g2[t4]) - Math.sqrt(m3[t4]);
              p2[t4] = Math.round(255 - 255 * (e4 / this.radius + this.cutoff));
            }
            return d2;
          }
        };
        class Sh {
          constructor(t3 = [], e3 = Ih) {
            if (this.data = t3, this.length = this.data.length, this.compare = e3, this.length > 0)
              for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--)
                this._down(t4);
          }
          push(t3) {
            this.data.push(t3), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (this.length === 0)
              return;
            const t3 = this.data[0], e3 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e3, this._down(0)), t3;
          }
          peek() {
            return this.data[0];
          }
          _up(t3) {
            const { data: e3, compare: r3 } = this, n2 = e3[t3];
            for (; t3 > 0; ) {
              const i3 = t3 - 1 >> 1, s4 = e3[i3];
              if (r3(n2, s4) >= 0)
                break;
              e3[t3] = s4, t3 = i3;
            }
            e3[t3] = n2;
          }
          _down(t3) {
            const { data: e3, compare: r3 } = this, n2 = this.length >> 1, i3 = e3[t3];
            for (; t3 < n2; ) {
              let n3 = 1 + (t3 << 1), s4 = e3[n3];
              const a2 = n3 + 1;
              if (a2 < this.length && r3(e3[a2], s4) < 0 && (n3 = a2, s4 = e3[a2]), r3(s4, i3) >= 0)
                break;
              e3[t3] = s4, t3 = n3;
            }
            e3[t3] = i3;
          }
        }
        function Ih(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        function zh(t3, e3 = 1, r3 = false) {
          let n2 = 1 / 0, s4 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
          const l2 = t3[0];
          for (let t4 = 0; t4 < l2.length; t4++) {
            const e4 = l2[t4];
            (!t4 || e4.x < n2) && (n2 = e4.x), (!t4 || e4.y < s4) && (s4 = e4.y), (!t4 || e4.x > a2) && (a2 = e4.x), (!t4 || e4.y > o2) && (o2 = e4.y);
          }
          const u2 = Math.min(a2 - n2, o2 - s4);
          let c2 = u2 / 2;
          const h3 = new Sh([], Mh);
          if (u2 === 0)
            return new i2(n2, s4);
          for (let e4 = n2; e4 < a2; e4 += u2)
            for (let r4 = s4; r4 < o2; r4 += u2)
              h3.push(new Th(e4 + c2, r4 + c2, c2, t3));
          let p2 = function(t4) {
            let e4 = 0, r4 = 0, n3 = 0;
            const i3 = t4[0];
            for (let t5 = 0, s5 = i3.length, a3 = s5 - 1; t5 < s5; a3 = t5++) {
              const s6 = i3[t5], o3 = i3[a3], l3 = s6.x * o3.y - o3.x * s6.y;
              r4 += (s6.x + o3.x) * l3, n3 += (s6.y + o3.y) * l3, e4 += 3 * l3;
            }
            return new Th(r4 / e4, n3 / e4, 0, t4);
          }(t3), d2 = h3.length;
          for (; h3.length; ) {
            const n3 = h3.pop();
            (n3.d > p2.d || !p2.d) && (p2 = n3, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, d2)), n3.max - p2.d <= e3 || (c2 = n3.h / 2, h3.push(new Th(n3.p.x - c2, n3.p.y - c2, c2, t3)), h3.push(new Th(n3.p.x + c2, n3.p.y - c2, c2, t3)), h3.push(new Th(n3.p.x - c2, n3.p.y + c2, c2, t3)), h3.push(new Th(n3.p.x + c2, n3.p.y + c2, c2, t3)), d2 += 4);
          }
          return r3 && (console.log(`num probes: ${d2}`), console.log(`best distance: ${p2.d}`)), p2.p;
        }
        function Mh(t3, e3) {
          return e3.max - t3.max;
        }
        function Th(t3, e3, r3, n2) {
          this.p = new i2(t3, e3), this.h = r3, this.d = function(t4, e4) {
            let r4 = false, n3 = 1 / 0;
            for (let i3 = 0; i3 < e4.length; i3++) {
              const s4 = e4[i3];
              for (let e5 = 0, i4 = s4.length, a2 = i4 - 1; e5 < i4; a2 = e5++) {
                const i5 = s4[e5], o2 = s4[a2];
                i5.y > t4.y != o2.y > t4.y && t4.x < (o2.x - i5.x) * (t4.y - i5.y) / (o2.y - i5.y) + i5.x && (r4 = !r4), n3 = Math.min(n3, sl(t4, i5, o2));
              }
            }
            return (r4 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        const Bh = Number.POSITIVE_INFINITY, Ch = Math.sqrt(2);
        function Ph(t3, e3) {
          return e3[1] !== Bh ? function(t4, e4, r3) {
            let n2 = 0, i3 = 0;
            switch (e4 = Math.abs(e4), r3 = Math.abs(r3), t4) {
              case "top-right":
              case "top-left":
              case "top":
                i3 = r3 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i3 = 7 - r3;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e4;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e4;
            }
            return [n2, i3];
          }(t3, e3[0], e3[1]) : function(t4, e4) {
            let r3 = 0, n2 = 0;
            e4 < 0 && (e4 = 0);
            const i3 = e4 / Ch;
            switch (t4) {
              case "top-right":
              case "top-left":
                n2 = i3 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = 7 - i3;
                break;
              case "bottom":
                n2 = 7 - e4;
                break;
              case "top":
                n2 = e4 - 7;
            }
            switch (t4) {
              case "top-right":
              case "bottom-right":
                r3 = -i3;
                break;
              case "top-left":
              case "bottom-left":
                r3 = i3;
                break;
              case "left":
                r3 = e4;
                break;
              case "right":
                r3 = -e4;
            }
            return [r3, n2];
          }(t3, e3[0]);
        }
        function Eh(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2) {
          t3.createArrays(), t3.tilePixelRatio = To / (512 * t3.overscaling), t3.compareText = {}, t3.iconsNeedLinear = false;
          const c2 = t3.layers[0].layout, h3 = t3.layers[0]._unevaluatedLayout._values, p2 = {};
          if (t3.textSizeData.kind === "composite") {
            const { minZoom: e4, maxZoom: r4 } = t3.textSizeData;
            p2.compositeTextSizes = [h3["text-size"].possiblyEvaluate(new Gs(e4), o2), h3["text-size"].possiblyEvaluate(new Gs(r4), o2)];
          }
          if (t3.iconSizeData.kind === "composite") {
            const { minZoom: e4, maxZoom: r4 } = t3.iconSizeData;
            p2.compositeIconSizes = [h3["icon-size"].possiblyEvaluate(new Gs(e4), o2), h3["icon-size"].possiblyEvaluate(new Gs(r4), o2)];
          }
          p2.layoutTextSize = h3["text-size"].possiblyEvaluate(new Gs(l2 + 1), o2), p2.layoutIconSize = h3["icon-size"].possiblyEvaluate(new Gs(l2 + 1), o2), p2.textMaxSize = h3["text-size"].possiblyEvaluate(new Gs(18), o2);
          const d2 = c2.get("text-rotation-alignment") === "map" && c2.get("symbol-placement") !== "point", f4 = c2.get("text-size");
          for (const s5 of t3.features) {
            const l3 = c2.get("text-font").evaluate(s5, {}, o2).join(","), h4 = f4.evaluate(s5, {}, o2), y2 = p2.layoutTextSize.evaluate(s5, {}, o2), m3 = (p2.layoutIconSize.evaluate(s5, {}, o2), { horizontal: {}, vertical: void 0 }), g2 = s5.text;
            let x3, v2 = [0, 0];
            if (g2) {
              const n3 = g2.toString(), a3 = c2.get("text-letter-spacing").evaluate(s5, {}, o2) * sc, u3 = c2.get("text-line-height").evaluate(s5, {}, o2) * sc, p3 = Is(n3) ? a3 : 0, f5 = c2.get("text-anchor").evaluate(s5, {}, o2), x4 = c2.get("text-variable-anchor");
              if (!x4) {
                const t4 = c2.get("text-radial-offset").evaluate(s5, {}, o2);
                v2 = t4 ? Ph(f5, [t4 * sc, Bh]) : c2.get("text-offset").evaluate(s5, {}, o2).map((t5) => t5 * sc);
              }
              let b3 = d2 ? "center" : c2.get("text-justify").evaluate(s5, {}, o2);
              const w3 = c2.get("symbol-placement"), _2 = w3 === "point", A3 = w3 === "point" ? c2.get("text-max-width").evaluate(s5, {}, o2) * sc : 0, k2 = (s6) => {
                t3.allowVerticalPlacement && Ss(n3) && (m3.vertical = Zc(g2, e3, r3, i3, l3, A3, u3, f5, s6, p3, v2, qc.vertical, true, w3, y2, h4));
              };
              if (!d2 && x4) {
                const t4 = b3 === "auto" ? x4.map((t5) => Dh(t5)) : [b3];
                let n4 = false;
                for (let s6 = 0; s6 < t4.length; s6++) {
                  const a4 = t4[s6];
                  if (!m3.horizontal[a4])
                    if (n4)
                      m3.horizontal[a4] = m3.horizontal[0];
                    else {
                      const t5 = Zc(g2, e3, r3, i3, l3, A3, u3, "center", a4, p3, v2, qc.horizontal, false, w3, y2, h4);
                      t5 && (m3.horizontal[a4] = t5, n4 = t5.positionedLines.length === 1);
                    }
                }
                k2("left");
              } else {
                if (b3 === "auto" && (b3 = Dh(f5)), _2 || c2.get("text-writing-mode").indexOf("horizontal") >= 0 || !Ss(n3)) {
                  const t4 = Zc(g2, e3, r3, i3, l3, A3, u3, f5, b3, p3, v2, qc.horizontal, false, w3, y2, h4);
                  t4 && (m3.horizontal[b3] = t4);
                }
                k2(w3 === "point" ? "left" : b3);
              }
            }
            let b2 = false;
            if (s5.icon && s5.icon.name) {
              const e4 = n2[s5.icon.name];
              e4 && (x3 = nh(i3[s5.icon.name], c2.get("icon-offset").evaluate(s5, {}, o2), c2.get("icon-anchor").evaluate(s5, {}, o2)), b2 = e4.sdf, t3.sdfIcons === void 0 ? t3.sdfIcons = e4.sdf : t3.sdfIcons !== e4.sdf && pt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e4.pixelRatio !== t3.pixelRatio || c2.get("icon-rotate").constantOr(1) !== 0) && (t3.iconsNeedLinear = true));
            }
            const w2 = Rh(m3.horizontal) || m3.vertical;
            t3.iconsInText || (t3.iconsInText = !!w2 && w2.iconsInText), (w2 || x3) && Vh(t3, s5, m3, x3, n2, p2, y2, 0, v2, b2, a2, o2, u2);
          }
          s4 && t3.generateCollisionDebugBuffers(l2, t3.collisionBoxArray);
        }
        function Dh(t3) {
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Vh(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2) {
          let d2 = s4.textMaxSize.evaluate(e3, {}, h3);
          d2 === void 0 && (d2 = a2);
          const f4 = t3.layers[0].layout, y2 = f4.get("icon-offset").evaluate(e3, {}, h3), m3 = Rh(r3.horizontal) || r3.vertical, g2 = a2 / 24, x3 = t3.tilePixelRatio * d2 / 24, v2 = t3.tilePixelRatio * f4.get("symbol-spacing"), b2 = f4.get("text-padding") * t3.tilePixelRatio, w2 = f4.get("icon-padding") * t3.tilePixelRatio, _2 = q(f4.get("text-max-angle")), A3 = f4.get("text-rotation-alignment") === "map" && f4.get("symbol-placement") !== "point", k2 = f4.get("icon-rotation-alignment") === "map" && f4.get("symbol-placement") !== "point", S3 = f4.get("symbol-placement"), I2 = v2 / 2, z2 = f4.get("icon-text-fit");
          let M2;
          n2 && z2 !== "none" && (t3.allowVerticalPlacement && r3.vertical && (M2 = ih(n2, r3.vertical, z2, f4.get("icon-text-fit-padding"), y2, g2)), m3 && (n2 = ih(n2, m3, z2, f4.get("icon-text-fit-padding"), y2, g2)));
          const T2 = (a3, o3, d3) => {
            if (o3.x < 0 || o3.x >= To || o3.y < 0 || o3.y >= To)
              return;
            const { x: f5, y: m4, z: g3 } = p2.projectTilePoint(o3.x, o3.y, d3), x4 = new sh(f5, m4, g3, 0, void 0);
            !function(t4, e4, r4, n3, i4, s5, a4, o4, l3, u3, c3, h4, p3, d4, f6, y3, m5, g4, x5, v3, b3, w3, _3, A4, k3) {
              const S4 = t4.addToLineVertexArray(e4, n3);
              let I3, z3, M3, T3, B2, C2, P2, E2 = 0, D2 = 0, V2 = 0, F3 = 0, L2 = -1, R2 = -1;
              const U2 = {};
              let $2 = Ja(""), O2 = 0, j2 = 0;
              if (l3._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [O2, j2] = l3.layout.get("text-offset").evaluate(b3, {}, k3).map((t5) => t5 * sc) : (O2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, k3) * sc, j2 = Bh), t4.allowVerticalPlacement && i4.vertical) {
                const t5 = i4.vertical;
                if (f6)
                  C2 = $h(t5), o4 && (P2 = $h(o4));
                else {
                  const n4 = l3.layout.get("text-rotate").evaluate(b3, {}, k3) + 90;
                  M3 = Uh(u3, r4, e4, c3, h4, p3, t5, d4, n4, y3), o4 && (T3 = Uh(u3, r4, e4, c3, h4, p3, o4, g4, n4));
                }
              }
              if (s5) {
                const n4 = l3.layout.get("icon-rotate").evaluate(b3, {}, k3), i5 = l3.layout.get("icon-text-fit") !== "none", a5 = vh(s5, n4, _3, i5), d5 = o4 ? vh(o4, n4, _3, i5) : void 0;
                z3 = Uh(u3, r4, e4, c3, h4, p3, s5, g4, n4), E2 = 4 * a5.length;
                const f7 = t4.iconSizeData;
                let y4 = null;
                f7.kind === "source" ? (y4 = [ac * l3.layout.get("icon-size").evaluate(b3, {}, k3)], y4[0] > Fh && pt(`${t4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : f7.kind === "composite" && (y4 = [ac * w3.compositeIconSizes[0].evaluate(b3, {}, k3), ac * w3.compositeIconSizes[1].evaluate(b3, {}, k3)], (y4[0] > Fh || y4[1] > Fh) && pt(`${t4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t4.addSymbols(t4.icon, a5, y4, v3, x5, b3, false, r4, e4, S4.lineStartIndex, S4.lineLength, -1, A4, k3), L2 = t4.icon.placedSymbolArray.length - 1, d5 && (D2 = 4 * d5.length, t4.addSymbols(t4.icon, d5, y4, v3, x5, b3, qc.vertical, r4, e4, S4.lineStartIndex, S4.lineLength, -1, A4, k3), R2 = t4.icon.placedSymbolArray.length - 1);
              }
              for (const n4 in i4.horizontal) {
                const s6 = i4.horizontal[n4];
                I3 || ($2 = Ja(s6.text), f6 ? B2 = $h(s6) : I3 = Uh(u3, r4, e4, c3, h4, p3, s6, d4, l3.layout.get("text-rotate").evaluate(b3, {}, k3), y3));
                const o5 = s6.positionedLines.length === 1;
                if (V2 += Lh(t4, r4, e4, s6, a4, l3, f6, b3, y3, S4, i4.vertical ? qc.horizontal : qc.horizontalOnly, o5 ? Object.keys(i4.horizontal) : [n4], U2, L2, w3, A4, k3), o5)
                  break;
              }
              i4.vertical && (F3 += Lh(t4, r4, e4, i4.vertical, a4, l3, f6, b3, y3, S4, qc.vertical, ["vertical"], U2, R2, w3, A4, k3));
              let q2 = -1;
              const N2 = (t5, e5) => t5 ? Math.max(t5, e5) : e5;
              q2 = N2(B2, q2), q2 = N2(C2, q2), q2 = N2(P2, q2);
              const G2 = q2 > -1 ? 1 : 0;
              t4.glyphOffsetArray.length >= Yh.MAX_GLYPHS && pt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), b3.sortKey !== void 0 && t4.addToSortKeyRanges(t4.symbolInstances.length, b3.sortKey), t4.symbolInstances.emplaceBack(r4.x, r4.y, r4.z, e4.x, e4.y, U2.right >= 0 ? U2.right : -1, U2.center >= 0 ? U2.center : -1, U2.left >= 0 ? U2.left : -1, U2.vertical >= 0 ? U2.vertical : -1, L2, R2, $2, I3 !== void 0 ? I3 : t4.collisionBoxArray.length, I3 !== void 0 ? I3 + 1 : t4.collisionBoxArray.length, M3 !== void 0 ? M3 : t4.collisionBoxArray.length, M3 !== void 0 ? M3 + 1 : t4.collisionBoxArray.length, z3 !== void 0 ? z3 : t4.collisionBoxArray.length, z3 !== void 0 ? z3 + 1 : t4.collisionBoxArray.length, T3 || t4.collisionBoxArray.length, T3 ? T3 + 1 : t4.collisionBoxArray.length, c3, V2, F3, E2, D2, G2, 0, O2, j2, q2);
            }(t3, o3, x4, a3, r3, n2, i3, M2, t3.layers[0], t3.collisionBoxArray, e3.index, e3.sourceLayerIndex, t3.index, b2, A3, l2, 0, w2, k2, y2, e3, s4, u2, c2, h3);
          };
          if (S3 === "line")
            for (const i4 of dh(e3.geometry, 0, 0, To, To)) {
              const e4 = hh(i4, v2, _2, r3.vertical || m3, n2, 24, x3, t3.overscaling, To);
              for (const r4 of e4) {
                const e5 = m3;
                e5 && Oh(t3, e5.text, I2, r4) || T2(i4, r4, h3);
              }
            }
          else if (S3 === "line-center") {
            for (const t4 of e3.geometry)
              if (t4.length > 1) {
                const e4 = ch(t4, _2, r3.vertical || m3, n2, 24, x3);
                e4 && T2(t4, e4, h3);
              }
          } else if (e3.type === "Polygon")
            for (const t4 of pu(e3.geometry, 0)) {
              const e4 = zh(t4, 16);
              T2(t4[0], new sh(e4.x, e4.y, 0, 0, void 0), h3);
            }
          else if (e3.type === "LineString")
            for (const t4 of e3.geometry)
              T2(t4, new sh(t4[0].x, t4[0].y, 0, 0, void 0), h3);
          else if (e3.type === "Point")
            for (const t4 of e3.geometry)
              for (const e4 of t4)
                T2([e4], new sh(e4.x, e4.y, 0, 0, void 0), h3);
        }
        const Fh = 32640;
        function Lh(t3, e3, r3, n2, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2, m3, g2) {
          const x3 = function(t4, e4, r4, n3, s5, a3, o3, l3) {
            const u3 = [];
            if (e4.positionedLines.length === 0)
              return u3;
            const c3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, h4 = function(t5) {
              const e5 = t5[0], r5 = t5[1], n4 = e5 * r5;
              return n4 > 0 ? [e5, -r5] : n4 < 0 ? [-e5, r5] : e5 === 0 ? [r5, e5] : [r5, -e5];
            }(r4);
            let p3 = Math.abs(e4.top - e4.bottom);
            for (const t5 of e4.positionedLines)
              p3 -= t5.lineOffset;
            const d3 = e4.positionedLines.length, f5 = p3 / d3;
            let y3 = e4.top - r4[1];
            for (let t5 = 0; t5 < d3; ++t5) {
              const n4 = e4.positionedLines[t5];
              y3 = kh(e4, f5, y3, t5);
              for (const t6 of n4.positionedGlyphs) {
                if (!t6.rect)
                  continue;
                const n5 = t6.rect || {};
                let a4 = 4, p4 = true, d4 = 1, f6 = 0;
                if (t6.imageName) {
                  const e5 = o3[t6.imageName];
                  if (!e5)
                    continue;
                  if (e5.sdf) {
                    pt("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  p4 = false, d4 = e5.pixelRatio, a4 = 1 / d4;
                }
                const m4 = (s5 || l3) && t6.vertical, g3 = t6.metrics.advance * t6.scale / 2, x4 = t6.metrics, v3 = t6.rect;
                if (v3 === null)
                  continue;
                l3 && e4.verticalizable && (f6 = t6.imageName ? g3 - t6.metrics.width * t6.scale / 2 : 0);
                const b3 = s5 ? [t6.x + g3, t6.y] : [0, 0];
                let w2 = [0, 0], _2 = [0, 0], A3 = false;
                s5 || (m4 ? (_2 = [t6.x + g3 + h4[0], t6.y + h4[1] - f6], A3 = true) : w2 = [t6.x + g3 + r4[0], t6.y + r4[1] - f6]);
                const k2 = v3.w * t6.scale / (d4 * (t6.localGlyph ? 2 : 1)), S3 = v3.h * t6.scale / (d4 * (t6.localGlyph ? 2 : 1));
                let I2, z2, M2, T2;
                if (m4) {
                  const e5 = t6.y - y3, r5 = new i2(-g3, g3 - e5), n6 = -Math.PI / 2, s6 = new i2(..._2);
                  I2 = new i2(-g3 + w2[0], w2[1]), I2._rotateAround(n6, r5)._add(s6), I2.x += -e5 + g3, I2.y -= (x4.left - a4) * t6.scale;
                  const o4 = t6.imageName ? x4.advance * t6.scale : sc * t6.scale, l4 = String.fromCharCode(t6.glyph);
                  dc(l4) ? I2.x += (1 - a4) * t6.scale : fc(l4) ? I2.x += o4 - x4.height * t6.scale + (-a4 - 1) * t6.scale : I2.x += t6.imageName || x4.width + 2 * a4 === v3.w && x4.height + 2 * a4 === v3.h ? (o4 - S3) / 2 : (o4 - (x4.height + 2 * a4) * t6.scale) / 2, z2 = new i2(I2.x, I2.y - k2), M2 = new i2(I2.x + S3, I2.y), T2 = new i2(I2.x + S3, I2.y - k2);
                } else {
                  const e5 = (x4.left - a4) * t6.scale - g3 + w2[0], r5 = (-x4.top - a4) * t6.scale + w2[1], n6 = e5 + k2, s6 = r5 + S3;
                  I2 = new i2(e5, r5), z2 = new i2(n6, r5), M2 = new i2(e5, s6), T2 = new i2(n6, s6);
                }
                if (c3) {
                  let t7;
                  t7 = s5 ? new i2(0, 0) : A3 ? new i2(h4[0], h4[1]) : new i2(r4[0], r4[1]), I2._rotateAround(c3, t7), z2._rotateAround(c3, t7), M2._rotateAround(c3, t7), T2._rotateAround(c3, t7);
                }
                const B2 = new i2(0, 0), C2 = new i2(0, 0);
                u3.push({ tl: I2, tr: z2, bl: M2, br: T2, tex: n5, writingMode: e4.writingMode, glyphOffset: b3, sectionIndex: t6.sectionIndex, isSDF: p4, pixelOffsetTL: B2, pixelOffsetBR: C2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return u3;
          }(0, n2, u2, a2, o2, l2, s4, t3.allowVerticalPlacement), v2 = t3.textSizeData;
          let b2 = null;
          v2.kind === "source" ? (b2 = [ac * a2.layout.get("text-size").evaluate(l2, {}, g2)], b2[0] > Fh && pt(`${t3.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : v2.kind === "composite" && (b2 = [ac * y2.compositeTextSizes[0].evaluate(l2, {}, g2), ac * y2.compositeTextSizes[1].evaluate(l2, {}, g2)], (b2[0] > Fh || b2[1] > Fh) && pt(`${t3.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t3.addSymbols(t3.text, x3, b2, u2, o2, l2, h3, e3, r3, c2.lineStartIndex, c2.lineLength, f4, m3, g2);
          for (const e4 of p2)
            d2[e4] = t3.text.placedSymbolArray.length - 1;
          return 4 * x3.length;
        }
        function Rh(t3) {
          for (const e3 in t3)
            return t3[e3];
          return null;
        }
        function Uh(t3, e3, r3, n2, s4, a2, o2, l2, u2, c2) {
          let h3 = o2.top, p2 = o2.bottom, d2 = o2.left, f4 = o2.right;
          const y2 = o2.collisionPadding;
          if (y2 && (d2 -= y2[0], h3 -= y2[1], f4 += y2[2], p2 += y2[3]), u2) {
            const t4 = new i2(d2, h3), e4 = new i2(f4, h3), r4 = new i2(d2, p2), n3 = new i2(f4, p2), s5 = q(u2);
            let a3 = new i2(0, 0);
            c2 && (a3 = new i2(c2[0], c2[1])), t4._rotateAround(s5, a3), e4._rotateAround(s5, a3), r4._rotateAround(s5, a3), n3._rotateAround(s5, a3), d2 = Math.min(t4.x, e4.x, r4.x, n3.x), f4 = Math.max(t4.x, e4.x, r4.x, n3.x), h3 = Math.min(t4.y, e4.y, r4.y, n3.y), p2 = Math.max(t4.y, e4.y, r4.y, n3.y);
          }
          return t3.emplaceBack(e3.x, e3.y, e3.z, r3.x, r3.y, d2, h3, f4, p2, l2, n2, s4, a2), t3.length - 1;
        }
        function $h(t3) {
          t3.collisionPadding && (t3.top -= t3.collisionPadding[1], t3.bottom += t3.collisionPadding[3]);
          const e3 = t3.bottom - t3.top;
          return e3 > 0 ? Math.max(10, e3) : null;
        }
        function Oh(t3, e3, r3, n2) {
          const i3 = t3.compareText;
          if (e3 in i3) {
            const t4 = i3[e3];
            for (let e4 = t4.length - 1; e4 >= 0; e4--)
              if (n2.dist(t4[e4]) < r3)
                return true;
          } else
            i3[e3] = [];
          return i3[e3].push(n2), false;
        }
        const jh = Bu.VectorTileFeature.types, qh = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Nh(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2, f4, y2) {
          const m3 = c2 ? Math.min(Fh, Math.round(c2[0])) : 0, g2 = c2 ? Math.min(Fh, Math.round(c2[1])) : 0;
          t3.emplaceBack(e3, r3, Math.round(32 * a2), Math.round(32 * o2), l2, u2, (m3 << 1) + (h3 ? 1 : 0), g2, 16 * p2, 16 * d2, 256 * f4, 256 * y2, n2, i3, s4, 0);
        }
        function Gh(t3, e3, r3) {
          t3.emplaceBack(e3.x, e3.y, r3), t3.emplaceBack(e3.x, e3.y, r3), t3.emplaceBack(e3.x, e3.y, r3), t3.emplaceBack(e3.x, e3.y, r3);
        }
        function Zh(t3) {
          for (const e3 of t3.sections)
            if (Ps(e3.text))
              return true;
          return false;
        }
        class Xh {
          constructor(t3) {
            this.layoutVertexArray = new xa(), this.indexArray = new ka(), this.programConfigurations = t3, this.segments = new Mo(), this.dynamicLayoutVertexArray = new ya(), this.opacityVertexArray = new va(), this.placedSymbolArray = new Ra();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t3, e3, r3, n2) {
            this.isEmpty() || (r3 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Qu.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e3), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, tc.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, qh, true), this.opacityVertexBuffer.itemSize = 1), (r3 || n2) && this.programConfigurations.upload(t3));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Zi("SymbolBuffers", Xh);
        class Kh {
          constructor(t3, e3, r3) {
            this.layoutVertexArray = new t3(), this.layoutAttributes = e3, this.indexArray = new r3(), this.segments = new Mo(), this.collisionVertexArray = new Aa(), this.collisionVertexArrayExt = new ya();
          }
          upload(t3) {
            this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, ec.members, true), this.collisionVertexBufferExt = t3.createVertexBuffer(this.collisionVertexArrayExt, rc.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        Zi("CollisionBuffers", Kh);
        class Yh {
          constructor(t3) {
            this.collisionBoxArray = t3.collisionBoxArray, this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.pixelRatio = t3.pixelRatio, this.sourceLayerIndex = t3.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = c([]), this.placementViewportMatrix = c([]);
            const e3 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = oc(this.zoom, e3["text-size"]), this.iconSizeData = oc(this.zoom, e3["icon-size"]);
            const r3 = this.layers[0].layout, n2 = r3.get("symbol-sort-key"), i3 = r3.get("symbol-z-order");
            this.canOverlap = r3.get("text-allow-overlap") || r3.get("icon-allow-overlap") || r3.get("text-ignore-placement") || r3.get("icon-ignore-placement"), this.sortFeaturesByKey = i3 !== "viewport-y" && n2.constantOr(1) !== void 0, this.sortFeaturesByY = (i3 === "viewport-y" || i3 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r3.get("text-writing-mode").map((t4) => qc[t4]), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.sourceID = t3.sourceID;
          }
          createArrays() {
            this.text = new Xh(new xo(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new Xh(new xo(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new Oa(), this.lineVertexArray = new ja(), this.symbolInstances = new $a();
          }
          calculateGlyphDependencies(t3, e3, r3, n2, i3) {
            for (let r4 = 0; r4 < t3.length; r4++)
              if (e3[t3.charCodeAt(r4)] = true, n2 && i3) {
                const n3 = pc[t3.charAt(r4)];
                n3 && (e3[n3.charCodeAt(0)] = true);
              }
          }
          populate(t3, e3, r3, n2) {
            const i3 = this.layers[0], s4 = i3.layout, a2 = s4.get("text-font"), o2 = s4.get("text-field"), l2 = s4.get("icon-image"), u2 = (o2.value.kind !== "constant" || o2.value.value instanceof Ke && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && (a2.value.kind !== "constant" || a2.value.value.length > 0), c2 = l2.value.kind !== "constant" || !!l2.value.value || Object.keys(l2.parameters).length > 0, h3 = s4.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2)
              return;
            const p2 = e3.iconDependencies, d2 = e3.glyphDependencies, f4 = e3.availableImages, y2 = new Gs(this.zoom);
            for (const { feature: e4, id: o3, index: l3, sourceLayerIndex: m3 } of t3) {
              const t4 = i3._featureFilter.needGeometry, g2 = Yo(e4, t4);
              if (!i3._featureFilter.filter(y2, g2, r3))
                continue;
              let x3, v2;
              if (t4 || (g2.geometry = Ko(e4, r3, n2)), u2) {
                const t5 = i3.getValueAndResolveTokens("text-field", g2, r3, f4), e5 = Ke.factory(t5);
                Zh(e5) && (this.hasRTLText = true), (!this.hasRTLText || js4() === "unavailable" || this.hasRTLText && Ns.isParsed()) && (x3 = hc(e5, i3, g2));
              }
              if (c2) {
                const t5 = i3.getValueAndResolveTokens("icon-image", g2, r3, f4);
                v2 = t5 instanceof Ye ? t5 : Ye.fromString(t5);
              }
              if (!x3 && !v2)
                continue;
              const b2 = this.sortFeaturesByKey ? h3.evaluate(g2, {}, r3) : void 0;
              if (this.features.push({ id: o3, text: x3, icon: v2, index: l3, sourceLayerIndex: m3, geometry: g2.geometry, properties: e4.properties, type: jh[e4.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x3) {
                const t5 = a2.evaluate(g2, {}, r3).join(","), e5 = s4.get("text-rotation-alignment") === "map" && s4.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(qc.vertical) >= 0;
                for (const r4 of x3.sections)
                  if (r4.image)
                    p2[r4.image.name] = true;
                  else {
                    const n3 = Ss(x3.toString()), i4 = r4.fontStack || t5, s5 = d2[i4] = d2[i4] || {};
                    this.calculateGlyphDependencies(r4.text, s5, e5, this.allowVerticalPlacement, n3);
                  }
              }
            }
            s4.get("symbol-placement") === "line" && (this.features = function(t4) {
              const e4 = {}, r4 = {}, n3 = [];
              let i4 = 0;
              function s5(e5) {
                n3.push(t4[e5]), i4++;
              }
              function a3(t5, e5, i5) {
                const s6 = r4[t5];
                return delete r4[t5], r4[e5] = s6, n3[s6].geometry[0].pop(), n3[s6].geometry[0] = n3[s6].geometry[0].concat(i5[0]), s6;
              }
              function o3(t5, r5, i5) {
                const s6 = e4[r5];
                return delete e4[r5], e4[t5] = s6, n3[s6].geometry[0].shift(), n3[s6].geometry[0] = i5[0].concat(n3[s6].geometry[0]), s6;
              }
              function l3(t5, e5, r5) {
                const n4 = r5 ? e5[0][e5[0].length - 1] : e5[0][0];
                return `${t5}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t4.length; u3++) {
                const c3 = t4[u3], h4 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s5(u3);
                  continue;
                }
                const d3 = l3(p3, h4), f5 = l3(p3, h4, true);
                if (d3 in r4 && f5 in e4 && r4[d3] !== e4[f5]) {
                  const t5 = o3(d3, f5, h4), i5 = a3(d3, f5, n3[t5].geometry);
                  delete e4[d3], delete r4[f5], r4[l3(p3, n3[i5].geometry, true)] = i5, n3[t5].geometry = null;
                } else
                  d3 in r4 ? a3(d3, f5, h4) : f5 in e4 ? o3(d3, f5, h4) : (s5(u3), e4[d3] = i4 - 1, r4[f5] = i4 - 1);
              }
              return n3.filter((t5) => t5.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t4, e4) => t4.sortKey - e4.sortKey);
          }
          update(t3, e3, r3, n2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e3, this.layers, r3, n2), this.icon.programConfigurations.updatePaintArrays(t3, e3, this.layers, r3, n2));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t3) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t3, e3) {
            const r3 = this.lineVertexArray.length;
            if (t3.segment !== void 0) {
              let r4 = t3.dist(e3[t3.segment + 1]), n2 = t3.dist(e3[t3.segment]);
              const i3 = {};
              for (let n3 = t3.segment + 1; n3 < e3.length; n3++)
                i3[n3] = { x: e3[n3].x, y: e3[n3].y, tileUnitDistanceFromAnchor: r4 }, n3 < e3.length - 1 && (r4 += e3[n3 + 1].dist(e3[n3]));
              for (let r5 = t3.segment || 0; r5 >= 0; r5--)
                i3[r5] = { x: e3[r5].x, y: e3[r5].y, tileUnitDistanceFromAnchor: n2 }, r5 > 0 && (n2 += e3[r5 - 1].dist(e3[r5]));
              for (let t4 = 0; t4 < e3.length; t4++) {
                const e4 = i3[t4];
                this.lineVertexArray.emplaceBack(e4.x, e4.y, e4.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
          }
          addSymbols(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2, h3, p2, d2) {
            const f4 = t3.indexArray, y2 = t3.layoutVertexArray, m3 = t3.segments.prepareSegment(4 * e3.length, y2, f4, this.canOverlap ? s4.sortKey : void 0), g2 = this.glyphOffsetArray.length, x3 = m3.vertexLength, v2 = this.allowVerticalPlacement && a2 === qc.vertical ? Math.PI / 2 : 0, b2 = s4.text && s4.text.sections;
            for (let n3 = 0; n3 < e3.length; n3++) {
              const { tl: i4, tr: a3, bl: u3, br: c3, tex: h4, pixelOffsetTL: g3, pixelOffsetBR: x4, minFontScaleX: w2, minFontScaleY: _2, glyphOffset: A3, isSDF: k2, sectionIndex: S3 } = e3[n3], I2 = m3.vertexLength, z2 = A3[1];
              Nh(y2, o2.x, o2.y, o2.z, l2.x, l2.y, i4.x, z2 + i4.y, h4.x, h4.y, r3, k2, g3.x, g3.y, w2, _2), Nh(y2, o2.x, o2.y, o2.z, l2.x, l2.y, a3.x, z2 + a3.y, h4.x + h4.w, h4.y, r3, k2, x4.x, g3.y, w2, _2), Nh(y2, o2.x, o2.y, o2.z, l2.x, l2.y, u3.x, z2 + u3.y, h4.x, h4.y + h4.h, r3, k2, g3.x, x4.y, w2, _2), Nh(y2, o2.x, o2.y, o2.z, l2.x, l2.y, c3.x, z2 + c3.y, h4.x + h4.w, h4.y + h4.h, r3, k2, x4.x, x4.y, w2, _2), Gh(t3.dynamicLayoutVertexArray, o2, v2), f4.emplaceBack(I2, I2 + 1, I2 + 2), f4.emplaceBack(I2 + 1, I2 + 2, I2 + 3), m3.vertexLength += 4, m3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(A3[0]), n3 !== e3.length - 1 && S3 === e3[n3 + 1].sectionIndex || t3.programConfigurations.populatePaintArrays(y2.length, s4, s4.index, {}, p2, d2, b2 && b2[S3]);
            }
            t3.placedSymbolArray.emplaceBack(o2.x, o2.y, o2.z, l2.x, l2.y, g2, this.glyphOffsetArray.length - g2, x3, u2, c2, l2.segment, r3 ? r3[0] : 0, r3 ? r3[1] : 0, n2[0], n2[1], a2, 0, false, 0, h3, 0);
          }
          _commitLayoutVertex(t3, e3, r3, n2, i3, s4, a2) {
            t3.emplaceBack(e3, r3, n2, i3, s4, Math.round(a2.x), Math.round(a2.y));
          }
          _addCollisionDebugVertices(t3, e3, r3, n2, s4, a2, o2) {
            const l2 = r3.segments.prepareSegment(4, r3.layoutVertexArray, r3.indexArray), u2 = l2.vertexLength, c2 = o2.tileAnchorX, h3 = o2.tileAnchorY;
            for (let t4 = 0; t4 < 4; t4++)
              r3.collisionVertexArray.emplaceBack(0, 0, 0, 0);
            r3.collisionVertexArrayExt.emplaceBack(e3, -t3.padding, -t3.padding), r3.collisionVertexArrayExt.emplaceBack(e3, t3.padding, -t3.padding), r3.collisionVertexArrayExt.emplaceBack(e3, t3.padding, t3.padding), r3.collisionVertexArrayExt.emplaceBack(e3, -t3.padding, t3.padding), this._commitLayoutVertex(r3.layoutVertexArray, n2, s4, a2, c2, h3, new i2(t3.x1, t3.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n2, s4, a2, c2, h3, new i2(t3.x2, t3.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n2, s4, a2, c2, h3, new i2(t3.x2, t3.y2)), this._commitLayoutVertex(r3.layoutVertexArray, n2, s4, a2, c2, h3, new i2(t3.x1, t3.y2)), l2.vertexLength += 4;
            const p2 = r3.indexArray;
            p2.emplaceBack(u2, u2 + 1), p2.emplaceBack(u2 + 1, u2 + 2), p2.emplaceBack(u2 + 2, u2 + 3), p2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t3, e3, r3, n2, i3, s4) {
            for (let a2 = n2; a2 < i3; a2++) {
              const n3 = r3.get(a2), i4 = this.getSymbolInstanceTextSize(t3, s4, e3, a2);
              this._addCollisionDebugVertices(n3, i4, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s4);
            }
          }
          _addIconDebugCollisionBoxes(t3, e3, r3, n2, i3, s4) {
            for (let a2 = n2; a2 < i3; a2++) {
              const n3 = r3.get(a2), i4 = this.getSymbolInstanceIconSize(t3, e3, a2);
              this._addCollisionDebugVertices(n3, i4, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s4);
            }
          }
          generateCollisionDebugBuffers(t3, e3) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Kh(wa, nc.members, Ca), this.iconCollisionBox = new Kh(wa, nc.members, Ca);
            const r3 = uc(this.iconSizeData, t3), n2 = uc(this.textSizeData, t3);
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const s4 = this.symbolInstances.get(i3);
              this._addTextDebugCollisionBoxes(n2, t3, e3, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._addTextDebugCollisionBoxes(n2, t3, e3, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r3, t3, e3, s4.iconBoxStartIndex, s4.iconBoxEndIndex, s4), this._addIconDebugCollisionBoxes(r3, t3, e3, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex, s4);
            }
          }
          getSymbolInstanceTextSize(t3, e3, r3, n2) {
            const i3 = this.text.placedSymbolArray.get(e3.rightJustifiedTextSymbolIndex >= 0 ? e3.rightJustifiedTextSymbolIndex : e3.centerJustifiedTextSymbolIndex >= 0 ? e3.centerJustifiedTextSymbolIndex : e3.leftJustifiedTextSymbolIndex >= 0 ? e3.leftJustifiedTextSymbolIndex : e3.verticalPlacedTextSymbolIndex >= 0 ? e3.verticalPlacedTextSymbolIndex : n2), s4 = lc(this.textSizeData, t3, i3) / sc;
            return this.tilePixelRatio * s4;
          }
          getSymbolInstanceIconSize(t3, e3, r3) {
            const n2 = this.icon.placedSymbolArray.get(r3), i3 = lc(this.iconSizeData, t3, n2);
            return this.tilePixelRatio * i3;
          }
          _commitDebugCollisionVertexUpdate(t3, e3, r3) {
            t3.emplaceBack(e3, -r3, -r3), t3.emplaceBack(e3, r3, -r3), t3.emplaceBack(e3, r3, r3), t3.emplaceBack(e3, -r3, r3);
          }
          _updateTextDebugCollisionBoxes(t3, e3, r3, n2, i3, s4) {
            for (let a2 = n2; a2 < i3; a2++) {
              const n3 = r3.get(a2), i4 = this.getSymbolInstanceTextSize(t3, s4, e3, a2);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i4, n3.padding);
            }
          }
          _updateIconDebugCollisionBoxes(t3, e3, r3, n2, i3) {
            for (let s4 = n2; s4 < i3; s4++) {
              const n3 = r3.get(s4), i4 = this.getSymbolInstanceIconSize(t3, e3, s4);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i4, n3.padding);
            }
          }
          updateCollisionDebugBuffers(t3, e3) {
            if (!this.hasDebugData())
              return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const r3 = uc(this.iconSizeData, t3), n2 = uc(this.textSizeData, t3);
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const s4 = this.symbolInstances.get(i3);
              this._updateTextDebugCollisionBoxes(n2, t3, e3, s4.textBoxStartIndex, s4.textBoxEndIndex, s4), this._updateTextDebugCollisionBoxes(n2, t3, e3, s4.verticalTextBoxStartIndex, s4.verticalTextBoxEndIndex, s4), this._updateIconDebugCollisionBoxes(r3, t3, e3, s4.iconBoxStartIndex, s4.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r3, t3, e3, s4.verticalIconBoxStartIndex, s4.verticalIconBoxEndIndex);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
            const u2 = {};
            for (let n3 = e3; n3 < r3; n3++) {
              const e4 = t3.get(n3);
              u2.textBox = { x1: e4.x1, y1: e4.y1, x2: e4.x2, y2: e4.y2, padding: e4.padding, projectedAnchorX: e4.projectedAnchorX, projectedAnchorY: e4.projectedAnchorY, projectedAnchorZ: e4.projectedAnchorZ, tileAnchorX: e4.tileAnchorX, tileAnchorY: e4.tileAnchorY }, u2.textFeatureIndex = e4.featureIndex;
              break;
            }
            for (let e4 = n2; e4 < i3; e4++) {
              const r4 = t3.get(e4);
              u2.verticalTextBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, projectedAnchorX: r4.projectedAnchorX, projectedAnchorY: r4.projectedAnchorY, projectedAnchorZ: r4.projectedAnchorZ, tileAnchorX: r4.tileAnchorX, tileAnchorY: r4.tileAnchorY }, u2.verticalTextFeatureIndex = r4.featureIndex;
              break;
            }
            for (let e4 = s4; e4 < a2; e4++) {
              const r4 = t3.get(e4);
              u2.iconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, projectedAnchorX: r4.projectedAnchorX, projectedAnchorY: r4.projectedAnchorY, projectedAnchorZ: r4.projectedAnchorZ, tileAnchorX: r4.tileAnchorX, tileAnchorY: r4.tileAnchorY }, u2.iconFeatureIndex = r4.featureIndex;
              break;
            }
            for (let e4 = o2; e4 < l2; e4++) {
              const r4 = t3.get(e4);
              u2.verticalIconBox = { x1: r4.x1, y1: r4.y1, x2: r4.x2, y2: r4.y2, padding: r4.padding, projectedAnchorX: r4.projectedAnchorX, projectedAnchorY: r4.projectedAnchorY, projectedAnchorZ: r4.projectedAnchorZ, tileAnchorX: r4.tileAnchorX, tileAnchorY: r4.tileAnchorY }, u2.verticalIconFeatureIndex = r4.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t3) {
            this.collisionArrays = [];
            for (let e3 = 0; e3 < this.symbolInstances.length; e3++) {
              const r3 = this.symbolInstances.get(e3);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t3, e3) {
            const r3 = t3.placedSymbolArray.get(e3), n2 = r3.vertexStartIndex + 4 * r3.numGlyphs;
            for (let e4 = r3.vertexStartIndex; e4 < n2; e4 += 4)
              t3.indexArray.emplaceBack(e4, e4 + 1, e4 + 2), t3.indexArray.emplaceBack(e4 + 1, e4 + 2, e4 + 3);
          }
          getSortedSymbolIndexes(t3) {
            if (this.sortedAngle === t3 && this.symbolInstanceIndexes !== void 0)
              return this.symbolInstanceIndexes;
            const e3 = Math.sin(t3), r3 = Math.cos(t3), n2 = [], i3 = [], s4 = [];
            for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
              s4.push(t4);
              const a2 = this.symbolInstances.get(t4);
              n2.push(0 | Math.round(e3 * a2.tileAnchorX + r3 * a2.tileAnchorY)), i3.push(a2.featureIndex);
            }
            return s4.sort((t4, e4) => n2[t4] - n2[e4] || i3[e4] - i3[t4]), s4;
          }
          addToSortKeyRanges(t3, e3) {
            const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r3 && r3.sortKey === e3 ? r3.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e3, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
          }
          sortFeatures(t3) {
            if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t4 of this.symbolInstanceIndexes) {
                const e3 = this.symbolInstances.get(t4);
                this.featureSortOrder.push(e3.featureIndex), [e3.rightJustifiedTextSymbolIndex, e3.centerJustifiedTextSymbolIndex, e3.leftJustifiedTextSymbolIndex].forEach((t5, e4, r3) => {
                  t5 >= 0 && r3.indexOf(t5) === e4 && this.addIndicesForPlacedSymbol(this.text, t5);
                }), e3.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e3.verticalPlacedTextSymbolIndex), e3.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.placedIconSymbolIndex), e3.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        Zi("SymbolBucket", Yh, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Yh.MAX_GLYPHS = 65535, Yh.addDynamicAttributes = Gh;
        const Hh = new sa({ "symbol-placement": new ta(ve.layout_symbol["symbol-placement"]), "symbol-spacing": new ta(ve.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ta(ve.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ea(ve.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ta(ve.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ta(ve.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new ta(ve.layout_symbol["icon-ignore-placement"]), "icon-optional": new ta(ve.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ta(ve.layout_symbol["icon-rotation-alignment"]), "icon-size": new ea(ve.layout_symbol["icon-size"]), "icon-text-fit": new ta(ve.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ta(ve.layout_symbol["icon-text-fit-padding"]), "icon-image": new ea(ve.layout_symbol["icon-image"]), "icon-rotate": new ea(ve.layout_symbol["icon-rotate"]), "icon-padding": new ta(ve.layout_symbol["icon-padding"]), "icon-keep-upright": new ta(ve.layout_symbol["icon-keep-upright"]), "icon-offset": new ea(ve.layout_symbol["icon-offset"]), "icon-anchor": new ea(ve.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ta(ve.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ta(ve.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ta(ve.layout_symbol["text-rotation-alignment"]), "text-field": new ea(ve.layout_symbol["text-field"]), "text-font": new ea(ve.layout_symbol["text-font"]), "text-size": new ea(ve.layout_symbol["text-size"]), "text-max-width": new ea(ve.layout_symbol["text-max-width"]), "text-line-height": new ea(ve.layout_symbol["text-line-height"]), "text-letter-spacing": new ea(ve.layout_symbol["text-letter-spacing"]), "text-justify": new ea(ve.layout_symbol["text-justify"]), "text-radial-offset": new ea(ve.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ta(ve.layout_symbol["text-variable-anchor"]), "text-anchor": new ea(ve.layout_symbol["text-anchor"]), "text-max-angle": new ta(ve.layout_symbol["text-max-angle"]), "text-writing-mode": new ta(ve.layout_symbol["text-writing-mode"]), "text-rotate": new ea(ve.layout_symbol["text-rotate"]), "text-padding": new ta(ve.layout_symbol["text-padding"]), "text-keep-upright": new ta(ve.layout_symbol["text-keep-upright"]), "text-transform": new ea(ve.layout_symbol["text-transform"]), "text-offset": new ea(ve.layout_symbol["text-offset"]), "text-allow-overlap": new ta(ve.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new ta(ve.layout_symbol["text-ignore-placement"]), "text-optional": new ta(ve.layout_symbol["text-optional"]) });
        var Jh = { paint: new sa({ "icon-opacity": new ea(ve.paint_symbol["icon-opacity"]), "icon-color": new ea(ve.paint_symbol["icon-color"]), "icon-halo-color": new ea(ve.paint_symbol["icon-halo-color"]), "icon-halo-width": new ea(ve.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ea(ve.paint_symbol["icon-halo-blur"]), "icon-translate": new ta(ve.paint_symbol["icon-translate"]), "icon-translate-anchor": new ta(ve.paint_symbol["icon-translate-anchor"]), "text-opacity": new ea(ve.paint_symbol["text-opacity"]), "text-color": new ea(ve.paint_symbol["text-color"], { runtimeType: Ce, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new ea(ve.paint_symbol["text-halo-color"]), "text-halo-width": new ea(ve.paint_symbol["text-halo-width"]), "text-halo-blur": new ea(ve.paint_symbol["text-halo-blur"]), "text-translate": new ta(ve.paint_symbol["text-translate"]), "text-translate-anchor": new ta(ve.paint_symbol["text-translate-anchor"]) }), layout: Hh };
        class Wh {
          constructor(t3) {
            this.type = t3.property.overrides ? t3.property.overrides.runtimeType : ze, this.defaultValue = t3;
          }
          evaluate(t3) {
            if (t3.formattedSection) {
              const e3 = this.defaultValue.property.overrides;
              if (e3 && e3.hasOverride(t3.formattedSection))
                return e3.getOverride(t3.formattedSection);
            }
            return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t3) {
            this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Zi("FormatSectionOverride", Wh, { omit: ["defaultValue"] });
        class Qh extends So {
          constructor(t3) {
            super(t3, Jh);
          }
          recalculate(t3, e3) {
            super.recalculate(t3, e3), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r3 = this.layout.get("text-writing-mode");
            if (r3) {
              const t4 = [];
              for (const e4 of r3)
                t4.indexOf(e4) < 0 && t4.push(e4);
              this.layout._values["text-writing-mode"] = t4;
            } else
              this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t3, e3, r3, n2) {
            const i3 = this.layout.get(t3).evaluate(e3, {}, r3, n2), s4 = this._unevaluatedLayout._values[t3];
            return s4.isDataDriven() || Nn(s4.value) || !i3 ? i3 : function(t4, e4) {
              return e4.replace(/{([^{}]+)}/g, (e5, r4) => r4 in t4 ? String(t4[r4]) : "");
            }(e3.properties, i3);
          }
          createBucket(t3) {
            return new Yh(t3);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t3 of Jh.paint.overridableProperties) {
              if (!Qh.hasPaintOverride(this.layout, t3))
                continue;
              const e3 = this.paint.get(t3), r3 = new Wh(e3), n2 = new qn(r3, e3.property.specification);
              let i3 = null;
              i3 = e3.value.kind === "constant" || e3.value.kind === "source" ? new Zn("source", n2) : new Xn("composite", n2, e3.value.zoomStops, e3.value._interpolationType), this.paint._values[t3] = new Ws(e3.property, i3, e3.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t3, e3, r3) {
            return !(!this.layout || e3.isDataDriven() || r3.isDataDriven()) && Qh.hasPaintOverride(this.layout, t3);
          }
          static hasPaintOverride(t3, e3) {
            const r3 = t3.get("text-field"), n2 = Jh.paint.properties[e3];
            let i3 = false;
            const s4 = (t4) => {
              for (const e4 of t4)
                if (n2.overrides && n2.overrides.hasOverride(e4))
                  return void (i3 = true);
            };
            if (r3.value.kind === "constant" && r3.value.value instanceof Ke)
              s4(r3.value.value.sections);
            else if (r3.value.kind === "source") {
              const t4 = (e5) => {
                i3 || (e5 instanceof tr && We(e5.value) === Ve ? s4(e5.value.sections) : e5 instanceof ir ? s4(e5.sections) : e5.eachChild(t4));
              }, e4 = r3.value;
              e4._styleExpression && t4(e4._styleExpression.expression);
            }
            return i3;
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
        }
        var tp = { paint: new sa({ "background-color": new ta(ve.paint_background["background-color"]), "background-pattern": new na(ve.paint_background["background-pattern"]), "background-opacity": new ta(ve.paint_background["background-opacity"]) }) }, ep = { paint: new sa({ "raster-opacity": new ta(ve.paint_raster["raster-opacity"]), "raster-hue-rotate": new ta(ve.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ta(ve.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ta(ve.paint_raster["raster-brightness-max"]), "raster-saturation": new ta(ve.paint_raster["raster-saturation"]), "raster-contrast": new ta(ve.paint_raster["raster-contrast"]), "raster-resampling": new ta(ve.paint_raster["raster-resampling"]), "raster-fade-duration": new ta(ve.paint_raster["raster-fade-duration"]) }) };
        class rp extends So {
          constructor(t3) {
            super(t3, {}), this.implementation = t3;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
          }
          serialize() {
          }
          onAdd(t3) {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }
          onRemove(t3) {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }
        }
        var np = { paint: new sa({ "sky-type": new ta(ve.paint_sky["sky-type"]), "sky-atmosphere-sun": new ta(ve.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new ta(ve.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new ta(ve.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new ta(ve.paint_sky["sky-gradient-radius"]), "sky-gradient": new ia(ve.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new ta(ve.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new ta(ve.paint_sky["sky-atmosphere-color"]), "sky-opacity": new ta(ve.paint_sky["sky-opacity"]) }) };
        function ip(t3, e3, r3) {
          const n2 = b(0, 0, 1), i3 = R(L());
          return function(t4, e4, r4) {
            r4 *= 0.5;
            var n3 = e4[0], i4 = e4[1], s4 = e4[2], a2 = e4[3], o2 = Math.sin(r4), l2 = Math.cos(r4);
            t4[0] = n3 * l2 - s4 * o2, t4[1] = i4 * l2 + a2 * o2, t4[2] = s4 * l2 + n3 * o2, t4[3] = a2 * l2 - i4 * o2;
          }(i3, i3, r3 ? -q(t3) + Math.PI : q(t3)), U(i3, i3, -q(e3)), C(n2, n2, i3), z(n2, n2);
        }
        const sp = { circle: class extends So {
          constructor(t3) {
            super(t3, yl);
          }
          createBucket(t3) {
            return new Jo(t3);
          }
          queryRadius(t3) {
            const e3 = t3;
            return cl("circle-radius", this, e3) + cl("circle-stroke-width", this, e3) + hl(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t3, e3, r3, n2, i3, s4, a2, o2) {
            const l2 = dl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s4.angle, t3.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e3, r3) + this.paint.get("circle-stroke-width").evaluate(e3, r3);
            return xl(t3, n2, s4, a2, o2, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", l2, u2);
          }
          getProgramIds() {
            return ["circle"];
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
        }, heatmap: class extends So {
          createBucket(t3) {
            return new Al(t3);
          }
          constructor(t3) {
            super(t3, Tl), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            t3 === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Bl({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(t3) {
            return cl("heatmap-radius", this, t3);
          }
          queryIntersectsFeature(t3, e3, r3, n2, s4, a2, o2, l2) {
            const u2 = this.paint.get("heatmap-radius").evaluate(e3, r3);
            return xl(t3, n2, a2, o2, l2, true, true, new i2(0, 0), u2);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
        }, hillshade: class extends So {
          constructor(t3) {
            super(t3, Cl);
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
        }, fill: class extends So {
          constructor(t3) {
            super(t3, xu);
          }
          getProgramIds() {
            const t3 = this.paint.get("fill-pattern"), e3 = t3 && t3.constantOr(1), r3 = [e3 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r3.push(e3 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r3;
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
          recalculate(t3, e3) {
            super.recalculate(t3, e3);
            const r3 = this.paint._values["fill-outline-color"];
            r3.value.kind === "constant" && r3.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t3) {
            return new mu(t3);
          }
          queryRadius() {
            return hl(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t3, e3, r3, n2, i3, s4) {
            return !t3.queryGeometry.isAboveHorizon && tl(pl(t3.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s4.angle, t3.pixelToTileUnitsFactor), n2);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends So {
          constructor(t3) {
            super(t3, Lu);
          }
          createBucket(t3) {
            return new Vu(t3);
          }
          queryRadius() {
            return hl(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
          queryIntersectsFeature(t3, e3, r3, n2, s4, a2, o2, l2, u2) {
            const c2 = dl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, t3.pixelToTileUnitsFactor), h3 = this.paint.get("fill-extrusion-height").evaluate(e3, r3), p2 = this.paint.get("fill-extrusion-base").evaluate(e3, r3), d2 = [0, 0], f4 = l2 && a2.elevation, y2 = a2.elevation ? a2.elevation.exaggeration() : 1;
            if (f4) {
              const e4 = t3.tile.getBucket(this).centroidVertexArray, r4 = u2 + 1;
              if (r4 < e4.length) {
                const t4 = e4.get(r4);
                d2[0] = t4.a_centroid_pos0, d2[1] = t4.a_centroid_pos1;
              }
            }
            if (d2[0] === 0 && d2[1] === 1)
              return false;
            const m3 = function(t4, e4, r4, n3, s5, a3, o3, l3, u3) {
              return a3 ? function(t5, e5, r5, n4, i3, s6, a4, o4, l4) {
                const u4 = [], c3 = [], h4 = [0, 0, 0, 1];
                for (const p3 of t5) {
                  const t6 = [], d3 = [];
                  for (const u5 of p3) {
                    const c4 = u5.x + n4.x, p4 = u5.y + n4.y, f5 = Ou(c4, p4, e5, r5, s6, a4, o4, l4);
                    h4[0] = c4, h4[1] = p4, h4[2] = f5.base, h4[3] = 1, F2(h4, h4, i3), h4[3] = Math.max(h4[3], 1e-5);
                    const y3 = $u([h4[0] / h4[3], h4[1] / h4[3], h4[2] / h4[3]]);
                    h4[0] = c4, h4[1] = p4, h4[2] = f5.top, h4[3] = 1, F2(h4, h4, i3), h4[3] = Math.max(h4[3], 1e-5);
                    const m4 = $u([h4[0] / h4[3], h4[1] / h4[3], h4[2] / h4[3]]);
                    t6.push(y3), d3.push(m4);
                  }
                  u4.push(t6), c3.push(d3);
                }
                return [u4, c3];
              }(t4, e4, r4, n3, s5, a3, o3, l3, u3) : function(t5, e5, r5, n4, s6) {
                const a4 = [], o4 = [], l4 = s6[8] * e5, u4 = s6[9] * e5, c3 = s6[10] * e5, h4 = s6[11] * e5, p3 = s6[8] * r5, d3 = s6[9] * r5, f5 = s6[10] * r5, y3 = s6[11] * r5;
                for (const e6 of t5) {
                  const t6 = [], r6 = [];
                  for (const a5 of e6) {
                    const e7 = a5.x + n4.x, o5 = a5.y + n4.y, m4 = s6[0] * e7 + s6[4] * o5 + s6[12], g3 = s6[1] * e7 + s6[5] * o5 + s6[13], x3 = s6[2] * e7 + s6[6] * o5 + s6[14], v2 = s6[3] * e7 + s6[7] * o5 + s6[15], b2 = m4 + l4, w2 = g3 + u4, _2 = x3 + c3, A3 = Math.max(v2 + h4, 1e-5), k2 = m4 + p3, S3 = g3 + d3, I2 = x3 + f5, z2 = Math.max(v2 + y3, 1e-5), M2 = new i2(b2 / A3, w2 / A3);
                    M2.z = _2 / A3, t6.push(M2);
                    const T2 = new i2(k2 / z2, S3 / z2);
                    T2.z = I2 / z2, r6.push(T2);
                  }
                  a4.push(t6), o4.push(r6);
                }
                return [a4, o4];
              }(t4, e4, r4, n3, s5);
            }(n2, p2, h3, c2, o2, f4 ? l2 : null, d2, y2, a2.center.lat), g2 = t3.queryGeometry;
            return function(t4, e4, r4) {
              let n3 = 1 / 0;
              tl(r4, e4) && (n3 = Uu(r4, e4[0]));
              for (let i3 = 0; i3 < e4.length; i3++) {
                const s5 = e4[i3], a3 = t4[i3];
                for (let t5 = 0; t5 < s5.length - 1; t5++) {
                  const e5 = s5[t5], i4 = [e5, s5[t5 + 1], a3[t5 + 1], a3[t5], e5];
                  Wo(r4, i4) && (n3 = Math.min(n3, Uu(r4, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(m3[0], m3[1], g2.isPointQuery() ? g2.screenBounds : g2.screenGeometry);
          }
        }, line: class extends So {
          constructor(t3) {
            super(t3, Hu), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            if (t3 === "line-gradient") {
              const t4 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t4._styleExpression && t4._styleExpression.expression instanceof Fr, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t3, e3) {
            super.recalculate(t3, e3), this.paint._values["line-floorwidth"] = Ju.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
          }
          createBucket(t3) {
            return new Ku(t3);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getProgramConfiguration(t3) {
            return new go(this, t3);
          }
          queryRadius(t3) {
            const e3 = t3, r3 = Wu(cl("line-width", this, e3), cl("line-gap-width", this, e3)), n2 = cl("line-offset", this, e3);
            return r3 / 2 + Math.abs(n2) + hl(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t3, e3, r3, n2, s4, a2) {
            if (t3.queryGeometry.isAboveHorizon)
              return false;
            const o2 = pl(t3.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, t3.pixelToTileUnitsFactor), l2 = t3.pixelToTileUnitsFactor / 2 * Wu(this.paint.get("line-width").evaluate(e3, r3), this.paint.get("line-gap-width").evaluate(e3, r3)), u2 = this.paint.get("line-offset").evaluate(e3, r3);
            return u2 && (n2 = function(t4, e4) {
              const r4 = [], n3 = new i2(0, 0);
              for (let i3 = 0; i3 < t4.length; i3++) {
                const s5 = t4[i3], a3 = [];
                for (let t5 = 0; t5 < s5.length; t5++) {
                  const r5 = s5[t5 - 1], i4 = s5[t5], o3 = s5[t5 + 1], l3 = t5 === 0 ? n3 : i4.sub(r5)._unit()._perp(), u3 = t5 === s5.length - 1 ? n3 : o3.sub(i4)._unit()._perp(), c2 = l3._add(u3)._unit();
                  c2._mult(1 / (c2.x * u3.x + c2.y * u3.y)), a3.push(c2._mult(e4)._add(i4));
                }
                r4.push(a3);
              }
              return r4;
            }(n2, u2 * t3.pixelToTileUnitsFactor)), function(t4, e4, r4) {
              for (let n3 = 0; n3 < e4.length; n3++) {
                const i3 = e4[n3];
                if (t4.length >= 3) {
                  for (let e5 = 0; e5 < i3.length; e5++)
                    if (ol(t4, i3[e5]))
                      return true;
                }
                if (el(t4, i3, r4))
                  return true;
              }
              return false;
            }(o2, n2, l2);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: Qh, background: class extends So {
          constructor(t3) {
            super(t3, tp);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
        }, raster: class extends So {
          constructor(t3) {
            super(t3, ep);
          }
          getProgramIds() {
            return ["raster"];
          }
        }, sky: class extends So {
          constructor(t3) {
            super(t3, np), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            t3 === "sky-gradient" ? this._updateColorRamp() : t3 !== "sky-atmosphere-sun" && t3 !== "sky-atmosphere-halo-color" && t3 !== "sky-atmosphere-color" && t3 !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = Bl({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t3) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
              return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e3 = t3.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e3.azimuthal || this._lightPosition.polar !== e3.polar;
            }
          }
          getCenter(t3, e3) {
            const r3 = this.paint.get("sky-type");
            if (r3 === "atmosphere") {
              const r4 = this.paint.get("sky-atmosphere-sun"), n2 = !r4, i3 = t3.style.light, s4 = i3.properties.get("position");
              return n2 && i3.properties.get("anchor") === "viewport" && pt("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? ip(s4.azimuthal, 90 - s4.polar, e3) : ip(r4[0], 90 - r4[1], e3);
            }
            if (r3 === "gradient") {
              const t4 = this.paint.get("sky-gradient-center");
              return ip(t4[0], 90 - t4[1], e3);
            }
          }
          is3D() {
            return false;
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t3) {
            this._skyboxInvalidated = false, this._lightPosition = t3.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t3 = this.paint.get("sky-type");
            return t3 === "atmosphere" ? ["skyboxCapture", "skybox"] : t3 === "gradient" ? ["skyboxGradient"] : null;
          }
        } }, { HTMLImageElement: ap, HTMLCanvasElement: op, HTMLVideoElement: lp, ImageData: up, ImageBitmap: cp } = a;
        class hp {
          constructor(t3, e3, r3, n2) {
            this.context = t3, this.format = r3, this.texture = t3.gl.createTexture(), this.update(e3, n2);
          }
          update(t3, e3, r3) {
            const { width: n2, height: i3 } = t3, { context: s4 } = this, { gl: a2 } = s4;
            if (a2.bindTexture(a2.TEXTURE_2D, this.texture), s4.pixelStoreUnpackFlipY.set(false), s4.pixelStoreUnpack.set(1), s4.pixelStoreUnpackPremultiplyAlpha.set(this.format === a2.RGBA && (!e3 || e3.premultiply !== false)), r3 || this.size && this.size[0] === n2 && this.size[1] === i3) {
              const { x: e4, y: s5 } = r3 || { x: 0, y: 0 };
              t3 instanceof ap || t3 instanceof op || t3 instanceof lp || t3 instanceof up || cp && t3 instanceof cp ? a2.texSubImage2D(a2.TEXTURE_2D, 0, e4, s5, a2.RGBA, a2.UNSIGNED_BYTE, t3) : a2.texSubImage2D(a2.TEXTURE_2D, 0, e4, s5, n2, i3, a2.RGBA, a2.UNSIGNED_BYTE, t3.data);
            } else
              this.size = [n2, i3], t3 instanceof ap || t3 instanceof op || t3 instanceof lp || t3 instanceof up || cp && t3 instanceof cp ? a2.texImage2D(a2.TEXTURE_2D, 0, this.format, this.format, a2.UNSIGNED_BYTE, t3) : a2.texImage2D(a2.TEXTURE_2D, 0, this.format, n2, i3, 0, this.format, a2.UNSIGNED_BYTE, t3.data);
            this.useMipmap = Boolean(e3 && e3.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && a2.generateMipmap(a2.TEXTURE_2D);
          }
          bind(t3, e3) {
            const { context: r3 } = this, { gl: n2 } = r3;
            n2.bindTexture(n2.TEXTURE_2D, this.texture), t3 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t3), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, this.useMipmap ? t3 === n2.NEAREST ? n2.NEAREST_MIPMAP_NEAREST : n2.LINEAR_MIPMAP_NEAREST : t3), this.filter = t3), e3 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e3), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e3), this.wrap = e3);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t3 } = this.context;
            t3.deleteTexture(this.texture), this.texture = null;
          }
        }
        class pp {
          constructor(t3, e3) {
            this.width = t3, this.height = e3, this.nextRow = 0, this.image = new zl({ width: t3, height: e3 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t3, e3) {
            const r3 = this.getKey(t3, e3);
            return this.positions[r3];
          }
          trim() {
            const t3 = this.width, e3 = this.height = it(this.nextRow);
            this.image.resize({ width: t3, height: e3 });
          }
          getKey(t3, e3) {
            return t3.join(",") + e3;
          }
          getDashRanges(t3, e3, r3) {
            const n2 = [];
            let i3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * r3 : 0, s4 = t3[0] * r3, a2 = true;
            n2.push({ left: i3, right: s4, isDash: a2, zeroLength: t3[0] === 0 });
            let o2 = t3[0];
            for (let e4 = 1; e4 < t3.length; e4++) {
              a2 = !a2;
              const l2 = t3[e4];
              i3 = o2 * r3, o2 += l2, s4 = o2 * r3, n2.push({ left: i3, right: s4, isDash: a2, zeroLength: l2 === 0 });
            }
            return n2;
          }
          addRoundDash(t3, e3, r3) {
            const n2 = e3 / 2;
            for (let e4 = -r3; e4 <= r3; e4++) {
              const i3 = this.width * (this.nextRow + r3 + e4);
              let s4 = 0, a2 = t3[s4];
              for (let o2 = 0; o2 < this.width; o2++) {
                o2 / a2.right > 1 && (a2 = t3[++s4]);
                const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
                let h3;
                const p2 = e4 / r3 * (n2 + 1);
                if (a2.isDash) {
                  const t4 = n2 - Math.abs(p2);
                  h3 = Math.sqrt(c2 * c2 + t4 * t4);
                } else
                  h3 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                this.image.data[i3 + o2] = Math.max(0, Math.min(255, h3 + 128));
              }
            }
          }
          addRegularDash(t3, e3) {
            for (let e4 = t3.length - 1; e4 >= 0; --e4) {
              const r4 = t3[e4], n3 = t3[e4 + 1];
              r4.zeroLength ? t3.splice(e4, 1) : n3 && n3.isDash === r4.isDash && (n3.left = r4.left, t3.splice(e4, 1));
            }
            const r3 = t3[0], n2 = t3[t3.length - 1];
            r3.isDash === n2.isDash && (r3.left = n2.left - this.width, n2.right = r3.right + this.width);
            const i3 = this.width * this.nextRow;
            let s4 = 0, a2 = t3[s4];
            for (let r4 = 0; r4 < this.width; r4++) {
              r4 / a2.right > 1 && (a2 = t3[++s4]);
              const n3 = Math.abs(r4 - a2.left), o2 = Math.abs(r4 - a2.right), l2 = Math.min(n3, o2);
              this.image.data[i3 + r4] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e3 + 128));
            }
          }
          addDash(t3, e3) {
            const r3 = this.getKey(t3, e3);
            if (this.positions[r3])
              return this.positions[r3];
            const n2 = e3 === "round", i3 = n2 ? 7 : 0, s4 = 2 * i3 + 1;
            if (this.nextRow + s4 > this.height)
              return pt("LineAtlas out of space"), null;
            t3.length === 0 && t3.push(1);
            let a2 = 0;
            for (let e4 = 0; e4 < t3.length; e4++)
              t3[e4] < 0 && (pt("Negative value is found in line dasharray, replacing values with 0"), t3[e4] = 0), a2 += t3[e4];
            if (a2 !== 0) {
              const r4 = this.width / a2, s5 = this.getDashRanges(t3, this.width, r4);
              n2 ? this.addRoundDash(s5, r4, i3) : this.addRegularDash(s5, e3 === "square" ? 0.5 * r4 : 0);
            }
            const o2 = this.nextRow + i3;
            this.nextRow += s4;
            const l2 = { tl: [o2, i3], br: [a2, 0] };
            return this.positions[r3] = l2, l2;
          }
        }
        Zi("LineAtlas", pp);
        class dp {
          constructor(t3) {
            this._callback = t3, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            delete this._channel, this._callback = () => {
            };
          }
        }
        const fp = a.performance;
        function yp(t3) {
          const e3 = t3 ? t3.url.toString() : void 0;
          return fp.getEntriesByName(e3);
        }
        class mp {
          constructor() {
            this.tasks = {}, this.taskQueue = [], at(["process"], this), this.invoker = new dp(this.process), this.nextId = 0;
          }
          add(t3, e3) {
            const r3 = this.nextId++, n2 = function({ type: t4, isSymbolTile: e4, zoom: r4 }) {
              return r4 = r4 || 0, t4 === "message" ? 0 : t4 !== "maybePrepare" || e4 ? t4 !== "parseTile" || e4 ? t4 === "parseTile" && e4 ? 300 - r4 : t4 === "maybePrepare" && e4 ? 400 - r4 : 500 : 200 - r4 : 100 - r4;
            }(e3);
            if (n2 === 0) {
              yt();
              try {
                t3();
              } finally {
              }
              return { cancel: () => {
              } };
            }
            return this.tasks[r3] = { fn: t3, metadata: e3, priority: n2, id: r3 }, this.taskQueue.push(r3), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r3];
            } };
          }
          process() {
            yt();
            try {
              if (this.taskQueue = this.taskQueue.filter((t4) => !!this.tasks[t4]), !this.taskQueue.length)
                return;
              const t3 = this.pick();
              if (t3 === null)
                return;
              const e3 = this.tasks[t3];
              if (delete this.tasks[t3], this.taskQueue.length && this.invoker.trigger(), !e3)
                return;
              e3.fn();
            } finally {
            }
          }
          pick() {
            let t3 = null, e3 = 1 / 0;
            for (let r4 = 0; r4 < this.taskQueue.length; r4++) {
              const n2 = this.tasks[this.taskQueue[r4]];
              n2.priority < e3 && (e3 = n2.priority, t3 = r4);
            }
            if (t3 === null)
              return null;
            const r3 = this.taskQueue[t3];
            return this.taskQueue.splice(t3, 1), r3;
          }
          remove() {
            this.invoker.remove();
          }
        }
        function gp(t3, e3, r3) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
          return [t3 * n2 - 2 * Math.PI * 6378137 / 2, e3 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class xp {
          constructor(t3, e3, r3) {
            this.z = t3, this.x = e3, this.y = r3, this.key = wp(0, t3, t3, e3, r3);
          }
          equals(t3) {
            return this.z === t3.z && this.x === t3.x && this.y === t3.y;
          }
          url(t3, e3) {
            const r3 = function(t4, e4, r4) {
              var n3 = gp(256 * t4, 256 * (e4 = Math.pow(2, r4) - e4 - 1), r4), i3 = gp(256 * (t4 + 1), 256 * (e4 + 1), r4);
              return n3[0] + "," + n3[1] + "," + i3[0] + "," + i3[1];
            }(this.x, this.y, this.z), n2 = function(t4, e4, r4) {
              let n3, i3 = "";
              for (let s4 = t4; s4 > 0; s4--)
                n3 = 1 << s4 - 1, i3 += (e4 & n3 ? 1 : 0) + (r4 & n3 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t3[(this.x + this.y) % t3.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(e3 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r3);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class vp {
          constructor(t3, e3) {
            this.wrap = t3, this.canonical = e3, this.key = wp(t3, e3.z, e3.z, e3.x, e3.y);
          }
        }
        class bp {
          constructor(t3, e3, r3, n2, i3) {
            this.overscaledZ = t3, this.wrap = e3, this.canonical = new xp(r3, +n2, +i3), this.key = e3 === 0 && t3 === r3 ? this.canonical.key : wp(e3, t3, r3, n2, i3);
          }
          equals(t3) {
            return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
          }
          scaledTo(t3) {
            const e3 = this.canonical.z - t3;
            return t3 > this.canonical.z ? new bp(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new bp(t3, this.wrap, t3, this.canonical.x >> e3, this.canonical.y >> e3);
          }
          calculateScaledKey(t3, e3 = true) {
            if (this.overscaledZ === t3 && e3)
              return this.key;
            if (t3 > this.canonical.z)
              return wp(this.wrap * +e3, t3, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r3 = this.canonical.z - t3;
              return wp(this.wrap * +e3, t3, t3, this.canonical.x >> r3, this.canonical.y >> r3);
            }
          }
          isChildOf(t3) {
            if (t3.wrap !== this.wrap)
              return false;
            const e3 = this.canonical.z - t3.canonical.z;
            return t3.overscaledZ === 0 || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e3 && t3.canonical.y === this.canonical.y >> e3;
          }
          children(t3) {
            if (this.overscaledZ >= t3)
              return [new bp(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e3 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new bp(e3, this.wrap, e3, r3, n2), new bp(e3, this.wrap, e3, r3 + 1, n2), new bp(e3, this.wrap, e3, r3, n2 + 1), new bp(e3, this.wrap, e3, r3 + 1, n2 + 1)];
          }
          isLessThan(t3) {
            return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
          }
          wrapped() {
            return new bp(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t3) {
            return new bp(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new vp(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function wp(t3, e3, r3, n2, i3) {
          const s4 = 1 << Math.min(r3, 22);
          let a2 = s4 * (i3 % s4) + n2 % s4;
          return t3 && r3 < 22 && (a2 += s4 * s4 * ((t3 < 0 ? -2 * t3 - 1 : 2 * t3) % (1 << 2 * (22 - r3)))), 16 * (32 * a2 + r3) + (e3 - r3);
        }
        Zi("CanonicalTileID", xp), Zi("OverscaledTileID", bp, { omit: ["projMatrix"] });
        class _p {
          constructor(t3, e3, r3) {
            this.func = t3, this.mask = e3, this.range = r3;
          }
        }
        _p.ReadOnly = false, _p.ReadWrite = true, _p.disabled = new _p(519, _p.ReadOnly, [0, 1]);
        const Ap = 7680;
        class kp {
          constructor(t3, e3, r3, n2, i3, s4) {
            this.test = t3, this.ref = e3, this.mask = r3, this.fail = n2, this.depthFail = i3, this.pass = s4;
          }
        }
        kp.disabled = new kp({ func: 519, mask: 0 }, 0, 0, Ap, Ap, Ap);
        class Sp {
          constructor(t3, e3, r3) {
            this.blendFunction = t3, this.blendColor = e3, this.mask = r3;
          }
        }
        Sp.Replace = [1, 0], Sp.disabled = new Sp(Sp.Replace, Ge.transparent, [false, false, false, false]), Sp.unblended = new Sp(Sp.Replace, Ge.transparent, [true, true, true, true]), Sp.alphaBlended = new Sp([1, 771], Ge.transparent, [true, true, true, true]);
        const Ip = 1029, zp = 2305;
        class Mp {
          constructor(t3, e3, r3) {
            this.enable = t3, this.mode = e3, this.frontFace = r3;
          }
        }
        Mp.disabled = new Mp(false, Ip, zp), Mp.backCCW = new Mp(true, Ip, zp), Mp.backCW = new Mp(true, Ip, 2304), Mp.frontCW = new Mp(true, 1028, 2304), Mp.frontCCW = new Mp(true, 1028, zp);
        class Tp {
          constructor(t3) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e3 = 0; e3 < t3.length; e3++) {
              const r3 = t3[e3];
              this._stringToNumber[r3] = e3, this._numberToString[e3] = r3;
            }
          }
          encode(t3) {
            return this._stringToNumber[t3];
          }
          decode(t3) {
            return this._numberToString[t3];
          }
        }
        class Bp {
          constructor(t3, e3, r3, n2, i3) {
            this.type = "Feature", this._vectorTileFeature = t3, t3._z = e3, t3._x = r3, t3._y = n2, this.properties = t3.properties, this.id = i3;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t3) {
            this._geometry = t3;
          }
          toJSON() {
            const t3 = { geometry: this.geometry };
            for (const e3 in this)
              e3 !== "_geometry" && e3 !== "_vectorTileFeature" && (t3[e3] = this[e3]);
            return t3;
          }
        }
        class Cp {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t3, e3, r3) {
            const n2 = String(e3);
            if (this.stateChanges[t3] = this.stateChanges[t3] || {}, this.stateChanges[t3][n2] = this.stateChanges[t3][n2] || {}, tt(this.stateChanges[t3][n2], r3), this.deletedStates[t3] === null) {
              this.deletedStates[t3] = {};
              for (const e4 in this.state[t3])
                e4 !== n2 && (this.deletedStates[t3][e4] = null);
            } else if (this.deletedStates[t3] && this.deletedStates[t3][n2] === null) {
              this.deletedStates[t3][n2] = {};
              for (const e4 in this.state[t3][n2])
                r3[e4] || (this.deletedStates[t3][n2][e4] = null);
            } else
              for (const e4 in r3)
                this.deletedStates[t3] && this.deletedStates[t3][n2] && this.deletedStates[t3][n2][e4] === null && delete this.deletedStates[t3][n2][e4];
          }
          removeFeatureState(t3, e3, r3) {
            if (this.deletedStates[t3] === null)
              return;
            const n2 = String(e3);
            if (this.deletedStates[t3] = this.deletedStates[t3] || {}, r3 && e3 !== void 0)
              this.deletedStates[t3][n2] !== null && (this.deletedStates[t3][n2] = this.deletedStates[t3][n2] || {}, this.deletedStates[t3][n2][r3] = null);
            else if (e3 !== void 0)
              if (this.stateChanges[t3] && this.stateChanges[t3][n2])
                for (r3 in this.deletedStates[t3][n2] = {}, this.stateChanges[t3][n2])
                  this.deletedStates[t3][n2][r3] = null;
              else
                this.deletedStates[t3][n2] = null;
            else
              this.deletedStates[t3] = null;
          }
          getState(t3, e3) {
            const r3 = String(e3), n2 = tt({}, (this.state[t3] || {})[r3], (this.stateChanges[t3] || {})[r3]);
            if (this.deletedStates[t3] === null)
              return {};
            if (this.deletedStates[t3]) {
              const r4 = this.deletedStates[t3][e3];
              if (r4 === null)
                return {};
              for (const t4 in r4)
                delete n2[t4];
            }
            return n2;
          }
          initializeTileState(t3, e3) {
            t3.setFeatureState(this.state, e3);
          }
          coalesceChanges(t3, e3) {
            const r3 = {};
            for (const t4 in this.stateChanges) {
              this.state[t4] = this.state[t4] || {};
              const e4 = {};
              for (const r4 in this.stateChanges[t4])
                this.state[t4][r4] || (this.state[t4][r4] = {}), tt(this.state[t4][r4], this.stateChanges[t4][r4]), e4[r4] = this.state[t4][r4];
              r3[t4] = e4;
            }
            for (const t4 in this.deletedStates) {
              this.state[t4] = this.state[t4] || {};
              const e4 = {};
              if (this.deletedStates[t4] === null)
                for (const r4 in this.state[t4])
                  e4[r4] = {}, this.state[t4][r4] = {};
              else
                for (const r4 in this.deletedStates[t4]) {
                  if (this.deletedStates[t4][r4] === null)
                    this.state[t4][r4] = {};
                  else
                    for (const e5 of Object.keys(this.deletedStates[t4][r4]))
                      delete this.state[t4][r4][e5];
                  e4[r4] = this.state[t4][r4];
                }
              r3[t4] = r3[t4] || {}, tt(r3[t4], e4);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(r3).length !== 0)
              for (const n2 in t3)
                t3[n2].setFeatureState(r3, e3);
          }
        }
        class Pp {
          constructor(t3) {
            this.size = t3, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t3, e3) {
            const r3 = this.toIdx(t3, e3);
            return { min: this.minimums[r3], max: this.maximums[r3] };
          }
          isLeaf(t3, e3) {
            return this.leaves[this.toIdx(t3, e3)];
          }
          toIdx(t3, e3) {
            return e3 * this.size + t3;
          }
        }
        function Ep(t3, e3, r3, n2) {
          let i3 = 0, s4 = Number.MAX_VALUE;
          for (let a2 = 0; a2 < 3; a2++)
            if (Math.abs(n2[a2]) < 1e-15) {
              if (r3[a2] < t3[a2] || r3[a2] > e3[a2])
                return null;
            } else {
              const o2 = 1 / n2[a2];
              let l2 = (t3[a2] - r3[a2]) * o2, u2 = (e3[a2] - r3[a2]) * o2;
              if (l2 > u2) {
                const t4 = l2;
                l2 = u2, u2 = t4;
              }
              if (l2 > i3 && (i3 = l2), u2 < s4 && (s4 = u2), i3 > s4)
                return null;
            }
          return i3;
        }
        function Dp(t3, e3, r3, n2, i3, s4, a2, o2, l2, u2, c2) {
          const h3 = n2 - t3, p2 = i3 - e3, d2 = s4 - r3, f4 = a2 - t3, y2 = o2 - e3, m3 = l2 - r3, g2 = c2[1] * m3 - c2[2] * y2, x3 = c2[2] * f4 - c2[0] * m3, v2 = c2[0] * y2 - c2[1] * f4, b2 = h3 * g2 + p2 * x3 + d2 * v2;
          if (Math.abs(b2) < 1e-15)
            return null;
          const w2 = 1 / b2, _2 = u2[0] - t3, A3 = u2[1] - e3, k2 = u2[2] - r3, S3 = (_2 * g2 + A3 * x3 + k2 * v2) * w2;
          if (S3 < 0 || S3 > 1)
            return null;
          const I2 = A3 * d2 - k2 * p2, z2 = k2 * h3 - _2 * d2, M2 = _2 * p2 - A3 * h3, T2 = (c2[0] * I2 + c2[1] * z2 + c2[2] * M2) * w2;
          return T2 < 0 || S3 + T2 > 1 ? null : (f4 * I2 + y2 * z2 + m3 * M2) * w2;
        }
        function Vp(t3, e3, r3) {
          return (t3 - e3) / (r3 - e3);
        }
        function Fp(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
          const u2 = 1 << r3, c2 = s4 - n2, h3 = a2 - i3, p2 = (t3 + 1) / u2 * c2 + n2, d2 = (e3 + 0) / u2 * h3 + i3, f4 = (e3 + 1) / u2 * h3 + i3;
          o2[0] = (t3 + 0) / u2 * c2 + n2, o2[1] = d2, l2[0] = p2, l2[1] = f4;
        }
        class Lp {
          constructor(t3) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t3, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
              return;
            const e3 = function(t4) {
              const e4 = Math.ceil(Math.log2(t4.dim / 8)), r4 = [];
              let n3 = Math.ceil(Math.pow(2, e4));
              const i3 = 1 / n3, s4 = (t5, e5, r5, n4, i4) => {
                const s5 = n4 ? 1 : 0, a3 = (t5 + 1) * r5 - s5, o3 = e5 * r5, l2 = (e5 + 1) * r5 - s5;
                i4[0] = t5 * r5, i4[1] = o3, i4[2] = a3, i4[3] = l2;
              };
              let a2 = new Pp(n3);
              const o2 = [];
              for (let e5 = 0; e5 < n3 * n3; e5++) {
                s4(e5 % n3, Math.floor(e5 / n3), i3, false, o2);
                const r5 = Up(o2[0], o2[1], t4), l2 = Up(o2[2], o2[1], t4), u2 = Up(o2[2], o2[3], t4), c2 = Up(o2[0], o2[3], t4);
                a2.minimums.push(Math.min(r5, l2, u2, c2)), a2.maximums.push(Math.max(r5, l2, u2, c2)), a2.leaves.push(1);
              }
              for (r4.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
                const t5 = r4[r4.length - 1];
                a2 = new Pp(n3);
                for (let e5 = 0; e5 < n3 * n3; e5++) {
                  s4(e5 % n3, Math.floor(e5 / n3), 2, true, o2);
                  const r5 = t5.getElevation(o2[0], o2[1]), i4 = t5.getElevation(o2[2], o2[1]), l2 = t5.getElevation(o2[2], o2[3]), u2 = t5.getElevation(o2[0], o2[3]), c2 = t5.isLeaf(o2[0], o2[1]), h3 = t5.isLeaf(o2[2], o2[1]), p2 = t5.isLeaf(o2[2], o2[3]), d2 = t5.isLeaf(o2[0], o2[3]), f4 = Math.min(r5.min, i4.min, l2.min, u2.min), y2 = Math.max(r5.max, i4.max, l2.max, u2.max), m3 = c2 && h3 && p2 && d2;
                  a2.maximums.push(y2), a2.minimums.push(f4), a2.leaves.push(y2 - f4 <= 5 && m3 ? 1 : 0);
                }
                r4.push(a2);
              }
              return r4;
            }(this.dem), r3 = e3.length - 1, n2 = e3[r3];
            this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e3, 0, 0, r3, 0);
          }
          raycastRoot(t3, e3, r3, n2, i3, s4, a2 = 1) {
            return Ep([t3, e3, -100], [r3, n2, this.maximums[0] * a2], i3, s4);
          }
          raycast(t3, e3, r3, n2, i3, s4, a2 = 1) {
            if (!this.nodeCount)
              return null;
            const o2 = this.raycastRoot(t3, e3, r3, n2, i3, s4, a2);
            if (o2 == null)
              return null;
            const l2 = [], u2 = [], c2 = [], h3 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
            for (; p2.length > 0; ) {
              const { idx: o3, t: d2, nodex: f4, nodey: y2, depth: m3 } = p2.pop();
              if (this.leaves[o3]) {
                Fp(f4, y2, m3, t3, e3, r3, n2, c2, h3);
                const o4 = 1 << m3, l3 = (f4 + 0) / o4, u3 = (f4 + 1) / o4, p3 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x3 = Up(l3, p3, this.dem) * a2, v2 = Up(u3, p3, this.dem) * a2, b2 = Up(u3, g3, this.dem) * a2, w2 = Up(l3, g3, this.dem) * a2, _2 = Dp(c2[0], c2[1], x3, h3[0], c2[1], v2, h3[0], h3[1], b2, i3, s4), A3 = Dp(h3[0], h3[1], b2, c2[0], h3[1], w2, c2[0], c2[1], x3, i3, s4), k2 = Math.min(_2 !== null ? _2 : Number.MAX_VALUE, A3 !== null ? A3 : Number.MAX_VALUE);
                if (k2 !== Number.MAX_VALUE)
                  return k2;
                {
                  const t4 = I([], i3, s4, d2);
                  if (Rp(x3, v2, w2, b2, Vp(t4[0], c2[0], h3[0]), Vp(t4[1], c2[1], h3[1])) >= t4[2])
                    return d2;
                }
                continue;
              }
              let g2 = 0;
              for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                Fp((f4 << 1) + this._siblingOffset[p3][0], (y2 << 1) + this._siblingOffset[p3][1], m3 + 1, t3, e3, r3, n2, c2, h3), c2[2] = -100, h3[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
                const d3 = Ep(c2, h3, i3, s4);
                if (d3 != null) {
                  const t4 = d3;
                  l2[p3] = t4;
                  let e4 = false;
                  for (let r4 = 0; r4 < g2 && !e4; r4++)
                    t4 >= l2[u2[r4]] && (u2.splice(r4, 0, p3), e4 = true);
                  e4 || (u2[g2] = p3), g2++;
                }
              }
              for (let t4 = 0; t4 < g2; t4++) {
                const e4 = u2[t4];
                p2.push({ idx: this.childOffsets[o3] + e4, t: l2[e4], nodex: (f4 << 1) + this._siblingOffset[e4][0], nodey: (y2 << 1) + this._siblingOffset[e4][1], depth: m3 + 1 });
              }
            }
            return null;
          }
          _addNode(t3, e3, r3) {
            return this.minimums.push(t3), this.maximums.push(e3), this.leaves.push(r3), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t3, e3, r3, n2, i3) {
            if (t3[n2].isLeaf(e3, r3) === 1)
              return;
            this.childOffsets[i3] || (this.childOffsets[i3] = this.nodeCount);
            const s4 = n2 - 1, a2 = t3[s4];
            let o2, l2 = 0;
            for (let t4 = 0; t4 < this._siblingOffset.length; t4++) {
              const n3 = 2 * e3 + this._siblingOffset[t4][0], i4 = 2 * r3 + this._siblingOffset[t4][1], s5 = a2.getElevation(n3, i4), u2 = a2.isLeaf(n3, i4), c2 = this._addNode(s5.min, s5.max, u2);
              u2 && (l2 |= 1 << t4), o2 || (o2 = c2);
            }
            for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
              l2 & 1 << n3 || this._construct(t3, 2 * e3 + this._siblingOffset[n3][0], 2 * r3 + this._siblingOffset[n3][1], s4, o2 + n3);
          }
        }
        function Rp(t3, e3, r3, n2, i3, s4) {
          return Lr(Lr(t3, r3, s4), Lr(e3, n2, s4), i3);
        }
        function Up(t3, e3, r3) {
          const n2 = r3.dim, i3 = Y(t3 * n2 - 0.5, 0, n2 - 1), s4 = Y(e3 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i3), o2 = Math.floor(s4), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
          return Rp(r3.get(a2, o2), r3.get(l2, o2), r3.get(a2, u2), r3.get(l2, u2), i3 - a2, s4 - o2);
        }
        const $p = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        class Op {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t3, e3, r3, n2 = false, i3 = false) {
            if (this.uid = t3, e3.height !== e3.width)
              throw new RangeError("DEM tiles must be square");
            if (r3 && r3 !== "mapbox" && r3 !== "terrarium")
              return pt(`"${r3}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e3.height;
            const s4 = this.dim = e3.height - 2;
            if (this.data = new Uint32Array(e3.data.buffer), this.encoding = r3 || "mapbox", this.borderReady = n2, !n2) {
              for (let t4 = 0; t4 < s4; t4++)
                this.data[this._idx(-1, t4)] = this.data[this._idx(0, t4)], this.data[this._idx(s4, t4)] = this.data[this._idx(s4 - 1, t4)], this.data[this._idx(t4, -1)] = this.data[this._idx(t4, 0)], this.data[this._idx(t4, s4)] = this.data[this._idx(t4, s4 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(s4, -1)] = this.data[this._idx(s4 - 1, 0)], this.data[this._idx(-1, s4)] = this.data[this._idx(0, s4 - 1)], this.data[this._idx(s4, s4)] = this.data[this._idx(s4 - 1, s4 - 1)], i3 && this._buildQuadTree();
            }
          }
          _buildQuadTree() {
            this._tree = new Lp(this);
          }
          get(t3, e3, r3 = false) {
            const n2 = new Uint8Array(this.data.buffer);
            r3 && (t3 = Y(t3, -1, this.dim), e3 = Y(e3, -1, this.dim));
            const i3 = 4 * this._idx(t3, e3);
            return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(n2[i3], n2[i3 + 1], n2[i3 + 2]);
          }
          static getUnpackVector(t3) {
            return $p[t3];
          }
          get unpackVector() {
            return $p[this.encoding];
          }
          _idx(t3, e3) {
            if (t3 < -1 || t3 >= this.dim + 1 || e3 < -1 || e3 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e3 + 1) * this.stride + (t3 + 1);
          }
          _unpackMapbox(t3, e3, r3) {
            return (256 * t3 * 256 + 256 * e3 + r3) / 10 - 1e4;
          }
          _unpackTerrarium(t3, e3, r3) {
            return 256 * t3 + e3 + r3 / 256 - 32768;
          }
          static pack(t3, e3) {
            const r3 = [0, 0, 0, 0], n2 = Op.getUnpackVector(e3);
            let i3 = Math.floor((t3 + n2[3]) / n2[2]);
            return r3[2] = i3 % 256, i3 = Math.floor(i3 / 256), r3[1] = i3 % 256, i3 = Math.floor(i3 / 256), r3[0] = i3, r3;
          }
          getPixels() {
            return new Ml({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t3, e3, r3) {
            if (this.dim !== t3.dim)
              throw new Error("dem dimension mismatch");
            let n2 = e3 * this.dim, i3 = e3 * this.dim + this.dim, s4 = r3 * this.dim, a2 = r3 * this.dim + this.dim;
            switch (e3) {
              case -1:
                n2 = i3 - 1;
                break;
              case 1:
                i3 = n2 + 1;
            }
            switch (r3) {
              case -1:
                s4 = a2 - 1;
                break;
              case 1:
                a2 = s4 + 1;
            }
            const o2 = -e3 * this.dim, l2 = -r3 * this.dim;
            for (let e4 = s4; e4 < a2; e4++)
              for (let r4 = n2; r4 < i3; r4++)
                this.data[this._idx(r4, e4)] = t3.data[this._idx(r4 + o2, e4 + l2)];
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        Zi("DEMData", Op), Zi("DemMinMaxQuadTree", Lp, { omit: ["dem"] });
        class jp {
          constructor(t3, e3) {
            this.max = t3, this.onRemove = e3, this.reset();
          }
          reset() {
            for (const t3 in this.data)
              for (const e3 of this.data[t3])
                e3.timeout && clearTimeout(e3.timeout), this.onRemove(e3.value);
            return this.data = {}, this.order = [], this;
          }
          add(t3, e3, r3) {
            const n2 = t3.wrapped().key;
            this.data[n2] === void 0 && (this.data[n2] = []);
            const i3 = { value: e3, timeout: void 0 };
            if (r3 !== void 0 && (i3.timeout = setTimeout(() => {
              this.remove(t3, i3);
            }, r3)), this.data[n2].push(i3), this.order.push(n2), this.order.length > this.max) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          has(t3) {
            return t3.wrapped().key in this.data;
          }
          getAndRemove(t3) {
            return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
          }
          _getAndRemoveByKey(t3) {
            const e3 = this.data[t3].shift();
            return e3.timeout && clearTimeout(e3.timeout), this.data[t3].length === 0 && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e3.value;
          }
          getByKey(t3) {
            const e3 = this.data[t3];
            return e3 ? e3[0].value : null;
          }
          get(t3) {
            return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
          }
          remove(t3, e3) {
            if (!this.has(t3))
              return this;
            const r3 = t3.wrapped().key, n2 = e3 === void 0 ? 0 : this.data[r3].indexOf(e3), i3 = this.data[r3][n2];
            return this.data[r3].splice(n2, 1), i3.timeout && clearTimeout(i3.timeout), this.data[r3].length === 0 && delete this.data[r3], this.onRemove(i3.value), this.order.splice(this.order.indexOf(r3), 1), this;
          }
          setMaxSize(t3) {
            for (this.max = t3; this.order.length > this.max; ) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          filter(t3) {
            const e3 = [];
            for (const r3 in this.data)
              for (const n2 of this.data[r3])
                t3(n2.value) || e3.push(n2);
            for (const t4 of e3)
              this.remove(t4.value.tileID, t4);
          }
        }
        class qp extends xe {
          constructor(t3, e3, r3) {
            super(), this.id = t3, this._onlySymbols = r3, e3.on("data", (t4) => {
              t4.dataType === "source" && t4.sourceDataType === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t4.dataType === "source" && t4.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
            }), e3.on("error", () => {
              this._sourceErrored = true;
            }), this._source = e3, this._tiles = {}, this._cache = new jp(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = null, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Cp();
          }
          onAdd(t3) {
            this.map = t3, this._minTileCacheSize = t3 ? t3._minTileCacheSize : null, this._maxTileCacheSize = t3 ? t3._maxTileCacheSize : null;
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (const t3 in this._tiles) {
              const e3 = this._tiles[t3];
              if (e3.state !== "loaded" && e3.state !== "errored")
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t3 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t3, e3) {
            return t3.isSymbolTile = this._onlySymbols, this._source.loadTile(t3, e3);
          }
          _unloadTile(t3) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t3, () => {
              });
          }
          _abortTile(t3) {
            if (this._source.abortTile)
              return this._source.abortTile(t3, () => {
              });
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t3) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e3 in this._tiles) {
              const r3 = this._tiles[e3];
              r3.upload(t3), r3.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Q(this._tiles).map((t3) => t3.tileID).sort(Np).map((t3) => t3.key);
          }
          getRenderableIds(t3) {
            const e3 = [];
            for (const r3 in this._tiles)
              this._isIdRenderable(+r3, t3) && e3.push(this._tiles[r3]);
            return t3 ? e3.sort((t4, e4) => {
              const r3 = t4.tileID, n2 = e4.tileID, s4 = new i2(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle), a2 = new i2(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
              return r3.overscaledZ - n2.overscaledZ || a2.y - s4.y || a2.x - s4.x;
            }).map((t4) => t4.tileID.key) : e3.map((t4) => t4.tileID).sort(Np).map((t4) => t4.key);
          }
          hasRenderableParent(t3) {
            const e3 = this.findLoadedParent(t3, 0);
            return !!e3 && this._isIdRenderable(e3.tileID.key);
          }
          _isIdRenderable(t3, e3) {
            return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e3 || !this._tiles[t3].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t3 in this._tiles)
                this._tiles[t3].state !== "errored" && this._reloadTile(+t3, "reloading");
            }
          }
          _reloadTile(t3, e3) {
            const r3 = this._tiles[t3];
            r3 && (r3.state !== "loading" && (r3.state = e3), this._loadTile(r3, this._tileLoaded.bind(this, r3, t3, e3)));
          }
          _tileLoaded(t3, e3, r3, n2) {
            if (n2)
              if (t3.state = "errored", n2.status !== 404)
                this._source.fire(new ge(n2, { tile: t3 }));
              else if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                const t4 = this.map.painter.terrain;
                this.update(this.transform, t4.getScaledDemTileSize(), true), t4.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            else
              t3.timeAdded = At.now(), r3 === "expired" && (t3.refreshedUponExpiration = true), this._setTileReloadTimer(e3, t3), this._source.type === "raster-dem" && t3.dem && this._backfillDEM(t3), this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._source.fire(new me("data", { dataType: "source", tile: t3, coord: t3.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(t3) {
            const e3 = this.getRenderableIds();
            for (let n2 = 0; n2 < e3.length; n2++) {
              const i3 = e3[n2];
              if (t3.neighboringTiles && t3.neighboringTiles[i3]) {
                const e4 = this.getTileByID(i3);
                r3(t3, e4), r3(e4, t3);
              }
            }
            function r3(t4, e4) {
              if (!t4.dem || t4.dem.borderReady)
                return;
              t4.needsHillshadePrepare = true, t4.needsDEMTextureUpload = true;
              let r4 = e4.tileID.canonical.x - t4.tileID.canonical.x;
              const n2 = e4.tileID.canonical.y - t4.tileID.canonical.y, i3 = Math.pow(2, t4.tileID.canonical.z), s4 = e4.tileID.key;
              r4 === 0 && n2 === 0 || Math.abs(n2) > 1 || (Math.abs(r4) > 1 && (Math.abs(r4 + i3) === 1 ? r4 += i3 : Math.abs(r4 - i3) === 1 && (r4 -= i3)), e4.dem && t4.dem && (t4.dem.backfillBorder(e4.dem, r4, n2), t4.neighboringTiles && t4.neighboringTiles[s4] && (t4.neighboringTiles[s4].backfilled = true)));
            }
          }
          getTile(t3) {
            return this.getTileByID(t3.key);
          }
          getTileByID(t3) {
            return this._tiles[t3];
          }
          _retainLoadedChildren(t3, e3, r3, n2) {
            for (const i3 in this._tiles) {
              let s4 = this._tiles[i3];
              if (n2[i3] || !s4.hasData() || s4.tileID.overscaledZ <= e3 || s4.tileID.overscaledZ > r3)
                continue;
              let a2 = s4.tileID;
              for (; s4 && s4.tileID.overscaledZ > e3 + 1; ) {
                const t4 = s4.tileID.scaledTo(s4.tileID.overscaledZ - 1);
                s4 = this._tiles[t4.key], s4 && s4.hasData() && (a2 = t4);
              }
              let o2 = a2;
              for (; o2.overscaledZ > e3; )
                if (o2 = o2.scaledTo(o2.overscaledZ - 1), t3[o2.key]) {
                  n2[a2.key] = a2;
                  break;
                }
            }
          }
          findLoadedParent(t3, e3) {
            if (t3.key in this._loadedParentTiles) {
              const r3 = this._loadedParentTiles[t3.key];
              return r3 && r3.tileID.overscaledZ >= e3 ? r3 : null;
            }
            for (let r3 = t3.overscaledZ - 1; r3 >= e3; r3--) {
              const e4 = t3.scaledTo(r3), n2 = this._getLoadedTile(e4);
              if (n2)
                return n2;
            }
          }
          _getLoadedTile(t3) {
            const e3 = this._tiles[t3.key];
            return e3 && e3.hasData() ? e3 : this._cache.getByKey(this._source.reparseOverscaled ? t3.wrapped().key : t3.canonical.key);
          }
          updateCacheSize(t3, e3) {
            e3 = e3 || this._source.tileSize;
            const r3 = Math.ceil(t3.width / e3) + 1, n2 = Math.ceil(t3.height / e3) + 1, i3 = Math.floor(r3 * n2 * 5), s4 = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, i3) : i3, a2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, s4) : s4;
            this._cache.setMaxSize(a2);
          }
          handleWrapJump(t3) {
            const e3 = Math.round((t3 - (this._prevLng === void 0 ? t3 : this._prevLng)) / 360);
            if (this._prevLng = t3, e3) {
              const t4 = {};
              for (const r3 in this._tiles) {
                const n2 = this._tiles[r3];
                n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e3), t4[n2.tileID.key] = n2;
              }
              this._tiles = t4;
              for (const t5 in this._timers)
                clearTimeout(this._timers[t5]), delete this._timers[t5];
              for (const t5 in this._tiles)
                this._setTileReloadTimer(+t5, this._tiles[t5]);
            }
          }
          update(t3, e3, r3) {
            if (this.transform = t3, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
              return;
            if (this.usedForTerrain && !r3)
              return;
            let n2;
            this.updateCacheSize(t3, e3), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n2 = t3.getVisibleUnwrappedCoordinates(this._source.tileID).map((t4) => new bp(t4.canonical.z, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y)) : (n2 = t3.coveringTiles({ tileSize: e3 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n2 = n2.filter((t4) => this._source.hasTile(t4)))) : n2 = [];
            const i3 = this._updateRetainedTiles(n2);
            if (Gp(this._source.type) && n2.length !== 0) {
              const t4 = {}, e4 = {}, r4 = Object.keys(i3);
              for (const n3 of r4) {
                const r5 = i3[n3], s6 = this._tiles[n3];
                if (!s6 || s6.fadeEndTime && s6.fadeEndTime <= At.now())
                  continue;
                const a2 = this.findLoadedParent(r5, Math.max(r5.overscaledZ - qp.maxOverzooming, this._source.minzoom));
                a2 && (this._addTile(a2.tileID), t4[a2.tileID.key] = a2.tileID), e4[n3] = r5;
              }
              const s5 = n2[n2.length - 1].overscaledZ;
              for (const t5 in this._tiles) {
                const r5 = this._tiles[t5];
                if (i3[t5] || !r5.hasData())
                  continue;
                let n3 = r5.tileID;
                for (; n3.overscaledZ > s5; ) {
                  n3 = n3.scaledTo(n3.overscaledZ - 1);
                  const s6 = this._tiles[n3.key];
                  if (s6 && s6.hasData() && e4[n3.key]) {
                    i3[t5] = r5.tileID;
                    break;
                  }
                }
              }
              for (const e5 in t4)
                i3[e5] || (this._coveredTiles[e5] = true, i3[e5] = t4[e5]);
            }
            for (const t4 in i3)
              this._tiles[t4].clearFadeHold();
            const s4 = function(t4, e4) {
              const r4 = [];
              for (const n3 in t4)
                n3 in e4 || r4.push(n3);
              return r4;
            }(this._tiles, i3);
            for (const t4 of s4) {
              const e4 = this._tiles[t4];
              e4.hasSymbolBuckets && !e4.holdingForFade() ? e4.setHoldDuration(this.map._fadeDuration) : e4.hasSymbolBuckets && !e4.symbolFadeFinished() || this._removeTile(+t4);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const t3 in this._tiles)
              this._tiles[t3].holdingForFade() && this._removeTile(+t3);
          }
          _updateRetainedTiles(t3) {
            const e3 = {};
            if (t3.length === 0)
              return e3;
            const r3 = {}, n2 = t3.reduce((t4, e4) => Math.min(t4, e4.overscaledZ), 1 / 0), i3 = t3[0].overscaledZ, s4 = Math.max(i3 - qp.maxOverzooming, this._source.minzoom), a2 = Math.max(i3 + qp.maxUnderzooming, this._source.minzoom), o2 = {};
            for (const r4 of t3) {
              const t4 = this._addTile(r4);
              e3[r4.key] = r4, t4.hasData() || n2 < this._source.maxzoom && (o2[r4.key] = r4);
            }
            this._retainLoadedChildren(o2, n2, a2, e3);
            for (const n3 of t3) {
              let t4 = this._tiles[n3.key];
              if (t4.hasData())
                continue;
              if (n3.canonical.z >= this._source.maxzoom) {
                const t5 = n3.children(this._source.maxzoom)[0], r4 = this.getTile(t5);
                if (r4 && r4.hasData()) {
                  e3[t5.key] = t5;
                  continue;
                }
              } else {
                const t5 = n3.children(this._source.maxzoom);
                if (e3[t5[0].key] && e3[t5[1].key] && e3[t5[2].key] && e3[t5[3].key])
                  continue;
              }
              let i4 = t4.wasRequested();
              for (let a3 = n3.overscaledZ - 1; a3 >= s4; --a3) {
                const s5 = n3.scaledTo(a3);
                if (r3[s5.key])
                  break;
                if (r3[s5.key] = true, t4 = this.getTile(s5), !t4 && i4 && (t4 = this._addTile(s5)), t4 && (e3[s5.key] = s5, i4 = t4.wasRequested(), t4.hasData()))
                  break;
              }
            }
            return e3;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t3 in this._tiles) {
              const e3 = [];
              let r3, n2 = this._tiles[t3].tileID;
              for (; n2.overscaledZ > 0; ) {
                if (n2.key in this._loadedParentTiles) {
                  r3 = this._loadedParentTiles[n2.key];
                  break;
                }
                e3.push(n2.key);
                const t4 = n2.scaledTo(n2.overscaledZ - 1);
                if (r3 = this._getLoadedTile(t4), r3)
                  break;
                n2 = t4;
              }
              for (const t4 of e3)
                this._loadedParentTiles[t4] = r3;
            }
          }
          _addTile(t3) {
            let e3 = this._tiles[t3.key];
            if (e3)
              return e3;
            e3 = this._cache.getAndRemove(t3), e3 && (this._setTileReloadTimer(t3.key, e3), e3.tileID = t3, this._state.initializeTileState(e3, this.map ? this.map.painter : null), this._cacheTimers[t3.key] && (clearTimeout(this._cacheTimers[t3.key]), delete this._cacheTimers[t3.key], this._setTileReloadTimer(t3.key, e3)));
            const r3 = Boolean(e3);
            if (!r3) {
              const r4 = this.map ? this.map.painter : null, n2 = this._source.type === "raster" || this._source.type === "raster-dem";
              e3 = new ad(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, r4, n2), this._loadTile(e3, this._tileLoaded.bind(this, e3, t3.key, e3.state));
            }
            return e3 ? (e3.uses++, this._tiles[t3.key] = e3, r3 || this._source.fire(new me("dataloading", { tile: e3, coord: e3.tileID, dataType: "source" })), e3) : null;
          }
          _setTileReloadTimer(t3, e3) {
            t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
            const r3 = e3.getExpiryTimeout();
            r3 && (this._timers[t3] = setTimeout(() => {
              this._reloadTile(t3, "expired"), delete this._timers[t3];
            }, r3));
          }
          _removeTile(t3) {
            const e3 = this._tiles[t3];
            e3 && (e3.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e3.uses > 0 || (e3.hasData() && e3.state !== "reloading" ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t3 in this._tiles)
              this._removeTile(+t3);
            this._source._clear && this._source._clear(), this._cache.reset();
          }
          tilesIn(t3, e3, r3) {
            const n2 = [], i3 = this.transform;
            if (!i3)
              return n2;
            for (const s4 in this._tiles) {
              const a2 = this._tiles[s4];
              if (r3 && a2.clearQueryDebugViz(), a2.holdingForFade())
                continue;
              const o2 = t3.containsTile(a2, i3, e3);
              o2 && n2.push(o2);
            }
            return n2;
          }
          getVisibleCoordinates(t3) {
            const e3 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
            for (const t4 of e3)
              t4.projMatrix = this.transform.calculateProjMatrix(t4.toUnwrapped());
            return e3;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (Gp(this._source.type))
              for (const t3 in this._tiles) {
                const e3 = this._tiles[t3];
                if (e3.fadeEndTime !== void 0 && e3.fadeEndTime >= At.now())
                  return true;
              }
            return false;
          }
          setFeatureState(t3, e3, r3) {
            this._state.updateState(t3 = t3 || "_geojsonTileLayer", e3, r3);
          }
          removeFeatureState(t3, e3, r3) {
            this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e3, r3);
          }
          getFeatureState(t3, e3) {
            return this._state.getState(t3 = t3 || "_geojsonTileLayer", e3);
          }
          setDependencies(t3, e3, r3) {
            const n2 = this._tiles[t3];
            n2 && n2.setDependencies(e3, r3);
          }
          reloadTilesForDependencies(t3, e3) {
            for (const r3 in this._tiles)
              this._tiles[r3].hasDependency(t3, e3) && this._reloadTile(+r3, "reloading");
            this._cache.filter((r3) => !r3.hasDependency(t3, e3));
          }
          _preloadTiles(t3, e3) {
            const r3 = new Map(), n2 = Array.isArray(t3) ? t3 : [t3], i3 = this.map.painter.terrain, s4 = this.usedForTerrain && i3 ? i3.getScaledDemTileSize() : this._source.tileSize;
            for (const t4 of n2) {
              const e4 = t4.coveringTiles({ tileSize: s4, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const t5 of e4)
                r3.set(t5.key, t5);
              this.usedForTerrain && t4.updateElevation(false);
            }
            const a2 = Array.from(r3.values()), o2 = this._source.type === "raster" || this._source.type === "raster-dem";
            W(a2, (t4, e4) => {
              const r4 = new ad(t4, this._source.tileSize * t4.overscaleFactor(), this.transform.tileZoom, this.map.painter, o2);
              this._loadTile(r4, (t5) => {
                this._source.type === "raster-dem" && r4.dem && this._backfillDEM(r4), e4(t5, r4);
              });
            }, e3);
          }
        }
        function Np(t3, e3) {
          const r3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), n2 = Math.abs(2 * e3.wrap) - +(e3.wrap < 0);
          return t3.overscaledZ - e3.overscaledZ || n2 - r3 || e3.canonical.y - t3.canonical.y || e3.canonical.x - t3.canonical.x;
        }
        function Gp(t3) {
          return t3 === "raster" || t3 === "image" || t3 === "video";
        }
        qp.maxOverzooming = 10, qp.maxUnderzooming = 3;
        class Zp {
          constructor(t3, e3, r3) {
            this._demTile = t3, this._dem = this._demTile.dem, this._scale = e3, this._offset = r3;
          }
          static create(t3, e3, r3) {
            const n2 = r3 || t3.findDEMTileFor(e3);
            if (!n2 || !n2.dem)
              return;
            const i3 = n2.dem, s4 = n2.tileID, a2 = 1 << e3.canonical.z - s4.canonical.z;
            return new Zp(n2, n2.tileSize / To / a2, [(e3.canonical.x / a2 - s4.canonical.x) * i3.dim, (e3.canonical.y / a2 - s4.canonical.y) * i3.dim]);
          }
          tileCoordToPixel(t3, e3) {
            const r3 = e3 * this._scale + this._offset[1], n2 = Math.floor(t3 * this._scale + this._offset[0]), s4 = Math.floor(r3);
            return new i2(n2, s4);
          }
          getElevationAt(t3, e3, r3, n2) {
            const i3 = t3 * this._scale + this._offset[0], s4 = e3 * this._scale + this._offset[1], a2 = Math.floor(i3), o2 = Math.floor(s4), l2 = this._dem;
            return n2 = !!n2, r3 ? Lr(Lr(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s4 - o2), Lr(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s4 - o2), i3 - a2) : l2.get(a2, o2, n2);
          }
          getElevationAtPixel(t3, e3, r3) {
            return this._dem.get(t3, e3, !!r3);
          }
          getMeterToDEM(t3) {
            return (1 << this._demTile.tileID.canonical.z) * Lo(1, t3) * this._dem.stride;
          }
        }
        class Xp {
          constructor(t3, e3) {
            this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new Oi(To, 16, 0), this.featureIndexArray = new Na(), this.promoteId = e3;
          }
          insert(t3, e3, r3, n2, i3, s4 = 0) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r3, n2, i3, s4);
            const o2 = this.grid;
            for (let t4 = 0; t4 < e3.length; t4++) {
              const r4 = e3[t4], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t5 = 0; t5 < r4.length; t5++) {
                const e4 = r4[t5];
                n3[0] = Math.min(n3[0], e4.x), n3[1] = Math.min(n3[1], e4.y), n3[2] = Math.max(n3[2], e4.x), n3[3] = Math.max(n3[3], e4.y);
              }
              n3[0] < To && n3[1] < To && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new Bu.VectorTile(new gc(this.rawTileData)).layers, this.sourceLayerCoder = new Tp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t3 in this.vtLayers)
                this.vtFeatures[t3] = [];
            }
            return this.vtLayers;
          }
          query(t3, e3, r3, n2) {
            this.loadVTLayers();
            const i3 = t3.params || {}, s4 = si(i3.filter), a2 = t3.tileResult, o2 = t3.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t4, e4, r4, n3) => ll(a2.bufferedTilespaceGeometry, t4, e4, r4, n3));
            u2.sort(Yp);
            let c2 = null;
            o2.elevation && u2.length > 0 && (c2 = Zp.create(o2.elevation, this.tileID));
            const h3 = {};
            let p2;
            for (let o3 = 0; o3 < u2.length; o3++) {
              const l3 = u2[o3];
              if (l3 === p2)
                continue;
              p2 = l3;
              const d2 = this.featureIndexArray.get(l3);
              let f4 = null;
              this.loadMatchingFeature(h3, d2, s4, i3.layers, i3.availableImages, e3, r3, n2, (e4, r4, n3, i4 = 0) => (f4 || (f4 = Ko(e4, this.tileID.canonical, t3.tileTransform)), r4.queryIntersectsFeature(a2, e4, n3, f4, this.z, t3.transform, t3.pixelPosMatrix, c2, i4)));
            }
            return h3;
          }
          loadMatchingFeature(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
            const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h3, layoutVertexArrayOffset: p2 } = e3, d2 = this.bucketLayerIDs[c2];
            if (n2 && !function(t4, e4) {
              for (let r4 = 0; r4 < t4.length; r4++)
                if (e4.indexOf(t4[r4]) >= 0)
                  return true;
              return false;
            }(n2, d2))
              return;
            const f4 = this.sourceLayerCoder.decode(h3), y2 = this.vtLayers[f4].feature(u2);
            if (r3.needGeometry) {
              const t4 = Yo(y2, true);
              if (!r3.filter(new Gs(this.tileID.overscaledZ), t4, this.tileID.canonical))
                return;
            } else if (!r3.filter(new Gs(this.tileID.overscaledZ), y2))
              return;
            const m3 = this.getId(y2, f4);
            for (let e4 = 0; e4 < d2.length; e4++) {
              const r4 = d2[e4];
              if (n2 && n2.indexOf(r4) < 0)
                continue;
              const c3 = s4[r4];
              if (!c3)
                continue;
              let h4 = {};
              m3 !== void 0 && o2 && (h4 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m3));
              const f5 = tt({}, a2[r4]);
              f5.paint = Kp(f5.paint, c3.paint, y2, h4, i3), f5.layout = Kp(f5.layout, c3.layout, y2, h4, i3);
              const g2 = !l2 || l2(y2, c3, h4, p2);
              if (!g2)
                continue;
              const x3 = new Bp(y2, this.z, this.x, this.y, m3);
              x3.layer = f5;
              let v2 = t3[r4];
              v2 === void 0 && (v2 = t3[r4] = []), v2.push({ featureIndex: u2, feature: x3, intersectionZ: g2 });
            }
          }
          lookupSymbolFeatures(t3, e3, r3, n2, i3, s4, a2, o2) {
            const l2 = {};
            this.loadVTLayers();
            const u2 = si(i3);
            for (const i4 of t3)
              this.loadMatchingFeature(l2, { bucketIndex: r3, sourceLayerIndex: n2, featureIndex: i4, layoutVertexArrayOffset: 0 }, u2, s4, a2, o2, e3);
            return l2;
          }
          loadFeature(t3) {
            const { featureIndex: e3, sourceLayerIndex: r3 } = t3;
            this.loadVTLayers();
            const n2 = this.sourceLayerCoder.decode(r3), i3 = this.vtFeatures[n2];
            if (i3[e3])
              return i3[e3];
            const s4 = this.vtLayers[n2].feature(e3);
            return i3[e3] = s4, s4;
          }
          hasLayer(t3) {
            for (const e3 of this.bucketLayerIDs)
              for (const r3 of e3)
                if (t3 === r3)
                  return true;
            return false;
          }
          getId(t3, e3) {
            let r3 = t3.id;
            return this.promoteId && (r3 = t3.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e3]], typeof r3 == "boolean" && (r3 = Number(r3))), r3;
          }
        }
        function Kp(t3, e3, r3, n2, i3) {
          return lt(t3, (t4, s4) => {
            const a2 = e3 instanceof Qs ? e3.get(s4) : null;
            return a2 && a2.evaluate ? a2.evaluate(r3, n2, i3) : a2;
          });
        }
        function Yp(t3, e3) {
          return e3 - t3;
        }
        Zi("FeatureIndex", Xp, { omit: ["rawTileData", "sourceLayerCoder"] });
        var Hp = ca([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Jp = 32, Wp = 33, Qp = new Uint16Array(8184);
        for (let t3 = 0; t3 < 2046; t3++) {
          let e3 = t3 + 2, r3 = 0, n2 = 0, i3 = 0, s4 = 0, a2 = 0, o2 = 0;
          for (1 & e3 ? i3 = s4 = a2 = Jp : r3 = n2 = o2 = Jp; (e3 >>= 1) > 1; ) {
            const t4 = r3 + i3 >> 1, l3 = n2 + s4 >> 1;
            1 & e3 ? (i3 = r3, s4 = n2, r3 = a2, n2 = o2) : (r3 = i3, n2 = s4, i3 = a2, s4 = o2), a2 = t4, o2 = l3;
          }
          const l2 = 4 * t3;
          Qp[l2 + 0] = r3, Qp[l2 + 1] = n2, Qp[l2 + 2] = i3, Qp[l2 + 3] = s4;
        }
        const td = new Uint16Array(2178), ed = new Uint8Array(1089), rd = new Uint16Array(1089);
        function nd(t3) {
          return t3 === 0 ? -0.03125 : t3 === 32 ? 0.03125 : 0;
        }
        var id = ca([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        const sd = { type: 2, extent: To, loadGeometry: () => [[new i2(0, 0), new i2(8193, 0), new i2(8193, 8193), new i2(0, 8193), new i2(0, 0)]] };
        class ad {
          constructor(t3, e3, r3, n2, i3) {
            this.tileID = t3, this.uid = rt(), this.uses = 0, this.tileSize = e3, this.tileZoom = r3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i3, this.expiredRequestCount = 0, this.state = "loading", n2 && n2.transform && (this.projection = n2.transform.projection);
          }
          registerFadeDuration(t3) {
            const e3 = t3 + this.timeAdded;
            e3 < At.now() || this.fadeEndTime && e3 < this.fadeEndTime || (this.fadeEndTime = e3);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = Ad(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t3, e3, r3) {
            if (this.unloadVectorData(), this.state = "loaded", t3) {
              t3.featureIndex && (this.latestFeatureIndex = t3.featureIndex, t3.rawTileData ? (this.latestRawTileData = t3.rawTileData, this.latestFeatureIndex.rawTileData = t3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t3.collisionBoxArray, this.buckets = function(t4, e4) {
                const r4 = {};
                if (!e4)
                  return r4;
                for (const n2 of t4) {
                  const t5 = n2.layerIds.map((t6) => e4.getLayer(t6)).filter(Boolean);
                  if (t5.length !== 0) {
                    n2.layers = t5, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e5) => t5.filter((t6) => t6.id === e5)[0]));
                    for (const e5 of t5)
                      r4[e5.id] = n2;
                  }
                }
                return r4;
              }(t3.buckets, e3.style), this.hasSymbolBuckets = false;
              for (const t4 in this.buckets) {
                const e4 = this.buckets[t4];
                if (e4 instanceof Yh) {
                  if (this.hasSymbolBuckets = true, !r3)
                    break;
                  e4.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const t4 in this.buckets) {
                  const e4 = this.buckets[t4];
                  if (e4 instanceof Yh && e4.hasRTLText) {
                    this.hasRTLText = true, Ns.isLoading() || Ns.isLoaded() || js4() !== "deferred" || qs2();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t4 in this.buckets) {
                const r4 = this.buckets[t4];
                this.queryPadding = Math.max(this.queryPadding, e3.style.getLayer(t4).queryRadius(r4));
              }
              t3.imageAtlas && (this.imageAtlas = t3.imageAtlas), t3.glyphAtlasImage && (this.glyphAtlasImage = t3.glyphAtlasImage), t3.lineAtlas && (this.lineAtlas = t3.lineAtlas);
            } else
              this.collisionBoxArray = new Fa();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const t3 in this.buckets)
                this.buckets[t3].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugIndexBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this.globeGridBuffer && (this.globeGridBuffer.destroy(), this.globeGridBuffer = null), this.globePoleBuffer && (this.globePoleBuffer.destroy(), this.globePoleBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          getBucket(t3) {
            return this.buckets[t3.id];
          }
          upload(t3) {
            for (const e4 in this.buckets) {
              const r3 = this.buckets[e4];
              r3.uploadPending() && r3.upload(t3);
            }
            const e3 = t3.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new hp(t3, this.imageAtlas.image, e3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new hp(t3, this.glyphAtlasImage, e3.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new hp(t3, this.lineAtlas.image, e3.ALPHA), this.lineAtlas.uploaded = true);
          }
          prepare(t3) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t3, e3, r3, n2, i3, s4, a2, o2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s4, params: i3, tileTransform: this.tileTransform }, t3, e3, r3) : {};
          }
          querySourceFeatures(t3, e3) {
            const r3 = this.latestFeatureIndex;
            if (!r3 || !r3.rawTileData)
              return;
            const n2 = r3.loadVTLayers(), i3 = e3 ? e3.sourceLayer : "", s4 = n2._geojsonTileLayer || n2[i3];
            if (!s4)
              return;
            const a2 = si(e3 && e3.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
            for (let e4 = 0; e4 < s4.length; e4++) {
              const n3 = s4.feature(e4);
              if (a2.needGeometry) {
                const t4 = Yo(n3, true);
                if (!a2.filter(new Gs(this.tileID.overscaledZ), t4, this.tileID.canonical))
                  continue;
              } else if (!a2.filter(new Gs(this.tileID.overscaledZ), n3))
                continue;
              const h3 = r3.getId(n3, i3), p2 = new Bp(n3, o2, l2, u2, h3);
              p2.tile = c2, t3.push(p2);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t3) {
            const e3 = this.expirationTime;
            if (t3.cacheControl) {
              const e4 = mt(t3.cacheControl);
              e4["max-age"] && (this.expirationTime = Date.now() + 1e3 * e4["max-age"]);
            } else
              t3.expires && (this.expirationTime = new Date(t3.expires).getTime());
            if (this.expirationTime) {
              const t4 = Date.now();
              let r3 = false;
              if (this.expirationTime > t4)
                r3 = false;
              else if (e3)
                if (this.expirationTime < e3)
                  r3 = true;
                else {
                  const n2 = this.expirationTime - e3;
                  n2 ? this.expirationTime = t4 + Math.max(n2, 3e4) : r3 = true;
                }
              else
                r3 = true;
              r3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t3, e3) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t3).length === 0 || !e3)
              return;
            const r3 = this.latestFeatureIndex.loadVTLayers(), n2 = e3.style.listImages();
            for (const i3 in this.buckets) {
              if (!e3.style.hasLayer(i3))
                continue;
              const s4 = this.buckets[i3], a2 = s4.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r3[a2], l2 = t3[a2];
              if (!o2 || !l2 || Object.keys(l2).length === 0)
                continue;
              if (s4.update(l2, o2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}), s4 instanceof Ku || s4 instanceof mu) {
                const t4 = e3.style._getSourceCache(s4.layers[0].source);
                e3._terrain && e3._terrain.enabled && t4 && s4.programConfigurations.needsUpload && e3._terrain._clearRenderCacheForTile(t4.id, this.tileID);
              }
              const u2 = e3 && e3.style && e3.style.getLayer(i3);
              u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(s4)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < At.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t3) {
            this.symbolFadeHoldUntil = At.now() + t3;
          }
          setDependencies(t3, e3) {
            const r3 = {};
            for (const t4 of e3)
              r3[t4] = true;
            this.dependencies[t3] = r3;
          }
          hasDependency(t3, e3) {
            for (const r3 of t3) {
              const t4 = this.dependencies[r3];
              if (t4) {
                for (const r4 of e3)
                  if (t4[r4])
                    return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t3, e3) {
            if (!e3 || e3.name === "mercator" || this._tileDebugBuffer)
              return;
            const r3 = Ko(sd, this.tileID.canonical, this.tileTransform)[0], n2 = new pa(), i3 = new Pa();
            for (let t4 = 0; t4 < r3.length; t4++) {
              const { x: e4, y: s4 } = r3[t4];
              n2.emplaceBack(e4, s4), i3.emplaceBack(t4);
            }
            i3.emplaceBack(0), this._tileDebugIndexBuffer = t3.createIndexBuffer(i3), this._tileDebugBuffer = t3.createVertexBuffer(n2, id.members), this._tileDebugSegments = Mo.simpleSegment(0, 0, n2.length, i3.length);
          }
          _makeTileBoundsBuffers(t3, e3) {
            if (this._tileBoundsBuffer || !e3 || e3.name === "mercator")
              return;
            const r3 = Ko(sd, this.tileID.canonical, this.tileTransform)[0];
            let n2, i3;
            if (this.isRaster) {
              const t4 = function(t5, e4) {
                const r4 = Ad(t5, e4), n3 = Math.pow(2, t5.z);
                for (let i5 = 0; i5 < Wp; i5++)
                  for (let s5 = 0; s5 < Wp; s5++) {
                    const a3 = Ro((t5.x + (s5 + nd(s5)) / Jp) / n3), o3 = Uo((t5.y + (i5 + nd(i5)) / Jp) / n3), l3 = e4.project(a3, o3), u2 = i5 * Wp + s5;
                    td[2 * u2 + 0] = Math.round((l3.x * r4.scale - r4.x) * To), td[2 * u2 + 1] = Math.round((l3.y * r4.scale - r4.y) * To);
                  }
                ed.fill(0), rd.fill(0);
                for (let t6 = 2045; t6 >= 0; t6--) {
                  const e5 = 4 * t6, r5 = Qp[e5 + 0], n4 = Qp[e5 + 1], i5 = Qp[e5 + 2], s5 = Qp[e5 + 3], a3 = r5 + i5 >> 1, o3 = n4 + s5 >> 1, l3 = a3 + o3 - n4, u2 = o3 + r5 - a3, c2 = n4 * Wp + r5, h3 = s5 * Wp + i5, p2 = o3 * Wp + a3, d2 = Math.hypot((td[2 * c2 + 0] + td[2 * h3 + 0]) / 2 - td[2 * p2 + 0], (td[2 * c2 + 1] + td[2 * h3 + 1]) / 2 - td[2 * p2 + 1]) >= 16;
                  if (ed[p2] = ed[p2] || (d2 ? 1 : 0), t6 < 1022) {
                    const t7 = (n4 + u2 >> 1) * Wp + (r5 + l3 >> 1), e6 = (s5 + u2 >> 1) * Wp + (i5 + l3 >> 1);
                    ed[p2] = ed[p2] || ed[t7] || ed[e6];
                  }
                }
                const i4 = new da(), s4 = new ka();
                let a2 = 0;
                function o2(t6, e5) {
                  const r5 = e5 * Wp + t6;
                  return rd[r5] === 0 && (i4.emplaceBack(td[2 * r5 + 0], td[2 * r5 + 1], t6 * To / Jp, e5 * To / Jp), rd[r5] = ++a2), rd[r5] - 1;
                }
                function l2(t6, e5, r5, n4, i5, a3) {
                  const u2 = t6 + r5 >> 1, c2 = e5 + n4 >> 1;
                  if (Math.abs(t6 - i5) + Math.abs(e5 - a3) > 1 && ed[c2 * Wp + u2])
                    l2(i5, a3, t6, e5, u2, c2), l2(r5, n4, i5, a3, u2, c2);
                  else {
                    const l3 = o2(t6, e5), u3 = o2(r5, n4), c3 = o2(i5, a3);
                    s4.emplaceBack(l3, u3, c3);
                  }
                }
                return l2(0, 0, Jp, Jp, Jp, 0), l2(Jp, Jp, 0, 0, 0, Jp), { vertices: i4, indices: s4 };
              }(this.tileID.canonical, e3);
              n2 = t4.vertices, i3 = t4.indices;
            } else {
              n2 = new da(), i3 = new ka();
              for (const { x: t5, y: e4 } of r3)
                n2.emplaceBack(t5, e4, 0, 0);
              const t4 = Dl(n2.int16, void 0, 4);
              for (let e4 = 0; e4 < t4.length; e4 += 3)
                i3.emplaceBack(t4[e4], t4[e4 + 1], t4[e4 + 2]);
            }
            this._tileBoundsBuffer = t3.createVertexBuffer(n2, id.members), this._tileBoundsIndexBuffer = t3.createIndexBuffer(i3), this._tileBoundsSegments = Mo.simpleSegment(0, 0, n2.length, i3.length);
          }
        }
        const od = ca([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_merc_pos", components: 2 }, { type: "Float32", name: "a_uv", components: 2 }]), ld = ca([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: ud } = od;
        function cd(t3, e3) {
          const r3 = t3.fovAboveCenter, n2 = t3.elevation ? t3.elevation.getMinElevationBelowMSL() * e3 : 0, i3 = (t3._camera.position[2] * t3.worldSize - n2) / Math.cos(t3._pitch), s4 = Math.sin(r3) * i3 / Math.sin(Math.max(Math.PI / 2 - t3._pitch - r3, 0.01)), a2 = Math.sin(t3._pitch) * s4 + i3;
          return Math.min(1.01 * a2, i3 * (1 / t3._horizonShift));
        }
        const hd = To / Math.PI / 2, pd = -hd, dd = hd, fd = [new gl([pd, pd, pd], [dd, dd, dd]), new gl([pd, pd, pd], [0, 0, dd]), new gl([0, pd, pd], [dd, 0, dd]), new gl([pd, 0, pd], [0, dd, dd]), new gl([0, 0, pd], [dd, dd, dd])];
        function yd(t3) {
          if (t3.z <= 1)
            return fd[t3.z + 2 * t3.y + t3.x];
          const [e3, r3] = md(t3), n2 = [xd(e3[0], e3[1]), xd(e3[0], r3[1]), xd(r3[0], e3[1]), xd(r3[0], r3[1])], i3 = [dd, dd, dd], s4 = [pd, pd, pd];
          for (const t4 of n2)
            i3[0] = Math.min(i3[0], t4[0]), i3[1] = Math.min(i3[1], t4[1]), i3[2] = Math.min(i3[2], t4[2]), s4[0] = Math.max(s4[0], t4[0]), s4[1] = Math.max(s4[1], t4[1]), s4[2] = Math.max(s4[2], t4[2]);
          return new gl(i3, s4);
        }
        function md(t3) {
          const e3 = Math.pow(2, t3.z), r3 = t3.x / e3, n2 = (t3.x + 1) / e3, i3 = (t3.y + 1) / e3;
          return [[Uo(t3.y / e3), Ro(r3)], [Uo(i3), Ro(n2)]];
        }
        function gd(t3, e3, r3, n2) {
          return r3 = q(r3), n2 || (n2 = hd), [t3 * Math.sin(r3) * n2, -e3 * n2, t3 * Math.cos(r3) * n2];
        }
        function xd(t3, e3, r3) {
          return gd(Math.cos(q(t3)), Math.sin(q(t3)), e3, r3);
        }
        function vd(t3) {
          return 16383 / Math.max(...E([], t3.max, t3.min));
        }
        function bd(t3) {
          const e3 = c(new Float64Array(16)), r3 = 1 / vd(t3);
          return p(e3, e3, t3.min), d(e3, e3, [r3, r3, r3]), e3;
        }
        function wd(t3, e3, r3) {
          const n2 = e3 / (2 * Math.PI), i3 = function(t4) {
            const e4 = To / (2 * Math.PI);
            return t4 / (2 * Math.PI) / e4;
          }(e3);
          if (!r3) {
            const n3 = Y(t3.center.lat, -85.051129, Oo);
            r3 = [Vo(t3.center.lng) * e3, Fo(n3) * e3];
          }
          const s4 = c(new Float64Array(16));
          return p(s4, s4, [r3[0], r3[1], -n2]), d(s4, s4, [i3, i3, i3]), f3(s4, s4, q(-t3._center.lat)), y(s4, s4, q(-t3._center.lng)), s4;
        }
        class _d {
          constructor(t3) {
            const e3 = this._createGridIndices();
            this.gridIndexBuffer = t3.createIndexBuffer(e3, true), this.gridSegments = Mo.simpleSegment(0, 0, 4225, 8192);
            const r3 = this._createPoleTriangleIndices();
            this.poleIndexBuffer = t3.createIndexBuffer(r3, true), this.poleSegments = Mo.simpleSegment(0, 0, 66, 64);
            const n2 = new Ta();
            n2.emplaceBack(-1, 1, 1, 0, 0, 0, 0), n2.emplaceBack(1, 1, 1, 0, 0, 1, 0), n2.emplaceBack(1, -1, 1, 0, 0, 1, 1), n2.emplaceBack(-1, -1, 1, 0, 0, 0, 1);
            const i3 = new ka();
            i3.emplaceBack(0, 1, 2), i3.emplaceBack(2, 3, 0), this.atmosphereVertexBuffer = t3.createVertexBuffer(n2, ld.members), this.atmosphereIndexBuffer = t3.createIndexBuffer(i3), this.atmosphereSegments = Mo.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.poleIndexBuffer.destroy(), this.gridIndexBuffer.destroy(), this.poleSegments.destroy(), this.gridSegments.destroy(), this.atmosphereVertexBuffer.destroy(), this.atmosphereIndexBuffer.destroy(), this.atmosphereSegments.destroy(), this.wireframeIndexBuffer && (this.wireframeIndexBuffer.destroy(), this.wireframeSegments.destroy());
          }
          static createPoleTriangleVertices(t3, e3, r3) {
            const n2 = new Ta(), i3 = e3 / Math.PI / 2;
            n2.emplaceBack(0, -i3, 0, 0, 0, 0.5, r3 ? 0 : 1);
            const s4 = 360 / t3, a2 = Math.cos(q(85)), o2 = Math.sin(q(85));
            for (let t4 = 0; t4 <= 64; t4++) {
              const e4 = t4 / 64, u2 = gd(a2, o2, 0 * (1 - (l2 = e4)) + s4 * l2, i3);
              n2.emplaceBack(u2[0], u2[1], u2[2], 0, 0, e4, r3 ? 0 : 1);
            }
            var l2;
            return n2;
          }
          _createPoleTriangleIndices() {
            const t3 = new ka();
            for (let e3 = 0; e3 <= 64; e3++)
              t3.emplaceBack(0, e3 + 1, e3 + 2);
            return t3;
          }
          static createGridVertices(t3) {
            const e3 = Math.pow(2, t3.z), r3 = (t4, e4, r4) => t4 * (1 - r4) + e4 * r4, [n2, i3] = md(t3), s4 = new Ta(), a2 = function(t4) {
              const e4 = c(new Float64Array(16)), r4 = vd(t4);
              var n3, i4;
              return d(e4, e4, [r4, r4, r4]), p(e4, e4, ((n3 = [])[0] = -(i4 = t4.min)[0], n3[1] = -i4[1], n3[2] = -i4[2], n3)), e4;
            }(yd(t3));
            s4.reserve(4096);
            for (let o2 = 0; o2 < 65; o2++) {
              const l2 = r3(n2[0], i3[0], o2 / 64), u2 = Fo(l2), c2 = u2 * e3 - t3.y, h3 = Math.sin(q(l2)), p2 = Math.cos(q(l2));
              for (let t4 = 0; t4 < 65; t4++) {
                const e4 = t4 / 64, o3 = r3(n2[1], i3[1], e4), l3 = gd(p2, h3, o3);
                B(l3, l3, a2);
                const d2 = Vo(o3);
                s4.emplaceBack(l3[0], l3[1], l3[2], d2, u2, e4, c2);
              }
            }
            return s4;
          }
          _createGridIndices() {
            const t3 = new ka(), e3 = (e4, r3) => {
              const n2 = 65 * r3 + e4;
              t3.emplaceBack(n2 + 1, n2, n2 + 65), t3.emplaceBack(n2 + 65, n2 + 65 + 1, n2 + 1);
            };
            for (let t4 = 0; t4 < 64; t4++)
              for (let r3 = 0; r3 < 64; r3++)
                e3(r3, t4);
            return t3;
          }
          getWirefameBuffer(t3) {
            if (!this.wireframeSegments) {
              const e3 = this._createWireframeGrid();
              this.wireframeIndexBuffer = t3.createIndexBuffer(e3), this.wireframeSegments = Mo.simpleSegment(0, 0, 4096, e3.length);
            }
            return [this.wireframeIndexBuffer, this.wireframeSegments];
          }
          _createWireframeGrid() {
            const t3 = new Ca(), e3 = (e4, r3) => {
              const n2 = 65 * r3 + e4;
              t3.emplaceBack(n2, n2 + 1), t3.emplaceBack(n2, n2 + 65), t3.emplaceBack(n2, n2 + 65 + 1);
            };
            for (let t4 = 0; t4 < 64; t4++)
              for (let r3 = 0; r3 < 64; r3++)
                e3(r3, t4);
            return t3;
          }
        }
        function Ad(t3, e3) {
          if (!e3.isReprojectedInTileSpace)
            return { scale: 1 << t3.z, x: t3.x, y: t3.y, x2: t3.x + 1, y2: t3.y + 1, projection: e3 };
          const r3 = Math.pow(2, -t3.z), n2 = t3.x * r3, i3 = (t3.x + 1) * r3, s4 = t3.y * r3, a2 = (t3.y + 1) * r3, o2 = Ro(n2), l2 = Ro(i3), u2 = Uo(s4), c2 = Uo(a2), h3 = e3.project(o2, u2), p2 = e3.project(l2, u2), d2 = e3.project(l2, c2), f4 = e3.project(o2, c2);
          let y2 = Math.min(h3.x, p2.x, d2.x, f4.x), m3 = Math.min(h3.y, p2.y, d2.y, f4.y), g2 = Math.max(h3.x, p2.x, d2.x, f4.x), x3 = Math.max(h3.y, p2.y, d2.y, f4.y);
          const v2 = r3 / 16;
          function b2(t4, r4, n3, i4, s5, a3) {
            const o3 = (n3 + s5) / 2, l3 = (i4 + a3) / 2, u3 = e3.project(Ro(o3), Uo(l3)), c3 = Math.max(0, y2 - u3.x, m3 - u3.y, u3.x - g2, u3.y - x3);
            y2 = Math.min(y2, u3.x), g2 = Math.max(g2, u3.x), m3 = Math.min(m3, u3.y), x3 = Math.max(x3, u3.y), c3 > v2 && (b2(t4, u3, n3, i4, o3, l3), b2(u3, r4, o3, l3, s5, a3));
          }
          b2(h3, p2, n2, s4, i3, s4), b2(p2, d2, i3, s4, i3, a2), b2(d2, f4, i3, a2, n2, a2), b2(f4, h3, n2, a2, n2, s4), y2 -= v2, m3 -= v2, g2 += v2, x3 += v2;
          const w2 = 1 / Math.max(g2 - y2, x3 - m3);
          return { scale: w2, x: y2 * w2, y: m3 * w2, x2: g2 * w2, y2: x3 * w2, projection: e3 };
        }
        class kd {
          constructor(t3) {
            const e3 = {}, r3 = [];
            for (const n3 in t3) {
              const i4 = t3[n3], s5 = e3[n3] = {};
              for (const t4 in i4.glyphs) {
                const e4 = i4.glyphs[+t4];
                if (!e4 || e4.bitmap.width === 0 || e4.bitmap.height === 0)
                  continue;
                const n4 = e4.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e4.bitmap.width + 2 * n4, h: e4.bitmap.height + 2 * n4 };
                r3.push(a2), s5[t4] = a2;
              }
            }
            const { w: n2, h: i3 } = $c(r3), s4 = new zl({ width: n2 || 1, height: i3 || 1 });
            for (const r4 in t3) {
              const n3 = t3[r4];
              for (const t4 in n3.glyphs) {
                const i4 = n3.glyphs[+t4];
                if (!i4 || i4.bitmap.width === 0 || i4.bitmap.height === 0)
                  continue;
                const a2 = e3[r4][t4], o2 = i4.metrics.localGlyph ? 2 : 1;
                zl.copy(i4.bitmap, s4, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i4.bitmap);
              }
            }
            this.image = s4, this.positions = e3;
          }
        }
        Zi("GlyphAtlas", kd);
        class Sd {
          constructor(t3) {
            this.tileID = new bp(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.tileZoom = t3.tileZoom, this.uid = t3.uid, this.zoom = t3.zoom, this.canonical = t3.tileID.canonical, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId, this.enableTerrain = !!t3.enableTerrain, this.isSymbolTile = t3.isSymbolTile, this.tileTransform = Ad(t3.tileID.canonical, t3.projection), this.projection = t3.projection;
          }
          parse(t3, e3, r3, n2, i3) {
            this.status = "parsing", this.data = t3, this.collisionBoxArray = new Fa();
            const s4 = new Tp(Object.keys(t3.layers).sort()), a2 = new Xp(this.tileID, this.promoteId);
            a2.bucketLayerIDs = [];
            const o2 = {}, l2 = new pp(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r3 }, c2 = e3.familiesBySource[this.source];
            for (const e4 in c2) {
              const n3 = t3.layers[e4];
              if (!n3)
                continue;
              let i4 = false, l3 = false;
              for (const t4 of c2[e4])
                t4[0].type === "symbol" ? i4 = true : l3 = true;
              if (this.isSymbolTile === true && !i4)
                continue;
              if (this.isSymbolTile === false && !l3)
                continue;
              n3.version === 1 && pt(`Vector tile source "${this.source}" layer "${e4}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const h4 = s4.encode(e4), p3 = [];
              for (let t4 = 0; t4 < n3.length; t4++) {
                const r4 = n3.feature(t4), i5 = a2.getId(r4, e4);
                p3.push({ feature: r4, id: i5, index: t4, sourceLayerIndex: h4 });
              }
              for (const t4 of c2[e4]) {
                const e5 = t4[0];
                this.isSymbolTile !== void 0 && e5.type === "symbol" !== this.isSymbolTile || e5.minzoom && this.zoom < Math.floor(e5.minzoom) || e5.maxzoom && this.zoom >= e5.maxzoom || e5.visibility !== "none" && (Id(t4, this.zoom, r3), (o2[e5.id] = e5.createBucket({ index: a2.bucketLayerIDs.length, layers: t4, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h4, sourceID: this.source, enableTerrain: this.enableTerrain, availableImages: r3 })).populate(p3, u2, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t4.map((t5) => t5.id)));
              }
            }
            let h3, p2, d2, f4;
            l2.trim();
            const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m3 = lt(u2.glyphDependencies, (t4) => Object.keys(t4).map(Number));
            Object.keys(m3).length ? n2.send("getGlyphs", { uid: this.uid, stacks: m3 }, (t4, e4) => {
              h3 || (h3 = t4, p2 = e4, v2.call(this));
            }, void 0, false, y2) : p2 = {};
            const g2 = Object.keys(u2.iconDependencies);
            g2.length ? n2.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t4, e4) => {
              h3 || (h3 = t4, d2 = e4, v2.call(this));
            }, void 0, false, y2) : d2 = {};
            const x3 = Object.keys(u2.patternDependencies);
            function v2() {
              if (h3)
                return i3(h3);
              if (p2 && d2 && f4) {
                const t4 = new kd(p2), e4 = new jc(d2, f4);
                for (const n3 in o2) {
                  const i4 = o2[n3];
                  i4 instanceof Yh ? (Id(i4.layers, this.zoom, r3), Eh(i4, p2, t4.positions, d2, e4.iconPositions, this.showCollisionBoxes, r3, this.tileID.canonical, this.tileZoom, this.projection), i4.projection = this.projection.name) : i4.hasPattern && (i4 instanceof Ku || i4 instanceof mu || i4 instanceof Vu) && (Id(i4.layers, this.zoom, r3), i4.addFeatures(u2, this.tileID.canonical, e4.patternPositions, r3));
                }
                this.status = "done", i3(null, { buckets: Q(o2).filter((t5) => !t5.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, lineAtlas: l2, imageAtlas: e4, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? d2 : null, glyphPositions: this.returnDependencies ? t4.positions : null });
              }
            }
            x3.length ? n2.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "patterns" }, (t4, e4) => {
              h3 || (h3 = t4, f4 = e4, v2.call(this));
            }, void 0, false, y2) : f4 = {}, v2.call(this);
          }
        }
        function Id(t3, e3, r3) {
          const n2 = new Gs(e3);
          for (const e4 of t3)
            e4.recalculate(n2, r3);
        }
        class zd {
          constructor(t3) {
            this.entries = {}, this.scheduler = t3;
          }
          request(t3, e3, r3, n2) {
            const i3 = this.entries[t3] = this.entries[t3] || { callbacks: [] };
            if (i3.result) {
              const [t4, r4] = i3.result;
              return this.scheduler ? this.scheduler.add(() => {
                n2(t4, r4);
              }, e3) : n2(t4, r4), () => {
              };
            }
            return i3.callbacks.push(n2), i3.cancel || (i3.cancel = r3((r4, n3) => {
              i3.result = [r4, n3];
              for (const t4 of i3.callbacks)
                this.scheduler ? this.scheduler.add(() => {
                  t4(r4, n3);
                }, e3) : t4(r4, n3);
              setTimeout(() => delete this.entries[t3], 3e3);
            })), () => {
              i3.result || (i3.callbacks = i3.callbacks.filter((t4) => t4 !== n2), i3.callbacks.length || (i3.cancel(), delete this.entries[t3]));
            };
          }
        }
        function Md(t3, e3, r3) {
          const n2 = JSON.stringify(t3.request);
          return t3.data && (this.deduped.entries[n2] = { result: [null, t3.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }, (e4) => {
            const n3 = ae(t3.request, (t4, n4, i3, s4) => {
              t4 ? e4(t4) : n4 && e4(null, { vectorTile: r3 ? void 0 : new Bu.VectorTile(new gc(n4)), rawData: n4, cacheControl: i3, expires: s4 });
            });
            return () => {
              n3.cancel(), e4();
            };
          }, e3);
        }
        const Td = c(new Float64Array(16));
        class Bd {
          constructor(t3, e3) {
            this._tr = t3, this._worldSize = e3;
          }
          createInversionMatrix() {
            return Td;
          }
          createTileMatrix(t3) {
            let e3, r3, n2;
            const i3 = t3.canonical, s4 = c(new Float64Array(16)), a2 = this._tr.projection;
            if (a2.isReprojectedInTileSpace) {
              const o2 = Ad(i3, a2);
              e3 = 1, r3 = o2.x + t3.wrap * o2.scale, n2 = o2.y, d(s4, s4, [e3 / o2.scale, e3 / o2.scale, this._tr.pixelsPerMeter / this._worldSize]);
            } else
              e3 = this._worldSize / this._tr.zoomScale(i3.z), r3 = (i3.x + Math.pow(2, i3.z) * t3.wrap) * e3, n2 = i3.y * e3;
            return p(s4, s4, [r3, n2, 0]), d(s4, s4, [e3 / To, e3 / To, 1]), s4;
          }
          pointCoordinate(t3, e3, r3) {
            const n2 = this._tr.horizonLineFromTop(false), s4 = new i2(t3, Math.max(n2, e3));
            return this._tr.rayIntersectionCoordinate(this._tr.pointRayIntersection(s4, r3));
          }
          upVector() {
            return [0, 0, 1];
          }
          upVectorScale() {
            return 1;
          }
        }
        var Cd = { name: "albers", range: [4, 7], center: [-96, 37.5], parallels: [29.5, 45.5], zAxisUnit: "meters", conic: true, isReprojectedInTileSpace: true, unsupportedLayers: ["custom"], initializeConstants() {
          if (this.constants && $(this.parallels, this.constants.parallels))
            return;
          const t3 = Math.sin(q(this.parallels[0])), e3 = (t3 + Math.sin(q(this.parallels[1]))) / 2, r3 = 1 + t3 * (2 * e3 - t3), n2 = Math.sqrt(r3) / e3;
          this.constants = { n: e3, c: r3, r0: n2, parallels: this.parallels };
        }, project(t3, e3) {
          this.initializeConstants();
          const r3 = q(t3 - this.center[0]), n2 = q(e3), { n: i3, c: s4, r0: a2 } = this.constants, o2 = Math.sqrt(s4 - 2 * i3 * Math.sin(n2)) / i3;
          return { x: o2 * Math.sin(r3 * i3), y: o2 * Math.cos(r3 * i3) - a2, z: 0 };
        }, unproject(t3, e3) {
          this.initializeConstants();
          const { n: r3, c: n2, r0: i3 } = this.constants, s4 = i3 + e3;
          let a2 = Math.atan2(t3, Math.abs(s4)) * Math.sign(s4);
          s4 * r3 < 0 && (a2 -= Math.PI * Math.sign(t3) * Math.sign(s4));
          const o2 = q(this.center[0]) * r3;
          a2 = J(a2, -Math.PI - o2, Math.PI - o2);
          const l2 = N(a2 / r3) + this.center[0], u2 = Math.asin(Y((n2 - (t3 * t3 + s4 * s4) * r3 * r3) / (2 * r3), -1, 1)), c2 = Y(N(u2), -85.051129, Oo);
          return new Po(l2, c2);
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) };
        const Pd = 1.340264, Ed = -0.081106, Dd = 893e-6, Vd = 3796e-6, Fd = Math.sqrt(3) / 2;
        var Ld = { name: "equalEarth", center: [0, 0], range: [3.5, 7], zAxisUnit: "meters", isReprojectedInTileSpace: true, unsupportedLayers: ["custom"], project(t3, e3) {
          e3 = e3 / 180 * Math.PI, t3 = t3 / 180 * Math.PI;
          const r3 = Math.asin(Fd * Math.sin(e3)), n2 = r3 * r3, i3 = n2 * n2 * n2;
          return { x: 0.5 * (t3 * Math.cos(r3) / (Fd * (Pd + 3 * Ed * n2 + i3 * (7 * Dd + 9 * Vd * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r3 * (Pd + Ed * n2 + i3 * (Dd + Vd * n2)) / Math.PI + 1), z: 0 };
        }, unproject(t3, e3) {
          t3 = (2 * t3 - 0.5) * Math.PI;
          let r3 = e3 = (2 * (1 - e3) - 1) * Math.PI, n2 = r3 * r3, i3 = n2 * n2 * n2;
          for (let t4, s5, a3, o3 = 0; o3 < 12 && (s5 = r3 * (Pd + Ed * n2 + i3 * (Dd + Vd * n2)) - e3, a3 = Pd + 3 * Ed * n2 + i3 * (7 * Dd + 9 * Vd * n2), t4 = s5 / a3, r3 = Y(r3 - t4, -Math.PI / 3, Math.PI / 3), n2 = r3 * r3, i3 = n2 * n2 * n2, !(Math.abs(t4) < 1e-12)); ++o3)
            ;
          const s4 = Fd * t3 * (Pd + 3 * Ed * n2 + i3 * (7 * Dd + 9 * Vd * n2)) / Math.cos(r3), a2 = Math.asin(Math.sin(r3) / Fd), o2 = Y(180 * s4 / Math.PI, -180, 180), l2 = Y(180 * a2 / Math.PI, -85.051129, Oo);
          return new Po(o2, l2);
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) }, Rd = { name: "equirectangular", supportsWorldCopies: true, center: [0, 0], range: [3.5, 7], zAxisUnit: "meters", wrap: true, isReprojectedInTileSpace: true, unsupportedLayers: ["custom"], project: (t3, e3) => ({ x: 0.5 + t3 / 360, y: 0.5 - e3 / 360, z: 0 }), unproject(t3, e3) {
          const r3 = 360 * (t3 - 0.5), n2 = Y(360 * (0.5 - e3), -85.051129, Oo);
          return new Po(r3, n2);
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) };
        const Ud = Math.PI / 2;
        function $d(t3) {
          return Math.tan((Ud + t3) / 2);
        }
        var Od = { name: "lambertConformalConic", range: [3.5, 7], zAxisUnit: "meters", center: [0, 30], parallels: [30, 30], conic: true, isReprojectedInTileSpace: true, unsupportedLayers: ["custom"], initializeConstants() {
          if (this.constants && $(this.parallels, this.constants.parallels))
            return;
          const t3 = q(this.parallels[0]), e3 = q(this.parallels[1]), r3 = Math.cos(t3), n2 = t3 === e3 ? Math.sin(t3) : Math.log(r3 / Math.cos(e3)) / Math.log($d(e3) / $d(t3)), i3 = r3 * Math.pow($d(t3), n2) / n2;
          this.constants = { n: n2, f: i3, parallels: this.parallels };
        }, project(t3, e3) {
          this.initializeConstants(), e3 = q(e3), t3 = q(t3 - this.center[0]);
          const r3 = 1e-6, { n: n2, f: i3 } = this.constants;
          i3 > 0 ? e3 < -Ud + r3 && (e3 = -Ud + r3) : e3 > Ud - r3 && (e3 = Ud - r3);
          const s4 = i3 / Math.pow($d(e3), n2), a2 = s4 * Math.sin(n2 * t3), o2 = i3 - s4 * Math.cos(n2 * t3);
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 0.5), z: 0 };
        }, unproject(t3, e3) {
          this.initializeConstants(), t3 = (2 * t3 - 0.5) * Math.PI, e3 = (2 * (1 - e3) - 0.5) * Math.PI;
          const { n: r3, f: n2 } = this.constants, i3 = n2 - e3, s4 = Math.sign(i3), a2 = Math.sign(r3) * Math.sqrt(t3 * t3 + i3 * i3);
          let o2 = Math.atan2(t3, Math.abs(i3)) * s4;
          i3 * r3 < 0 && (o2 -= Math.PI * Math.sign(t3) * s4);
          const l2 = Y(N(o2 / r3) + this.center[0], -180, 180), u2 = Y(N(2 * Math.atan(Math.pow(n2 / a2, 1 / r3)) - Ud), -85.051129, Oo);
          return new Po(l2, u2);
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) }, jd = { name: "mercator", wrap: true, requiresDraping: false, supportsWorldCopies: true, supportsTerrain: true, supportsFog: true, supportsFreeCamera: true, zAxisUnit: "meters", center: [0, 0], project: (t3, e3) => ({ x: Vo(t3), y: Fo(e3), z: 0 }), unproject(t3, e3) {
          const r3 = Ro(t3), n2 = Uo(e3);
          return new Po(r3, n2);
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) };
        const qd = q(Oo);
        var Nd = { name: "naturalEarth", center: [0, 0], range: [3.5, 7], isReprojectedInTileSpace: true, zAxisUnit: "meters", unsupportedLayers: ["custom"], project(t3, e3) {
          const r3 = (e3 = q(e3)) * e3, n2 = r3 * r3;
          return { x: 0.5 * ((t3 = q(t3)) * (0.8707 - 0.131979 * r3 + n2 * (n2 * (3971e-6 * r3 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e3 * (1.007226 + r3 * (0.015085 + n2 * (0.028874 * r3 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
        }, unproject(t3, e3) {
          t3 = (2 * t3 - 0.5) * Math.PI;
          let r3 = e3 = (2 * (1 - e3) - 1) * Math.PI, n2 = 25, i3 = 0, s4 = r3 * r3;
          do {
            s4 = r3 * r3;
            const t4 = s4 * s4;
            i3 = (r3 * (1.007226 + s4 * (0.015085 + t4 * (0.028874 * s4 - 0.044475 - 5916e-6 * t4))) - e3) / (1.007226 + s4 * (0.045255 + t4 * (0.259866 * s4 - 0.311325 - 5916e-6 * 11 * t4))), r3 = Y(r3 - i3, -qd, qd);
          } while (Math.abs(i3) > 1e-6 && --n2 > 0);
          s4 = r3 * r3;
          const a2 = Y(N(t3 / (0.8707 + s4 * (s4 * (s4 * s4 * s4 * (3971e-6 - 1529e-6 * s4) - 0.013791) - 0.131979))), -180, 180), o2 = N(r3);
          return new Po(a2, o2);
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) };
        const Gd = q(Oo), Zd = { albers: Cd, equalEarth: Ld, equirectangular: Rd, lambertConformalConic: Od, mercator: jd, naturalEarth: Nd, winkelTripel: { name: "winkelTripel", center: [0, 0], range: [3.5, 7], zAxisUnit: "meters", isReprojectedInTileSpace: true, unsupportedLayers: ["custom"], project(t3, e3) {
          e3 = q(e3), t3 = q(t3);
          const r3 = Math.cos(e3), n2 = 2 / Math.PI, i3 = Math.acos(r3 * Math.cos(t3 / 2)), s4 = Math.sin(i3) / i3, a2 = 0.5 * (t3 * n2 + 2 * r3 * Math.sin(t3 / 2) / s4) || 0, o2 = 0.5 * (e3 + Math.sin(e3) / s4) || 0;
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
        }, unproject(t3, e3) {
          let r3 = t3 = (2 * t3 - 0.5) * Math.PI, n2 = e3 = (2 * (1 - e3) - 1) * Math.PI, i3 = 25;
          const s4 = 1e-6;
          let a2 = 0, o2 = 0;
          do {
            const i4 = Math.cos(n2), s5 = Math.sin(n2), l2 = 2 * s5 * i4, u2 = s5 * s5, c2 = i4 * i4, h3 = Math.cos(r3 / 2), p2 = Math.sin(r3 / 2), d2 = 2 * h3 * p2, f4 = p2 * p2, y2 = 1 - c2 * h3 * h3, m3 = y2 ? 1 / y2 : 0, g2 = y2 ? Math.acos(i4 * h3) * Math.sqrt(1 / y2) : 0, x3 = 0.5 * (2 * g2 * i4 * p2 + 2 * r3 / Math.PI) - t3, v2 = 0.5 * (g2 * s5 + n2) - e3, b2 = 0.5 * m3 * (c2 * f4 + g2 * i4 * h3 * u2) + 1 / Math.PI, w2 = m3 * (d2 * l2 / 4 - g2 * s5 * p2), _2 = 0.125 * m3 * (l2 * p2 - g2 * s5 * c2 * d2), A3 = 0.5 * m3 * (u2 * h3 + g2 * f4 * i4) + 0.5, k2 = w2 * _2 - A3 * b2;
            a2 = (v2 * w2 - x3 * A3) / k2, o2 = (x3 * _2 - v2 * b2) / k2, r3 = Y(r3 - a2, -Math.PI, Math.PI), n2 = Y(n2 - o2, -Gd, Gd);
          } while ((Math.abs(a2) > s4 || Math.abs(o2) > s4) && --i3 > 0);
          return new Po(N(r3), N(n2));
        }, projectTilePoint: (t3, e3) => ({ x: t3, y: e3, z: 0 }), locationPoint: (t3, e3) => t3._coordinatePoint(t3.locationCoordinate(e3), false), pixelsPerMeter: (t3, e3) => Lo(1, t3) * e3, farthestPixelDistance(t3) {
          return cd(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize));
        }, createTileTransform: (t3, e3) => new Bd(t3, e3) } };
        t2.ARRAY_TYPE = l, t2.AUTH_ERR_MSG = Et, t2.Aabb = gl, t2.Actor = class {
          constructor(t3, e3, r3) {
            this.target = t3, this.parent = e3, this.mapId = r3, this.callbacks = {}, this.cancelCallbacks = {}, at(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = yt() ? t3 : a, this.scheduler = new mp();
          }
          send(t3, e3, r3, n2, i3 = false, s4) {
            const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r3 && (r3.metadata = s4, this.callbacks[a2] = r3);
            const o2 = wt(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: a2, type: t3, hasCallback: !!r3, targetMapId: n2, mustQueue: i3, sourceMapId: this.mapId, data: Yi(e3, o2) }, o2), { cancel: () => {
              r3 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
            } };
          }
          receive(t3) {
            const e3 = t3.data, r3 = e3.id;
            if (r3 && (!e3.targetMapId || this.mapId === e3.targetMapId))
              if (e3.type === "<cancel>") {
                const t4 = this.cancelCallbacks[r3];
                delete this.cancelCallbacks[r3], t4 && t4.cancel();
              } else if (e3.mustQueue || yt()) {
                const t4 = this.callbacks[r3];
                this.cancelCallbacks[r3] = this.scheduler.add(() => this.processTask(r3, e3), t4 && t4.metadata || { type: "message" });
              } else
                this.processTask(r3, e3);
          }
          processTask(t3, e3) {
            if (e3.type === "<response>") {
              const r3 = this.callbacks[t3];
              delete this.callbacks[t3], r3 && (e3.error ? r3(Hi(e3.error)) : r3(null, Hi(e3.data)));
            } else {
              const r3 = wt(this.globalScope) ? void 0 : [], n2 = e3.hasCallback ? (e4, n3) => {
                delete this.cancelCallbacks[t3], this.target.postMessage({ id: t3, type: "<response>", sourceMapId: this.mapId, error: e4 ? Yi(e4) : null, data: Yi(n3, r3) }, r3);
              } : (t4) => {
              }, i3 = Hi(e3.data);
              if (this.parent[e3.type])
                this.parent[e3.type](e3.sourceMapId, i3, n2);
              else if (this.parent.getWorkerSource) {
                const t4 = e3.type.split(".");
                this.parent.getWorkerSource(e3.sourceMapId, t4[0], i3.source)[t4[1]](i3, n2);
              } else
                n2(new Error(`Could not find function ${e3.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t2.CanonicalTileID = xp, t2.Color = Ge, t2.ColorMode = Sp, t2.CullFaceMode = Mp, t2.DEMData = Op, t2.DataConstantProperty = ta, t2.DedupedRequest = zd, t2.DepthMode = _p, t2.EXTENT = To, t2.Elevation = class {
          getAtPointOrZero(t3, e3 = 0) {
            return this.getAtPoint(t3, e3) || 0;
          }
          getAtPoint(t3, e3, r3 = true) {
            e3 == null && (e3 = null);
            const n2 = this._source();
            if (!n2)
              return e3;
            if (t3.y < 0 || t3.y > 1)
              return e3;
            const i3 = n2.getSource().maxzoom, s4 = 1 << i3, a2 = Math.floor(t3.x), o2 = t3.x - a2, l2 = new bp(i3, a2, i3, Math.floor(o2 * s4), Math.floor(t3.y * s4)), u2 = this.findDEMTileFor(l2);
            if (!u2 || !u2.dem)
              return e3;
            const c2 = u2.dem, h3 = 1 << u2.tileID.canonical.z, p2 = (o2 * h3 - u2.tileID.canonical.x) * c2.dim, d2 = (t3.y * h3 - u2.tileID.canonical.y) * c2.dim, f4 = Math.floor(p2), y2 = Math.floor(d2);
            return (r3 ? this.exaggeration() : 1) * Lr(Lr(c2.get(f4, y2), c2.get(f4, y2 + 1), d2 - y2), Lr(c2.get(f4 + 1, y2), c2.get(f4 + 1, y2 + 1), d2 - y2), p2 - f4);
          }
          getAtTileOffset(t3, e3, r3) {
            const n2 = 1 << t3.canonical.z;
            return this.getAtPointOrZero(new jo(t3.wrap + (t3.canonical.x + e3 / To) / n2, (t3.canonical.y + r3 / To) / n2));
          }
          getAtTileOffsetFunc(t3, e3) {
            return (r3) => {
              const n2 = this.getAtTileOffset(t3, r3.x, r3.y), i3 = e3.upVector(t3.canonical, r3.x, r3.y);
              return S2(i3, i3, n2 * e3.upVectorScale(t3.canonical)), i3;
            };
          }
          getForTilePoints(t3, e3, r3, n2) {
            const i3 = Zp.create(this, t3, n2);
            return !!i3 && (e3.forEach((t4) => {
              t4[2] = this.exaggeration() * i3.getElevationAt(t4[0], t4[1], r3);
            }), true);
          }
          getMinMaxForTile(t3) {
            const e3 = this.findDEMTileFor(t3);
            if (!e3 || !e3.dem)
              return null;
            const r3 = e3.dem.tree, n2 = e3.tileID, i3 = 1 << t3.canonical.z - n2.canonical.z;
            let s4 = t3.canonical.x / i3 - n2.canonical.x, a2 = t3.canonical.y / i3 - n2.canonical.y, o2 = 0;
            for (let e4 = 0; e4 < t3.canonical.z - n2.canonical.z && !r3.leaves[o2]; e4++) {
              s4 *= 2, a2 *= 2;
              const t4 = 2 * Math.floor(a2) + Math.floor(s4);
              o2 = r3.childOffsets[o2] + t4, s4 %= 1, a2 %= 1;
            }
            return { min: this.exaggeration() * r3.minimums[o2], max: this.exaggeration() * r3.maximums[o2] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t3, e3, r3) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t3) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t3) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
        }, t2.ErrorEvent = ge, t2.EvaluationParameters = Gs, t2.Event = me, t2.Evented = xe, t2.Frustum = ml, t2.GLOBE_ZOOM_THRESHOLD_MAX = 6, t2.GlobeSharedBuffers = _d, t2.GlyphManager = xh, t2.ImagePosition = Oc, t2.LineAtlas = pp, t2.LngLat = Po, t2.LngLatBounds = Bo, t2.LocalGlyphMode = gh, t2.MAX_MERCATOR_LATITUDE = Oo, t2.MercatorCoordinate = jo, t2.ONE_EM = sc, t2.OverscaledTileID = bp, t2.Properties = sa, t2.RGBAImage = Ml, t2.Ray = class {
          constructor(t3, e3) {
            this.pos = t3, this.dir = e3;
          }
          intersectsPlane(t3, e3, r3) {
            const n2 = M(e3, this.dir);
            if (Math.abs(n2) < 1e-6)
              return false;
            const i3 = ((t3[0] - this.pos[0]) * e3[0] + (t3[1] - this.pos[1]) * e3[1] + (t3[2] - this.pos[2]) * e3[2]) / n2;
            return r3[0] = this.pos[0] + this.dir[0] * i3, r3[1] = this.pos[1] + this.dir[1] * i3, r3[2] = this.pos[2] + this.dir[2] * i3, true;
          }
          closestPointOnSphere(t3, e3, r3) {
            if (function(t4, e4) {
              var r4 = t4[0], n3 = t4[1], i4 = t4[2], s5 = e4[0], a3 = e4[1], l3 = e4[2];
              return Math.abs(r4 - s5) <= o * Math.max(1, Math.abs(r4), Math.abs(s5)) && Math.abs(n3 - a3) <= o * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i4 - l3) <= o * Math.max(1, Math.abs(i4), Math.abs(l3));
            }(this.pos, t3) || e3 === 0)
              return r3[0] = r3[1] = r3[2] = 0, false;
            const [n2, i3, s4] = this.dir, a2 = this.pos[0] - t3[0], l2 = this.pos[1] - t3[1], u2 = this.pos[2] - t3[2], c2 = n2 * n2 + i3 * i3 + s4 * s4, h3 = 2 * (a2 * n2 + l2 * i3 + u2 * s4), p2 = h3 * h3 - 4 * c2 * (a2 * a2 + l2 * l2 + u2 * u2 - e3 * e3);
            if (p2 < 0) {
              const t4 = Math.max(-h3 / 2, 0), o2 = a2 + n2 * t4, c3 = l2 + i3 * t4, p3 = u2 + s4 * t4, d2 = Math.hypot(o2, c3, p3);
              return r3[0] = o2 * e3 / d2, r3[1] = c3 * e3 / d2, r3[2] = p3 * e3 / d2, false;
            }
            {
              const t4 = (-h3 - Math.sqrt(p2)) / (2 * c2);
              if (t4 < 0) {
                const t5 = Math.hypot(a2, l2, u2);
                return r3[0] = a2 * e3 / t5, r3[1] = l2 * e3 / t5, r3[2] = u2 * e3 / t5, false;
              }
              return r3[0] = a2 + n2 * t4, r3[1] = l2 + i3 * t4, r3[2] = u2 + s4 * t4, true;
            }
          }
        }, t2.RequestManager = class {
          constructor(t3, e3, r3) {
            this._transformRequestFn = t3, this._customAccessToken = e3, this._silenceAuthErrors = !!r3, this._createSkuToken();
          }
          _createSkuToken() {
            const t3 = function() {
              let t4 = "";
              for (let e3 = 0; e3 < 10; e3++)
                t4 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", Pt, t4].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t3.token, this._skuTokenExpiresAt = t3.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t3, e3) {
            return this._transformRequestFn && this._transformRequestFn(t3, e3) || { url: t3 };
          }
          normalizeStyleURL(t3, e3) {
            if (!Dt(t3))
              return t3;
            const r3 = Lt(t3);
            return r3.path = `/styles/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e3);
          }
          normalizeGlyphsURL(t3, e3) {
            if (!Dt(t3))
              return t3;
            const r3 = Lt(t3);
            return r3.path = `/fonts/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e3);
          }
          normalizeSourceURL(t3, e3) {
            if (!Dt(t3))
              return t3;
            const r3 = Lt(t3);
            return r3.path = `/v4/${r3.authority}.json`, r3.params.push("secure"), this._makeAPIURL(r3, this._customAccessToken || e3);
          }
          normalizeSpriteURL(t3, e3, r3, n2) {
            const i3 = Lt(t3);
            return Dt(t3) ? (i3.path = `/styles/v1${i3.path}/sprite${e3}${r3}`, this._makeAPIURL(i3, this._customAccessToken || n2)) : (i3.path += `${e3}${r3}`, Rt(i3));
          }
          normalizeTileURL(t3, e3, r3) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t3 && !Dt(t3))
              return t3;
            const n2 = Lt(t3);
            n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e3 || r3 && n2.authority !== "raster" && r3 === 512 ? "@2x" : ""}${It.supported ? ".webp" : "$1"}`), n2.authority === "raster" ? n2.path = `/${St.RASTER_URL_PREFIX}${n2.path}` : (n2.path = n2.path.replace(/^.+\/v4\//, "/"), n2.path = `/${St.TILE_URL_VERSION}${n2.path}`);
            const i3 = this._customAccessToken || function(t4) {
              for (const e4 of t4) {
                const t5 = e4.match(/^access_token=(.*)$/);
                if (t5)
                  return t5[1];
              }
              return null;
            }(n2.params) || St.ACCESS_TOKEN;
            return St.REQUIRE_ACCESS_TOKEN && i3 && this._skuToken && n2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n2, i3);
          }
          canonicalizeTileURL(t3, e3) {
            const r3 = Lt(t3);
            if (!r3.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r3.path.match(/\.[\w]+$/))
              return t3;
            let n2 = "mapbox://";
            r3.path.match(/^\/raster\/v1\//) ? n2 += `raster/${r3.path.replace(`/${St.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${r3.path.replace(`/${St.TILE_URL_VERSION}/`, "")}`;
            let i3 = r3.params;
            return e3 && (i3 = i3.filter((t4) => !t4.match(/^access_token=/))), i3.length && (n2 += `?${i3.join("&")}`), n2;
          }
          canonicalizeTileset(t3, e3) {
            const r3 = !!e3 && Dt(e3), n2 = [];
            for (const e4 of t3.tiles || [])
              Vt(e4) ? n2.push(this.canonicalizeTileURL(e4, r3)) : n2.push(e4);
            return n2;
          }
          _makeAPIURL(t3, e3) {
            const r3 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n2 = Lt(St.API_URL);
            if (t3.protocol = n2.protocol, t3.authority = n2.authority, t3.protocol === "http") {
              const e4 = t3.params.indexOf("secure");
              e4 >= 0 && t3.params.splice(e4, 1);
            }
            if (n2.path !== "/" && (t3.path = `${n2.path}${t3.path}`), !St.REQUIRE_ACCESS_TOKEN)
              return Rt(t3);
            if (e3 = e3 || St.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!e3)
                throw new Error(`An API access token is required to use Mapbox GL. ${r3}`);
              if (e3[0] === "s")
                throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r3}`);
            }
            return t3.params = t3.params.filter((t4) => t4.indexOf("access_token") === -1), t3.params.push(`access_token=${e3 || ""}`), Rt(t3);
          }
        }, t2.ResourceType = re, t2.SegmentVector = Mo, t2.SourceCache = qp, t2.StencilMode = kp, t2.StructArrayLayout1ui2 = Pa, t2.StructArrayLayout2f1f2i16 = _a, t2.StructArrayLayout2i4 = pa, t2.StructArrayLayout2ui4 = Ca, t2.StructArrayLayout3f12 = ya, t2.StructArrayLayout3ui6 = ka, t2.StructArrayLayout4i8 = da, t2.Texture = hp, t2.Tile = ad, t2.Transitionable = Ks, t2.Uniform1f = io, t2.Uniform1i = class extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = 0;
          }
          set(t3) {
            this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
          }
        }, t2.Uniform2f = class extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = [0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
          }
        }, t2.Uniform3f = class extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = [0, 0, 0];
          }
          set(t3) {
            t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
          }
        }, t2.Uniform4f = so, t2.UniformColor = ao, t2.UniformMatrix2f = class extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = uo;
          }
          set(t3) {
            for (let e3 = 0; e3 < 4; e3++)
              if (t3[e3] !== this.current[e3]) {
                this.current = t3, this.gl.uniformMatrix2fv(this.location, false, t3);
                break;
              }
          }
        }, t2.UniformMatrix3f = class extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = lo;
          }
          set(t3) {
            for (let e3 = 0; e3 < 9; e3++)
              if (t3[e3] !== this.current[e3]) {
                this.current = t3, this.gl.uniformMatrix3fv(this.location, false, t3);
                break;
              }
          }
        }, t2.UniformMatrix4f = class extends no {
          constructor(t3, e3) {
            super(t3, e3), this.current = oo;
          }
          set(t3) {
            if (t3[12] !== this.current[12] || t3[0] !== this.current[0])
              return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
            for (let e3 = 1; e3 < 16; e3++)
              if (t3[e3] !== this.current[e3]) {
                this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
                break;
              }
          }
        }, t2.UnwrappedTileID = vp, t2.ValidationError = be, t2.VectorTileWorkerSource = class extends xe {
          constructor(t3, e3, r3, n2, i3) {
            super(), this.actor = t3, this.layerIndex = e3, this.availableImages = r3, this.loadVectorData = i3 || Md, this.loading = {}, this.loaded = {}, this.deduped = new zd(t3.scheduler), this.isSpriteLoaded = n2, this.scheduler = t3.scheduler;
          }
          loadTile(t3, e3) {
            const r3 = t3.uid, n2 = t3 && t3.request, i3 = n2 && n2.collectResourceTiming, s4 = this.loading[r3] = new Sd(t3);
            s4.abort = this.loadVectorData(t3, (a2, o2) => {
              const l2 = !this.loading[r3];
              if (delete this.loading[r3], l2 || a2 || !o2)
                return s4.status = "done", l2 || (this.loaded[r3] = s4), e3(a2);
              const u2 = o2.rawData, c2 = {};
              o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s4.vectorTile = o2.vectorTile || new Bu.VectorTile(new gc(u2));
              const h3 = () => {
                s4.parse(s4.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, r4) => {
                  if (t4 || !r4)
                    return e3(t4);
                  const s5 = {};
                  if (i3) {
                    const t5 = yp(n2);
                    t5.length > 0 && (s5.resourceTiming = JSON.parse(JSON.stringify(t5)));
                  }
                  e3(null, tt({ rawTileData: u2.slice(0) }, r4, c2, s5));
                });
              };
              this.isSpriteLoaded ? h3() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(h3, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }) : h3();
              }), this.loaded = this.loaded || {}, this.loaded[r3] = s4;
            });
          }
          reloadTile(t3, e3) {
            const r3 = this.loaded, n2 = t3.uid, i3 = this;
            if (r3 && r3[n2]) {
              const s4 = r3[n2];
              s4.showCollisionBoxes = t3.showCollisionBoxes, s4.enableTerrain = !!t3.enableTerrain, s4.projection = t3.projection;
              const a2 = (t4, r4) => {
                const n3 = s4.reloadCallback;
                n3 && (delete s4.reloadCallback, s4.parse(s4.vectorTile, i3.layerIndex, this.availableImages, i3.actor, n3)), e3(t4, r4);
              };
              s4.status === "parsing" ? s4.reloadCallback = a2 : s4.status === "done" && (s4.vectorTile ? s4.parse(s4.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
            }
          }
          abortTile(t3, e3) {
            const r3 = t3.uid, n2 = this.loading[r3];
            n2 && (n2.abort && n2.abort(), delete this.loading[r3]), e3();
          }
          removeTile(t3, e3) {
            const r3 = this.loaded, n2 = t3.uid;
            r3 && r3[n2] && delete r3[n2], e3();
          }
        }, t2.WritingMode = qc, t2.ZoomHistory = Ji, t2.add = w, t2.addDynamicAttributes = Gh, t2.adjoint = function(t3, e3) {
          var r3 = e3[0], n2 = e3[1], i3 = e3[2], s4 = e3[3], a2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8];
          return t3[0] = a2 * c2 - o2 * u2, t3[1] = i3 * u2 - n2 * c2, t3[2] = n2 * o2 - i3 * a2, t3[3] = o2 * l2 - s4 * c2, t3[4] = r3 * c2 - i3 * l2, t3[5] = i3 * s4 - r3 * o2, t3[6] = s4 * u2 - a2 * l2, t3[7] = n2 * l2 - r3 * u2, t3[8] = r3 * a2 - n2 * s4, t3;
        }, t2.asyncAll = W, t2.bezier = X, t2.bindAll = at, t2.boundsAttributes = id, t2.bufferConvexPolygon = function(t3, e3) {
          const r3 = [];
          for (let n2 = 0; n2 < t3.length; n2++) {
            const i3 = J(n2 - 1, -1, t3.length - 1), s4 = J(n2 + 1, -1, t3.length - 1), a2 = t3[n2], o2 = t3[s4], l2 = t3[i3].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h3 = l2.add(u2).unit().mult(-1 * e3 / Math.sin(c2 / 2));
            r3.push(a2.add(h3));
          }
          return r3;
        }, t2.cacheEntryPossiblyAdded = function(t3) {
          ee++, ee > Wt && (t3.getActor().send("enforceCacheSizeLimit", Jt), ee = 0);
        }, t2.calculateGlobeMatrix = wd, t2.calculateGlobeMercatorMatrix = function(t3) {
          const e3 = t3.worldSize, r3 = Y(t3.center.lat, -85.051129, Oo), n2 = new i2(Vo(t3.center.lng) * e3, Fo(r3) * e3), s4 = Lo(1, t3.center.lat) * e3, a2 = t3.pixelsPerMeter, o2 = e3 / (s4 / t3.pixelsPerMeter), l2 = c(new Float64Array(16));
          return p(l2, l2, [n2.x, n2.y, 0]), d(l2, l2, [o2, o2, a2]), l2;
        }, t2.clamp = Y, t2.clearTileCache = function(t3) {
          const e3 = a.caches.delete(Kt);
          t3 && e3.catch(t3).then(() => t3());
        }, t2.clipLine = dh, t2.clone = function(t3) {
          var e3 = new l(16);
          return e3[0] = t3[0], e3[1] = t3[1], e3[2] = t3[2], e3[3] = t3[3], e3[4] = t3[4], e3[5] = t3[5], e3[6] = t3[6], e3[7] = t3[7], e3[8] = t3[8], e3[9] = t3[9], e3[10] = t3[10], e3[11] = t3[11], e3[12] = t3[12], e3[13] = t3[13], e3[14] = t3[14], e3[15] = t3[15], e3;
        }, t2.clone$1 = ct, t2.collisionCircleLayout = ic, t2.config = St, t2.conjugate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = e3[3], t3;
        }, t2.create = function() {
          var t3 = new l(16);
          return l != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
        }, t2.create$1 = u, t2.createExpression = Gn, t2.createLayout = ca, t2.createStyleLayer = function(t3) {
          return t3.type === "custom" ? new rp(t3) : new sp[t3.type](t3);
        }, t2.cross = T, t2.degToRad = q, t2.div = function(t3, e3, r3) {
          return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3[2] = e3[2] / r3[2], t3;
        }, t2.dot = M, t2.ease = K, t2.easeCubicInOut = Z2, t2.emitValidationErrors = $i, t2.endsWith = ot, t2.enforceCacheSizeLimit = function(t3) {
          Qt(), Yt && Yt.then((e3) => {
            e3.keys().then((r3) => {
              for (let n2 = 0; n2 < r3.length - t3; n2++)
                e3.delete(r3[n2]);
            });
          });
        }, t2.evaluateSizeForFeature = lc, t2.evaluateSizeForZoom = uc, t2.evaluateVariableOffset = Ph, t2.evented = Os, t2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
        }, t2.exactEquals$1 = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2];
        }, t2.exported = At, t2.exported$1 = It, t2.extend = tt, t2.extend$1 = _e, t2.filterObject = ut, t2.fromMat4 = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[4], t3[4] = e3[5], t3[5] = e3[6], t3[6] = e3[8], t3[7] = e3[9], t3[8] = e3[10], t3;
        }, t2.fromQuat = function(t3, e3) {
          var r3 = e3[0], n2 = e3[1], i3 = e3[2], s4 = e3[3], a2 = r3 + r3, o2 = n2 + n2, l2 = i3 + i3, u2 = r3 * a2, c2 = n2 * a2, h3 = n2 * o2, p2 = i3 * a2, d2 = i3 * o2, f4 = i3 * l2, y2 = s4 * a2, m3 = s4 * o2, g2 = s4 * l2;
          return t3[0] = 1 - h3 - f4, t3[1] = c2 + g2, t3[2] = p2 - m3, t3[3] = 0, t3[4] = c2 - g2, t3[5] = 1 - u2 - f4, t3[6] = d2 + y2, t3[7] = 0, t3[8] = p2 + m3, t3[9] = d2 - y2, t3[10] = 1 - u2 - h3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, t2.fromRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n2 = Math.cos(e3);
          return t3[0] = n2, t3[1] = r3, t3[2] = 0, t3[3] = -r3, t3[4] = n2, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, t2.fromScaling = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e3[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e3[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, t2.furthestTileCorner = function(t3) {
          const e3 = Math.round((t3 + 45 + 360) % 360 / 90) % 4;
          return G[e3];
        }, t2.getAABBPointSquareDist = function(t3, e3, r3) {
          let n2 = 0;
          for (let i3 = 0; i3 < 2; ++i3) {
            const s4 = r3 ? r3[i3] : 0;
            t3[i3] > s4 && (n2 += (t3[i3] - s4) * (t3[i3] - s4)), e3[i3] < s4 && (n2 += (s4 - e3[i3]) * (s4 - e3[i3]));
          }
          return n2;
        }, t2.getAnchorAlignment = eh, t2.getAnchorJustification = Dh, t2.getBounds = function(t3) {
          let e3 = 1 / 0, r3 = 1 / 0, n2 = -1 / 0, s4 = -1 / 0;
          for (const i3 of t3)
            e3 = Math.min(e3, i3.x), r3 = Math.min(r3, i3.y), n2 = Math.max(n2, i3.x), s4 = Math.max(s4, i3.y);
          return { min: new i2(e3, r3), max: new i2(n2, s4) };
        }, t2.getColumn = function(t3, e3) {
          return [t3[4 * e3], t3[4 * e3 + 1], t3[4 * e3 + 2], t3[4 * e3 + 3]];
        }, t2.getImage = de, t2.getJSON = function(t3, e3) {
          return se(tt(t3, { type: "json" }), e3);
        }, t2.getMapSessionAPI = Zt, t2.getPerformanceMeasurement = yp, t2.getProjection = function(t3) {
          const e3 = Zd[t3.name];
          if (!e3)
            throw new Error(`Invalid projection name: ${t3.name}`);
          return e3.conic ? function(t4, e4) {
            if (e4.parallels && Math.abs(e4.parallels[0] + e4.parallels[1]) < 0.01) {
              let r3 = function(t5) {
                const e5 = Math.max(0.01, Math.cos(q(t5))), r4 = 1 / (2 * Math.max(Math.PI * e5, 1 / e5));
                return { wrap: true, supportsWorldCopies: true, unsupportedLayers: ["custom"], project(t6, n2) {
                  const i3 = q(t6) * e5, s4 = Math.sin(q(n2)) / e5;
                  return { x: i3 * r4 + 0.5, y: -s4 * r4 + 0.5, z: 0 };
                }, unproject(t6, n2) {
                  const i3 = -(n2 - 0.5) / r4, s4 = Y(N((t6 - 0.5) / r4) / e5, -180, 180), a2 = Math.asin(Y(i3 * e5, -1, 1)), o2 = Y(N(a2), -85.051129, Oo);
                  return new Po(s4, o2);
                } };
              }(e4.parallels[0]);
              if (e4.name === "lambertConformalConic") {
                const { project: t5, unproject: e5 } = Zd.mercator;
                r3 = { wrap: true, supportsWorldCopies: true, project: t5, unproject: e5 };
              }
              return tt({}, t4, e4, r3);
            }
            return tt({}, t4, e4);
          }(e3, t3) : e3;
        }, t2.getRTLTextPluginStatus = js4, t2.getReferrer = ie, t2.getTilePoint = function(t3, { x: e3, y: r3 }, n2 = 0) {
          return new i2(((e3 - n2) * t3.scale - t3.x) * To, (r3 * t3.scale - t3.y) * To);
        }, t2.getTileVec3 = function(t3, e3, r3 = 0) {
          return b(((e3.x - r3) * t3.scale - t3.x) * To, (e3.y * t3.scale - t3.y) * To, $o(e3.z, e3.y));
        }, t2.getVideo = function(t3, e3) {
          const r3 = a.document.createElement("video");
          r3.muted = true, r3.onloadstart = function() {
            e3(null, r3);
          };
          for (let e4 = 0; e4 < t3.length; e4++) {
            const n2 = a.document.createElement("source");
            ue(t3[e4]) || (r3.crossOrigin = "Anonymous"), n2.src = t3[e4], r3.appendChild(n2);
          }
          return { cancel: () => {
          } };
        }, t2.globeBuffersForTileMesh = function(t3, e3, r3, n2) {
          const i3 = t3.context, s4 = t3.transform;
          let a2 = e3.globeGridBuffer, o2 = e3.globePoleBuffer;
          if (!a2) {
            const t4 = _d.createGridVertices(r3.canonical);
            a2 = e3.globeGridBuffer = i3.createVertexBuffer(t4, ud, false);
          }
          if (!o2) {
            const t4 = _d.createPoleTriangleVertices(n2, s4.tileSize * n2, r3.canonical.y === 0);
            o2 = e3.globePoleBuffer = i3.createVertexBuffer(t4, ud, false);
          }
          return [a2, o2];
        }, t2.globeDenormalizeECEF = bd, t2.globeMatrixForTile = function(t3, e3) {
          const r3 = bd(yd(t3)), n2 = ((i3 = new Float64Array(16))[0] = (s4 = e3)[0], i3[1] = s4[1], i3[2] = s4[2], i3[3] = s4[3], i3[4] = s4[4], i3[5] = s4[5], i3[6] = s4[6], i3[7] = s4[7], i3[8] = s4[8], i3[9] = s4[9], i3[10] = s4[10], i3[11] = s4[11], i3[12] = s4[12], i3[13] = s4[13], i3[14] = s4[14], i3[15] = s4[15], i3);
          var i3, s4;
          return m2(n2, n2, r3), n2;
        }, t2.globePoleMatrixForTile = function(t3, e3, r3) {
          const n2 = c(new Float64Array(16)), i3 = Math.pow(2, t3.z), s4 = (t3.x - i3 / 2) / i3 * Math.PI * 2, a2 = r3.point, o2 = r3.worldSize / (r3.tileSize * i3);
          return p(n2, n2, [a2.x, a2.y, -r3.worldSize / Math.PI / 2]), d(n2, n2, [o2, o2, o2]), f3(n2, n2, q(-r3._center.lat)), y(n2, n2, q(-r3._center.lng)), y(n2, n2, s4), e3 && d(n2, n2, [1, -1, 1]), n2;
        }, t2.globeTileBounds = yd, t2.globeToMercatorTransition = function(t3) {
          return H(5, 6, t3);
        }, t2.identity = c, t2.identity$1 = R, t2.invert = function(t3, e3) {
          var r3 = e3[0], n2 = e3[1], i3 = e3[2], s4 = e3[3], a2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8], h3 = e3[9], p2 = e3[10], d2 = e3[11], f4 = e3[12], y2 = e3[13], m3 = e3[14], g2 = e3[15], x3 = r3 * o2 - n2 * a2, v2 = r3 * l2 - i3 * a2, b2 = r3 * u2 - s4 * a2, w2 = n2 * l2 - i3 * o2, _2 = n2 * u2 - s4 * o2, A3 = i3 * u2 - s4 * l2, k2 = c2 * y2 - h3 * f4, S3 = c2 * m3 - p2 * f4, I2 = c2 * g2 - d2 * f4, z2 = h3 * m3 - p2 * y2, M2 = h3 * g2 - d2 * y2, T2 = p2 * g2 - d2 * m3, B2 = x3 * T2 - v2 * M2 + b2 * z2 + w2 * I2 - _2 * S3 + A3 * k2;
          return B2 ? (t3[0] = (o2 * T2 - l2 * M2 + u2 * z2) * (B2 = 1 / B2), t3[1] = (i3 * M2 - n2 * T2 - s4 * z2) * B2, t3[2] = (y2 * A3 - m3 * _2 + g2 * w2) * B2, t3[3] = (p2 * _2 - h3 * A3 - d2 * w2) * B2, t3[4] = (l2 * I2 - a2 * T2 - u2 * S3) * B2, t3[5] = (r3 * T2 - i3 * I2 + s4 * S3) * B2, t3[6] = (m3 * b2 - f4 * A3 - g2 * v2) * B2, t3[7] = (c2 * A3 - p2 * b2 + d2 * v2) * B2, t3[8] = (a2 * M2 - o2 * I2 + u2 * k2) * B2, t3[9] = (n2 * I2 - r3 * M2 - s4 * k2) * B2, t3[10] = (f4 * _2 - y2 * b2 + g2 * x3) * B2, t3[11] = (h3 * b2 - c2 * _2 - d2 * x3) * B2, t3[12] = (o2 * S3 - a2 * z2 - l2 * k2) * B2, t3[13] = (r3 * z2 - n2 * S3 + i3 * k2) * B2, t3[14] = (y2 * v2 - f4 * w2 - m3 * x3) * B2, t3[15] = (c2 * w2 - h3 * v2 + p2 * x3) * B2, t3) : null;
        }, t2.isMapAuthenticated = function(t3) {
          return Xt.has(t3);
        }, t2.isMapboxURL = Dt, t2.isSafariWithAntialiasingBug = function(t3) {
          const e3 = t3.navigator ? t3.navigator.userAgent : null;
          return !!wt(t3) && e3 && (e3.match("Version/15.4") || e3.match("Version/15.5") || e3.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t2.latFromMercatorY = Uo, t2.len = V, t2.length = v, t2.length$1 = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
        }, t2.loadVectorTile = Md, t2.makeRequest = se, t2.mercatorXfromLng = Vo, t2.mercatorYfromLat = Fo, t2.mercatorZfromAltitude = Lo, t2.mul = m2, t2.mul$1 = D, t2.multiply = function(t3, e3, r3) {
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h3 = e3[8], p2 = r3[0], d2 = r3[1], f4 = r3[2], y2 = r3[3], m3 = r3[4], g2 = r3[5], x3 = r3[6], v2 = r3[7], b2 = r3[8];
          return t3[0] = p2 * n2 + d2 * a2 + f4 * u2, t3[1] = p2 * i3 + d2 * o2 + f4 * c2, t3[2] = p2 * s4 + d2 * l2 + f4 * h3, t3[3] = y2 * n2 + m3 * a2 + g2 * u2, t3[4] = y2 * i3 + m3 * o2 + g2 * c2, t3[5] = y2 * s4 + m3 * l2 + g2 * h3, t3[6] = x3 * n2 + v2 * a2 + b2 * u2, t3[7] = x3 * i3 + v2 * o2 + b2 * c2, t3[8] = x3 * s4 + v2 * l2 + b2 * h3, t3;
        }, t2.multiply$1 = h2, t2.multiply$2 = A2, t2.nextPowerOfTwo = it, t2.normalize = z, t2.normalize$1 = function(t3, e3) {
          var r3 = e3[0], n2 = e3[1], i3 = e3[2], s4 = e3[3], a2 = r3 * r3 + n2 * n2 + i3 * i3 + s4 * s4;
          return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t3[0] = r3 * a2, t3[1] = n2 * a2, t3[2] = i3 * a2, t3[3] = s4 * a2, t3;
        }, t2.number = Lr, t2.ortho = function(t3, e3, r3, n2, i3, s4, a2) {
          var o2 = 1 / (e3 - r3), l2 = 1 / (n2 - i3), u2 = 1 / (s4 - a2);
          return t3[0] = -2 * o2, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u2, t3[11] = 0, t3[12] = (e3 + r3) * o2, t3[13] = (i3 + n2) * l2, t3[14] = (a2 + s4) * u2, t3[15] = 1, t3;
        }, t2.pbf = gc, t2.perspective = function(t3, e3, r3, n2, i3) {
          var s4, a2 = 1 / Math.tan(e3 / 2);
          return t3[0] = a2 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, i3 != null && i3 !== 1 / 0 ? (t3[10] = (i3 + n2) * (s4 = 1 / (n2 - i3)), t3[14] = 2 * i3 * n2 * s4) : (t3[10] = -1, t3[14] = -2 * n2), t3;
        }, t2.pick = function(t3, e3) {
          const r3 = {};
          for (let n2 = 0; n2 < e3.length; n2++) {
            const i3 = e3[n2];
            i3 in t3 && (r3[i3] = t3[i3]);
          }
          return r3;
        }, t2.plugin = Ns, t2.pointGeometry = i2, t2.polygonIntersectsBox = ll, t2.polygonIntersectsPolygon = Wo, t2.polygonizeBounds = function(t3, e3, r3 = 0, n2 = true) {
          const s4 = new i2(r3, r3), a2 = t3.sub(s4), o2 = e3.add(s4), l2 = [a2, new i2(o2.x, a2.y), o2, new i2(a2.x, o2.y)];
          return n2 && l2.push(a2), l2;
        }, t2.posAttributes = Hp, t2.postMapLoadEvent = Nt, t2.postTurnstileEvent = jt, t2.potpack = $c, t2.prevPowerOfTwo = function(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t3) / Math.LN2));
        }, t2.radToDeg = N, t2.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t2.registerForPluginStateChange = function(t3) {
          return t3({ pluginStatus: Ls, pluginURL: Rs }), Os.on("pluginStateChange", t3), t3;
        }, t2.removeAuthState = function(t3) {
          Xt.delete(t3);
        }, t2.renderColorRamp = Bl, t2.rotateX = f3, t2.rotateX$1 = U, t2.rotateY = y, t2.rotateZ = function(t3, e3, r3) {
          var n2 = Math.sin(r3), i3 = Math.cos(r3), s4 = e3[0], a2 = e3[1], o2 = e3[2], l2 = e3[3], u2 = e3[4], c2 = e3[5], h3 = e3[6], p2 = e3[7];
          return e3 !== t3 && (t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s4 * i3 + u2 * n2, t3[1] = a2 * i3 + c2 * n2, t3[2] = o2 * i3 + h3 * n2, t3[3] = l2 * i3 + p2 * n2, t3[4] = u2 * i3 - s4 * n2, t3[5] = c2 * i3 - a2 * n2, t3[6] = h3 * i3 - o2 * n2, t3[7] = p2 * i3 - l2 * n2, t3;
        }, t2.rotateZ$1 = function(t3, e3, r3) {
          r3 *= 0.5;
          var n2 = e3[0], i3 = e3[1], s4 = e3[2], a2 = e3[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
          return t3[0] = n2 * l2 + i3 * o2, t3[1] = i3 * l2 - n2 * o2, t3[2] = s4 * l2 + a2 * o2, t3[3] = a2 * l2 - s4 * o2, t3;
        }, t2.scale = d, t2.scale$1 = function(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3;
        }, t2.scale$2 = S2, t2.scaleAndAdd = I, t2.setCacheLimits = function(t3, e3) {
          Jt = t3, Wt = e3;
        }, t2.setColumn = function(t3, e3, r3) {
          t3[4 * e3 + 0] = r3[0], t3[4 * e3 + 1] = r3[1], t3[4 * e3 + 2] = r3[2], t3[4 * e3 + 3] = r3[3];
        }, t2.setRTLTextPlugin = function(t3, e3, r3 = false) {
          if (Ls === Es || Ls === Ds || Ls === Vs)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          Rs = At.resolveURL(t3), Ls = Es, Fs = e3, $s(), r3 || qs2();
        }, t2.smoothstep = H, t2.spec = ve, t2.storeAuthState = function(t3, e3) {
          e3 ? Xt.add(t3) : Xt.delete(t3);
        }, t2.sub = E, t2.subtract = _, t2.symbolSize = cc, t2.tileAABB = function(t3, e3, r3, n2, i3, s4, a2, o2, l2) {
          if (l2.name === "globe") {
            const a3 = yd(new vp(s4, new xp(r3, n2, i3)).canonical).getCorners(), o3 = Number.MAX_VALUE, l3 = [-o3, -o3, -o3], p3 = [o3, o3, o3], d2 = wd(t3, e3);
            for (let t4 = 0; t4 < a3.length; t4++)
              B(a3[t4], a3[t4], d2), c2 = p3, h3 = a3[t4], (u2 = p3)[0] = Math.min(c2[0], h3[0]), u2[1] = Math.min(c2[1], h3[1]), u2[2] = Math.min(c2[2], h3[2]), k(l3, l3, a3[t4]);
            return new gl(p3, l3);
          }
          var u2, c2, h3;
          const p2 = Ad({ z: r3, x: n2, y: i3 }, l2);
          return new gl([(s4 + p2.x / p2.scale) * e3, e3 * (p2.y / p2.scale), a2], [(s4 + p2.x2 / p2.scale) * e3, e3 * (p2.y2 / p2.scale), o2]);
        }, t2.tileTransform = Ad, t2.transformMat3 = function(t3, e3, r3) {
          var n2 = e3[0], i3 = e3[1], s4 = e3[2];
          return t3[0] = n2 * r3[0] + i3 * r3[3] + s4 * r3[6], t3[1] = n2 * r3[1] + i3 * r3[4] + s4 * r3[7], t3[2] = n2 * r3[2] + i3 * r3[5] + s4 * r3[8], t3;
        }, t2.transformMat4 = B, t2.transformMat4$1 = F2, t2.transformQuat = C, t2.translate = p, t2.transpose = function(t3, e3) {
          if (t3 === e3) {
            var r3 = e3[1], n2 = e3[2], i3 = e3[5];
            t3[1] = e3[3], t3[2] = e3[6], t3[3] = r3, t3[5] = e3[7], t3[6] = n2, t3[7] = i3;
          } else
            t3[0] = e3[0], t3[1] = e3[3], t3[2] = e3[6], t3[3] = e3[1], t3[4] = e3[4], t3[5] = e3[7], t3[6] = e3[2], t3[7] = e3[5], t3[8] = e3[8];
          return t3;
        }, t2.triggerPluginCompletionEvent = Us, t2.uniqueId = rt, t2.validateCustomStyleLayer = function(t3) {
          const e3 = [], r3 = t3.id;
          return r3 === void 0 && e3.push({ message: `layers.${r3}: missing required property "id"` }), t3.render === void 0 && e3.push({ message: `layers.${r3}: missing required method "render"` }), t3.renderingMode && t3.renderingMode !== "2d" && t3.renderingMode !== "3d" && e3.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e3;
        }, t2.validateFog = Li, t2.validateLight = Fi, t2.validateStyle = Vi, t2.values = Q, t2.vectorTile = Bu, t2.version = e2, t2.warnOnce = pt, t2.window = a, t2.wrap = J;
      });
      define2(["./shared"], function(e2) {
        "use strict";
        function t2(e3) {
          const r3 = typeof e3;
          if (r3 === "number" || r3 === "boolean" || r3 === "string" || e3 == null)
            return JSON.stringify(e3);
          if (Array.isArray(e3)) {
            let r4 = "[";
            for (const o3 of e3)
              r4 += `${t2(o3)},`;
            return `${r4}]`;
          }
          const o2 = Object.keys(e3).sort();
          let n2 = "{";
          for (let r4 = 0; r4 < o2.length; r4++)
            n2 += `${JSON.stringify(o2[r4])}:${t2(e3[o2[r4]])},`;
          return `${n2}}`;
        }
        function r2(r3) {
          let o2 = "";
          for (const n2 of e2.refProperties)
            o2 += `/${t2(r3[n2])}`;
          return o2;
        }
        class o {
          constructor(e3) {
            this.keyCache = {}, e3 && this.replace(e3);
          }
          replace(e3) {
            this._layerConfigs = {}, this._layers = {}, this.update(e3, []);
          }
          update(t3, o2) {
            for (const r3 of t3)
              this._layerConfigs[r3.id] = r3, (this._layers[r3.id] = e2.createStyleLayer(r3)).compileFilter(), this.keyCache[r3.id] && delete this.keyCache[r3.id];
            for (const e3 of o2)
              delete this.keyCache[e3], delete this._layerConfigs[e3], delete this._layers[e3];
            this.familiesBySource = {};
            const n2 = function(e3, t4) {
              const o3 = {};
              for (let n4 = 0; n4 < e3.length; n4++) {
                const i3 = t4 && t4[e3[n4].id] || r2(e3[n4]);
                t4 && (t4[e3[n4].id] = i3);
                let s4 = o3[i3];
                s4 || (s4 = o3[i3] = []), s4.push(e3[n4]);
              }
              const n3 = [];
              for (const e4 in o3)
                n3.push(o3[e4]);
              return n3;
            }(e2.values(this._layerConfigs), this.keyCache);
            for (const e3 of n2) {
              const t4 = e3.map((e4) => this._layers[e4.id]), r3 = t4[0];
              if (r3.visibility === "none")
                continue;
              const o3 = r3.source || "";
              let n3 = this.familiesBySource[o3];
              n3 || (n3 = this.familiesBySource[o3] = {});
              const i3 = r3.sourceLayer || "_geojsonTileLayer";
              let s4 = n3[i3];
              s4 || (s4 = n3[i3] = []), s4.push(t4);
            }
          }
        }
        const { ImageBitmap: n } = e2.window;
        class i2 {
          loadTile(t3, r3) {
            const { uid: o2, encoding: i3, rawImageData: s4, padding: a2, buildQuadTree: l2 } = t3, u2 = n && s4 instanceof n ? this.getImageData(s4, a2) : s4;
            r3(null, new e2.DEMData(o2, u2, i3, a2 < 1, l2));
          }
          getImageData(t3, r3) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t3.width, t3.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t3.width, this.offscreenCanvas.height = t3.height, this.offscreenCanvasContext.drawImage(t3, 0, 0, t3.width, t3.height);
            const o2 = this.offscreenCanvasContext.getImageData(-r3, -r3, t3.width + 2 * r3, t3.height + 2 * r3);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e2.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
          }
        }
        var s3 = function e3(t3, r3) {
          var o2, n2 = t3 && t3.type;
          if (n2 === "FeatureCollection")
            for (o2 = 0; o2 < t3.features.length; o2++)
              e3(t3.features[o2], r3);
          else if (n2 === "GeometryCollection")
            for (o2 = 0; o2 < t3.geometries.length; o2++)
              e3(t3.geometries[o2], r3);
          else if (n2 === "Feature")
            e3(t3.geometry, r3);
          else if (n2 === "Polygon")
            a(t3.coordinates, r3);
          else if (n2 === "MultiPolygon")
            for (o2 = 0; o2 < t3.coordinates.length; o2++)
              a(t3.coordinates[o2], r3);
          return t3;
        };
        function a(e3, t3) {
          if (e3.length !== 0) {
            l(e3[0], t3);
            for (var r3 = 1; r3 < e3.length; r3++)
              l(e3[r3], !t3);
          }
        }
        function l(e3, t3) {
          for (var r3 = 0, o2 = 0, n2 = 0, i3 = e3.length, s4 = i3 - 1; n2 < i3; s4 = n2++) {
            var a2 = (e3[n2][0] - e3[s4][0]) * (e3[s4][1] + e3[n2][1]), l2 = r3 + a2;
            o2 += Math.abs(r3) >= Math.abs(a2) ? r3 - l2 + a2 : a2 - l2 + r3, r3 = l2;
          }
          r3 + o2 >= 0 != !!t3 && e3.reverse();
        }
        const u = e2.vectorTile.VectorTileFeature.prototype.toGeoJSON;
        class h2 {
          constructor(t3) {
            this._feature = t3, this.extent = e2.EXTENT, this.type = t3.type, this.properties = t3.tags, "id" in t3 && !isNaN(t3.id) && (this.id = parseInt(t3.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const t3 = [];
              for (const r3 of this._feature.geometry)
                t3.push([new e2.pointGeometry(r3[0], r3[1])]);
              return t3;
            }
            {
              const t3 = [];
              for (const r3 of this._feature.geometry) {
                const o2 = [];
                for (const t4 of r3)
                  o2.push(new e2.pointGeometry(t4[0], t4[1]));
                t3.push(o2);
              }
              return t3;
            }
          }
          toGeoJSON(e3, t3, r3) {
            return u.call(this, e3, t3, r3);
          }
        }
        class c {
          constructor(t3) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e2.EXTENT, this.length = t3.length, this._features = t3;
          }
          feature(e3) {
            return new h2(this._features[e3]);
          }
        }
        var f3 = e2.vectorTile.VectorTileFeature, p = g;
        function g(e3, t3) {
          this.options = t3 || {}, this.features = e3, this.length = e3.length;
        }
        function d(e3, t3) {
          this.id = typeof e3.id == "number" ? e3.id : void 0, this.type = e3.type, this.rawGeometry = e3.type === 1 ? [e3.geometry] : e3.geometry, this.properties = e3.tags, this.extent = t3 || 4096;
        }
        g.prototype.feature = function(e3) {
          return new d(this.features[e3], this.options.extent);
        }, d.prototype.loadGeometry = function() {
          var t3 = this.rawGeometry;
          this.geometry = [];
          for (var r3 = 0; r3 < t3.length; r3++) {
            for (var o2 = t3[r3], n2 = [], i3 = 0; i3 < o2.length; i3++)
              n2.push(new e2.pointGeometry(o2[i3][0], o2[i3][1]));
            this.geometry.push(n2);
          }
          return this.geometry;
        }, d.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e3 = this.geometry, t3 = 1 / 0, r3 = -1 / 0, o2 = 1 / 0, n2 = -1 / 0, i3 = 0; i3 < e3.length; i3++)
            for (var s4 = e3[i3], a2 = 0; a2 < s4.length; a2++) {
              var l2 = s4[a2];
              t3 = Math.min(t3, l2.x), r3 = Math.max(r3, l2.x), o2 = Math.min(o2, l2.y), n2 = Math.max(n2, l2.y);
            }
          return [t3, o2, r3, n2];
        }, d.prototype.toGeoJSON = f3.prototype.toGeoJSON;
        var m2 = v, y = p;
        function v(t3) {
          var r3 = new e2.pbf();
          return function(e3, t4) {
            for (var r4 in e3.layers)
              t4.writeMessage(3, x2, e3.layers[r4]);
          }(t3, r3), r3.finish();
        }
        function x2(e3, t3) {
          var r3;
          t3.writeVarintField(15, e3.version || 1), t3.writeStringField(1, e3.name || ""), t3.writeVarintField(5, e3.extent || 4096);
          var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r3 = 0; r3 < e3.length; r3++)
            o2.feature = e3.feature(r3), t3.writeMessage(2, w, o2);
          var n2 = o2.keys;
          for (r3 = 0; r3 < n2.length; r3++)
            t3.writeStringField(3, n2[r3]);
          var i3 = o2.values;
          for (r3 = 0; r3 < i3.length; r3++)
            t3.writeMessage(4, T, i3[r3]);
        }
        function w(e3, t3) {
          var r3 = e3.feature;
          r3.id !== void 0 && t3.writeVarintField(1, r3.id), t3.writeMessage(2, S2, e3), t3.writeVarintField(3, r3.type), t3.writeMessage(4, b, r3);
        }
        function S2(e3, t3) {
          var r3 = e3.feature, o2 = e3.keys, n2 = e3.values, i3 = e3.keycache, s4 = e3.valuecache;
          for (var a2 in r3.properties) {
            var l2 = r3.properties[a2], u2 = i3[a2];
            if (l2 !== null) {
              u2 === void 0 && (o2.push(a2), i3[a2] = u2 = o2.length - 1), t3.writeVarint(u2);
              var h3 = typeof l2;
              h3 !== "string" && h3 !== "boolean" && h3 !== "number" && (l2 = JSON.stringify(l2));
              var c2 = h3 + ":" + l2, f4 = s4[c2];
              f4 === void 0 && (n2.push(l2), s4[c2] = f4 = n2.length - 1), t3.writeVarint(f4);
            }
          }
        }
        function M(e3, t3) {
          return (t3 << 3) + (7 & e3);
        }
        function P(e3) {
          return e3 << 1 ^ e3 >> 31;
        }
        function b(e3, t3) {
          for (var r3 = e3.loadGeometry(), o2 = e3.type, n2 = 0, i3 = 0, s4 = r3.length, a2 = 0; a2 < s4; a2++) {
            var l2 = r3[a2], u2 = 1;
            o2 === 1 && (u2 = l2.length), t3.writeVarint(M(1, u2));
            for (var h3 = o2 === 3 ? l2.length - 1 : l2.length, c2 = 0; c2 < h3; c2++) {
              c2 === 1 && o2 !== 1 && t3.writeVarint(M(2, h3 - 1));
              var f4 = l2[c2].x - n2, p2 = l2[c2].y - i3;
              t3.writeVarint(P(f4)), t3.writeVarint(P(p2)), n2 += f4, i3 += p2;
            }
            o2 === 3 && t3.writeVarint(M(7, 1));
          }
        }
        function T(e3, t3) {
          var r3 = typeof e3;
          r3 === "string" ? t3.writeStringField(1, e3) : r3 === "boolean" ? t3.writeBooleanField(7, e3) : r3 === "number" && (e3 % 1 != 0 ? t3.writeDoubleField(3, e3) : e3 < 0 ? t3.writeSVarintField(6, e3) : t3.writeVarintField(5, e3));
        }
        function k(e3, t3, r3, o2, n2, i3) {
          if (n2 - o2 <= r3)
            return;
          const s4 = o2 + n2 >> 1;
          I(e3, t3, s4, o2, n2, i3 % 2), k(e3, t3, r3, o2, s4 - 1, i3 + 1), k(e3, t3, r3, s4 + 1, n2, i3 + 1);
        }
        function I(e3, t3, r3, o2, n2, i3) {
          for (; n2 > o2; ) {
            if (n2 - o2 > 600) {
              const s5 = n2 - o2 + 1, a3 = r3 - o2 + 1, l3 = Math.log(s5), u2 = 0.5 * Math.exp(2 * l3 / 3), h3 = 0.5 * Math.sqrt(l3 * u2 * (s5 - u2) / s5) * (a3 - s5 / 2 < 0 ? -1 : 1);
              I(e3, t3, r3, Math.max(o2, Math.floor(r3 - a3 * u2 / s5 + h3)), Math.min(n2, Math.floor(r3 + (s5 - a3) * u2 / s5 + h3)), i3);
            }
            const s4 = t3[2 * r3 + i3];
            let a2 = o2, l2 = n2;
            for (_(e3, t3, o2, r3), t3[2 * n2 + i3] > s4 && _(e3, t3, o2, n2); a2 < l2; ) {
              for (_(e3, t3, a2, l2), a2++, l2--; t3[2 * a2 + i3] < s4; )
                a2++;
              for (; t3[2 * l2 + i3] > s4; )
                l2--;
            }
            t3[2 * o2 + i3] === s4 ? _(e3, t3, o2, l2) : (l2++, _(e3, t3, l2, n2)), l2 <= r3 && (o2 = l2 + 1), r3 <= l2 && (n2 = l2 - 1);
          }
        }
        function _(e3, t3, r3, o2) {
          L(e3, r3, o2), L(t3, 2 * r3, 2 * o2), L(t3, 2 * r3 + 1, 2 * o2 + 1);
        }
        function L(e3, t3, r3) {
          const o2 = e3[t3];
          e3[t3] = e3[r3], e3[r3] = o2;
        }
        function C(e3, t3, r3, o2) {
          const n2 = e3 - r3, i3 = t3 - o2;
          return n2 * n2 + i3 * i3;
        }
        m2.fromVectorTileJs = v, m2.fromGeojsonVt = function(e3, t3) {
          t3 = t3 || {};
          var r3 = {};
          for (var o2 in e3)
            r3[o2] = new p(e3[o2].features, t3), r3[o2].name = o2, r3[o2].version = t3.version, r3[o2].extent = t3.extent;
          return v({ layers: r3 });
        }, m2.GeoJSONWrapper = y;
        const O = (e3) => e3[0], z = (e3) => e3[1];
        class E {
          constructor(e3, t3 = O, r3 = z, o2 = 64, n2 = Float64Array) {
            this.nodeSize = o2, this.points = e3;
            const i3 = e3.length < 65536 ? Uint16Array : Uint32Array, s4 = this.ids = new i3(e3.length), a2 = this.coords = new n2(2 * e3.length);
            for (let o3 = 0; o3 < e3.length; o3++)
              s4[o3] = o3, a2[2 * o3] = t3(e3[o3]), a2[2 * o3 + 1] = r3(e3[o3]);
            k(s4, a2, o2, 0, s4.length - 1, 0);
          }
          range(e3, t3, r3, o2) {
            return function(e4, t4, r4, o3, n2, i3, s4) {
              const a2 = [0, e4.length - 1, 0], l2 = [];
              let u2, h3;
              for (; a2.length; ) {
                const c2 = a2.pop(), f4 = a2.pop(), p2 = a2.pop();
                if (f4 - p2 <= s4) {
                  for (let s5 = p2; s5 <= f4; s5++)
                    u2 = t4[2 * s5], h3 = t4[2 * s5 + 1], u2 >= r4 && u2 <= n2 && h3 >= o3 && h3 <= i3 && l2.push(e4[s5]);
                  continue;
                }
                const g2 = Math.floor((p2 + f4) / 2);
                u2 = t4[2 * g2], h3 = t4[2 * g2 + 1], u2 >= r4 && u2 <= n2 && h3 >= o3 && h3 <= i3 && l2.push(e4[g2]);
                const d2 = (c2 + 1) % 2;
                (c2 === 0 ? r4 <= u2 : o3 <= h3) && (a2.push(p2), a2.push(g2 - 1), a2.push(d2)), (c2 === 0 ? n2 >= u2 : i3 >= h3) && (a2.push(g2 + 1), a2.push(f4), a2.push(d2));
              }
              return l2;
            }(this.ids, this.coords, e3, t3, r3, o2, this.nodeSize);
          }
          within(e3, t3, r3) {
            return function(e4, t4, r4, o2, n2, i3) {
              const s4 = [0, e4.length - 1, 0], a2 = [], l2 = n2 * n2;
              for (; s4.length; ) {
                const u2 = s4.pop(), h3 = s4.pop(), c2 = s4.pop();
                if (h3 - c2 <= i3) {
                  for (let n3 = c2; n3 <= h3; n3++)
                    C(t4[2 * n3], t4[2 * n3 + 1], r4, o2) <= l2 && a2.push(e4[n3]);
                  continue;
                }
                const f4 = Math.floor((c2 + h3) / 2), p2 = t4[2 * f4], g2 = t4[2 * f4 + 1];
                C(p2, g2, r4, o2) <= l2 && a2.push(e4[f4]);
                const d2 = (u2 + 1) % 2;
                (u2 === 0 ? r4 - n2 <= p2 : o2 - n2 <= g2) && (s4.push(c2), s4.push(f4 - 1), s4.push(d2)), (u2 === 0 ? r4 + n2 >= p2 : o2 + n2 >= g2) && (s4.push(f4 + 1), s4.push(h3), s4.push(d2));
              }
              return a2;
            }(this.ids, this.coords, e3, t3, r3, this.nodeSize);
          }
        }
        const F2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e3) => e3 }, N = Math.fround || (j = new Float32Array(1), (e3) => (j[0] = +e3, j[0]));
        var j;
        class Z2 {
          constructor(e3) {
            this.options = D(Object.create(F2), e3), this.trees = new Array(this.options.maxZoom + 1);
          }
          load(e3) {
            const { log: t3, minZoom: r3, maxZoom: o2, nodeSize: n2 } = this.options;
            t3 && console.time("total time");
            const i3 = `prepare ${e3.length} points`;
            t3 && console.time(i3), this.points = e3;
            let s4 = [];
            for (let t4 = 0; t4 < e3.length; t4++)
              e3[t4].geometry && s4.push(J(e3[t4], t4));
            this.trees[o2 + 1] = new E(s4, $, B, n2, Float32Array), t3 && console.timeEnd(i3);
            for (let e4 = o2; e4 >= r3; e4--) {
              const r4 = +Date.now();
              s4 = this._cluster(s4, e4), this.trees[e4] = new E(s4, $, B, n2, Float32Array), t3 && console.log("z%d: %d clusters in %dms", e4, s4.length, +Date.now() - r4);
            }
            return t3 && console.timeEnd("total time"), this;
          }
          getClusters(e3, t3) {
            let r3 = ((e3[0] + 180) % 360 + 360) % 360 - 180;
            const o2 = Math.max(-90, Math.min(90, e3[1]));
            let n2 = e3[2] === 180 ? 180 : ((e3[2] + 180) % 360 + 360) % 360 - 180;
            const i3 = Math.max(-90, Math.min(90, e3[3]));
            if (e3[2] - e3[0] >= 360)
              r3 = -180, n2 = 180;
            else if (r3 > n2) {
              const e4 = this.getClusters([r3, o2, 180, i3], t3), s5 = this.getClusters([-180, o2, n2, i3], t3);
              return e4.concat(s5);
            }
            const s4 = this.trees[this._limitZoom(t3)], a2 = s4.range(X(r3), V(i3), X(n2), V(o2)), l2 = [];
            for (const e4 of a2) {
              const t4 = s4.points[e4];
              l2.push(t4.numPoints ? W(t4) : this.points[t4.index]);
            }
            return l2;
          }
          getChildren(e3) {
            const t3 = this._getOriginId(e3), r3 = this._getOriginZoom(e3), o2 = "No cluster with the specified id.", n2 = this.trees[r3];
            if (!n2)
              throw new Error(o2);
            const i3 = n2.points[t3];
            if (!i3)
              throw new Error(o2);
            const s4 = this.options.radius / (this.options.extent * Math.pow(2, r3 - 1)), a2 = n2.within(i3.x, i3.y, s4), l2 = [];
            for (const t4 of a2) {
              const r4 = n2.points[t4];
              r4.parentId === e3 && l2.push(r4.numPoints ? W(r4) : this.points[r4.index]);
            }
            if (l2.length === 0)
              throw new Error(o2);
            return l2;
          }
          getLeaves(e3, t3, r3) {
            const o2 = [];
            return this._appendLeaves(o2, e3, t3 = t3 || 10, r3 = r3 || 0, 0), o2;
          }
          getTile(e3, t3, r3) {
            const o2 = this.trees[this._limitZoom(e3)], n2 = Math.pow(2, e3), { extent: i3, radius: s4 } = this.options, a2 = s4 / i3, l2 = (r3 - a2) / n2, u2 = (r3 + 1 + a2) / n2, h3 = { features: [] };
            return this._addTileFeatures(o2.range((t3 - a2) / n2, l2, (t3 + 1 + a2) / n2, u2), o2.points, t3, r3, n2, h3), t3 === 0 && this._addTileFeatures(o2.range(1 - a2 / n2, l2, 1, u2), o2.points, n2, r3, n2, h3), t3 === n2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / n2, u2), o2.points, -1, r3, n2, h3), h3.features.length ? h3 : null;
          }
          getClusterExpansionZoom(e3) {
            let t3 = this._getOriginZoom(e3) - 1;
            for (; t3 <= this.options.maxZoom; ) {
              const r3 = this.getChildren(e3);
              if (t3++, r3.length !== 1)
                break;
              e3 = r3[0].properties.cluster_id;
            }
            return t3;
          }
          _appendLeaves(e3, t3, r3, o2, n2) {
            const i3 = this.getChildren(t3);
            for (const t4 of i3) {
              const i4 = t4.properties;
              if (i4 && i4.cluster ? n2 + i4.point_count <= o2 ? n2 += i4.point_count : n2 = this._appendLeaves(e3, i4.cluster_id, r3, o2, n2) : n2 < o2 ? n2++ : e3.push(t4), e3.length === r3)
                break;
            }
            return n2;
          }
          _addTileFeatures(e3, t3, r3, o2, n2, i3) {
            for (const s4 of e3) {
              const e4 = t3[s4], a2 = e4.numPoints;
              let l2, u2, h3;
              if (a2)
                l2 = Y(e4), u2 = e4.x, h3 = e4.y;
              else {
                const t4 = this.points[e4.index];
                l2 = t4.properties, u2 = X(t4.geometry.coordinates[0]), h3 = V(t4.geometry.coordinates[1]);
              }
              const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u2 * n2 - r3)), Math.round(this.options.extent * (h3 * n2 - o2))]], tags: l2 };
              let f4;
              a2 ? f4 = e4.id : this.options.generateId ? f4 = e4.index : this.points[e4.index].id && (f4 = this.points[e4.index].id), f4 !== void 0 && (c2.id = f4), i3.features.push(c2);
            }
          }
          _limitZoom(e3) {
            return Math.max(this.options.minZoom, Math.min(+e3, this.options.maxZoom + 1));
          }
          _cluster(e3, t3) {
            const r3 = [], { radius: o2, extent: n2, reduce: i3, minPoints: s4 } = this.options, a2 = o2 / (n2 * Math.pow(2, t3));
            for (let o3 = 0; o3 < e3.length; o3++) {
              const n3 = e3[o3];
              if (n3.zoom <= t3)
                continue;
              n3.zoom = t3;
              const l2 = this.trees[t3 + 1], u2 = l2.within(n3.x, n3.y, a2), h3 = n3.numPoints || 1;
              let c2 = h3;
              for (const e4 of u2) {
                const r4 = l2.points[e4];
                r4.zoom > t3 && (c2 += r4.numPoints || 1);
              }
              if (c2 > h3 && c2 >= s4) {
                let e4 = n3.x * h3, s5 = n3.y * h3, a3 = i3 && h3 > 1 ? this._map(n3, true) : null;
                const f4 = (o3 << 5) + (t3 + 1) + this.points.length;
                for (const r4 of u2) {
                  const o4 = l2.points[r4];
                  if (o4.zoom <= t3)
                    continue;
                  o4.zoom = t3;
                  const u3 = o4.numPoints || 1;
                  e4 += o4.x * u3, s5 += o4.y * u3, o4.parentId = f4, i3 && (a3 || (a3 = this._map(n3, true)), i3(a3, this._map(o4)));
                }
                n3.parentId = f4, r3.push(G(e4 / c2, s5 / c2, f4, c2, a3));
              } else if (r3.push(n3), c2 > 1)
                for (const e4 of u2) {
                  const o4 = l2.points[e4];
                  o4.zoom <= t3 || (o4.zoom = t3, r3.push(o4));
                }
            }
            return r3;
          }
          _getOriginId(e3) {
            return e3 - this.points.length >> 5;
          }
          _getOriginZoom(e3) {
            return (e3 - this.points.length) % 32;
          }
          _map(e3, t3) {
            if (e3.numPoints)
              return t3 ? D({}, e3.properties) : e3.properties;
            const r3 = this.points[e3.index].properties, o2 = this.options.map(r3);
            return t3 && o2 === r3 ? D({}, o2) : o2;
          }
        }
        function G(e3, t3, r3, o2, n2) {
          return { x: N(e3), y: N(t3), zoom: 1 / 0, id: r3, parentId: -1, numPoints: o2, properties: n2 };
        }
        function J(e3, t3) {
          const [r3, o2] = e3.geometry.coordinates;
          return { x: N(X(r3)), y: N(V(o2)), zoom: 1 / 0, index: t3, parentId: -1 };
        }
        function W(e3) {
          return { type: "Feature", id: e3.id, properties: Y(e3), geometry: { type: "Point", coordinates: [(t3 = e3.x, 360 * (t3 - 0.5)), A2(e3.y)] } };
          var t3;
        }
        function Y(e3) {
          const t3 = e3.numPoints, r3 = t3 >= 1e4 ? `${Math.round(t3 / 1e3)}k` : t3 >= 1e3 ? Math.round(t3 / 100) / 10 + "k" : t3;
          return D(D({}, e3.properties), { cluster: true, cluster_id: e3.id, point_count: t3, point_count_abbreviated: r3 });
        }
        function X(e3) {
          return e3 / 360 + 0.5;
        }
        function V(e3) {
          const t3 = Math.sin(e3 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function A2(e3) {
          const t3 = (180 - 360 * e3) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
        }
        function D(e3, t3) {
          for (const r3 in t3)
            e3[r3] = t3[r3];
          return e3;
        }
        function $(e3) {
          return e3.x;
        }
        function B(e3) {
          return e3.y;
        }
        function R(e3, t3, r3, o2) {
          for (var n2, i3 = o2, s4 = r3 - t3 >> 1, a2 = r3 - t3, l2 = e3[t3], u2 = e3[t3 + 1], h3 = e3[r3], c2 = e3[r3 + 1], f4 = t3 + 3; f4 < r3; f4 += 3) {
            var p2 = q(e3[f4], e3[f4 + 1], l2, u2, h3, c2);
            if (p2 > i3)
              n2 = f4, i3 = p2;
            else if (p2 === i3) {
              var g2 = Math.abs(f4 - s4);
              g2 < a2 && (n2 = f4, a2 = g2);
            }
          }
          i3 > o2 && (n2 - t3 > 3 && R(e3, t3, n2, o2), e3[n2 + 2] = i3, r3 - n2 > 3 && R(e3, n2, r3, o2));
        }
        function q(e3, t3, r3, o2, n2, i3) {
          var s4 = n2 - r3, a2 = i3 - o2;
          if (s4 !== 0 || a2 !== 0) {
            var l2 = ((e3 - r3) * s4 + (t3 - o2) * a2) / (s4 * s4 + a2 * a2);
            l2 > 1 ? (r3 = n2, o2 = i3) : l2 > 0 && (r3 += s4 * l2, o2 += a2 * l2);
          }
          return (s4 = e3 - r3) * s4 + (a2 = t3 - o2) * a2;
        }
        function U(e3, t3, r3, o2) {
          var n2 = { id: e3 === void 0 ? null : e3, type: t3, geometry: r3, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e4) {
            var t4 = e4.geometry, r4 = e4.type;
            if (r4 === "Point" || r4 === "MultiPoint" || r4 === "LineString")
              Q(e4, t4);
            else if (r4 === "Polygon" || r4 === "MultiLineString")
              for (var o3 = 0; o3 < t4.length; o3++)
                Q(e4, t4[o3]);
            else if (r4 === "MultiPolygon")
              for (o3 = 0; o3 < t4.length; o3++)
                for (var n3 = 0; n3 < t4[o3].length; n3++)
                  Q(e4, t4[o3][n3]);
          }(n2), n2;
        }
        function Q(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3 += 3)
            e3.minX = Math.min(e3.minX, t3[r3]), e3.minY = Math.min(e3.minY, t3[r3 + 1]), e3.maxX = Math.max(e3.maxX, t3[r3]), e3.maxY = Math.max(e3.maxY, t3[r3 + 1]);
        }
        function H(e3, t3, r3, o2) {
          if (t3.geometry) {
            var n2 = t3.geometry.coordinates, i3 = t3.geometry.type, s4 = Math.pow(r3.tolerance / ((1 << r3.maxZoom) * r3.extent), 2), a2 = [], l2 = t3.id;
            if (r3.promoteId ? l2 = t3.properties[r3.promoteId] : r3.generateId && (l2 = o2 || 0), i3 === "Point")
              K(n2, a2);
            else if (i3 === "MultiPoint")
              for (var u2 = 0; u2 < n2.length; u2++)
                K(n2[u2], a2);
            else if (i3 === "LineString")
              ee(n2, a2, s4, false);
            else if (i3 === "MultiLineString") {
              if (r3.lineMetrics) {
                for (u2 = 0; u2 < n2.length; u2++)
                  ee(n2[u2], a2 = [], s4, false), e3.push(U(l2, "LineString", a2, t3.properties));
                return;
              }
              te(n2, a2, s4, false);
            } else if (i3 === "Polygon")
              te(n2, a2, s4, true);
            else {
              if (i3 !== "MultiPolygon") {
                if (i3 === "GeometryCollection") {
                  for (u2 = 0; u2 < t3.geometry.geometries.length; u2++)
                    H(e3, { id: l2, geometry: t3.geometry.geometries[u2], properties: t3.properties }, r3, o2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (u2 = 0; u2 < n2.length; u2++) {
                var h3 = [];
                te(n2[u2], h3, s4, true), a2.push(h3);
              }
            }
            e3.push(U(l2, i3, a2, t3.properties));
          }
        }
        function K(e3, t3) {
          t3.push(re(e3[0])), t3.push(oe(e3[1])), t3.push(0);
        }
        function ee(e3, t3, r3, o2) {
          for (var n2, i3, s4 = 0, a2 = 0; a2 < e3.length; a2++) {
            var l2 = re(e3[a2][0]), u2 = oe(e3[a2][1]);
            t3.push(l2), t3.push(u2), t3.push(0), a2 > 0 && (s4 += o2 ? (n2 * u2 - l2 * i3) / 2 : Math.sqrt(Math.pow(l2 - n2, 2) + Math.pow(u2 - i3, 2))), n2 = l2, i3 = u2;
          }
          var h3 = t3.length - 3;
          t3[2] = 1, R(t3, 0, h3, r3), t3[h3 + 2] = 1, t3.size = Math.abs(s4), t3.start = 0, t3.end = t3.size;
        }
        function te(e3, t3, r3, o2) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            var i3 = [];
            ee(e3[n2], i3, r3, o2), t3.push(i3);
          }
        }
        function re(e3) {
          return e3 / 360 + 0.5;
        }
        function oe(e3) {
          var t3 = Math.sin(e3 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function ne(e3, t3, r3, o2, n2, i3, s4, a2) {
          if (o2 /= t3, i3 >= (r3 /= t3) && s4 < o2)
            return e3;
          if (s4 < r3 || i3 >= o2)
            return null;
          for (var l2 = [], u2 = 0; u2 < e3.length; u2++) {
            var h3 = e3[u2], c2 = h3.geometry, f4 = h3.type, p2 = n2 === 0 ? h3.minX : h3.minY, g2 = n2 === 0 ? h3.maxX : h3.maxY;
            if (p2 >= r3 && g2 < o2)
              l2.push(h3);
            else if (!(g2 < r3 || p2 >= o2)) {
              var d2 = [];
              if (f4 === "Point" || f4 === "MultiPoint")
                ie(c2, d2, r3, o2, n2);
              else if (f4 === "LineString")
                se(c2, d2, r3, o2, n2, false, a2.lineMetrics);
              else if (f4 === "MultiLineString")
                le(c2, d2, r3, o2, n2, false);
              else if (f4 === "Polygon")
                le(c2, d2, r3, o2, n2, true);
              else if (f4 === "MultiPolygon")
                for (var m3 = 0; m3 < c2.length; m3++) {
                  var y2 = [];
                  le(c2[m3], y2, r3, o2, n2, true), y2.length && d2.push(y2);
                }
              if (d2.length) {
                if (a2.lineMetrics && f4 === "LineString") {
                  for (m3 = 0; m3 < d2.length; m3++)
                    l2.push(U(h3.id, f4, d2[m3], h3.tags));
                  continue;
                }
                f4 !== "LineString" && f4 !== "MultiLineString" || (d2.length === 1 ? (f4 = "LineString", d2 = d2[0]) : f4 = "MultiLineString"), f4 !== "Point" && f4 !== "MultiPoint" || (f4 = d2.length === 3 ? "Point" : "MultiPoint"), l2.push(U(h3.id, f4, d2, h3.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function ie(e3, t3, r3, o2, n2) {
          for (var i3 = 0; i3 < e3.length; i3 += 3) {
            var s4 = e3[i3 + n2];
            s4 >= r3 && s4 <= o2 && (t3.push(e3[i3]), t3.push(e3[i3 + 1]), t3.push(e3[i3 + 2]));
          }
        }
        function se(e3, t3, r3, o2, n2, i3, s4) {
          for (var a2, l2, u2 = ae(e3), h3 = n2 === 0 ? he : ce, c2 = e3.start, f4 = 0; f4 < e3.length - 3; f4 += 3) {
            var p2 = e3[f4], g2 = e3[f4 + 1], d2 = e3[f4 + 2], m3 = e3[f4 + 3], y2 = e3[f4 + 4], v2 = n2 === 0 ? p2 : g2, x3 = n2 === 0 ? m3 : y2, w2 = false;
            s4 && (a2 = Math.sqrt(Math.pow(p2 - m3, 2) + Math.pow(g2 - y2, 2))), v2 < r3 ? x3 > r3 && (l2 = h3(u2, p2, g2, m3, y2, r3), s4 && (u2.start = c2 + a2 * l2)) : v2 > o2 ? x3 < o2 && (l2 = h3(u2, p2, g2, m3, y2, o2), s4 && (u2.start = c2 + a2 * l2)) : ue(u2, p2, g2, d2), x3 < r3 && v2 >= r3 && (l2 = h3(u2, p2, g2, m3, y2, r3), w2 = true), x3 > o2 && v2 <= o2 && (l2 = h3(u2, p2, g2, m3, y2, o2), w2 = true), !i3 && w2 && (s4 && (u2.end = c2 + a2 * l2), t3.push(u2), u2 = ae(e3)), s4 && (c2 += a2);
          }
          var S3 = e3.length - 3;
          p2 = e3[S3], g2 = e3[S3 + 1], d2 = e3[S3 + 2], (v2 = n2 === 0 ? p2 : g2) >= r3 && v2 <= o2 && ue(u2, p2, g2, d2), S3 = u2.length - 3, i3 && S3 >= 3 && (u2[S3] !== u2[0] || u2[S3 + 1] !== u2[1]) && ue(u2, u2[0], u2[1], u2[2]), u2.length && t3.push(u2);
        }
        function ae(e3) {
          var t3 = [];
          return t3.size = e3.size, t3.start = e3.start, t3.end = e3.end, t3;
        }
        function le(e3, t3, r3, o2, n2, i3) {
          for (var s4 = 0; s4 < e3.length; s4++)
            se(e3[s4], t3, r3, o2, n2, i3, false);
        }
        function ue(e3, t3, r3, o2) {
          e3.push(t3), e3.push(r3), e3.push(o2);
        }
        function he(e3, t3, r3, o2, n2, i3) {
          var s4 = (i3 - t3) / (o2 - t3);
          return e3.push(i3), e3.push(r3 + (n2 - r3) * s4), e3.push(1), s4;
        }
        function ce(e3, t3, r3, o2, n2, i3) {
          var s4 = (i3 - r3) / (n2 - r3);
          return e3.push(t3 + (o2 - t3) * s4), e3.push(i3), e3.push(1), s4;
        }
        function fe(e3, t3) {
          for (var r3 = [], o2 = 0; o2 < e3.length; o2++) {
            var n2, i3 = e3[o2], s4 = i3.type;
            if (s4 === "Point" || s4 === "MultiPoint" || s4 === "LineString")
              n2 = pe(i3.geometry, t3);
            else if (s4 === "MultiLineString" || s4 === "Polygon") {
              n2 = [];
              for (var a2 = 0; a2 < i3.geometry.length; a2++)
                n2.push(pe(i3.geometry[a2], t3));
            } else if (s4 === "MultiPolygon")
              for (n2 = [], a2 = 0; a2 < i3.geometry.length; a2++) {
                for (var l2 = [], u2 = 0; u2 < i3.geometry[a2].length; u2++)
                  l2.push(pe(i3.geometry[a2][u2], t3));
                n2.push(l2);
              }
            r3.push(U(i3.id, s4, n2, i3.tags));
          }
          return r3;
        }
        function pe(e3, t3) {
          var r3 = [];
          r3.size = e3.size, e3.start !== void 0 && (r3.start = e3.start, r3.end = e3.end);
          for (var o2 = 0; o2 < e3.length; o2 += 3)
            r3.push(e3[o2] + t3, e3[o2 + 1], e3[o2 + 2]);
          return r3;
        }
        function ge(e3, t3) {
          if (e3.transformed)
            return e3;
          var r3, o2, n2, i3 = 1 << e3.z, s4 = e3.x, a2 = e3.y;
          for (r3 = 0; r3 < e3.features.length; r3++) {
            var l2 = e3.features[r3], u2 = l2.geometry, h3 = l2.type;
            if (l2.geometry = [], h3 === 1)
              for (o2 = 0; o2 < u2.length; o2 += 2)
                l2.geometry.push(de(u2[o2], u2[o2 + 1], t3, i3, s4, a2));
            else
              for (o2 = 0; o2 < u2.length; o2++) {
                var c2 = [];
                for (n2 = 0; n2 < u2[o2].length; n2 += 2)
                  c2.push(de(u2[o2][n2], u2[o2][n2 + 1], t3, i3, s4, a2));
                l2.geometry.push(c2);
              }
          }
          return e3.transformed = true, e3;
        }
        function de(e3, t3, r3, o2, n2, i3) {
          return [Math.round(r3 * (e3 * o2 - n2)), Math.round(r3 * (t3 * o2 - i3))];
        }
        function me(e3, t3, r3, o2, n2) {
          for (var i3 = t3 === n2.maxZoom ? 0 : n2.tolerance / ((1 << t3) * n2.extent), s4 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r3, y: o2, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e3.length; a2++) {
            s4.numFeatures++, ye(s4, e3[a2], i3, n2);
            var l2 = e3[a2].minX, u2 = e3[a2].minY, h3 = e3[a2].maxX, c2 = e3[a2].maxY;
            l2 < s4.minX && (s4.minX = l2), u2 < s4.minY && (s4.minY = u2), h3 > s4.maxX && (s4.maxX = h3), c2 > s4.maxY && (s4.maxY = c2);
          }
          return s4;
        }
        function ye(e3, t3, r3, o2) {
          var n2 = t3.geometry, i3 = t3.type, s4 = [];
          if (i3 === "Point" || i3 === "MultiPoint")
            for (var a2 = 0; a2 < n2.length; a2 += 3)
              s4.push(n2[a2]), s4.push(n2[a2 + 1]), e3.numPoints++, e3.numSimplified++;
          else if (i3 === "LineString")
            ve(s4, n2, e3, r3, false, false);
          else if (i3 === "MultiLineString" || i3 === "Polygon")
            for (a2 = 0; a2 < n2.length; a2++)
              ve(s4, n2[a2], e3, r3, i3 === "Polygon", a2 === 0);
          else if (i3 === "MultiPolygon")
            for (var l2 = 0; l2 < n2.length; l2++) {
              var u2 = n2[l2];
              for (a2 = 0; a2 < u2.length; a2++)
                ve(s4, u2[a2], e3, r3, true, a2 === 0);
            }
          if (s4.length) {
            var h3 = t3.tags || null;
            if (i3 === "LineString" && o2.lineMetrics) {
              for (var c2 in h3 = {}, t3.tags)
                h3[c2] = t3.tags[c2];
              h3.mapbox_clip_start = n2.start / n2.size, h3.mapbox_clip_end = n2.end / n2.size;
            }
            var f4 = { geometry: s4, type: i3 === "Polygon" || i3 === "MultiPolygon" ? 3 : i3 === "LineString" || i3 === "MultiLineString" ? 2 : 1, tags: h3 };
            t3.id !== null && (f4.id = t3.id), e3.features.push(f4);
          }
        }
        function ve(e3, t3, r3, o2, n2, i3) {
          var s4 = o2 * o2;
          if (o2 > 0 && t3.size < (n2 ? s4 : o2))
            r3.numPoints += t3.length / 3;
          else {
            for (var a2 = [], l2 = 0; l2 < t3.length; l2 += 3)
              (o2 === 0 || t3[l2 + 2] > s4) && (r3.numSimplified++, a2.push(t3[l2]), a2.push(t3[l2 + 1])), r3.numPoints++;
            n2 && function(e4, t4) {
              for (var r4 = 0, o3 = 0, n3 = e4.length, i4 = n3 - 2; o3 < n3; i4 = o3, o3 += 2)
                r4 += (e4[o3] - e4[i4]) * (e4[o3 + 1] + e4[i4 + 1]);
              if (r4 > 0 === t4)
                for (o3 = 0, n3 = e4.length; o3 < n3 / 2; o3 += 2) {
                  var s5 = e4[o3], a3 = e4[o3 + 1];
                  e4[o3] = e4[n3 - 2 - o3], e4[o3 + 1] = e4[n3 - 1 - o3], e4[n3 - 2 - o3] = s5, e4[n3 - 1 - o3] = a3;
                }
            }(a2, i3), e3.push(a2);
          }
        }
        function xe(e3, t3) {
          var r3 = (t3 = this.options = function(e4, t4) {
            for (var r4 in t4)
              e4[r4] = t4[r4];
            return e4;
          }(Object.create(this.options), t3)).debug;
          if (r3 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t3.promoteId && t3.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var o2 = function(e4, t4) {
            var r4 = [];
            if (e4.type === "FeatureCollection")
              for (var o3 = 0; o3 < e4.features.length; o3++)
                H(r4, e4.features[o3], t4, o3);
            else
              H(r4, e4.type === "Feature" ? e4 : { geometry: e4 }, t4);
            return r4;
          }(e3, t3);
          this.tiles = {}, this.tileCoords = [], r3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o2 = function(e4, t4) {
            var r4 = t4.buffer / t4.extent, o3 = e4, n2 = ne(e4, 1, -1 - r4, r4, 0, -1, 2, t4), i3 = ne(e4, 1, 1 - r4, 2 + r4, 0, -1, 2, t4);
            return (n2 || i3) && (o3 = ne(e4, 1, -r4, 1 + r4, 0, -1, 2, t4) || [], n2 && (o3 = fe(n2, 1).concat(o3)), i3 && (o3 = o3.concat(fe(i3, -1)))), o3;
          }(o2, t3)).length && this.splitTile(o2, 0, 0, 0), r3 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function we(e3, t3, r3) {
          return 32 * ((1 << e3) * r3 + t3) + e3;
        }
        function Se(e3, t3) {
          const r3 = e3.tileID.canonical;
          if (!this._geoJSONIndex)
            return t3(null, null);
          const o2 = this._geoJSONIndex.getTile(r3.z, r3.x, r3.y);
          if (!o2)
            return t3(null, null);
          const n2 = new c(o2.features);
          let i3 = m2(n2);
          i3.byteOffset === 0 && i3.byteLength === i3.buffer.byteLength || (i3 = new Uint8Array(i3)), t3(null, { vectorTile: n2, rawData: i3.buffer });
        }
        xe.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, xe.prototype.splitTile = function(e3, t3, r3, o2, n2, i3, s4) {
          for (var a2 = [e3, t3, r3, o2], l2 = this.options, u2 = l2.debug; a2.length; ) {
            o2 = a2.pop(), r3 = a2.pop(), t3 = a2.pop(), e3 = a2.pop();
            var h3 = 1 << t3, c2 = we(t3, r3, o2), f4 = this.tiles[c2];
            if (!f4 && (u2 > 1 && console.time("creation"), f4 = this.tiles[c2] = me(e3, t3, r3, o2, l2), this.tileCoords.push({ z: t3, x: r3, y: o2 }), u2)) {
              u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, r3, o2, f4.numFeatures, f4.numPoints, f4.numSimplified), console.timeEnd("creation"));
              var p2 = "z" + t3;
              this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
            }
            if (f4.source = e3, n2) {
              if (t3 === l2.maxZoom || t3 === n2)
                continue;
              var g2 = 1 << n2 - t3;
              if (r3 !== Math.floor(i3 / g2) || o2 !== Math.floor(s4 / g2))
                continue;
            } else if (t3 === l2.indexMaxZoom || f4.numPoints <= l2.indexMaxPoints)
              continue;
            if (f4.source = null, e3.length !== 0) {
              u2 > 1 && console.time("clipping");
              var d2, m3, y2, v2, x3, w2, S3 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S3, P2 = 0.5 + S3, b2 = 1 + S3;
              d2 = m3 = y2 = v2 = null, x3 = ne(e3, h3, r3 - S3, r3 + P2, 0, f4.minX, f4.maxX, l2), w2 = ne(e3, h3, r3 + M2, r3 + b2, 0, f4.minX, f4.maxX, l2), e3 = null, x3 && (d2 = ne(x3, h3, o2 - S3, o2 + P2, 1, f4.minY, f4.maxY, l2), m3 = ne(x3, h3, o2 + M2, o2 + b2, 1, f4.minY, f4.maxY, l2), x3 = null), w2 && (y2 = ne(w2, h3, o2 - S3, o2 + P2, 1, f4.minY, f4.maxY, l2), v2 = ne(w2, h3, o2 + M2, o2 + b2, 1, f4.minY, f4.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t3 + 1, 2 * r3, 2 * o2), a2.push(m3 || [], t3 + 1, 2 * r3, 2 * o2 + 1), a2.push(y2 || [], t3 + 1, 2 * r3 + 1, 2 * o2), a2.push(v2 || [], t3 + 1, 2 * r3 + 1, 2 * o2 + 1);
            }
          }
        }, xe.prototype.getTile = function(e3, t3, r3) {
          var o2 = this.options, n2 = o2.extent, i3 = o2.debug;
          if (e3 < 0 || e3 > 24)
            return null;
          var s4 = 1 << e3, a2 = we(e3, t3 = (t3 % s4 + s4) % s4, r3);
          if (this.tiles[a2])
            return ge(this.tiles[a2], n2);
          i3 > 1 && console.log("drilling down to z%d-%d-%d", e3, t3, r3);
          for (var l2, u2 = e3, h3 = t3, c2 = r3; !l2 && u2 > 0; )
            u2--, h3 = Math.floor(h3 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[we(u2, h3, c2)];
          return l2 && l2.source ? (i3 > 1 && console.log("found parent tile z%d-%d-%d", u2, h3, c2), i3 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h3, c2, e3, t3, r3), i3 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ge(this.tiles[a2], n2) : null) : null;
        };
        class Me extends e2.VectorTileWorkerSource {
          constructor(e3, t3, r3, o2, n2) {
            super(e3, t3, r3, o2, Se), n2 && (this.loadGeoJSON = n2);
          }
          loadData(t3, r3) {
            const o2 = t3 && t3.request, n2 = o2 && o2.collectResourceTiming;
            this.loadGeoJSON(t3, (i3, a2) => {
              if (i3 || !a2)
                return r3(i3);
              if (typeof a2 != "object")
                return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              {
                s3(a2, true);
                try {
                  if (t3.filter) {
                    const r4 = e2.createExpression(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if (r4.result === "error")
                      throw new Error(r4.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
                    const o3 = a2.features.filter((e3) => r4.value.evaluate({ zoom: 0 }, e3));
                    a2 = { type: "FeatureCollection", features: o3 };
                  }
                  this._geoJSONIndex = t3.cluster ? new Z2(function({ superclusterOptions: t4, clusterProperties: r4 }) {
                    if (!r4 || !t4)
                      return t4;
                    const o3 = {}, n3 = {}, i4 = { accumulated: null, zoom: 0 }, s4 = { properties: null }, a3 = Object.keys(r4);
                    for (const t5 of a3) {
                      const [i5, s5] = r4[t5], a4 = e2.createExpression(s5), l3 = e2.createExpression(typeof i5 == "string" ? [i5, ["accumulated"], ["get", t5]] : i5);
                      o3[t5] = a4.value, n3[t5] = l3.value;
                    }
                    return t4.map = (e3) => {
                      s4.properties = e3;
                      const t5 = {};
                      for (const e4 of a3)
                        t5[e4] = o3[e4].evaluate(i4, s4);
                      return t5;
                    }, t4.reduce = (e3, t5) => {
                      s4.properties = t5;
                      for (const t6 of a3)
                        i4.accumulated = e3[t6], e3[t6] = n3[t6].evaluate(i4, s4);
                    }, t4;
                  }(t3)).load(a2.features) : function(e3, t4) {
                    return new xe(e3, t4);
                  }(a2, t3.geojsonVtOptions);
                } catch (i4) {
                  return r3(i4);
                }
                this.loaded = {};
                const l2 = {};
                if (n2) {
                  const r4 = e2.getPerformanceMeasurement(o2);
                  r4 && (l2.resourceTiming = {}, l2.resourceTiming[t3.source] = JSON.parse(JSON.stringify(r4)));
                }
                r3(null, l2);
              }
            });
          }
          reloadTile(e3, t3) {
            const r3 = this.loaded;
            return r3 && r3[e3.uid] ? super.reloadTile(e3, t3) : this.loadTile(e3, t3);
          }
          loadGeoJSON(t3, r3) {
            if (t3.request)
              e2.getJSON(t3.request, r3);
            else {
              if (typeof t3.data != "string")
                return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              try {
                return r3(null, JSON.parse(t3.data));
              } catch (e3) {
                return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(e3, t3) {
            try {
              t3(null, this._geoJSONIndex.getClusterExpansionZoom(e3.clusterId));
            } catch (e4) {
              t3(e4);
            }
          }
          getClusterChildren(e3, t3) {
            try {
              t3(null, this._geoJSONIndex.getChildren(e3.clusterId));
            } catch (e4) {
              t3(e4);
            }
          }
          getClusterLeaves(e3, t3) {
            try {
              t3(null, this._geoJSONIndex.getLeaves(e3.clusterId, e3.limit, e3.offset));
            } catch (e4) {
              t3(e4);
            }
          }
        }
        class Pe {
          constructor(t3) {
            this.self = t3, this.actor = new e2.Actor(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e2.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e2.VectorTileWorkerSource, geojson: Me }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e3, t4) => {
              if (this.workerSourceTypes[e3])
                throw new Error(`Worker source with name "${e3}" already registered.`);
              this.workerSourceTypes[e3] = t4;
            }, this.self.registerRTLTextPlugin = (t4) => {
              if (e2.plugin.isParsed())
                throw new Error("RTL text plugin already registered.");
              e2.plugin.applyArabicShaping = t4.applyArabicShaping, e2.plugin.processBidirectionalText = t4.processBidirectionalText, e2.plugin.processStyledBidirectionalText = t4.processStyledBidirectionalText;
            };
          }
          clearCaches(e3, t3, r3) {
            delete this.layerIndexes[e3], delete this.availableImages[e3], delete this.workerSources[e3], delete this.demWorkerSources[e3], r3();
          }
          checkIfReady(e3, t3, r3) {
            r3();
          }
          setReferrer(e3, t3) {
            this.referrer = t3;
          }
          spriteLoaded(t3, r3) {
            this.isSpriteLoaded[t3] = r3;
            for (const o2 in this.workerSources[t3]) {
              const n2 = this.workerSources[t3][o2];
              for (const t4 in n2)
                n2[t4] instanceof e2.VectorTileWorkerSource && (n2[t4].isSpriteLoaded = r3, n2[t4].fire(new e2.Event("isSpriteLoaded")));
            }
          }
          setImages(e3, t3, r3) {
            this.availableImages[e3] = t3;
            for (const r4 in this.workerSources[e3]) {
              const o2 = this.workerSources[e3][r4];
              for (const e4 in o2)
                o2[e4].availableImages = t3;
            }
            r3();
          }
          enableTerrain(e3, t3, r3) {
            this.terrain = t3, r3();
          }
          setProjection(t3, r3) {
            this.projections[t3] = e2.getProjection(r3);
          }
          setLayers(e3, t3, r3) {
            this.getLayerIndex(e3).replace(t3), r3();
          }
          updateLayers(e3, t3, r3) {
            this.getLayerIndex(e3).update(t3.layers, t3.removedIds), r3();
          }
          loadTile(t3, r3, o2) {
            const n2 = this.enableTerrain ? e2.extend({ enableTerrain: this.terrain }, r3) : r3;
            n2.projection = this.projections[t3] || this.defaultProjection, this.getWorkerSource(t3, r3.type, r3.source).loadTile(n2, o2);
          }
          loadDEMTile(t3, r3, o2) {
            const n2 = this.enableTerrain ? e2.extend({ buildQuadTree: this.terrain }, r3) : r3;
            this.getDEMWorkerSource(t3, r3.source).loadTile(n2, o2);
          }
          reloadTile(t3, r3, o2) {
            const n2 = this.enableTerrain ? e2.extend({ enableTerrain: this.terrain }, r3) : r3;
            n2.projection = this.projections[t3] || this.defaultProjection, this.getWorkerSource(t3, r3.type, r3.source).reloadTile(n2, o2);
          }
          abortTile(e3, t3, r3) {
            this.getWorkerSource(e3, t3.type, t3.source).abortTile(t3, r3);
          }
          removeTile(e3, t3, r3) {
            this.getWorkerSource(e3, t3.type, t3.source).removeTile(t3, r3);
          }
          removeSource(e3, t3, r3) {
            if (!this.workerSources[e3] || !this.workerSources[e3][t3.type] || !this.workerSources[e3][t3.type][t3.source])
              return;
            const o2 = this.workerSources[e3][t3.type][t3.source];
            delete this.workerSources[e3][t3.type][t3.source], o2.removeSource !== void 0 ? o2.removeSource(t3, r3) : r3();
          }
          loadWorkerSource(e3, t3, r3) {
            try {
              this.self.importScripts(t3.url), r3();
            } catch (e4) {
              r3(e4.toString());
            }
          }
          syncRTLPluginState(t3, r3, o2) {
            try {
              e2.plugin.setState(r3);
              const t4 = e2.plugin.getPluginURL();
              if (e2.plugin.isLoaded() && !e2.plugin.isParsed() && t4 != null) {
                this.self.importScripts(t4);
                const r4 = e2.plugin.isParsed();
                o2(r4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), r4);
              }
            } catch (e3) {
              o2(e3.toString());
            }
          }
          getAvailableImages(e3) {
            let t3 = this.availableImages[e3];
            return t3 || (t3 = []), t3;
          }
          getLayerIndex(e3) {
            let t3 = this.layerIndexes[e3];
            return t3 || (t3 = this.layerIndexes[e3] = new o()), t3;
          }
          getWorkerSource(e3, t3, r3) {
            return this.workerSources[e3] || (this.workerSources[e3] = {}), this.workerSources[e3][t3] || (this.workerSources[e3][t3] = {}), this.workerSources[e3][t3][r3] || (this.workerSources[e3][t3][r3] = new this.workerSourceTypes[t3]({ send: (t4, r4, o2, n2, i3, s4) => {
              this.actor.send(t4, r4, o2, e3, i3, s4);
            }, scheduler: this.actor.scheduler }, this.getLayerIndex(e3), this.getAvailableImages(e3), this.isSpriteLoaded[e3])), this.workerSources[e3][t3][r3];
          }
          getDEMWorkerSource(e3, t3) {
            return this.demWorkerSources[e3] || (this.demWorkerSources[e3] = {}), this.demWorkerSources[e3][t3] || (this.demWorkerSources[e3][t3] = new i2()), this.demWorkerSources[e3][t3];
          }
          enforceCacheSizeLimit(t3, r3) {
            e2.enforceCacheSizeLimit(r3);
          }
          getWorkerPerformanceMetrics(e3, t3, r3) {
            r3(void 0, void 0);
          }
        }
        return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope && (self.worker = new Pe(self)), Pe;
      });
      define2(["./shared"], function(e2) {
        "use strict";
        var t2 = i2;
        function i2(e3) {
          return !function(e4) {
            return typeof window == "undefined" || typeof document == "undefined" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var e5, t4, i3 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i3);
              try {
                t4 = new Worker(o2), e5 = true;
              } catch (t5) {
                e5 = false;
              }
              return t4 && t4.terminate(), URL.revokeObjectURL(o2), e5;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var e5 = document.createElement("canvas");
              e5.width = e5.height = 1;
              var t4 = e5.getContext("2d");
              if (!t4)
                return false;
              var i3 = t4.getImageData(0, 0, 1, 1);
              return i3 && i3.width === e5.width;
            }() ? (o[t3 = e4 && e4.failIfMajorPerformanceCaveat] === void 0 && (o[t3] = function(e5) {
              var t4, o2 = function(e6) {
                var t5 = document.createElement("canvas"), o3 = Object.create(i2.webGLContextAttributes);
                return o3.failIfMajorPerformanceCaveat = e6, t5.getContext("webgl", o3) || t5.getContext("experimental-webgl", o3);
              }(e5);
              if (!o2)
                return false;
              try {
                t4 = o2.createShader(o2.VERTEX_SHADER);
              } catch (e6) {
                return false;
              }
              return !(!t4 || o2.isContextLost()) && (o2.shaderSource(t4, "void main() {}"), o2.compileShader(t4), o2.getShaderParameter(t4, o2.COMPILE_STATUS) === true);
            }(t3)), o[t3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var t3;
          }(e3);
        }
        var o = {};
        function r2(e3, t3) {
          var i3 = t3[0], o2 = t3[1], r3 = t3[2], n2 = t3[3], a2 = i3 * n2 - r3 * o2;
          return a2 ? (e3[0] = n2 * (a2 = 1 / a2), e3[1] = -o2 * a2, e3[2] = -r3 * a2, e3[3] = i3 * a2, e3) : null;
        }
        function n(e3, t3) {
          if (Array.isArray(e3)) {
            if (!Array.isArray(t3) || e3.length !== t3.length)
              return false;
            for (let i3 = 0; i3 < e3.length; i3++)
              if (!n(e3[i3], t3[i3]))
                return false;
            return true;
          }
          if (typeof e3 == "object" && e3 !== null && t3 !== null) {
            if (typeof t3 != "object")
              return false;
            if (Object.keys(e3).length !== Object.keys(t3).length)
              return false;
            for (const i3 in e3)
              if (!n(e3[i3], t3[i3]))
                return false;
            return true;
          }
          return e3 === t3;
        }
        i2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        const a = { create: function(t3, i3, o2) {
          const r3 = e2.window.document.createElement(t3);
          return i3 !== void 0 && (r3.className = i3), o2 && o2.appendChild(r3), r3;
        }, createSVG: function(t3, i3, o2) {
          const r3 = e2.window.document.createElementNS("http://www.w3.org/2000/svg", t3);
          for (const e3 of Object.keys(i3))
            r3.setAttributeNS(null, e3, i3[e3]);
          return o2 && o2.appendChild(r3), r3;
        } }, s3 = e2.window.document && e2.window.document.documentElement.style, l = s3 && s3.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
        let c;
        a.disableDrag = function() {
          s3 && l && (c = s3[l], s3[l] = "none");
        }, a.enableDrag = function() {
          s3 && l && (s3[l] = c);
        };
        const h2 = function(t3) {
          t3.preventDefault(), t3.stopPropagation(), e2.window.removeEventListener("click", h2, true);
        };
        function u(t3, i3, o2) {
          const r3 = t3.offsetWidth === i3.width ? 1 : t3.offsetWidth / i3.width;
          return new e2.pointGeometry((o2.clientX - i3.left) * r3, (o2.clientY - i3.top) * r3);
        }
        function _(e3) {
          const { userImage: t3 } = e3;
          return !!(t3 && t3.render && t3.render()) && (e3.data.replace(new Uint8Array(t3.data.buffer)), true);
        }
        a.suppressClick = function() {
          e2.window.addEventListener("click", h2, true), e2.window.setTimeout(() => {
            e2.window.removeEventListener("click", h2, true);
          }, 0);
        }, a.mousePos = function(e3, t3) {
          const i3 = e3.getBoundingClientRect();
          return u(e3, i3, t3);
        }, a.touchPos = function(e3, t3) {
          const i3 = e3.getBoundingClientRect(), o2 = [];
          for (let r3 = 0; r3 < t3.length; r3++)
            o2.push(u(e3, i3, t3[r3]));
          return o2;
        }, a.mouseButton = function(t3) {
          return e2.window.InstallTrigger !== void 0 && t3.button === 2 && t3.ctrlKey && e2.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t3.button;
        };
        class d extends e2.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e2.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e3) {
            if (this.loaded !== e3 && (this.loaded = e3, e3)) {
              for (const { ids: e4, callback: t3 } of this.requestors)
                this._notify(e4, t3);
              this.requestors = [];
            }
          }
          getImage(e3) {
            return this.images[e3];
          }
          addImage(e3, t3) {
            this._validate(e3, t3) && (this.images[e3] = t3);
          }
          _validate(t3, i3) {
            let o2 = true;
            return this._validateStretch(i3.stretchX, i3.data && i3.data.width) || (this.fire(new e2.ErrorEvent(new Error(`Image "${t3}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i3.stretchY, i3.data && i3.data.height) || (this.fire(new e2.ErrorEvent(new Error(`Image "${t3}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i3.content, i3) || (this.fire(new e2.ErrorEvent(new Error(`Image "${t3}" has invalid "content" value`))), o2 = false), o2;
          }
          _validateStretch(e3, t3) {
            if (!e3)
              return true;
            let i3 = 0;
            for (const o2 of e3) {
              if (o2[0] < i3 || o2[1] < o2[0] || t3 < o2[1])
                return false;
              i3 = o2[1];
            }
            return true;
          }
          _validateContent(e3, t3) {
            return !(e3 && (e3.length !== 4 || e3[0] < 0 || t3.data.width < e3[0] || e3[1] < 0 || t3.data.height < e3[1] || e3[2] < 0 || t3.data.width < e3[2] || e3[3] < 0 || t3.data.height < e3[3] || e3[2] < e3[0] || e3[3] < e3[1]));
          }
          updateImage(e3, t3) {
            t3.version = this.images[e3].version + 1, this.images[e3] = t3, this.updatedImages[e3] = true;
          }
          removeImage(e3) {
            const t3 = this.images[e3];
            delete this.images[e3], delete this.patterns[e3], t3.userImage && t3.userImage.onRemove && t3.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e3, t3) {
            let i3 = true;
            if (!this.isLoaded())
              for (const t4 of e3)
                this.images[t4] || (i3 = false);
            this.isLoaded() || i3 ? this._notify(e3, t3) : this.requestors.push({ ids: e3, callback: t3 });
          }
          _notify(t3, i3) {
            const o2 = {};
            for (const i4 of t3) {
              this.images[i4] || this.fire(new e2.Event("styleimagemissing", { id: i4 }));
              const t4 = this.images[i4];
              t4 ? o2[i4] = { data: t4.data.clone(), pixelRatio: t4.pixelRatio, sdf: t4.sdf, version: t4.version, stretchX: t4.stretchX, stretchY: t4.stretchY, content: t4.content, hasRenderCallback: Boolean(t4.userImage && t4.userImage.render) } : e2.warnOnce(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i3(null, o2);
          }
          getPixelSize() {
            const { width: e3, height: t3 } = this.atlasImage;
            return { width: e3, height: t3 };
          }
          getPattern(t3) {
            const i3 = this.patterns[t3], o2 = this.getImage(t3);
            if (!o2)
              return null;
            if (i3 && i3.position.version === o2.version)
              return i3.position;
            if (i3)
              i3.position.version = o2.version;
            else {
              const i4 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r3 = new e2.ImagePosition(i4, o2);
              this.patterns[t3] = { bin: i4, position: r3 };
            }
            return this._updatePatternAtlas(), this.patterns[t3].position;
          }
          bind(t3) {
            const i3 = t3.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e2.Texture(t3, this.atlasImage, i3.RGBA), this.atlasTexture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t3 = [];
            for (const e3 in this.patterns)
              t3.push(this.patterns[e3].bin);
            const { w: i3, h: o2 } = e2.potpack(t3), r3 = this.atlasImage;
            r3.resize({ width: i3 || 1, height: o2 || 1 });
            for (const t4 in this.patterns) {
              const { bin: i4 } = this.patterns[t4], o3 = i4.x + 1, n2 = i4.y + 1, a2 = this.images[t4].data, s4 = a2.width, l2 = a2.height;
              e2.RGBAImage.copy(a2, r3, { x: 0, y: 0 }, { x: o3, y: n2 }, { width: s4, height: l2 }), e2.RGBAImage.copy(a2, r3, { x: 0, y: l2 - 1 }, { x: o3, y: n2 - 1 }, { width: s4, height: 1 }), e2.RGBAImage.copy(a2, r3, { x: 0, y: 0 }, { x: o3, y: n2 + l2 }, { width: s4, height: 1 }), e2.RGBAImage.copy(a2, r3, { x: s4 - 1, y: 0 }, { x: o3 - 1, y: n2 }, { width: 1, height: l2 }), e2.RGBAImage.copy(a2, r3, { x: 0, y: 0 }, { x: o3 + s4, y: n2 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e3) {
            for (const t3 of e3) {
              if (this.callbackDispatchedThisFrame[t3])
                continue;
              this.callbackDispatchedThisFrame[t3] = true;
              const e4 = this.images[t3];
              _(e4) && this.updateImage(t3, e4);
            }
          }
        }
        const p = new e2.Properties({ anchor: new e2.DataConstantProperty(e2.spec.light.anchor), position: new class {
          constructor() {
            this.specification = e2.spec.light.position;
          }
          possiblyEvaluate(t3, i3) {
            return function([t4, i4, o2]) {
              const r3 = e2.degToRad(i4 + 90), n2 = e2.degToRad(o2);
              return { x: t4 * Math.cos(r3) * Math.sin(n2), y: t4 * Math.sin(r3) * Math.sin(n2), z: t4 * Math.cos(n2), azimuthal: i4, polar: o2 };
            }(t3.expression.evaluate(i3));
          }
          interpolate(t3, i3, o2) {
            return { x: e2.number(t3.x, i3.x, o2), y: e2.number(t3.y, i3.y, o2), z: e2.number(t3.z, i3.z, o2), azimuthal: e2.number(t3.azimuthal, i3.azimuthal, o2), polar: e2.number(t3.polar, i3.polar, o2) };
          }
        }(), color: new e2.DataConstantProperty(e2.spec.light.color), intensity: new e2.DataConstantProperty(e2.spec.light.intensity) }), m2 = "-transition";
        class f3 extends e2.Evented {
          constructor(t3) {
            super(), this._transitionable = new e2.Transitionable(p), this.setLight(t3), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t3, i3 = {}) {
            if (!this._validate(e2.validateLight, t3, i3))
              for (const i4 in t3) {
                const o2 = t3[i4];
                e2.endsWith(i4, m2) ? this._transitionable.setTransition(i4.slice(0, -m2.length), o2) : this._transitionable.setValue(i4, o2);
              }
          }
          updateTransitions(e3) {
            this._transitioning = this._transitionable.transitioned(e3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e3) {
            this.properties = this._transitioning.possiblyEvaluate(e3);
          }
          _validate(t3, i3, o2) {
            return (!o2 || o2.validate !== false) && e2.emitValidationErrors(this, t3.call(e2.validateStyle, e2.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: e2.spec })));
          }
        }
        const g = new e2.Properties({ source: new e2.DataConstantProperty(e2.spec.terrain.source), exaggeration: new e2.DataConstantProperty(e2.spec.terrain.exaggeration) }), v = "-transition";
        class x2 extends e2.Evented {
          constructor(t3, i3) {
            super(), this._transitionable = new e2.Transitionable(g), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i3;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t3) {
            for (const i3 in t3) {
              const o2 = t3[i3];
              e2.endsWith(i3, v) ? this._transitionable.setTransition(i3.slice(0, -v.length), o2) : this._transitionable.setValue(i3, o2);
            }
          }
          updateTransitions(e3) {
            this._transitioning = this._transitionable.transitioned(e3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e3) {
            this.properties = this._transitioning.possiblyEvaluate(e3);
          }
        }
        function y(t3, i3, o2, r3) {
          const n2 = e2.smoothstep(45, 65, o2), [a2, s4] = b(t3, r3), l2 = e2.length(i3);
          let c2 = 1 - Math.min(1, Math.exp((l2 - a2) / (s4 - a2) * -6));
          return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * n2 * t3.alpha;
        }
        function b(e3, t3) {
          const i3 = 0.5 / Math.tan(0.5 * t3);
          return [e3.range[0] + i3, e3.range[1] + i3];
        }
        const w = new e2.Properties({ range: new e2.DataConstantProperty(e2.spec.fog.range), color: new e2.DataConstantProperty(e2.spec.fog.color), "horizon-blend": new e2.DataConstantProperty(e2.spec.fog["horizon-blend"]) }), T = "-transition";
        class E extends e2.Evented {
          constructor(t3, i3) {
            super(), this._transitionable = new e2.Transitionable(w), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this._transform = i3;
          }
          get state() {
            return { range: this.properties.get("range"), horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t3, i3 = {}) {
            if (!this._validate(e2.validateFog, t3, i3))
              for (const i4 in t3) {
                const o2 = t3[i4];
                e2.endsWith(i4, T) ? this._transitionable.setTransition(i4.slice(0, -T.length), o2) : this._transitionable.setValue(i4, o2);
              }
          }
          getOpacity(t3) {
            if (!this._transform.projection.supportsFog)
              return 0;
            const i3 = this.properties && this.properties.get("color") || 1;
            return e2.smoothstep(45, 65, t3) * i3.a;
          }
          getOpacityAtLatLng(t3, i3) {
            return this._transform.projection.supportsFog ? function(t4, i4, o2) {
              const r3 = e2.MercatorCoordinate.fromLngLat(i4), n2 = o2.elevation ? o2.elevation.getAtPointOrZero(r3) : 0, a2 = [r3.x, r3.y, n2];
              return e2.transformMat4(a2, a2, o2.mercatorFogMatrix), y(t4, a2, o2.pitch, o2._fov);
            }(this.state, t3, i3) : 0;
          }
          getFovAdjustedRange(e3) {
            return this._transform.projection.supportsFog ? b(this.state, e3) : [0, 1];
          }
          updateTransitions(e3) {
            this._transitioning = this._transitionable.transitioned(e3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e3) {
            this.properties = this._transitioning.possiblyEvaluate(e3);
          }
          _validate(t3, i3, o2) {
            return (!o2 || o2.validate !== false) && e2.emitValidationErrors(this, t3.call(e2.validateStyle, e2.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: e2.spec })));
          }
        }
        class C {
          constructor(t3, i3) {
            this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = e2.uniqueId();
            const o2 = this.workerPool.acquire(this.id);
            for (let e3 = 0; e3 < o2.length; e3++) {
              const t4 = new C.Actor(o2[e3], i3, this.id);
              t4.name = `Worker ${e3}`, this.actors.push(t4);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t3, i3, o2) {
            e2.asyncAll(this.actors, (e3, o3) => {
              e3.send(t3, i3, o3);
            }, o2 = o2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((e3) => {
              e3.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        function M(t3, i3, o2) {
          return i3 * (e2.EXTENT / (t3.tileSize * Math.pow(2, o2 - t3.tileID.overscaledZ)));
        }
        C.Actor = e2.Actor;
        class S2 {
          constructor(e3, t3, i3) {
            this.context = e3;
            const o2 = e3.gl;
            this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), e3.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete t3.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e3) {
            const t3 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e3.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const I = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class z {
          constructor(e3, t3, i3, o2) {
            this.length = t3.length, this.attributes = i3, this.itemSize = t3.bytesPerElement, this.dynamicDraw = o2, this.context = e3;
            const r3 = e3.gl;
            this.buffer = r3.createBuffer(), e3.bindVertexBuffer.set(this.buffer), r3.bufferData(r3.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? r3.DYNAMIC_DRAW : r3.STATIC_DRAW), this.dynamicDraw || delete t3.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e3) {
            const t3 = this.context.gl;
            this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e3.arrayBuffer);
          }
          enableAttributes(e3, t3) {
            for (let i3 = 0; i3 < this.attributes.length; i3++) {
              const o2 = t3.attributes[this.attributes[i3].name];
              o2 !== void 0 && e3.enableVertexAttribArray(o2);
            }
          }
          setVertexAttribPointers(e3, t3, i3) {
            for (let o2 = 0; o2 < this.attributes.length; o2++) {
              const r3 = this.attributes[o2], n2 = t3.attributes[r3.name];
              n2 !== void 0 && e3.vertexAttribPointer(n2, r3.components, e3[I[r3.type]], false, this.itemSize, r3.offset + this.itemSize * (i3 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class D {
          constructor(e3) {
            this.gl = e3.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e3) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class P extends D {
          getDefault() {
            return e2.Color.transparent;
          }
          set(e3) {
            const t3 = this.current;
            (e3.r !== t3.r || e3.g !== t3.g || e3.b !== t3.b || e3.a !== t3.a || this.dirty) && (this.gl.clearColor(e3.r, e3.g, e3.b, e3.a), this.current = e3, this.dirty = false);
          }
        }
        class A2 extends D {
          getDefault() {
            return 1;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.clearDepth(e3), this.current = e3, this.dirty = false);
          }
        }
        class L extends D {
          getDefault() {
            return 0;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.clearStencil(e3), this.current = e3, this.dirty = false);
          }
        }
        class R extends D {
          getDefault() {
            return [true, true, true, true];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || e3[2] !== t3[2] || e3[3] !== t3[3] || this.dirty) && (this.gl.colorMask(e3[0], e3[1], e3[2], e3[3]), this.current = e3, this.dirty = false);
          }
        }
        class k extends D {
          getDefault() {
            return true;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.depthMask(e3), this.current = e3, this.dirty = false);
          }
        }
        class O extends D {
          getDefault() {
            return 255;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.stencilMask(e3), this.current = e3, this.dirty = false);
          }
        }
        class B extends D {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e3) {
            const t3 = this.current;
            (e3.func !== t3.func || e3.ref !== t3.ref || e3.mask !== t3.mask || this.dirty) && (this.gl.stencilFunc(e3.func, e3.ref, e3.mask), this.current = e3, this.dirty = false);
          }
        }
        class F2 extends D {
          getDefault() {
            const e3 = this.gl;
            return [e3.KEEP, e3.KEEP, e3.KEEP];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || e3[2] !== t3[2] || this.dirty) && (this.gl.stencilOp(e3[0], e3[1], e3[2]), this.current = e3, this.dirty = false);
          }
        }
        class U extends D {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e3, this.dirty = false;
          }
        }
        class N extends D {
          getDefault() {
            return [0, 1];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || this.dirty) && (this.gl.depthRange(e3[0], e3[1]), this.current = e3, this.dirty = false);
          }
        }
        class G extends D {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e3, this.dirty = false;
          }
        }
        class j extends D {
          getDefault() {
            return this.gl.LESS;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.depthFunc(e3), this.current = e3, this.dirty = false);
          }
        }
        class Z2 extends D {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e3, this.dirty = false;
          }
        }
        class V extends D {
          getDefault() {
            const e3 = this.gl;
            return [e3.ONE, e3.ZERO];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || this.dirty) && (this.gl.blendFunc(e3[0], e3[1]), this.current = e3, this.dirty = false);
          }
        }
        class W extends D {
          getDefault() {
            return e2.Color.transparent;
          }
          set(e3) {
            const t3 = this.current;
            (e3.r !== t3.r || e3.g !== t3.g || e3.b !== t3.b || e3.a !== t3.a || this.dirty) && (this.gl.blendColor(e3.r, e3.g, e3.b, e3.a), this.current = e3, this.dirty = false);
          }
        }
        class q extends D {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.blendEquation(e3), this.current = e3, this.dirty = false);
          }
        }
        class X extends D {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e3, this.dirty = false;
          }
        }
        class $ extends D {
          getDefault() {
            return this.gl.BACK;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.cullFace(e3), this.current = e3, this.dirty = false);
          }
        }
        class H extends D {
          getDefault() {
            return this.gl.CCW;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.frontFace(e3), this.current = e3, this.dirty = false);
          }
        }
        class K extends D {
          getDefault() {
            return null;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.useProgram(e3), this.current = e3, this.dirty = false);
          }
        }
        class Y extends D {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.activeTexture(e3), this.current = e3, this.dirty = false);
          }
        }
        class J extends D {
          getDefault() {
            const e3 = this.gl;
            return [0, 0, e3.drawingBufferWidth, e3.drawingBufferHeight];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || e3[2] !== t3[2] || e3[3] !== t3[3] || this.dirty) && (this.gl.viewport(e3[0], e3[1], e3[2], e3[3]), this.current = e3, this.dirty = false);
          }
        }
        class Q extends D {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindFramebuffer(t3.FRAMEBUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class ee extends D {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindRenderbuffer(t3.RENDERBUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class te extends D {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindTexture(t3.TEXTURE_2D, e3), this.current = e3, this.dirty = false;
          }
        }
        class ie extends D {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindBuffer(t3.ARRAY_BUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class oe extends D {
          getDefault() {
            return null;
          }
          set(e3) {
            const t3 = this.gl;
            t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class re extends D {
          constructor(e3) {
            super(e3), this.vao = e3.extVertexArrayObject;
          }
          getDefault() {
            return null;
          }
          set(e3) {
            this.vao && (e3 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e3), this.current = e3, this.dirty = false);
          }
        }
        class ne extends D {
          getDefault() {
            return 4;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_ALIGNMENT, e3), this.current = e3, this.dirty = false;
          }
        }
        class ae extends D {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3), this.current = e3, this.dirty = false;
          }
        }
        class se extends D {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e3), this.current = e3, this.dirty = false;
          }
        }
        class le extends D {
          constructor(e3, t3) {
            super(e3), this.context = e3, this.parent = t3;
          }
          getDefault() {
            return null;
          }
        }
        class ce extends le {
          setDirty() {
            this.dirty = true;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e3, 0), this.current = e3, this.dirty = false;
          }
        }
        class he extends le {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferRenderbuffer(t3.FRAMEBUFFER, this.attachment(), t3.RENDERBUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class ue extends he {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        class _e {
          constructor(e3, t3, i3, o2) {
            this.context = e3, this.width = t3, this.height = i3;
            const r3 = this.framebuffer = e3.gl.createFramebuffer();
            this.colorAttachment = new ce(e3, r3), o2 && (this.depthAttachment = new he(e3, r3));
          }
          destroy() {
            const e3 = this.context.gl, t3 = this.colorAttachment.get();
            if (t3 && e3.deleteTexture(t3), this.depthAttachment) {
              const t4 = this.depthAttachment.get();
              t4 && e3.deleteRenderbuffer(t4);
            }
            e3.deleteFramebuffer(this.framebuffer);
          }
        }
        class de {
          constructor(e3) {
            this.gl = e3, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new P(this), this.clearDepth = new A2(this), this.clearStencil = new L(this), this.colorMask = new R(this), this.depthMask = new k(this), this.stencilMask = new O(this), this.stencilFunc = new B(this), this.stencilOp = new F2(this), this.stencilTest = new U(this), this.depthRange = new N(this), this.depthTest = new G(this), this.depthFunc = new j(this), this.blend = new Z2(this), this.blendFunc = new V(this), this.blendColor = new W(this), this.blendEquation = new q(this), this.cullFace = new X(this), this.cullFaceSide = new $(this), this.frontFace = new H(this), this.program = new K(this), this.activeTexture = new Y(this), this.viewport = new J(this), this.bindFramebuffer = new Q(this), this.bindRenderbuffer = new ee(this), this.bindTexture = new te(this), this.bindVertexBuffer = new ie(this), this.bindElementBuffer = new oe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new re(this), this.pixelStoreUnpack = new ne(this), this.pixelStoreUnpackPremultiplyAlpha = new ae(this), this.pixelStoreUnpackFlipY = new se(this), this.extTextureFilterAnisotropic = e3.getExtension("EXT_texture_filter_anisotropic") || e3.getExtension("MOZ_EXT_texture_filter_anisotropic") || e3.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e3.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extTextureHalfFloat = e3.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e3.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e3.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = e3.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e3.getParameter(e3.MAX_TEXTURE_SIZE);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e3, t3) {
            return new S2(this, e3, t3);
          }
          createVertexBuffer(e3, t3, i3) {
            return new z(this, e3, t3, i3);
          }
          createRenderbuffer(e3, t3, i3) {
            const o2 = this.gl, r3 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(r3), o2.renderbufferStorage(o2.RENDERBUFFER, e3, t3, i3), this.bindRenderbuffer.set(null), r3;
          }
          createFramebuffer(e3, t3, i3) {
            return new _e(this, e3, t3, i3);
          }
          clear({ color: e3, depth: t3, stencil: i3 }) {
            const o2 = this.gl;
            let r3 = 0;
            e3 && (r3 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e3), this.colorMask.set([true, true, true, true])), t3 !== void 0 && (r3 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), i3 !== void 0 && (r3 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), o2.clear(r3);
          }
          setCullFace(e3) {
            e3.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e3.mode), this.frontFace.set(e3.frontFace));
          }
          setDepthMode(e3) {
            e3.func !== this.gl.ALWAYS || e3.mask ? (this.depthTest.set(true), this.depthFunc.set(e3.func), this.depthMask.set(e3.mask), this.depthRange.set(e3.range)) : this.depthTest.set(false);
          }
          setStencilMode(e3) {
            e3.test.func !== this.gl.ALWAYS || e3.mask ? (this.stencilTest.set(true), this.stencilMask.set(e3.mask), this.stencilOp.set([e3.fail, e3.depthFail, e3.pass]), this.stencilFunc.set({ func: e3.test.func, ref: e3.ref, mask: e3.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t3) {
            n(t3.blendFunction, e2.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t3.blendFunction), this.blendColor.set(t3.blendColor)), this.colorMask.set(t3.mask);
          }
          unbindVAO() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          }
        }
        class pe {
          constructor(e3, t3, i3, o2) {
            this.screenBounds = e3, this.cameraPoint = t3, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i3, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this.screenGeometry.map((e4) => o2.pointCoordinate3D(e4)), this.cameraGeometry = this.bufferedCameraGeometry(0);
          }
          static createFromScreenPoints(t3, i3) {
            let o2, r3;
            if (t3 instanceof e2.pointGeometry || typeof t3[0] == "number") {
              const n2 = e2.pointGeometry.convert(t3);
              o2 = [e2.pointGeometry.convert(t3)], r3 = i3.isPointAboveHorizon(n2);
            } else {
              const n2 = e2.pointGeometry.convert(t3[0]), a2 = e2.pointGeometry.convert(t3[1]);
              o2 = [n2, a2], r3 = e2.polygonizeBounds(n2, a2).every((e3) => i3.isPointAboveHorizon(e3));
            }
            return new pe(o2, i3.getCameraPoint(), r3, i3);
          }
          isPointQuery() {
            return this.screenBounds.length === 1;
          }
          bufferedScreenGeometry(t3) {
            return e2.polygonizeBounds(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t3);
          }
          bufferedCameraGeometry(t3) {
            const i3 = this.screenBounds[0], o2 = this.screenBounds.length === 1 ? this.screenBounds[0].add(new e2.pointGeometry(1, 1)) : this.screenBounds[1], r3 = e2.polygonizeBounds(i3, o2, 0, false);
            return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i3.x && this.cameraPoint.x < o2.x ? r3.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r3[2] = this.cameraPoint : this.cameraPoint.x <= i3.x && (r3[3] = this.cameraPoint)), e2.bufferConvexPolygon(r3, t3);
          }
          containsTile(t3, i3, o2) {
            const r3 = t3.queryPadding + 1, n2 = t3.tileID.wrap, a2 = o2 ? this._bufferedCameraMercator(r3, i3).map((i4) => e2.getTilePoint(t3.tileTransform, i4, n2)) : this._bufferedScreenMercator(r3, i3).map((i4) => e2.getTilePoint(t3.tileTransform, i4, n2)), s4 = this.screenGeometryMercator.map((i4) => e2.getTileVec3(t3.tileTransform, i4, n2)), l2 = s4.map((t4) => new e2.pointGeometry(t4[0], t4[1])), c2 = i3.getFreeCameraOptions().position || new e2.MercatorCoordinate(0, 0, 0), h3 = e2.getTileVec3(t3.tileTransform, c2, n2), u2 = s4.map((t4) => {
              const i4 = e2.sub(t4, t4, h3);
              return e2.normalize(i4, i4), new e2.Ray(h3, i4);
            }), _2 = M(t3, 1, i3.zoom);
            if (e2.polygonIntersectsBox(a2, 0, 0, e2.EXTENT, e2.EXTENT))
              return { queryGeometry: this, tilespaceGeometry: l2, tilespaceRays: u2, bufferedTilespaceGeometry: a2, bufferedTilespaceBounds: (d2 = e2.getBounds(a2), d2.min.x = e2.clamp(d2.min.x, 0, e2.EXTENT), d2.min.y = e2.clamp(d2.min.y, 0, e2.EXTENT), d2.max.x = e2.clamp(d2.max.x, 0, e2.EXTENT), d2.max.y = e2.clamp(d2.max.y, 0, e2.EXTENT), d2), tile: t3, tileID: t3.tileID, pixelToTileUnitsFactor: _2 };
            var d2;
          }
          _bufferedScreenMercator(e3, t3) {
            const i3 = me(e3);
            if (this._screenRaycastCache[i3])
              return this._screenRaycastCache[i3];
            {
              const o2 = this.bufferedScreenGeometry(e3).map((e4) => t3.pointCoordinate3D(e4));
              return this._screenRaycastCache[i3] = o2, o2;
            }
          }
          _bufferedCameraMercator(e3, t3) {
            const i3 = me(e3);
            if (this._cameraRaycastCache[i3])
              return this._cameraRaycastCache[i3];
            {
              const o2 = this.bufferedCameraGeometry(e3).map((e4) => t3.pointCoordinate3D(e4));
              return this._cameraRaycastCache[i3] = o2, o2;
            }
          }
        }
        function me(e3) {
          return 100 * e3 | 0;
        }
        function fe(t3, i3, o2) {
          const r3 = function(r4, n2) {
            if (r4)
              return o2(r4);
            if (n2) {
              const r5 = e2.pick(e2.extend(n2, t3), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              n2.vector_layers && (r5.vectorLayers = n2.vector_layers, r5.vectorLayerIds = r5.vectorLayers.map((e3) => e3.id)), r5.tiles = i3.canonicalizeTileset(r5, t3.url), o2(null, r5);
            }
          };
          return t3.url ? e2.getJSON(i3.transformRequest(i3.normalizeSourceURL(t3.url), e2.ResourceType.Source), r3) : e2.exported.frame(() => r3(null, t3));
        }
        class ge {
          constructor(t3, i3, o2) {
            this.bounds = e2.LngLatBounds.convert(this.validateBounds(t3)), this.minzoom = i3 || 0, this.maxzoom = o2 || 24;
          }
          validateBounds(e3) {
            return Array.isArray(e3) && e3.length === 4 ? [Math.max(-180, e3[0]), Math.max(-90, e3[1]), Math.min(180, e3[2]), Math.min(90, e3[3])] : [-180, -90, 180, 90];
          }
          contains(t3) {
            const i3 = Math.pow(2, t3.z), o2 = Math.floor(e2.mercatorXfromLng(this.bounds.getWest()) * i3), r3 = Math.floor(e2.mercatorYfromLat(this.bounds.getNorth()) * i3), n2 = Math.ceil(e2.mercatorXfromLng(this.bounds.getEast()) * i3), a2 = Math.ceil(e2.mercatorYfromLat(this.bounds.getSouth()) * i3);
            return t3.x >= o2 && t3.x < n2 && t3.y >= r3 && t3.y < a2;
          }
        }
        class ve extends e2.Evented {
          constructor(t3, i3, o2, r3) {
            super(), this.id = t3, this.dispatcher = o2, this.setEventedParent(r3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e2.extend({ type: "raster" }, i3), e2.extend(this, e2.pick(i3, ["url", "scheme", "tileSize"]));
          }
          load() {
            this._loaded = false, this.fire(new e2.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = fe(this._options, this.map._requestManager, (t3, i3) => {
              this._tileJSONRequest = null, this._loaded = true, t3 ? this.fire(new e2.ErrorEvent(t3)) : i3 && (e2.extend(this, i3), i3.bounds && (this.tileBounds = new ge(i3.bounds, this.minzoom, this.maxzoom)), e2.postTurnstileEvent(i3.tiles), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e3) {
            this.map = e3, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          serialize() {
            return e2.extend({}, this._options);
          }
          hasTile(e3) {
            return !this.tileBounds || this.tileBounds.contains(e3.canonical);
          }
          loadTile(t3, i3) {
            const o2 = e2.exported.devicePixelRatio >= 2, r3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
            t3.request = e2.getImage(this.map._requestManager.transformRequest(r3, e2.ResourceType.Tile), (o3, r4, n2, a2) => {
              if (delete t3.request, t3.aborted)
                t3.state = "unloaded", i3(null);
              else if (o3)
                t3.state = "errored", i3(o3);
              else if (r4) {
                this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: n2, expires: a2 });
                const o4 = this.map.painter.context, s4 = o4.gl;
                t3.texture = this.map.painter.getTileTexture(r4.width), t3.texture ? t3.texture.update(r4, { useMipmap: true }) : (t3.texture = new e2.Texture(o4, r4, s4.RGBA, { useMipmap: true }), t3.texture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE), o4.extTextureFilterAnisotropic && s4.texParameterf(s4.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), t3.state = "loaded", e2.cacheEntryPossiblyAdded(this.dispatcher), i3(null);
              }
            });
          }
          abortTile(e3, t3) {
            e3.request && (e3.request.cancel(), delete e3.request), t3();
          }
          unloadTile(e3, t3) {
            e3.texture && this.map.painter.saveTileTexture(e3.texture), t3();
          }
          hasTransition() {
            return false;
          }
        }
        let xe;
        function ye(t3, i3, o2, r3, n2, a2, s4, l2) {
          const c2 = [t3, o2, n2, i3, r3, a2, 1, 1, 1], h3 = [s4, l2, 1], u2 = e2.adjoint([], c2), [_2, d2, p2] = e2.transformMat3(h3, h3, e2.transpose(u2, u2));
          return e2.multiply(c2, [_2, 0, 0, 0, d2, 0, 0, 0, p2], c2);
        }
        class be extends e2.Evented {
          constructor(e3, t3, i3, o2) {
            super(), this.id = e3, this.dispatcher = i3, this.coordinates = t3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t3;
          }
          load(t3, i3) {
            this._loaded = false, this.fire(new e2.Event("dataloading", { dataType: "source" })), this.url = this.options.url, e2.getImage(this.map._requestManager.transformRequest(this.url, e2.ResourceType.Image), (o2, r3) => {
              this._loaded = true, o2 ? this.fire(new e2.ErrorEvent(o2)) : r3 && (this.image = e2.exported.getImageData(r3), this.width = this.image.width, this.height = this.image.height, t3 && (this.coordinates = t3), i3 && i3(), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e3) {
            return this.image && e3.url ? (this.options.url = e3.url, this.load(e3.coordinates, () => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e3) {
            this.map = e3, this.load();
          }
          setCoordinates(t3) {
            this.coordinates = t3, delete this._boundsArray;
            const i3 = t3.map(e2.MercatorCoordinate.fromLngLat);
            return this.tileID = function(t4) {
              let i4 = 1 / 0, o2 = 1 / 0, r3 = -1 / 0, n2 = -1 / 0;
              for (const e3 of t4)
                i4 = Math.min(i4, e3.x), o2 = Math.min(o2, e3.y), r3 = Math.max(r3, e3.x), n2 = Math.max(n2, e3.y);
              const a2 = Math.max(r3 - i4, n2 - o2), s4 = Math.max(0, Math.floor(-Math.log(a2) / Math.LN2)), l2 = Math.pow(2, s4);
              return new e2.CanonicalTileID(s4, Math.floor((i4 + r3) / 2 * l2), Math.floor((o2 + n2) / 2 * l2));
            }(i3), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            delete this._boundsArray;
          }
          _makeBoundsArray() {
            const t3 = e2.tileTransform(this.tileID, this.map.transform.projection), [i3, o2, r3, n2] = this.coordinates.map((i4) => {
              const o3 = t3.projection.project(i4[0], i4[1]);
              return e2.getTilePoint(t3, o3)._round();
            });
            return this.perspectiveTransform = function(t4, i4, o3, r4, n3, a2, s4, l2, c2, h3) {
              const u2 = ye(0, 0, t4, 0, 0, i4, t4, i4), _2 = ye(o3, r4, n3, a2, s4, l2, c2, h3);
              return e2.multiply(_2, e2.adjoint(u2, u2), _2), [_2[6] / _2[8] * t4 / e2.EXTENT, _2[7] / _2[8] * i4 / e2.EXTENT];
            }(this.width, this.height, i3.x, i3.y, o2.x, o2.y, n2.x, n2.y, r3.x, r3.y), this._boundsArray = new e2.StructArrayLayout4i8(), this._boundsArray.emplaceBack(i3.x, i3.y, 0, 0), this._boundsArray.emplaceBack(o2.x, o2.y, e2.EXTENT, 0), this._boundsArray.emplaceBack(n2.x, n2.y, 0, e2.EXTENT), this._boundsArray.emplaceBack(r3.x, r3.y, e2.EXTENT, e2.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image)
              return;
            const t3 = this.map.painter.context, i3 = t3.gl;
            this._boundsArray || this._makeBoundsArray(), this.boundsBuffer || (this.boundsBuffer = t3.createVertexBuffer(this._boundsArray, e2.boundsAttributes.members)), this.boundsSegments || (this.boundsSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new e2.Texture(t3, this.image, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE));
            for (const e3 in this.tiles) {
              const t4 = this.tiles[e3];
              t4.state !== "loaded" && (t4.state = "loaded", t4.texture = this.texture);
            }
          }
          loadTile(e3, t3) {
            this.tileID && this.tileID.equals(e3.tileID.canonical) ? (this.tiles[String(e3.tileID.wrap)] = e3, e3.buckets = {}, t3(null)) : (e3.state = "errored", t3(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        const we = { vector: class extends e2.Evented {
          constructor(t3, i3, o2, r3) {
            if (super(), this.id = t3, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e2.extend(this, e2.pick(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = e2.extend({ type: "vector" }, i3), this._collectResourceTiming = i3.collectResourceTiming, this.tileSize !== 512)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r3), this._tileWorkers = {}, this._deduped = new e2.DedupedRequest();
          }
          load() {
            this._loaded = false, this.fire(new e2.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = fe(this._options, this.map._requestManager, (t3, i3) => {
              this._tileJSONRequest = null, this._loaded = true, t3 ? this.fire(new e2.ErrorEvent(t3)) : i3 && (e2.extend(this, i3), i3.bounds && (this.tileBounds = new ge(i3.bounds, this.minzoom, this.maxzoom)), e2.postTurnstileEvent(i3.tiles, this.map._requestManager._customAccessToken), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e3) {
            return !this.tileBounds || this.tileBounds.contains(e3.canonical);
          }
          onAdd(e3) {
            this.map = e3, this.load();
          }
          setSourceProperty(e3) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), e3();
            const t3 = this.map.style._getSourceCaches(this.id);
            for (const e4 of t3)
              e4.clearTiles();
            this.load();
          }
          setTiles(e3) {
            return this.setSourceProperty(() => {
              this._options.tiles = e3;
            }), this;
          }
          setUrl(e3) {
            return this.setSourceProperty(() => {
              this.url = e3, this._options.url = e3;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          serialize() {
            return e2.extend({}, this._options);
          }
          loadTile(t3, i3) {
            const o2 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(o2, e2.ResourceType.Tile), data: void 0, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e2.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t3.isSymbolTile };
            if (r3.request.collectResourceTiming = this._collectResourceTiming, t3.actor && t3.state !== "expired")
              t3.state === "loading" ? t3.reloadCallback = i3 : t3.request = t3.actor.send("reloadTile", r3, n2.bind(this));
            else if (t3.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
              t3.request = t3.actor.send("loadTile", r3, n2.bind(this), void 0, true);
            else {
              const i4 = e2.loadVectorTile.call({ deduped: this._deduped }, r3, (e3, i5) => {
                e3 || !i5 ? n2.call(this, e3) : (r3.data = { cacheControl: i5.cacheControl, expires: i5.expires, rawData: i5.rawData.slice(0) }, t3.actor && t3.actor.send("loadTile", r3, n2.bind(this), void 0, true));
              }, true);
              t3.request = { cancel: i4 };
            }
            function n2(o3, r4) {
              return delete t3.request, t3.aborted ? i3(null) : o3 && o3.status !== 404 ? i3(o3) : (r4 && r4.resourceTiming && (t3.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && r4 && t3.setExpiryData(r4), t3.loadVectorData(r4, this.map.painter), e2.cacheEntryPossiblyAdded(this.dispatcher), i3(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
            }
          }
          abortTile(e3) {
            e3.request && (e3.request.cancel(), delete e3.request), e3.actor && e3.actor.send("abortTile", { uid: e3.uid, type: this.type, source: this.id });
          }
          unloadTile(e3) {
            e3.unloadVectorData(), e3.actor && e3.actor.send("removeTile", { uid: e3.uid, type: this.type, source: this.id });
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
        }, raster: ve, "raster-dem": class extends ve {
          constructor(t3, i3, o2, r3) {
            super(t3, i3, o2, r3), this.type = "raster-dem", this.maxzoom = 22, this._options = e2.extend({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox";
          }
          loadTile(t3, i3) {
            const o2 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function r3(e3, o3) {
              e3 && (t3.state = "errored", i3(e3)), o3 && (t3.dem = o3, t3.dem.onDeserialize(), t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true, t3.state = "loaded", i3(null));
            }
            t3.request = e2.getImage(this.map._requestManager.transformRequest(o2, e2.ResourceType.Tile), function(o3, n2, a2, s4) {
              if (delete t3.request, t3.aborted)
                t3.state = "unloaded", i3(null);
              else if (o3)
                t3.state = "errored", i3(o3);
              else if (n2) {
                this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: a2, expires: s4 });
                const i4 = e2.window.ImageBitmap && n2 instanceof e2.window.ImageBitmap && (xe == null && (xe = e2.window.OffscreenCanvas && new e2.window.OffscreenCanvas(1, 1).getContext("2d") && typeof e2.window.createImageBitmap == "function"), xe), o4 = 1 - (n2.width - e2.prevPowerOfTwo(n2.width)) / 2;
                o4 < 1 || t3.neighboringTiles || (t3.neighboringTiles = this._getNeighboringTiles(t3.tileID));
                const l2 = i4 ? n2 : e2.exported.getImageData(n2, o4), c2 = { uid: t3.uid, coord: t3.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o4 };
                t3.actor && t3.state !== "expired" || (t3.actor = this.dispatcher.getActor(), t3.actor.send("loadDEMTile", c2, r3.bind(this), void 0, true));
              }
            }.bind(this));
          }
          _getNeighboringTiles(t3) {
            const i3 = t3.canonical, o2 = Math.pow(2, i3.z), r3 = (i3.x - 1 + o2) % o2, n2 = i3.x === 0 ? t3.wrap - 1 : t3.wrap, a2 = (i3.x + 1 + o2) % o2, s4 = i3.x + 1 === o2 ? t3.wrap + 1 : t3.wrap, l2 = {};
            return l2[new e2.OverscaledTileID(t3.overscaledZ, n2, i3.z, r3, i3.y).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, s4, i3.z, a2, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new e2.OverscaledTileID(t3.overscaledZ, n2, i3.z, r3, i3.y - 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, t3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, s4, i3.z, a2, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < o2 && (l2[new e2.OverscaledTileID(t3.overscaledZ, n2, i3.z, r3, i3.y + 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, t3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, s4, i3.z, a2, i3.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(e3) {
            e3.demTexture && this.map.painter.saveTileTexture(e3.demTexture), e3.fbo && (e3.fbo.destroy(), delete e3.fbo), e3.dem && delete e3.dem, delete e3.neighboringTiles, e3.state = "unloaded";
          }
        }, geojson: class extends e2.Evented {
          constructor(t3, i3, o2, r3) {
            super(), this.id = t3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r3), this._data = i3.data, this._options = e2.extend({}, i3), this._collectResourceTiming = i3.collectResourceTiming, i3.maxzoom !== void 0 && (this.maxzoom = i3.maxzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
            const n2 = e2.EXTENT / this.tileSize;
            this.workerOptions = e2.extend({ source: this.id, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (i3.buffer !== void 0 ? i3.buffer : 128) * n2, tolerance: (i3.tolerance !== void 0 ? i3.tolerance : 0.375) * n2, extent: e2.EXTENT, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: i3.clusterMaxZoom !== void 0 ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: e2.EXTENT, radius: (i3.clusterRadius !== void 0 ? i3.clusterRadius : 50) * n2, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter }, i3.workerOptions);
          }
          onAdd(e3) {
            this.map = e3, this.setData(this._data);
          }
          setData(e3) {
            return this._data = e3, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e3, t3) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e3, source: this.id }, t3), this;
          }
          getClusterChildren(e3, t3) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e3, source: this.id }, t3), this;
          }
          getClusterLeaves(e3, t3, i3, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e3, limit: t3, offset: i3 }, o2), this;
          }
          _updateWorkerData() {
            if (this._pendingLoad)
              return void (this._coalesce = true);
            this.fire(new e2.Event("dataloading", { dataType: "source" })), this._loaded = false;
            const t3 = e2.extend({}, this.workerOptions), i3 = this._data;
            typeof i3 == "string" ? (t3.request = this.map._requestManager.transformRequest(e2.exported.resolveURL(i3), e2.ResourceType.Source), t3.request.collectResourceTiming = this._collectResourceTiming) : t3.data = JSON.stringify(i3), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t3, (t4, i4) => {
              if (this._loaded = true, this._pendingLoad = null, t4)
                this.fire(new e2.ErrorEvent(t4));
              else {
                const t5 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && i4 && i4.resourceTiming && i4.resourceTiming[this.id] && (t5.resourceTiming = i4.resourceTiming[this.id]), this.fire(new e2.Event("data", t5)), this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t3, i3) {
            const o2 = t3.actor ? "reloadTile" : "loadTile";
            t3.actor = this.actor, t3.request = this.actor.send(o2, { type: this.type, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e2.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e3, r3) => (delete t3.request, t3.unloadVectorData(), t3.aborted ? i3(null) : e3 ? i3(e3) : (t3.loadVectorData(r3, this.map.painter, o2 === "reloadTile"), i3(null))), void 0, o2 === "loadTile");
          }
          abortTile(e3) {
            e3.request && (e3.request.cancel(), delete e3.request), e3.aborted = true;
          }
          unloadTile(e3) {
            e3.unloadVectorData(), this.actor.send("removeTile", { uid: e3.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e2.extend({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends be {
          constructor(e3, t3, i3, o2) {
            super(e3, t3, i3, o2), this.roundZoom = true, this.type = "video", this.options = t3;
          }
          load() {
            this._loaded = false;
            const t3 = this.options;
            this.urls = [];
            for (const i3 of t3.urls)
              this.urls.push(this.map._requestManager.transformRequest(i3, e2.ResourceType.Source).url);
            e2.getVideo(this.urls, (t4, i3) => {
              this._loaded = true, t4 ? this.fire(new e2.ErrorEvent(t4)) : i3 && (this.video = i3, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t3) {
            if (this.video) {
              const i3 = this.video.seekable;
              t3 < i3.start(0) || t3 > i3.end(0) ? this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = t3;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e3) {
            this.map || (this.map = e3, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
              return;
            const t3 = this.map.painter.context, i3 = t3.gl;
            this.texture ? this.video.paused || (this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), i3.texSubImage2D(i3.TEXTURE_2D, 0, 0, 0, i3.RGBA, i3.UNSIGNED_BYTE, this.video)) : (this.texture = new e2.Texture(t3, this.video, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._boundsArray || this._makeBoundsArray(), this.boundsBuffer || (this.boundsBuffer = t3.createVertexBuffer(this._boundsArray, e2.boundsAttributes.members)), this.boundsSegments || (this.boundsSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2));
            for (const e3 in this.tiles) {
              const t4 = this.tiles[e3];
              t4.state !== "loaded" && (t4.state = "loaded", t4.texture = this.texture);
            }
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: be, canvas: class extends be {
          constructor(t3, i3, o2, r3) {
            super(t3, i3, o2, r3), i3.coordinates ? Array.isArray(i3.coordinates) && i3.coordinates.length === 4 && !i3.coordinates.some((e3) => !Array.isArray(e3) || e3.length !== 2 || e3.some((e4) => typeof e4 != "number")) || this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, 'missing required property "coordinates"'))), i3.animate && typeof i3.animate != "boolean" && this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? typeof i3.canvas == "string" || i3.canvas instanceof e2.window.HTMLCanvasElement || this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = i3.animate === void 0 || i3.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e2.window.HTMLCanvasElement ? this.options.canvas : e2.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e2.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e3) {
            this.map = e3, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t3 = true), this._hasInvalidDimensions())
              return;
            if (Object.keys(this.tiles).length === 0)
              return;
            const i3 = this.map.painter.context, o2 = i3.gl;
            this._boundsArray || this._makeBoundsArray(), this.boundsBuffer || (this.boundsBuffer = i3.createVertexBuffer(this._boundsArray, e2.boundsAttributes.members)), this.boundsSegments || (this.boundsSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (t3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e2.Texture(i3, this.canvas, o2.RGBA, { premultiply: true });
            for (const e3 in this.tiles) {
              const t4 = this.tiles[e3];
              t4.state !== "loaded" && (t4.state = "loaded", t4.texture = this.texture);
            }
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e3 of [this.canvas.width, this.canvas.height])
              if (isNaN(e3) || e3 <= 0)
                return true;
            return false;
          }
        } }, Te = function(t3, i3, o2, r3) {
          const n2 = new we[i3.type](t3, i3, o2, r3);
          if (n2.id !== t3)
            throw new Error(`Expected Source id to be ${t3} instead of ${n2.id}`);
          return e2.bindAll(["load", "abort", "unload", "serialize", "prepare"], n2), n2;
        };
        function Ee(t3, i3) {
          const o2 = e2.identity([]);
          return e2.scale(o2, o2, [0.5 * t3.width, 0.5 * -t3.height, 1]), e2.translate(o2, o2, [1, -1, 0]), e2.multiply$1(o2, o2, t3.calculateProjMatrix(i3.toUnwrapped()));
        }
        function Ce(e3, t3, i3, o2, r3, n2, a2, s4 = false) {
          const l2 = e3.tilesIn(o2, a2, s4);
          l2.sort(Se);
          const c2 = [];
          for (const o3 of l2)
            c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t3, i3, e3._state, o3, r3, n2, Ee(e3.transform, o3.tile.tileID), s4) });
          const h3 = function(e4) {
            const t4 = {}, i4 = {};
            for (const o3 of e4) {
              const e5 = o3.queryResults, r4 = o3.wrappedTileID, n3 = i4[r4] = i4[r4] || {};
              for (const i5 in e5) {
                const o4 = e5[i5], r5 = n3[i5] = n3[i5] || {}, a3 = t4[i5] = t4[i5] || [];
                for (const e6 of o4)
                  r5[e6.featureIndex] || (r5[e6.featureIndex] = true, a3.push(e6));
              }
            }
            return t4;
          }(c2);
          for (const t4 in h3)
            h3[t4].forEach((t5) => {
              const i4 = t5.feature, o3 = e3.getFeatureState(i4.layer["source-layer"], i4.id);
              i4.source = i4.layer.source, i4.layer["source-layer"] && (i4.sourceLayer = i4.layer["source-layer"]), i4.state = o3;
            });
          return h3;
        }
        function Me(e3, t3) {
          const i3 = e3.getRenderableIds().map((t4) => e3.getTileByID(t4)), o2 = [], r3 = {};
          for (let e4 = 0; e4 < i3.length; e4++) {
            const n2 = i3[e4], a2 = n2.tileID.canonical.key;
            r3[a2] || (r3[a2] = true, n2.querySourceFeatures(o2, t3));
          }
          return o2;
        }
        function Se(e3, t3) {
          const i3 = e3.tileID, o2 = t3.tileID;
          return i3.overscaledZ - o2.overscaledZ || i3.canonical.y - o2.canonical.y || i3.wrap - o2.wrap || i3.canonical.x - o2.canonical.x;
        }
        function Ie() {
          return Kr.workerClass != null ? new Kr.workerClass() : new e2.window.Worker(Kr.workerUrl);
        }
        const ze = "mapboxgl_preloaded_worker_pool";
        class De {
          constructor() {
            this.active = {};
          }
          acquire(e3) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < De.workerCount; )
                this.workers.push(new Ie());
            return this.active[e3] = true, this.workers.slice();
          }
          release(e3) {
            delete this.active[e3], this.numActive() === 0 && (this.workers.forEach((e4) => {
              e4.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[ze];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let Pe;
        function Ae() {
          return Pe || (Pe = new De()), Pe;
        }
        function Le(t3, i3) {
          const o2 = {};
          for (const e3 in t3)
            e3 !== "ref" && (o2[e3] = t3[e3]);
          return e2.refProperties.forEach((e3) => {
            e3 in i3 && (o2[e3] = i3[e3]);
          }), o2;
        }
        function Re(e3) {
          e3 = e3.slice();
          const t3 = Object.create(null);
          for (let i3 = 0; i3 < e3.length; i3++)
            t3[e3[i3].id] = e3[i3];
          for (let i3 = 0; i3 < e3.length; i3++)
            "ref" in e3[i3] && (e3[i3] = Le(e3[i3], t3[e3[i3].ref]));
          return e3;
        }
        De.workerCount = 2;
        const ke = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
        function Oe(e3, t3, i3) {
          i3.push({ command: ke.addSource, args: [e3, t3[e3]] });
        }
        function Be(e3, t3, i3) {
          t3.push({ command: ke.removeSource, args: [e3] }), i3[e3] = true;
        }
        function Fe(e3, t3, i3, o2) {
          Be(e3, i3, o2), Oe(e3, t3, i3);
        }
        function Ue(e3, t3, i3) {
          let o2;
          for (o2 in e3[i3])
            if (e3[i3].hasOwnProperty(o2) && o2 !== "data" && !n(e3[i3][o2], t3[i3][o2]))
              return false;
          for (o2 in t3[i3])
            if (t3[i3].hasOwnProperty(o2) && o2 !== "data" && !n(e3[i3][o2], t3[i3][o2]))
              return false;
          return true;
        }
        function Ne(e3, t3, i3, o2, r3, a2) {
          let s4;
          for (s4 in t3 = t3 || {}, e3 = e3 || {})
            e3.hasOwnProperty(s4) && (n(e3[s4], t3[s4]) || i3.push({ command: a2, args: [o2, s4, t3[s4], r3] }));
          for (s4 in t3)
            t3.hasOwnProperty(s4) && !e3.hasOwnProperty(s4) && (n(e3[s4], t3[s4]) || i3.push({ command: a2, args: [o2, s4, t3[s4], r3] }));
        }
        function Ge(e3) {
          return e3.id;
        }
        function je(e3, t3) {
          return e3[t3.id] = t3, e3;
        }
        class Ze {
          constructor(e3, t3) {
            this.reset(e3, t3);
          }
          reset(e3, t3) {
            this.points = e3 || [], this._distances = [0];
            for (let e4 = 1; e4 < this.points.length; e4++)
              this._distances[e4] = this._distances[e4 - 1] + this.points[e4].dist(this.points[e4 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t3) {
            if (this.points.length === 1)
              return this.points[0];
            t3 = e2.clamp(t3, 0, 1);
            let i3 = 1, o2 = this._distances[i3];
            const r3 = t3 * this.paddedLength + this.padding;
            for (; o2 < r3 && i3 < this._distances.length; )
              o2 = this._distances[++i3];
            const n2 = i3 - 1, a2 = this._distances[n2], s4 = o2 - a2, l2 = s4 > 0 ? (r3 - a2) / s4 : 0;
            return this.points[n2].mult(1 - l2).add(this.points[i3].mult(l2));
          }
        }
        class Ve {
          constructor(e3, t3, i3) {
            const o2 = this.boxCells = [], r3 = this.circleCells = [];
            this.xCellCount = Math.ceil(e3 / i3), this.yCellCount = Math.ceil(t3 / i3);
            for (let e4 = 0; e4 < this.xCellCount * this.yCellCount; e4++)
              o2.push([]), r3.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e3, this.height = t3, this.xScale = this.xCellCount / e3, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e3, t3, i3, o2, r3) {
            this._forEachCell(t3, i3, o2, r3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e3), this.bboxes.push(t3), this.bboxes.push(i3), this.bboxes.push(o2), this.bboxes.push(r3);
          }
          insertCircle(e3, t3, i3, o2) {
            this._forEachCell(t3 - o2, i3 - o2, t3 + o2, i3 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e3), this.circles.push(t3), this.circles.push(i3), this.circles.push(o2);
          }
          _insertBoxCell(e3, t3, i3, o2, r3, n2) {
            this.boxCells[r3].push(n2);
          }
          _insertCircleCell(e3, t3, i3, o2, r3, n2) {
            this.circleCells[r3].push(n2);
          }
          _query(e3, t3, i3, o2, r3, n2) {
            if (i3 < 0 || e3 > this.width || o2 < 0 || t3 > this.height)
              return !r3 && [];
            const a2 = [];
            if (e3 <= 0 && t3 <= 0 && this.width <= i3 && this.height <= o2) {
              if (r3)
                return true;
              for (let e4 = 0; e4 < this.boxKeys.length; e4++)
                a2.push({ key: this.boxKeys[e4], x1: this.bboxes[4 * e4], y1: this.bboxes[4 * e4 + 1], x2: this.bboxes[4 * e4 + 2], y2: this.bboxes[4 * e4 + 3] });
              for (let e4 = 0; e4 < this.circleKeys.length; e4++) {
                const t4 = this.circles[3 * e4], i4 = this.circles[3 * e4 + 1], o3 = this.circles[3 * e4 + 2];
                a2.push({ key: this.circleKeys[e4], x1: t4 - o3, y1: i4 - o3, x2: t4 + o3, y2: i4 + o3 });
              }
              return n2 ? a2.filter(n2) : a2;
            }
            return this._forEachCell(e3, t3, i3, o2, this._queryCell, a2, { hitTest: r3, seenUids: { box: {}, circle: {} } }, n2), r3 ? a2.length > 0 : a2;
          }
          _queryCircle(e3, t3, i3, o2, r3) {
            const n2 = e3 - i3, a2 = e3 + i3, s4 = t3 - i3, l2 = t3 + i3;
            if (a2 < 0 || n2 > this.width || l2 < 0 || s4 > this.height)
              return !o2 && [];
            const c2 = [];
            return this._forEachCell(n2, s4, a2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e3, y: t3, radius: i3 }, seenUids: { box: {}, circle: {} } }, r3), o2 ? c2.length > 0 : c2;
          }
          query(e3, t3, i3, o2, r3) {
            return this._query(e3, t3, i3, o2, false, r3);
          }
          hitTest(e3, t3, i3, o2, r3) {
            return this._query(e3, t3, i3, o2, true, r3);
          }
          hitTestCircle(e3, t3, i3, o2) {
            return this._queryCircle(e3, t3, i3, true, o2);
          }
          _queryCell(e3, t3, i3, o2, r3, n2, a2, s4) {
            const l2 = a2.seenUids, c2 = this.boxCells[r3];
            if (c2 !== null) {
              const r4 = this.bboxes;
              for (const h4 of c2)
                if (!l2.box[h4]) {
                  l2.box[h4] = true;
                  const c3 = 4 * h4;
                  if (e3 <= r4[c3 + 2] && t3 <= r4[c3 + 3] && i3 >= r4[c3 + 0] && o2 >= r4[c3 + 1] && (!s4 || s4(this.boxKeys[h4]))) {
                    if (a2.hitTest)
                      return n2.push(true), true;
                    n2.push({ key: this.boxKeys[h4], x1: r4[c3], y1: r4[c3 + 1], x2: r4[c3 + 2], y2: r4[c3 + 3] });
                  }
                }
            }
            const h3 = this.circleCells[r3];
            if (h3 !== null) {
              const r4 = this.circles;
              for (const c3 of h3)
                if (!l2.circle[c3]) {
                  l2.circle[c3] = true;
                  const h4 = 3 * c3;
                  if (this._circleAndRectCollide(r4[h4], r4[h4 + 1], r4[h4 + 2], e3, t3, i3, o2) && (!s4 || s4(this.circleKeys[c3]))) {
                    if (a2.hitTest)
                      return n2.push(true), true;
                    {
                      const e4 = r4[h4], t4 = r4[h4 + 1], i4 = r4[h4 + 2];
                      n2.push({ key: this.circleKeys[c3], x1: e4 - i4, y1: t4 - i4, x2: e4 + i4, y2: t4 + i4 });
                    }
                  }
                }
            }
          }
          _queryCellCircle(e3, t3, i3, o2, r3, n2, a2, s4) {
            const l2 = a2.circle, c2 = a2.seenUids, h3 = this.boxCells[r3];
            if (h3 !== null) {
              const e4 = this.bboxes;
              for (const t4 of h3)
                if (!c2.box[t4]) {
                  c2.box[t4] = true;
                  const i4 = 4 * t4;
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e4[i4 + 0], e4[i4 + 1], e4[i4 + 2], e4[i4 + 3]) && (!s4 || s4(this.boxKeys[t4])))
                    return n2.push(true), true;
                }
            }
            const u2 = this.circleCells[r3];
            if (u2 !== null) {
              const e4 = this.circles;
              for (const t4 of u2)
                if (!c2.circle[t4]) {
                  c2.circle[t4] = true;
                  const i4 = 3 * t4;
                  if (this._circlesCollide(e4[i4], e4[i4 + 1], e4[i4 + 2], l2.x, l2.y, l2.radius) && (!s4 || s4(this.circleKeys[t4])))
                    return n2.push(true), true;
                }
            }
          }
          _forEachCell(e3, t3, i3, o2, r3, n2, a2, s4) {
            const l2 = this._convertToXCellCoord(e3), c2 = this._convertToYCellCoord(t3), h3 = this._convertToXCellCoord(i3), u2 = this._convertToYCellCoord(o2);
            for (let _2 = l2; _2 <= h3; _2++)
              for (let l3 = c2; l3 <= u2; l3++)
                if (r3.call(this, e3, t3, i3, o2, this.xCellCount * l3 + _2, n2, a2, s4))
                  return;
          }
          _convertToXCellCoord(e3) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e3 * this.xScale)));
          }
          _convertToYCellCoord(e3) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e3 * this.yScale)));
          }
          _circlesCollide(e3, t3, i3, o2, r3, n2) {
            const a2 = o2 - e3, s4 = r3 - t3, l2 = i3 + n2;
            return l2 * l2 > a2 * a2 + s4 * s4;
          }
          _circleAndRectCollide(e3, t3, i3, o2, r3, n2, a2) {
            const s4 = (n2 - o2) / 2, l2 = Math.abs(e3 - (o2 + s4));
            if (l2 > s4 + i3)
              return false;
            const c2 = (a2 - r3) / 2, h3 = Math.abs(t3 - (r3 + c2));
            if (h3 > c2 + i3)
              return false;
            if (l2 <= s4 || h3 <= c2)
              return true;
            const u2 = l2 - s4, _2 = h3 - c2;
            return u2 * u2 + _2 * _2 <= i3 * i3;
          }
        }
        const We = Math.tan(85 * Math.PI / 180);
        function qe(t3, i3, o2, n2, a2, s4) {
          let l2 = e2.create();
          if (o2) {
            if (a2.projection.name === "globe")
              l2 = e2.calculateGlobeMatrix(a2, a2.worldSize / a2._projectionScaler, [0, 0]), e2.multiply$1(l2, l2, e2.globeDenormalizeECEF(e2.globeTileBounds(i3)));
            else {
              const e3 = r2([], s4);
              l2[0] = e3[0], l2[1] = e3[1], l2[4] = e3[2], l2[5] = e3[3];
            }
            n2 || e2.rotateZ(l2, l2, a2.angle);
          } else
            e2.multiply$1(l2, a2.labelPlaneMatrix, t3);
          return l2;
        }
        function Xe(t3, i3, o2, r3, n2, a2) {
          if (o2) {
            if (n2.projection.name === "globe") {
              const s4 = qe(t3, i3, o2, r3, n2, a2);
              return e2.invert(s4, s4), e2.multiply$1(s4, t3, s4), s4;
            }
            {
              const i4 = e2.clone(t3), o3 = e2.identity([]);
              return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e2.multiply$1(i4, i4, o3), r3 || e2.rotateZ(i4, i4, -n2.angle), i4;
            }
          }
          return n2.glCoordMatrix;
        }
        function $e(t3, i3, o2 = 0) {
          const r3 = [t3.x, t3.y, o2, 1];
          o2 ? e2.transformMat4$1(r3, r3, i3) : at(r3, r3, i3);
          const n2 = r3[3];
          return { point: new e2.pointGeometry(r3[0] / n2, r3[1] / n2), signedDistanceFromCamera: n2 };
        }
        function He(e3, t3) {
          return Math.min(0.5 + e3 / t3 * 0.5, 1.5);
        }
        function Ke(e3, t3) {
          const i3 = e3[0] / e3[3], o2 = e3[1] / e3[3];
          return i3 >= -t3[0] && i3 <= t3[0] && o2 >= -t3[1] && o2 <= t3[1];
        }
        function Ye(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3) {
          const u2 = o2.transform, _2 = r3 ? t3.textSizeData : t3.iconSizeData, d2 = e2.evaluateSizeForZoom(_2, o2.transform.zoom), p2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], m3 = r3 ? t3.text.dynamicLayoutVertexArray : t3.icon.dynamicLayoutVertexArray;
          m3.clear();
          const f4 = t3.lineVertexArray, g2 = r3 ? t3.text.placedSymbolArray : t3.icon.placedSymbolArray, v2 = o2.transform.width / o2.transform.height;
          let x3 = false;
          for (let r4 = 0; r4 < g2.length; r4++) {
            const y2 = g2.get(r4);
            if (y2.writingMode !== e2.WritingMode.vertical || x3 || r4 !== 0 && g2.get(r4 - 1).writingMode === e2.WritingMode.horizontal || (x3 = true), y2.hidden || y2.writingMode === e2.WritingMode.vertical && !x3) {
              nt(y2.numGlyphs, m3);
              continue;
            }
            x3 = false;
            const b2 = new e2.pointGeometry(y2.tileAnchorX, y2.tileAnchorY), w2 = c2 ? c2(b2) : [0, 0, 0], T2 = u2.projection.projectTilePoint(b2.x, b2.y, h3.canonical), E2 = [T2.x + w2[0], T2.y + w2[1], T2.z + w2[2]], C2 = [...E2, 1];
            if (e2.transformMat4$1(C2, C2, i3), !Ke(C2, p2)) {
              nt(y2.numGlyphs, m3);
              continue;
            }
            const M2 = He(o2.transform.cameraToCenterDistance, C2[3]), S3 = e2.evaluateSizeForFeature(_2, d2, y2), I2 = s4 ? S3 / M2 : S3 * M2, z2 = $e(new e2.pointGeometry(E2[0], E2[1]), n2, E2[2]);
            if (z2.signedDistanceFromCamera <= 0) {
              nt(y2.numGlyphs, m3);
              continue;
            }
            let D2 = {};
            const P2 = s4 ? null : c2, A3 = et(y2, I2, false, l2, i3, n2, a2, t3.glyphOffsetArray, f4, m3, z2.point, b2, D2, v2, P2, u2.projection, h3);
            x3 = A3.useVertical, P2 && A3.needsFlipping && (D2 = {}), (A3.notEnoughRoom || x3 || A3.needsFlipping && et(y2, I2, true, l2, i3, n2, a2, t3.glyphOffsetArray, f4, m3, z2.point, b2, D2, v2, P2, u2.projection, h3).notEnoughRoom) && nt(y2.numGlyphs, m3);
          }
          r3 ? t3.text.dynamicLayoutVertexBuffer.updateData(m3) : t3.icon.dynamicLayoutVertexBuffer.updateData(m3);
        }
        function Je(e3, t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2) {
          const m3 = s4.glyphStartIndex + s4.numGlyphs, f4 = s4.lineStartIndex, g2 = s4.lineStartIndex + s4.lineLength, v2 = t3.getoffsetX(s4.glyphStartIndex), x3 = t3.getoffsetX(m3 - 1), y2 = ot(e3 * v2, i3, o2, r3, n2, a2, s4.segment, f4, g2, l2, c2, h3, u2, _2, true, d2, p2);
          if (!y2)
            return null;
          const b2 = ot(e3 * x3, i3, o2, r3, n2, a2, s4.segment, f4, g2, l2, c2, h3, u2, _2, true, d2, p2);
          return b2 ? { first: y2, last: b2 } : null;
        }
        function Qe(t3, i3, o2, r3) {
          return t3.writingMode === e2.WritingMode.horizontal && Math.abs(o2.y - i3.y) > Math.abs(o2.x - i3.x) * r3 ? { useVertical: true } : t3.writingMode === e2.WritingMode.vertical ? i3.y < o2.y ? { needsFlipping: true } : null : t3.flipState !== 0 && function(e3, t4, i4) {
            const o3 = (t4.x - e3.x) * i4;
            return o3 === 0 || Math.abs((t4.y - e3.y) / o3) > We;
          }(i3, o2, r3) ? t3.flipState === 1 ? { needsFlipping: true } : null : i3.x > o2.x ? { needsFlipping: true } : null;
        }
        function et(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2, m3, f4, g2) {
          const v2 = i3 / 24, x3 = t3.lineOffsetX * v2, y2 = t3.lineOffsetY * v2;
          let b2;
          if (t3.numGlyphs > 1) {
            const e3 = t3.glyphStartIndex + t3.numGlyphs, i4 = t3.lineStartIndex, n3 = t3.lineStartIndex + t3.lineLength, h4 = Je(v2, l2, x3, y2, o2, u2, _2, t3, c2, a2, d2, m3, false, f4, g2);
            if (!h4)
              return { notEnoughRoom: true };
            const w2 = $e(h4.first.point, s4).point, T2 = $e(h4.last.point, s4).point;
            if (r3 && !o2) {
              const e4 = Qe(t3, w2, T2, p2);
              if (t3.flipState = e4 && e4.needsFlipping ? 1 : 2, e4)
                return e4;
            }
            b2 = [h4.first];
            for (let r4 = t3.glyphStartIndex + 1; r4 < e3 - 1; r4++)
              b2.push(ot(v2 * l2.getoffsetX(r4), x3, y2, o2, u2, _2, t3.segment, i4, n3, c2, a2, d2, m3, false, false, f4, g2));
            b2.push(h4.last);
          } else {
            if (r3 && !o2) {
              const i5 = $e(_2, n2).point, o3 = t3.lineStartIndex + t3.segment + 1, r4 = new e2.pointGeometry(c2.getx(o3), c2.gety(o3)), a3 = $e(r4, n2), s5 = Qe(t3, i5, a3.signedDistanceFromCamera > 0 ? a3.point : it(_2, r4, i5, 1, n2, void 0, f4, g2.canonical), p2);
              if (t3.flipState = s5 && s5.needsFlipping ? 1 : 2, s5)
                return s5;
            }
            const i4 = ot(v2 * l2.getoffsetX(t3.glyphStartIndex), x3, y2, o2, u2, _2, t3.segment, t3.lineStartIndex, t3.lineStartIndex + t3.lineLength, c2, a2, d2, m3, false, false, f4, g2);
            if (!i4)
              return { notEnoughRoom: true };
            b2 = [i4];
          }
          for (const t4 of b2)
            e2.addDynamicAttributes(h3, t4.point, t4.angle);
          return {};
        }
        function tt(t3, i3, o2, r3, n2) {
          const a2 = r3.projectTilePoint(t3.x, t3.y, i3);
          if (!n2)
            return $e(a2, o2, a2.z);
          const s4 = n2(t3);
          return $e(new e2.pointGeometry(a2.x + s4[0], a2.y + s4[1]), o2, a2.z + s4[2]);
        }
        function it(e3, t3, i3, o2, r3, n2, a2, s4) {
          const l2 = tt(e3.add(e3.sub(t3)._unit()), s4, r3, a2, n2).point, c2 = i3.sub(l2);
          return i3.add(c2._mult(o2 / c2.mag()));
        }
        function ot(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2, m3, f4, g2) {
          const v2 = r3 ? t3 - i3 : t3 + i3;
          let x3 = v2 > 0 ? 1 : -1, y2 = 0;
          r3 && (x3 *= -1, y2 = Math.PI), x3 < 0 && (y2 += Math.PI);
          let b2 = x3 > 0 ? l2 + s4 : l2 + s4 + 1, w2 = n2, T2 = n2, E2 = 0, C2 = 0;
          const M2 = Math.abs(v2), S3 = [], I2 = [];
          let z2 = a2;
          const D2 = () => {
            const t4 = b2 - x3;
            return E2 === 0 ? a2 : new e2.pointGeometry(h3.getx(t4), h3.gety(t4));
          }, P2 = () => it(D2(), z2, T2, M2 - E2 + 1, u2, d2, f4, g2.canonical);
          for (; E2 + C2 <= M2; ) {
            if (b2 += x3, b2 < l2 || b2 >= c2)
              return null;
            if (T2 = w2, S3.push(w2), p2 && I2.push(z2 || D2()), w2 = _2[b2], w2 === void 0) {
              z2 = new e2.pointGeometry(h3.getx(b2), h3.gety(b2));
              const t4 = tt(z2, g2.canonical, u2, f4, d2);
              w2 = t4.signedDistanceFromCamera > 0 ? _2[b2] = t4.point : P2();
            } else
              z2 = null;
            E2 += C2, C2 = T2.dist(w2);
          }
          m3 && d2 && (z2 = z2 || new e2.pointGeometry(h3.getx(b2), h3.gety(b2)), _2[b2] = w2 = _2[b2] === void 0 ? w2 : P2(), C2 = T2.dist(w2));
          const A3 = (M2 - E2) / C2, L2 = w2.sub(T2), R2 = L2.mult(A3)._add(T2);
          o2 && R2._add(L2._unit()._perp()._mult(o2 * x3));
          const k2 = y2 + Math.atan2(w2.y - T2.y, w2.x - T2.x);
          return S3.push(R2), p2 && (z2 = z2 || new e2.pointGeometry(h3.getx(b2), h3.gety(b2)), I2.push(function(t4, i4, o3) {
            const r4 = 1 - o3;
            return new e2.pointGeometry(t4.x * r4 + i4.x * o3, t4.y * r4 + i4.y * o3);
          }(I2.length > 0 ? I2[I2.length - 1] : z2, z2, A3))), { point: R2, angle: k2, path: S3, tilePath: I2 };
        }
        const rt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function nt(e3, t3) {
          for (let i3 = 0; i3 < e3; i3++) {
            const e4 = t3.length;
            t3.resize(e4 + 4), t3.float32.set(rt, 3 * e4);
          }
        }
        function at(e3, t3, i3) {
          const o2 = t3[0], r3 = t3[1];
          return e3[0] = i3[0] * o2 + i3[4] * r3 + i3[12], e3[1] = i3[1] * o2 + i3[5] * r3 + i3[13], e3[3] = i3[3] * o2 + i3[7] * r3 + i3[15], e3;
        }
        const st = 100;
        class lt {
          constructor(e3, t3, i3 = new Ve(e3.width + 200, e3.height + 200, 25), o2 = new Ve(e3.width + 200, e3.height + 200, 25)) {
            this.transform = e3, this.grid = i3, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e3._pitch) * e3.cameraToCenterDistance, this.screenRightBoundary = e3.width + st, this.screenBottomBoundary = e3.height + st, this.gridRightBoundary = e3.width + 200, this.gridBottomBoundary = e3.height + 200, this.fogState = t3;
          }
          placeCollisionBox(e3, t3, i3, o2, r3, n2, a2) {
            let s4 = t3.projectedAnchorX, l2 = t3.projectedAnchorY, c2 = t3.projectedAnchorZ;
            const h3 = t3.elevation, u2 = t3.tileID;
            if (h3 && u2) {
              const e4 = this.transform.projection.createTileTransform(this.transform, this.transform.worldSize), i4 = e4.upVector(u2.canonical, t3.tileAnchorX, t3.tileAnchorY), o3 = e4.upVectorScale(u2.canonical);
              s4 += i4[0] * h3 * o3, l2 += i4[1] * h3 * o3, c2 += i4[2] * h3 * o3;
            }
            const _2 = this.projectAndGetPerspectiveRatio(n2, s4, l2, c2, t3.tileID), d2 = r3 * _2.perspectiveRatio, p2 = (t3.x1 * e3 + i3.x - t3.padding) * d2 + _2.point.x, m3 = (t3.y1 * e3 + i3.y - t3.padding) * d2 + _2.point.y, f4 = (t3.x2 * e3 + i3.x + t3.padding) * d2 + _2.point.x, g2 = (t3.y2 * e3 + i3.y + t3.padding) * d2 + _2.point.y, v2 = _2.perspectiveRatio <= 0.55 || _2.aboveHorizon;
            return !this.isInsideGrid(p2, m3, f4, g2) || !o2 && this.grid.hitTest(p2, m3, f4, g2, a2) || v2 ? { box: [], offscreen: false } : { box: [p2, m3, f4, g2], offscreen: this.isOffscreen(p2, m3, f4, g2) };
          }
          placeCollisionCircles(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2) {
            const m3 = [], f4 = this.transform.elevation, g2 = this.transform.projection.createTileTransform(this.transform, this.transform.worldSize), v2 = f4 ? f4.getAtTileOffsetFunc(p2, g2) : (e3) => [0, 0, 0], x3 = new e2.pointGeometry(i3.tileAnchorX, i3.tileAnchorY), y2 = this.transform.projection.projectTilePoint(i3.tileAnchorX, i3.tileAnchorY, p2.canonical), b2 = v2(x3), w2 = [y2.x + b2[0], y2.y + b2[1], y2.z + b2[2]], T2 = this.projectAndGetPerspectiveRatio(a2, w2[0], w2[1], w2[2], p2), { perspectiveRatio: E2 } = T2, C2 = (h3 ? n2 / E2 : n2 * E2) / e2.ONE_EM, M2 = $e(new e2.pointGeometry(w2[0], w2[1]), s4, w2[2]).point, S3 = T2.signedDistanceFromCamera > 0 ? Je(C2, r3, i3.lineOffsetX * C2, i3.lineOffsetY * C2, false, M2, x3, i3, o2, s4, {}, f4 && !h3 ? v2 : null, h3 && !!f4, this.transform.projection, p2) : null;
            let I2 = false, z2 = false, D2 = true;
            if (S3 && !T2.aboveHorizon) {
              const i4 = 0.5 * _2 * E2 + d2, o3 = new e2.pointGeometry(-100, -100), r4 = new e2.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n3 = new Ze(), a3 = S3.first, s5 = S3.last;
              let h4 = [];
              for (let e3 = a3.path.length - 1; e3 >= 1; e3--)
                h4.push(a3.path[e3]);
              for (let e3 = 1; e3 < s5.path.length; e3++)
                h4.push(s5.path[e3]);
              const p3 = 2.5 * i4;
              if (l2) {
                const e3 = h4.map(f4 ? (e4, t4) => {
                  const i5 = v2(t4 < a3.path.length - 1 ? a3.tilePath[a3.path.length - 1 - t4] : s5.tilePath[t4 - a3.path.length + 2]);
                  return $e(e4, l2, i5[2]);
                } : (e4) => $e(e4, l2));
                h4 = e3.some((e4) => e4.signedDistanceFromCamera <= 0) ? [] : e3.map((e4) => e4.point);
              }
              let g3 = [];
              if (h4.length > 0) {
                const t4 = h4[0].clone(), i5 = h4[0].clone();
                for (let e3 = 1; e3 < h4.length; e3++)
                  t4.x = Math.min(t4.x, h4[e3].x), t4.y = Math.min(t4.y, h4[e3].y), i5.x = Math.max(i5.x, h4[e3].x), i5.y = Math.max(i5.y, h4[e3].y);
                g3 = t4.x >= o3.x && i5.x <= r4.x && t4.y >= o3.y && i5.y <= r4.y ? [h4] : i5.x < o3.x || t4.x > r4.x || i5.y < o3.y || t4.y > r4.y ? [] : e2.clipLine([h4], o3.x, o3.y, r4.x, r4.y);
              }
              for (const e3 of g3) {
                n3.reset(e3, 0.25 * i4);
                let o4 = 0;
                o4 = n3.length <= 0.5 * i4 ? 1 : Math.ceil(n3.paddedLength / p3) + 1;
                for (let e4 = 0; e4 < o4; e4++) {
                  const r5 = e4 / Math.max(o4 - 1, 1), a4 = n3.lerp(r5), s6 = a4.x + st, l3 = a4.y + st;
                  m3.push(s6, l3, i4, 0);
                  const h5 = s6 - i4, _3 = l3 - i4, d3 = s6 + i4, p4 = l3 + i4;
                  if (D2 = D2 && this.isOffscreen(h5, _3, d3, p4), z2 = z2 || this.isInsideGrid(h5, _3, d3, p4), !t3 && this.grid.hitTestCircle(s6, l3, i4, u2) && (I2 = true, !c2))
                    return { circles: [], offscreen: false, collisionDetected: I2 };
                }
              }
            }
            return { circles: !c2 && I2 || !z2 ? [] : m3, offscreen: D2, collisionDetected: I2 };
          }
          queryRenderedSymbols(t3) {
            if (t3.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
              return {};
            const i3 = [];
            let o2 = 1 / 0, r3 = 1 / 0, n2 = -1 / 0, a2 = -1 / 0;
            for (const s5 of t3) {
              const t4 = new e2.pointGeometry(s5.x + st, s5.y + st);
              o2 = Math.min(o2, t4.x), r3 = Math.min(r3, t4.y), n2 = Math.max(n2, t4.x), a2 = Math.max(a2, t4.y), i3.push(t4);
            }
            const s4 = this.grid.query(o2, r3, n2, a2).concat(this.ignoredGrid.query(o2, r3, n2, a2)), l2 = {}, c2 = {};
            for (const t4 of s4) {
              const o3 = t4.key;
              if (l2[o3.bucketInstanceId] === void 0 && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                continue;
              const r4 = [new e2.pointGeometry(t4.x1, t4.y1), new e2.pointGeometry(t4.x2, t4.y1), new e2.pointGeometry(t4.x2, t4.y2), new e2.pointGeometry(t4.x1, t4.y2)];
              e2.polygonIntersectsPolygon(i3, r4) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, c2[o3.bucketInstanceId] === void 0 && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
            }
            return c2;
          }
          insertCollisionBox(e3, t3, i3, o2, r3) {
            (t3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i3, featureIndex: o2, collisionGroupID: r3 }, e3[0], e3[1], e3[2], e3[3]);
          }
          insertCollisionCircles(e3, t3, i3, o2, r3) {
            const n2 = t3 ? this.ignoredGrid : this.grid, a2 = { bucketInstanceId: i3, featureIndex: o2, collisionGroupID: r3 };
            for (let t4 = 0; t4 < e3.length; t4 += 4)
              n2.insertCircle(a2, e3[t4], e3[t4 + 1], e3[t4 + 2]);
          }
          projectAndGetPerspectiveRatio(t3, i3, o2, r3, n2) {
            const a2 = [i3, o2, r3 || 0, 1];
            let s4 = false;
            if (r3 || this.transform.pitch > 0) {
              e2.transformMat4$1(a2, a2, t3);
              let l2 = false;
              this.fogState && n2 && (l2 = function(t4, i4, o3, r4, n3, a3) {
                const s5 = a3.calculateFogTileMatrix(n3), l3 = [i4, o3, r4];
                return e2.transformMat4(l3, l3, s5), y(t4, l3, a3.pitch, a3._fov);
              }(this.fogState, i3, o2, r3 || 0, n2.toUnwrapped(), this.transform) > 0.9), s4 = a2[2] > a2[3] || l2;
            } else
              at(a2, a2, t3);
            return { point: new e2.pointGeometry((a2[0] / a2[3] + 1) / 2 * this.transform.width + st, (-a2[1] / a2[3] + 1) / 2 * this.transform.height + st), perspectiveRatio: Math.min(0.5 + this.transform.cameraToCenterDistance / a2[3] * 0.5, 1.5), signedDistanceFromCamera: a2[3], aboveHorizon: s4 };
          }
          isOffscreen(e3, t3, i3, o2) {
            return i3 < st || e3 >= this.screenRightBoundary || o2 < st || t3 > this.screenBottomBoundary;
          }
          isInsideGrid(e3, t3, i3, o2) {
            return i3 >= 0 && e3 < this.gridRightBoundary && o2 >= 0 && t3 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t3 = e2.identity([]);
            return e2.translate(t3, t3, [-100, -100, 0]), t3;
          }
        }
        class ct {
          constructor(e3, t3, i3, o2) {
            this.opacity = e3 ? Math.max(0, Math.min(1, e3.opacity + (e3.placed ? t3 : -t3))) : o2 && i3 ? 1 : 0, this.placed = i3;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class ht {
          constructor(e3, t3, i3, o2, r3, n2 = false) {
            this.text = new ct(e3 ? e3.text : null, t3, i3, r3), this.icon = new ct(e3 ? e3.icon : null, t3, o2, r3), this.clipped = n2;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class ut {
          constructor(e3, t3, i3, o2 = false) {
            this.text = e3, this.icon = t3, this.skipFade = i3, this.clipped = o2;
          }
        }
        class _t {
          constructor() {
            this.invProjMatrix = e2.create(), this.viewportMatrix = e2.create(), this.circles = [];
          }
        }
        class dt {
          constructor(e3, t3, i3, o2, r3) {
            this.bucketInstanceId = e3, this.featureIndex = t3, this.sourceLayerIndex = i3, this.bucketIndex = o2, this.tileID = r3;
          }
        }
        class pt {
          constructor(e3) {
            this.crossSourceCollisions = e3, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e3) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[e3]) {
              const t3 = ++this.maxGroupID;
              this.collisionGroups[e3] = { ID: t3, predicate: (e4) => e4.collisionGroupID === t3 };
            }
            return this.collisionGroups[e3];
          }
        }
        function mt(t3, i3, o2, r3, n2) {
          const { horizontalAlign: a2, verticalAlign: s4 } = e2.getAnchorAlignment(t3), l2 = -(a2 - 0.5) * i3, c2 = -(s4 - 0.5) * o2, h3 = e2.evaluateVariableOffset(t3, r3);
          return new e2.pointGeometry(l2 + h3[0] * n2, c2 + h3[1] * n2);
        }
        function ft(t3, i3, o2, r3, n2) {
          const a2 = new e2.pointGeometry(t3, i3);
          return o2 && a2._rotate(r3 ? n2 : -n2), a2;
        }
        class gt {
          constructor(e3, t3, i3, o2, r3) {
            this.transform = e3.clone(), this.collisionIndex = new lt(this.transform, r3), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t3, this.retainedQueryData = {}, this.collisionGroups = new pt(i3), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t3, i3, o2, r3) {
            const n2 = o2.getBucket(i3), a2 = o2.latestFeatureIndex;
            if (!n2 || !a2 || i3.id !== n2.layerIds[0])
              return;
            const s4 = n2.layers[0].layout, l2 = o2.collisionBoxArray, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h3 = o2.tileSize / e2.EXTENT, u2 = o2.tileID.toUnwrapped(), _2 = this.transform.calculateProjMatrix(u2), d2 = s4.get("text-pitch-alignment") === "map", p2 = s4.get("text-rotation-alignment") === "map";
            i3.compileFilter();
            const m3 = i3.dynamicFilter(), f4 = i3.dynamicFilterNeedsFeature(), g2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), v2 = qe(_2, o2.tileID.canonical, d2, p2, this.transform, g2);
            let x3 = null;
            if (d2) {
              const t4 = Xe(_2, o2.tileID.canonical, d2, p2, this.transform, g2);
              x3 = e2.multiply$1([], this.transform.labelPlaneMatrix, t4);
            }
            let y2 = null;
            m3 && o2.latestFeatureIndex && (y2 = { unwrappedTileID: u2, dynamicFilter: m3, dynamicFilterNeedsFeature: f4, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[n2.bucketInstanceId] = new dt(n2.bucketInstanceId, a2, n2.sourceLayerIndex, n2.index, o2.tileID);
            const b2 = { bucket: n2, layout: s4, posMatrix: _2, textLabelPlaneMatrix: v2, labelToScreenMatrix: x3, clippingData: y2, scale: c2, textPixelRatio: h3, holdingForFade: o2.holdingForFade(), collisionBoxArray: l2, partiallyEvaluatedTextSize: e2.evaluateSizeForZoom(n2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e2.evaluateSizeForZoom(n2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n2.sourceID) };
            if (r3)
              for (const e3 of n2.sortKeyRanges) {
                const { sortKey: i4, symbolInstanceStart: o3, symbolInstanceEnd: r4 } = e3;
                t3.push({ sortKey: i4, symbolInstanceStart: o3, symbolInstanceEnd: r4, parameters: b2 });
              }
            else
              t3.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: b2 });
          }
          attemptAnchorPlacement(e3, t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2, m3, f4, g2) {
            const v2 = [u2.textOffset0, u2.textOffset1], x3 = mt(e3, i3, o2, v2, r3), y2 = this.collisionIndex.placeCollisionBox(r3, t3, ft(x3.x, x3.y, n2, a2, this.transform.angle), h3, s4, l2, c2.predicate);
            if ((!m3 || this.collisionIndex.placeCollisionBox(d2.getSymbolInstanceIconSize(g2, this.transform.zoom, _2), m3, ft(x3.x, x3.y, n2, a2, this.transform.angle), h3, s4, l2, c2.predicate).box.length !== 0) && y2.box.length > 0) {
              let t4;
              return this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (t4 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), this.variableOffsets[u2.crossTileID] = { textOffset: v2, width: i3, height: o2, anchor: e3, textScale: r3, prevAnchor: t4 }, this.markUsedJustification(d2, e3, u2, p2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, p2, u2), this.placedOrientations[u2.crossTileID] = p2), { shift: x3, placedGlyphBoxes: y2 };
            }
          }
          placeLayerBucketPart(t3, i3, o2, r3) {
            const { bucket: n2, layout: a2, posMatrix: s4, textLabelPlaneMatrix: l2, labelToScreenMatrix: c2, clippingData: h3, textPixelRatio: u2, holdingForFade: _2, collisionBoxArray: d2, partiallyEvaluatedTextSize: p2, partiallyEvaluatedIconSize: m3, collisionGroup: f4 } = t3.parameters, g2 = a2.get("text-optional"), v2 = a2.get("icon-optional"), x3 = a2.get("text-allow-overlap"), y2 = a2.get("icon-allow-overlap"), b2 = a2.get("text-rotation-alignment") === "map", w2 = a2.get("text-pitch-alignment") === "map", T2 = a2.get("icon-text-fit") !== "none", E2 = a2.get("symbol-z-order") === "viewport-y", C2 = x3 && (y2 || !n2.hasIconData() || v2), M2 = y2 && (x3 || !n2.hasTextData() || g2);
            !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2), o2 && r3 && n2.updateCollisionDebugBuffers(this.transform.zoom, d2);
            const S3 = (t4, r4, d3) => {
              if (h3) {
                const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                let r5 = null;
                if (h3.dynamicFilterNeedsFeature) {
                  const e3 = this.retainedQueryData[n2.bucketInstanceId];
                  r5 = h3.featureIndex.loadFeature({ featureIndex: t4.featureIndex, bucketIndex: e3.bucketIndex, sourceLayerIndex: e3.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (!(0, h3.dynamicFilter)(o3, r5, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new e2.pointGeometry(t4.tileAnchorX, t4.tileAnchorY), this.transform.calculateDistanceTileData(h3.unwrappedTileID)))
                  return this.placements[t4.crossTileID] = new ut(false, false, false, true), void (i3[t4.crossTileID] = true);
              }
              if (i3[t4.crossTileID])
                return;
              if (_2)
                return void (this.placements[t4.crossTileID] = new ut(false, false, false));
              let E3 = false, S4 = false, I2 = true, z2 = null, D2 = { box: null, offscreen: null }, P2 = { box: null, offscreen: null }, A3 = null, L2 = null, R2 = null, k2 = 0, O2 = 0, B2 = 0;
              d3.textFeatureIndex ? k2 = d3.textFeatureIndex : t4.useRuntimeCollisionCircles && (k2 = t4.featureIndex), d3.verticalTextFeatureIndex && (O2 = d3.verticalTextFeatureIndex);
              const F3 = (e3) => {
                e3.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID, (this.transform.elevation || e3.elevation) && (e3.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[n2.bucketInstanceId].tileID, e3.tileAnchorX, e3.tileAnchorY) : 0);
              }, U2 = d3.textBox;
              if (U2) {
                F3(U2);
                const i4 = (i5) => {
                  let o4 = e2.WritingMode.horizontal;
                  if (n2.allowVerticalPlacement && !i5 && this.prevPlacement) {
                    const e3 = this.prevPlacement.placedOrientations[t4.crossTileID];
                    e3 && (this.placedOrientations[t4.crossTileID] = e3, o4 = e3, this.markUsedOrientation(n2, o4, t4));
                  }
                  return o4;
                }, o3 = (i5, o4) => {
                  if (n2.allowVerticalPlacement && t4.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
                    for (const t5 of n2.writingModes)
                      if (t5 === e2.WritingMode.vertical ? (D2 = o4(), P2 = D2) : D2 = i5(), D2 && D2.box && D2.box.length)
                        break;
                  } else
                    D2 = i5();
                };
                if (a2.get("text-variable-anchor")) {
                  let l3 = a2.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[t4.crossTileID]) {
                    const e3 = this.prevPlacement.variableOffsets[t4.crossTileID];
                    l3.indexOf(e3.anchor) > 0 && (l3 = l3.filter((t5) => t5 !== e3.anchor), l3.unshift(e3.anchor));
                  }
                  const c3 = (e3, i5, o4) => {
                    const a3 = n2.getSymbolInstanceTextSize(p2, t4, this.transform.zoom, r4), c4 = (e3.x2 - e3.x1) * a3 + 2 * e3.padding, h5 = (e3.y2 - e3.y1) * a3 + 2 * e3.padding, _3 = T2 && !y2 ? i5 : null;
                    _3 && F3(_3);
                    let d4 = { box: [], offscreen: false };
                    const g3 = x3 ? 2 * l3.length : l3.length;
                    for (let i6 = 0; i6 < g3; ++i6) {
                      const g4 = this.attemptAnchorPlacement(l3[i6 % l3.length], e3, c4, h5, a3, b2, w2, u2, s4, f4, i6 >= l3.length, t4, r4, n2, o4, _3, p2, m3);
                      if (g4 && (d4 = g4.placedGlyphBoxes, d4 && d4.box && d4.box.length)) {
                        E3 = true, z2 = g4.shift;
                        break;
                      }
                    }
                    return d4;
                  };
                  o3(() => c3(U2, d3.iconBox, e2.WritingMode.horizontal), () => {
                    const i5 = d3.verticalTextBox;
                    return i5 && F3(i5), n2.allowVerticalPlacement && !(D2 && D2.box && D2.box.length) && t4.numVerticalGlyphVertices > 0 && i5 ? c3(i5, d3.verticalIconBox, e2.WritingMode.vertical) : { box: null, offscreen: null };
                  }), D2 && (E3 = D2.box, I2 = D2.offscreen);
                  const h4 = i4(D2 && D2.box);
                  if (!E3 && this.prevPlacement) {
                    const e3 = this.prevPlacement.variableOffsets[t4.crossTileID];
                    e3 && (this.variableOffsets[t4.crossTileID] = e3, this.markUsedJustification(n2, e3.anchor, t4, h4));
                  }
                } else {
                  const a3 = (i5, o4) => {
                    const a4 = n2.getSymbolInstanceTextSize(p2, t4, this.transform.zoom, r4), l3 = this.collisionIndex.placeCollisionBox(a4, i5, new e2.pointGeometry(0, 0), x3, u2, s4, f4.predicate);
                    return l3 && l3.box && l3.box.length && (this.markUsedOrientation(n2, o4, t4), this.placedOrientations[t4.crossTileID] = o4), l3;
                  };
                  o3(() => a3(U2, e2.WritingMode.horizontal), () => {
                    const i5 = d3.verticalTextBox;
                    return n2.allowVerticalPlacement && t4.numVerticalGlyphVertices > 0 && i5 ? (F3(i5), a3(i5, e2.WritingMode.vertical)) : { box: null, offscreen: null };
                  }), i4(D2 && D2.box && D2.box.length);
                }
              }
              if (A3 = D2, E3 = A3 && A3.box && A3.box.length > 0, I2 = A3 && A3.offscreen, t4.useRuntimeCollisionCircles) {
                const i4 = n2.text.placedSymbolArray.get(t4.centerJustifiedTextSymbolIndex >= 0 ? t4.centerJustifiedTextSymbolIndex : t4.verticalPlacedTextSymbolIndex), r5 = e2.evaluateSizeForFeature(n2.textSizeData, p2, i4), h4 = a2.get("text-padding");
                L2 = this.collisionIndex.placeCollisionCircles(x3, i4, n2.lineVertexArray, n2.glyphOffsetArray, r5, s4, l2, c2, o2, w2, f4.predicate, t4.collisionCircleDiameter * r5 / e2.ONE_EM, h4, this.retainedQueryData[n2.bucketInstanceId].tileID), E3 = x3 || L2.circles.length > 0 && !L2.collisionDetected, I2 = I2 && L2.offscreen;
              }
              if (d3.iconFeatureIndex && (B2 = d3.iconFeatureIndex), d3.iconBox) {
                const t5 = (t6) => {
                  F3(t6);
                  const i4 = T2 && z2 ? ft(z2.x, z2.y, b2, w2, this.transform.angle) : new e2.pointGeometry(0, 0), o3 = n2.getSymbolInstanceIconSize(m3, this.transform.zoom, r4);
                  return this.collisionIndex.placeCollisionBox(o3, t6, i4, y2, u2, s4, f4.predicate);
                };
                P2 && P2.box && P2.box.length && d3.verticalIconBox ? (R2 = t5(d3.verticalIconBox), S4 = R2.box.length > 0) : (R2 = t5(d3.iconBox), S4 = R2.box.length > 0), I2 = I2 && R2.offscreen;
              }
              const N2 = g2 || t4.numHorizontalGlyphVertices === 0 && t4.numVerticalGlyphVertices === 0, G2 = v2 || t4.numIconVertices === 0;
              if (N2 || G2 ? G2 ? N2 || (S4 = S4 && E3) : E3 = S4 && E3 : S4 = E3 = S4 && E3, E3 && A3 && A3.box && this.collisionIndex.insertCollisionBox(A3.box, a2.get("text-ignore-placement"), n2.bucketInstanceId, P2 && P2.box && O2 ? O2 : k2, f4.ID), S4 && R2 && this.collisionIndex.insertCollisionBox(R2.box, a2.get("icon-ignore-placement"), n2.bucketInstanceId, B2, f4.ID), L2 && (E3 && this.collisionIndex.insertCollisionCircles(L2.circles, a2.get("text-ignore-placement"), n2.bucketInstanceId, k2, f4.ID), o2)) {
                const e3 = n2.bucketInstanceId;
                let t5 = this.collisionCircleArrays[e3];
                t5 === void 0 && (t5 = this.collisionCircleArrays[e3] = new _t());
                for (let e4 = 0; e4 < L2.circles.length; e4 += 4)
                  t5.circles.push(L2.circles[e4 + 0]), t5.circles.push(L2.circles[e4 + 1]), t5.circles.push(L2.circles[e4 + 2]), t5.circles.push(L2.collisionDetected ? 1 : 0);
              }
              this.placements[t4.crossTileID] = new ut(E3 || C2, S4 || M2, I2 || n2.justReloaded), i3[t4.crossTileID] = true;
            };
            if (E2) {
              const e3 = n2.getSortedSymbolIndexes(this.transform.angle);
              for (let t4 = e3.length - 1; t4 >= 0; --t4) {
                const i4 = e3[t4];
                S3(n2.symbolInstances.get(i4), i4, n2.collisionArrays[i4]);
              }
            } else
              for (let e3 = t3.symbolInstanceStart; e3 < t3.symbolInstanceEnd; e3++)
                S3(n2.symbolInstances.get(e3), e3, n2.collisionArrays[e3]);
            if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
              const t4 = this.collisionCircleArrays[n2.bucketInstanceId];
              e2.invert(t4.invProjMatrix, s4), t4.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            n2.justReloaded = false;
          }
          markUsedJustification(t3, i3, o2, r3) {
            let n2;
            n2 = r3 === e2.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[e2.getAnchorJustification(i3)];
            const a2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
            for (const e3 of a2)
              e3 >= 0 && (t3.text.placedSymbolArray.get(e3).crossTileID = n2 >= 0 && e3 !== n2 ? 0 : o2.crossTileID);
          }
          markUsedOrientation(t3, i3, o2) {
            const r3 = i3 === e2.WritingMode.horizontal || i3 === e2.WritingMode.horizontalOnly ? i3 : 0, n2 = i3 === e2.WritingMode.vertical ? i3 : 0, a2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
            for (const e3 of a2)
              t3.text.placedSymbolArray.get(e3).placedOrientation = r3;
            o2.verticalPlacedTextSymbolIndex && (t3.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = n2);
          }
          commit(e3) {
            this.commitTime = e3, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t3 = this.prevPlacement;
            let i3 = false;
            this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
            const o2 = t3 ? t3.symbolFadeChange(e3) : 1, r3 = t3 ? t3.opacities : {}, n2 = t3 ? t3.variableOffsets : {}, a2 = t3 ? t3.placedOrientations : {};
            for (const e4 in this.placements) {
              const t4 = this.placements[e4], n3 = r3[e4];
              n3 ? (this.opacities[e4] = new ht(n3, o2, t4.text, t4.icon, null, t4.clipped), i3 = i3 || t4.text !== n3.text.placed || t4.icon !== n3.icon.placed) : (this.opacities[e4] = new ht(null, o2, t4.text, t4.icon, t4.skipFade, t4.clipped), i3 = i3 || t4.text || t4.icon);
            }
            for (const e4 in r3) {
              const t4 = r3[e4];
              if (!this.opacities[e4]) {
                const r4 = new ht(t4, o2, false, false);
                r4.isHidden() || (this.opacities[e4] = r4, i3 = i3 || t4.text.placed || t4.icon.placed);
              }
            }
            for (const e4 in n2)
              this.variableOffsets[e4] || !this.opacities[e4] || this.opacities[e4].isHidden() || (this.variableOffsets[e4] = n2[e4]);
            for (const e4 in a2)
              this.placedOrientations[e4] || !this.opacities[e4] || this.opacities[e4].isHidden() || (this.placedOrientations[e4] = a2[e4]);
            i3 ? this.lastPlacementChangeTime = e3 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e3);
          }
          updateLayerOpacities(e3, t3) {
            const i3 = {};
            for (const o2 of t3) {
              const t4 = o2.getBucket(e3);
              t4 && o2.latestFeatureIndex && e3.id === t4.layerIds[0] && this.updateBucketOpacities(t4, i3, o2.collisionBoxArray);
            }
          }
          updateBucketOpacities(t3, i3, o2) {
            t3.hasTextData() && t3.text.opacityVertexArray.clear(), t3.hasIconData() && t3.icon.opacityVertexArray.clear(), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexArray.clear(), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexArray.clear();
            const r3 = t3.layers[0].layout, n2 = !!t3.layers[0].dynamicFilter(), a2 = new ht(null, 0, false, false, true), s4 = r3.get("text-allow-overlap"), l2 = r3.get("icon-allow-overlap"), c2 = r3.get("text-variable-anchor"), h3 = r3.get("text-rotation-alignment") === "map", u2 = r3.get("text-pitch-alignment") === "map", _2 = r3.get("icon-text-fit") !== "none", d2 = new ht(null, 0, s4 && (l2 || !t3.hasIconData() || r3.get("icon-optional")), l2 && (s4 || !t3.hasTextData() || r3.get("text-optional")), true);
            !t3.collisionArrays && o2 && (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) && t3.deserializeCollisionBoxes(o2);
            const p2 = (e3, t4, i4) => {
              for (let o3 = 0; o3 < t4 / 4; o3++)
                e3.opacityVertexArray.emplaceBack(i4);
            };
            let m3 = 0;
            for (let o3 = 0; o3 < t3.symbolInstances.length; o3++) {
              const r4 = t3.symbolInstances.get(o3), { numHorizontalGlyphVertices: s5, numVerticalGlyphVertices: l3, crossTileID: f4 } = r4;
              let g2 = this.opacities[f4];
              i3[f4] ? g2 = a2 : g2 || (g2 = d2, this.opacities[f4] = g2), i3[f4] = true;
              const v2 = s5 > 0 || l3 > 0, x3 = r4.numIconVertices > 0, y2 = this.placedOrientations[r4.crossTileID], b2 = y2 === e2.WritingMode.vertical, w2 = y2 === e2.WritingMode.horizontal || y2 === e2.WritingMode.horizontalOnly;
              if (!v2 && !x3 || g2.isHidden() || m3++, v2) {
                const e3 = Mt(g2.text);
                p2(t3.text, s5, b2 ? St : e3), p2(t3.text, l3, w2 ? St : e3);
                const i4 = g2.text.isHidden();
                [r4.rightJustifiedTextSymbolIndex, r4.centerJustifiedTextSymbolIndex, r4.leftJustifiedTextSymbolIndex].forEach((e4) => {
                  e4 >= 0 && (t3.text.placedSymbolArray.get(e4).hidden = i4 || b2 ? 1 : 0);
                }), r4.verticalPlacedTextSymbolIndex >= 0 && (t3.text.placedSymbolArray.get(r4.verticalPlacedTextSymbolIndex).hidden = i4 || w2 ? 1 : 0);
                const o4 = this.variableOffsets[r4.crossTileID];
                o4 && this.markUsedJustification(t3, o4.anchor, r4, y2);
                const n3 = this.placedOrientations[r4.crossTileID];
                n3 && (this.markUsedJustification(t3, "left", r4, n3), this.markUsedOrientation(t3, n3, r4));
              }
              if (x3) {
                const e3 = Mt(g2.icon);
                r4.placedIconSymbolIndex >= 0 && (p2(t3.icon, r4.numIconVertices, b2 ? St : e3), t3.icon.placedSymbolArray.get(r4.placedIconSymbolIndex).hidden = g2.icon.isHidden()), r4.verticalPlacedIconSymbolIndex >= 0 && (p2(t3.icon, r4.numVerticalIconVertices, w2 ? St : e3), t3.icon.placedSymbolArray.get(r4.verticalPlacedIconSymbolIndex).hidden = g2.icon.isHidden());
              }
              if (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) {
                const i4 = t3.collisionArrays[o3];
                if (i4) {
                  let o4 = new e2.pointGeometry(0, 0), r5 = true;
                  if (i4.textBox || i4.verticalTextBox) {
                    if (c2) {
                      const e3 = this.variableOffsets[f4];
                      e3 ? (o4 = mt(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textScale), h3 && o4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : r5 = false;
                    }
                    n2 && (r5 = !g2.clipped), i4.textBox && vt(t3.textCollisionBox.collisionVertexArray, g2.text.placed, !r5 || b2, o4.x, o4.y), i4.verticalTextBox && vt(t3.textCollisionBox.collisionVertexArray, g2.text.placed, !r5 || w2, o4.x, o4.y);
                  }
                  const a3 = r5 && Boolean(!w2 && i4.verticalIconBox);
                  i4.iconBox && vt(t3.iconCollisionBox.collisionVertexArray, g2.icon.placed, a3, _2 ? o4.x : 0, _2 ? o4.y : 0), i4.verticalIconBox && vt(t3.iconCollisionBox.collisionVertexArray, g2.icon.placed, !a3, _2 ? o4.x : 0, _2 ? o4.y : 0);
                }
              }
            }
            if (t3.fullyClipped = m3 === 0, t3.sortFeatures(this.transform.angle), this.retainedQueryData[t3.bucketInstanceId] && (this.retainedQueryData[t3.bucketInstanceId].featureSortOrder = t3.featureSortOrder), t3.hasTextData() && t3.text.opacityVertexBuffer && t3.text.opacityVertexBuffer.updateData(t3.text.opacityVertexArray), t3.hasIconData() && t3.icon.opacityVertexBuffer && t3.icon.opacityVertexBuffer.updateData(t3.icon.opacityVertexArray), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexBuffer && t3.iconCollisionBox.collisionVertexBuffer.updateData(t3.iconCollisionBox.collisionVertexArray), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexBuffer && t3.textCollisionBox.collisionVertexBuffer.updateData(t3.textCollisionBox.collisionVertexArray), t3.bucketInstanceId in this.collisionCircleArrays) {
              const e3 = this.collisionCircleArrays[t3.bucketInstanceId];
              t3.placementInvProjMatrix = e3.invProjMatrix, t3.placementViewportMatrix = e3.viewportMatrix, t3.collisionCircleArray = e3.circles, delete this.collisionCircleArrays[t3.bucketInstanceId];
            }
          }
          symbolFadeChange(e3) {
            return this.fadeDuration === 0 ? 1 : (e3 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e3) {
            return Math.max(0, (this.transform.zoom - e3) / 1.5);
          }
          hasTransitions(e3) {
            return this.stale || e3 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e3, t3) {
            const i3 = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
            return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * i3 > e3;
          }
          setStale() {
            this.stale = true;
          }
        }
        function vt(e3, t3, i3, o2, r3) {
          e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r3 || 0), e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r3 || 0), e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r3 || 0), e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r3 || 0);
        }
        const xt = Math.pow(2, 25), yt = Math.pow(2, 24), bt = Math.pow(2, 17), wt = Math.pow(2, 16), Tt = Math.pow(2, 9), Et = Math.pow(2, 8), Ct = Math.pow(2, 1);
        function Mt(e3) {
          if (e3.opacity === 0 && !e3.placed)
            return 0;
          if (e3.opacity === 1 && e3.placed)
            return 4294967295;
          const t3 = e3.placed ? 1 : 0, i3 = Math.floor(127 * e3.opacity);
          return i3 * xt + t3 * yt + i3 * bt + t3 * wt + i3 * Tt + t3 * Et + i3 * Ct + t3;
        }
        const St = 0;
        class It {
          constructor(e3) {
            this._sortAcrossTiles = e3.layout.get("symbol-z-order") !== "viewport-y" && e3.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e3, t3, i3, o2, r3) {
            const n2 = this._bucketParts;
            for (; this._currentTileIndex < e3.length; )
              if (t3.getBucketParts(n2, o2, e3[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r3())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e4, t4) => e4.sortKey - t4.sortKey)); this._currentPartIndex < n2.length; ) {
              const e4 = n2[this._currentPartIndex];
              if (t3.placeLayerBucketPart(e4, this._seenCrossTileIDs, i3, e4.symbolInstanceStart === 0), this._currentPartIndex++, r3())
                return true;
            }
            return false;
          }
        }
        class zt {
          constructor(e3, t3, i3, o2, r3, n2, a2, s4) {
            this.placement = new gt(e3, r3, n2, a2, s4), this._currentPlacementIndex = t3.length - 1, this._forceFullPlacement = i3, this._showCollisionBoxes = o2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t3, i3, o2) {
            const r3 = e2.exported.now(), n2 = () => {
              const t4 = e2.exported.now() - r3;
              return !this._forceFullPlacement && t4 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const e3 = i3[t3[this._currentPlacementIndex]], r4 = this.placement.collisionIndex.transform.zoom;
              if (e3.type === "symbol" && (!e3.minzoom || e3.minzoom <= r4) && (!e3.maxzoom || e3.maxzoom > r4)) {
                if (this._inProgressLayer || (this._inProgressLayer = new It(e3)), this._inProgressLayer.continuePlacement(o2[e3.source], this.placement, this._showCollisionBoxes, e3, n2))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e3) {
            return this.placement.commit(e3), this.placement;
          }
        }
        const Dt = 512 / e2.EXTENT / 2;
        class Pt {
          constructor(e3, t3, i3) {
            this.tileID = e3, this.indexedSymbolInstances = {}, this.bucketInstanceId = i3;
            for (let i4 = 0; i4 < t3.length; i4++) {
              const o2 = t3.get(i4), r3 = o2.key;
              this.indexedSymbolInstances[r3] || (this.indexedSymbolInstances[r3] = []), this.indexedSymbolInstances[r3].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, e3) });
            }
          }
          getScaledCoordinates(t3, i3) {
            const o2 = Dt / Math.pow(2, i3.canonical.z - this.tileID.canonical.z);
            return { x: Math.floor((i3.canonical.x * e2.EXTENT + t3.tileAnchorX) * o2), y: Math.floor((i3.canonical.y * e2.EXTENT + t3.tileAnchorY) * o2) };
          }
          findMatches(e3, t3, i3) {
            const o2 = this.tileID.canonical.z < t3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t3.canonical.z);
            for (let r3 = 0; r3 < e3.length; r3++) {
              const n2 = e3.get(r3);
              if (n2.crossTileID)
                continue;
              const a2 = this.indexedSymbolInstances[n2.key];
              if (!a2)
                continue;
              const s4 = this.getScaledCoordinates(n2, t3);
              for (const e4 of a2)
                if (Math.abs(e4.coord.x - s4.x) <= o2 && Math.abs(e4.coord.y - s4.y) <= o2 && !i3[e4.crossTileID]) {
                  i3[e4.crossTileID] = true, n2.crossTileID = e4.crossTileID;
                  break;
                }
            }
          }
        }
        class At {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Lt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e3) {
            const t3 = Math.round((e3 - this.lng) / 360);
            if (t3 !== 0)
              for (const e4 in this.indexes) {
                const i3 = this.indexes[e4], o2 = {};
                for (const e5 in i3) {
                  const r3 = i3[e5];
                  r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + t3), o2[r3.tileID.key] = r3;
                }
                this.indexes[e4] = o2;
              }
            this.lng = e3;
          }
          addBucket(e3, t3, i3) {
            if (this.indexes[e3.overscaledZ] && this.indexes[e3.overscaledZ][e3.key]) {
              if (this.indexes[e3.overscaledZ][e3.key].bucketInstanceId === t3.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(e3.overscaledZ, this.indexes[e3.overscaledZ][e3.key]);
            }
            for (let e4 = 0; e4 < t3.symbolInstances.length; e4++)
              t3.symbolInstances.get(e4).crossTileID = 0;
            this.usedCrossTileIDs[e3.overscaledZ] || (this.usedCrossTileIDs[e3.overscaledZ] = {});
            const o2 = this.usedCrossTileIDs[e3.overscaledZ];
            for (const i4 in this.indexes) {
              const r3 = this.indexes[i4];
              if (Number(i4) > e3.overscaledZ)
                for (const i5 in r3) {
                  const n2 = r3[i5];
                  n2.tileID.isChildOf(e3) && n2.findMatches(t3.symbolInstances, e3, o2);
                }
              else {
                const n2 = r3[e3.scaledTo(Number(i4)).key];
                n2 && n2.findMatches(t3.symbolInstances, e3, o2);
              }
            }
            for (let e4 = 0; e4 < t3.symbolInstances.length; e4++) {
              const r3 = t3.symbolInstances.get(e4);
              r3.crossTileID || (r3.crossTileID = i3.generate(), o2[r3.crossTileID] = true);
            }
            return this.indexes[e3.overscaledZ] === void 0 && (this.indexes[e3.overscaledZ] = {}), this.indexes[e3.overscaledZ][e3.key] = new Pt(e3, t3.symbolInstances, t3.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e3, t3) {
            for (const i3 in t3.indexedSymbolInstances)
              for (const o2 of t3.indexedSymbolInstances[i3])
                delete this.usedCrossTileIDs[e3][o2.crossTileID];
          }
          removeStaleBuckets(e3) {
            let t3 = false;
            for (const i3 in this.indexes) {
              const o2 = this.indexes[i3];
              for (const r3 in o2)
                e3[o2[r3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, o2[r3]), delete o2[r3], t3 = true);
            }
            return t3;
          }
        }
        class Rt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new At(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e3, t3, i3, o2) {
            let r3 = this.layerIndexes[e3.id];
            r3 === void 0 && (r3 = this.layerIndexes[e3.id] = new Lt());
            let n2 = false;
            const a2 = {};
            o2.name !== "globe" && r3.handleWrapJump(i3);
            for (const i4 of t3) {
              const t4 = i4.getBucket(e3);
              t4 && e3.id === t4.layerIds[0] && (t4.bucketInstanceId || (t4.bucketInstanceId = ++this.maxBucketInstanceId), r3.addBucket(i4.tileID, t4, this.crossTileIDs) && (n2 = true), a2[t4.bucketInstanceId] = true);
            }
            return r3.removeStaleBuckets(a2) && (n2 = true), n2;
          }
          pruneUnusedLayers(e3) {
            const t3 = {};
            e3.forEach((e4) => {
              t3[e4] = true;
            });
            for (const e4 in this.layerIndexes)
              t3[e4] || delete this.layerIndexes[e4];
          }
        }
        const kt = (t3, i3) => e2.emitValidationErrors(t3, i3 && i3.filter((e3) => e3.identifier !== "source.canvas")), Ot = e2.pick(ke, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), Bt = e2.pick(ke, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ft = function() {
          const t3 = {}, i3 = e2.spec.$version;
          for (const o2 in e2.spec.$root) {
            const r3 = e2.spec.$root[o2];
            if (r3.required) {
              let e3 = null;
              e3 = o2 === "version" ? i3 : r3.type === "array" ? [] : {}, e3 != null && (t3[o2] = e3);
            }
          }
          return t3;
        }(), Ut = { fill: true, line: true, background: true, hillshade: true, raster: true };
        class Nt extends e2.Evented {
          constructor(t3, i3 = {}) {
            super(), this.map = t3, this.dispatcher = new C(Ae(), this), this.imageManager = new d(), this.imageManager.setEventedParent(this), this.glyphManager = new e2.GlyphManager(t3._requestManager, i3.localFontFamily ? e2.LocalGlyphMode.all : i3.localIdeographFontFamily ? e2.LocalGlyphMode.ideographs : e2.LocalGlyphMode.none, i3.localFontFamily || i3.localIdeographFontFamily), this.lineAtlas = new e2.LineAtlas(256, 512), this.crossTileSymbolIndex = new Rt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new e2.ZoomHistory(), this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e2.getReferrer());
            const o2 = this;
            this._rtlTextPluginCallback = Nt.registerForPluginStateChange((t4) => {
              o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t4.pluginStatus, pluginURL: t4.pluginURL }, (t5, i4) => {
                if (e2.triggerPluginCompletionEvent(t5), i4 && i4.every((e3) => e3))
                  for (const e3 in o2._sourceCaches) {
                    const t6 = o2._sourceCaches[e3], i5 = t6.getSource().type;
                    i5 !== "vector" && i5 !== "geojson" || t6.reload();
                  }
              });
            }), this.on("data", (e3) => {
              if (e3.dataType !== "source" || e3.sourceDataType !== "metadata")
                return;
              const t4 = this.getSource(e3.sourceId);
              if (t4 && t4.vectorLayerIds)
                for (const e4 in this._layers) {
                  const i4 = this._layers[e4];
                  i4.source === t4.id && this._validateLayer(i4);
                }
            });
          }
          loadURL(t3, i3 = {}) {
            this.fire(new e2.Event("dataloading", { dataType: "style" }));
            const o2 = typeof i3.validate == "boolean" ? i3.validate : !e2.isMapboxURL(t3);
            t3 = this.map._requestManager.normalizeStyleURL(t3, i3.accessToken);
            const r3 = this.map._requestManager.transformRequest(t3, e2.ResourceType.Style);
            this._request = e2.getJSON(r3, (t4, i4) => {
              this._request = null, t4 ? this.fire(new e2.ErrorEvent(t4)) : i4 && this._load(i4, o2);
            });
          }
          loadJSON(t3, i3 = {}) {
            this.fire(new e2.Event("dataloading", { dataType: "style" })), this._request = e2.exported.frame(() => {
              this._request = null, this._load(t3, i3.validate !== false);
            });
          }
          loadEmpty() {
            this.fire(new e2.Event("dataloading", { dataType: "style" })), this._load(Ft, false);
          }
          _updateLayerCount(e3, t3) {
            const i3 = t3 ? 1 : -1;
            e3.is3D() && (this._num3DLayers += i3), e3.type === "circle" && (this._numCircleLayers += i3), e3.type === "symbol" && (this._numSymbolLayers += i3);
          }
          _load(t3, i3) {
            if (i3 && kt(this, e2.validateStyle(t3)))
              return;
            this._loaded = true, this.stylesheet = t3, this.updateProjection();
            for (const e3 in t3.sources)
              this.addSource(e3, t3.sources[e3], { validate: false });
            this._changed = false, t3.sprite ? this._loadSprite(t3.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t3.glyphs);
            const o2 = Re(this.stylesheet.layers);
            this._order = o2.map((e3) => e3.id), this._layers = {}, this._serializedLayers = {};
            for (let t4 of o2)
              t4 = e2.createStyleLayer(t4), t4.setEventedParent(this, { layer: { id: t4.id } }), this._layers[t4.id] = t4, this._serializedLayers[t4.id] = t4.serialize(), this._updateLayerCount(t4, true);
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new f3(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e2.Event("data", { dataType: "style" })), this.fire(new e2.Event("style.load"));
          }
          terrainSetForDrapingOnly() {
            return this.terrain && this.terrain.drapeRenderMode === 0;
          }
          setProjection(e3) {
            e3 ? this.stylesheet.projection = e3 : delete this.stylesheet.projection, this.updateProjection();
          }
          updateProjection() {
            const e3 = this.map.transform.projection, t3 = this.map.transform.setProjection(this.map._runtimeProjection || (this.stylesheet ? this.stylesheet.projection : void 0)), i3 = this.map.transform.projection;
            if (this._loaded && (i3.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null)), this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), t3) {
              if (i3.isReprojectedInTileSpace || e3.isReprojectedInTileSpace) {
                this.map.painter.clearBackgroundTiles();
                for (const e4 in this._sourceCaches)
                  this._sourceCaches[e4].clearTiles();
              } else
                this._forceSymbolLayerUpdate();
              this.map._update(true);
            }
          }
          _loadSprite(t3) {
            this._spriteRequest = function(t4, i3, o2) {
              let r3, n2, a2;
              const s4 = e2.exported.devicePixelRatio > 1 ? "@2x" : "";
              let l2 = e2.getJSON(i3.transformRequest(i3.normalizeSpriteURL(t4, s4, ".json"), e2.ResourceType.SpriteJSON), (e3, t5) => {
                l2 = null, a2 || (a2 = e3, r3 = t5, h3());
              }), c2 = e2.getImage(i3.transformRequest(i3.normalizeSpriteURL(t4, s4, ".png"), e2.ResourceType.SpriteImage), (e3, t5) => {
                c2 = null, a2 || (a2 = e3, n2 = t5, h3());
              });
              function h3() {
                if (a2)
                  o2(a2);
                else if (r3 && n2) {
                  const t5 = e2.exported.getImageData(n2), i4 = {};
                  for (const o3 in r3) {
                    const { width: n3, height: a3, x: s5, y: l3, sdf: c3, pixelRatio: h4, stretchX: u2, stretchY: _2, content: d2 } = r3[o3], p2 = new e2.RGBAImage({ width: n3, height: a3 });
                    e2.RGBAImage.copy(t5, p2, { x: s5, y: l3 }, { x: 0, y: 0 }, { width: n3, height: a3 }), i4[o3] = { data: p2, pixelRatio: h4, sdf: c3, stretchX: u2, stretchY: _2, content: d2 };
                  }
                  o2(null, i4);
                }
              }
              return { cancel() {
                l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
              } };
            }(t3, this.map._requestManager, (t4, i3) => {
              if (this._spriteRequest = null, t4)
                this.fire(new e2.ErrorEvent(t4));
              else if (i3)
                for (const e3 in i3)
                  this.imageManager.addImage(e3, i3[e3]);
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e2.Event("data", { dataType: "style" }));
            });
          }
          _validateLayer(t3) {
            const i3 = this.getSource(t3.source);
            if (!i3)
              return;
            const o2 = t3.sourceLayer;
            o2 && (i3.type === "geojson" || i3.vectorLayerIds && i3.vectorLayerIds.indexOf(o2) === -1) && this.fire(new e2.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i3.id}" as specified by style layer "${t3.id}"`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const e3 in this._sourceCaches)
              if (!this._sourceCaches[e3].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeLayers(e3) {
            const t3 = [];
            for (const i3 of e3) {
              const e4 = this._layers[i3];
              e4.type !== "custom" && t3.push(e4.serialize());
            }
            return t3;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            if (this.fog && this.fog.hasTransition())
              return true;
            for (const e3 in this._sourceCaches)
              if (this._sourceCaches[e3].hasTransition())
                return true;
            for (const e3 in this._layers)
              if (this._layers[e3].hasTransition())
                return true;
            return false;
          }
          get order() {
            return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
          }
          isLayerDraped(e3) {
            return !!this.terrain && Ut[e3.type];
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading");
          }
          update(t3) {
            if (!this._loaded)
              return;
            const i3 = this._changed;
            if (this._changed) {
              const e3 = Object.keys(this._updatedLayers), i4 = Object.keys(this._removedLayers);
              (e3.length || i4.length) && this._updateWorkerLayers(e3, i4);
              for (const e4 in this._updatedSources) {
                const t4 = this._updatedSources[e4];
                t4 === "reload" ? this._reloadSource(e4) : t4 === "clear" && this._clearSource(e4);
              }
              this._updateTilesForChangedImages();
              for (const e4 in this._updatedPaintProps)
                this._layers[e4].updateTransitions(t3);
              this.light.updateTransitions(t3), this.fog && this.fog.updateTransitions(t3), this._resetUpdates();
            }
            const o2 = {};
            for (const e3 in this._sourceCaches) {
              const t4 = this._sourceCaches[e3];
              o2[e3] = t4.used, t4.used = false;
            }
            for (const e3 of this._order) {
              const i4 = this._layers[e3];
              if (i4.recalculate(t3, this._availableImages), !i4.isHidden(t3.zoom)) {
                const e4 = this._getLayerSourceCache(i4);
                e4 && (e4.used = true);
              }
              const o3 = this.map.painter;
              if (o3) {
                const e4 = i4.getProgramIds();
                if (!e4)
                  continue;
                const r3 = i4.getProgramConfiguration(t3.zoom);
                for (const t4 of e4)
                  o3.useProgram(t4, r3);
              }
            }
            for (const t4 in o2) {
              const i4 = this._sourceCaches[t4];
              o2[t4] !== i4.used && i4.getSource().fire(new e2.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i4.getSource().id }));
            }
            this.light.recalculate(t3), this.terrain && this.terrain.recalculate(t3), this.fog && this.fog.recalculate(t3), this.z = t3.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i3 && this.fire(new e2.Event("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e3 = Object.keys(this._changedImages);
            if (e3.length) {
              for (const t3 in this._sourceCaches)
                this._sourceCaches[t3].reloadTilesForDependencies(["icons", "patterns"], e3);
              this._changedImages = {};
            }
          }
          _updateWorkerLayers(e3, t3) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e3), removedIds: t3 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }
          setState(t3) {
            if (this._checkLoaded(), kt(this, e2.validateStyle(t3)))
              return false;
            (t3 = e2.clone$1(t3)).layers = Re(t3.layers);
            const i3 = function(e3, t4) {
              if (!e3)
                return [{ command: ke.setStyle, args: [t4] }];
              let i4 = [];
              try {
                if (!n(e3.version, t4.version))
                  return [{ command: ke.setStyle, args: [t4] }];
                n(e3.center, t4.center) || i4.push({ command: ke.setCenter, args: [t4.center] }), n(e3.zoom, t4.zoom) || i4.push({ command: ke.setZoom, args: [t4.zoom] }), n(e3.bearing, t4.bearing) || i4.push({ command: ke.setBearing, args: [t4.bearing] }), n(e3.pitch, t4.pitch) || i4.push({ command: ke.setPitch, args: [t4.pitch] }), n(e3.sprite, t4.sprite) || i4.push({ command: ke.setSprite, args: [t4.sprite] }), n(e3.glyphs, t4.glyphs) || i4.push({ command: ke.setGlyphs, args: [t4.glyphs] }), n(e3.transition, t4.transition) || i4.push({ command: ke.setTransition, args: [t4.transition] }), n(e3.light, t4.light) || i4.push({ command: ke.setLight, args: [t4.light] }), n(e3.fog, t4.fog) || i4.push({ command: ke.setFog, args: [t4.fog] }), n(e3.projection, t4.projection) || i4.push({ command: ke.setProjection, args: [t4.projection] });
                const o3 = {}, r3 = [];
                !function(e4, t5, i5, o4) {
                  let r4;
                  for (r4 in t5 = t5 || {}, e4 = e4 || {})
                    e4.hasOwnProperty(r4) && (t5.hasOwnProperty(r4) || Be(r4, i5, o4));
                  for (r4 in t5)
                    t5.hasOwnProperty(r4) && (e4.hasOwnProperty(r4) ? n(e4[r4], t5[r4]) || (e4[r4].type === "geojson" && t5[r4].type === "geojson" && Ue(e4, t5, r4) ? i5.push({ command: ke.setGeoJSONSourceData, args: [r4, t5[r4].data] }) : Fe(r4, t5, i5, o4)) : Oe(r4, t5, i5));
                }(e3.sources, t4.sources, r3, o3);
                const a2 = [];
                e3.layers && e3.layers.forEach((e4) => {
                  o3[e4.source] ? i4.push({ command: ke.removeLayer, args: [e4.id] }) : a2.push(e4);
                });
                let s4 = e3.terrain;
                s4 && o3[s4.source] && (i4.push({ command: ke.setTerrain, args: [void 0] }), s4 = void 0), i4 = i4.concat(r3), n(s4, t4.terrain) || i4.push({ command: ke.setTerrain, args: [t4.terrain] }), function(e4, t5, i5) {
                  t5 = t5 || [];
                  const o4 = (e4 = e4 || []).map(Ge), r4 = t5.map(Ge), a3 = e4.reduce(je, {}), s5 = t5.reduce(je, {}), l2 = o4.slice(), c2 = Object.create(null);
                  let h3, u2, _2, d2, p2, m3, f4;
                  for (h3 = 0, u2 = 0; h3 < o4.length; h3++)
                    _2 = o4[h3], s5.hasOwnProperty(_2) ? u2++ : (i5.push({ command: ke.removeLayer, args: [_2] }), l2.splice(l2.indexOf(_2, u2), 1));
                  for (h3 = 0, u2 = 0; h3 < r4.length; h3++)
                    _2 = r4[r4.length - 1 - h3], l2[l2.length - 1 - h3] !== _2 && (a3.hasOwnProperty(_2) ? (i5.push({ command: ke.removeLayer, args: [_2] }), l2.splice(l2.lastIndexOf(_2, l2.length - u2), 1)) : u2++, m3 = l2[l2.length - h3], i5.push({ command: ke.addLayer, args: [s5[_2], m3] }), l2.splice(l2.length - h3, 0, _2), c2[_2] = true);
                  for (h3 = 0; h3 < r4.length; h3++)
                    if (_2 = r4[h3], d2 = a3[_2], p2 = s5[_2], !c2[_2] && !n(d2, p2))
                      if (n(d2.source, p2.source) && n(d2["source-layer"], p2["source-layer"]) && n(d2.type, p2.type)) {
                        for (f4 in Ne(d2.layout, p2.layout, i5, _2, null, ke.setLayoutProperty), Ne(d2.paint, p2.paint, i5, _2, null, ke.setPaintProperty), n(d2.filter, p2.filter) || i5.push({ command: ke.setFilter, args: [_2, p2.filter] }), n(d2.minzoom, p2.minzoom) && n(d2.maxzoom, p2.maxzoom) || i5.push({ command: ke.setLayerZoomRange, args: [_2, p2.minzoom, p2.maxzoom] }), d2)
                          d2.hasOwnProperty(f4) && f4 !== "layout" && f4 !== "paint" && f4 !== "filter" && f4 !== "metadata" && f4 !== "minzoom" && f4 !== "maxzoom" && (f4.indexOf("paint.") === 0 ? Ne(d2[f4], p2[f4], i5, _2, f4.slice(6), ke.setPaintProperty) : n(d2[f4], p2[f4]) || i5.push({ command: ke.setLayerProperty, args: [_2, f4, p2[f4]] }));
                        for (f4 in p2)
                          p2.hasOwnProperty(f4) && !d2.hasOwnProperty(f4) && f4 !== "layout" && f4 !== "paint" && f4 !== "filter" && f4 !== "metadata" && f4 !== "minzoom" && f4 !== "maxzoom" && (f4.indexOf("paint.") === 0 ? Ne(d2[f4], p2[f4], i5, _2, f4.slice(6), ke.setPaintProperty) : n(d2[f4], p2[f4]) || i5.push({ command: ke.setLayerProperty, args: [_2, f4, p2[f4]] }));
                      } else
                        i5.push({ command: ke.removeLayer, args: [_2] }), m3 = l2[l2.lastIndexOf(_2) + 1], i5.push({ command: ke.addLayer, args: [p2, m3] });
                }(a2, t4.layers, i4);
              } catch (e4) {
                console.warn("Unable to compute style diff:", e4), i4 = [{ command: ke.setStyle, args: [t4] }];
              }
              return i4;
            }(this.serialize(), t3).filter((e3) => !(e3.command in Bt));
            if (i3.length === 0)
              return false;
            const o2 = i3.filter((e3) => !(e3.command in Ot));
            if (o2.length > 0)
              throw new Error(`Unimplemented: ${o2.map((e3) => e3.command).join(", ")}.`);
            return i3.forEach((e3) => {
              e3.command !== "setTransition" && this[e3.command].apply(this, e3.args);
            }), this.stylesheet = t3, this.updateProjection(), true;
          }
          addImage(t3, i3) {
            if (this.getImage(t3))
              return this.fire(new e2.ErrorEvent(new Error("An image with this name already exists.")));
            this.imageManager.addImage(t3, i3), this._afterImageUpdated(t3);
          }
          updateImage(e3, t3) {
            this.imageManager.updateImage(e3, t3);
          }
          getImage(e3) {
            return this.imageManager.getImage(e3);
          }
          removeImage(t3) {
            if (!this.getImage(t3))
              return this.fire(new e2.ErrorEvent(new Error("No image with this name exists.")));
            this.imageManager.removeImage(t3), this._afterImageUpdated(t3);
          }
          _afterImageUpdated(t3) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e2.Event("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addSource(t3, i3, o2 = {}) {
            if (this._checkLoaded(), this.getSource(t3) !== void 0)
              throw new Error("There is already a source with this ID");
            if (!i3.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(e2.validateStyle.source, `sources.${t3}`, i3, null, o2))
              return;
            this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
            const r3 = Te(t3, i3, this.dispatcher, this);
            r3.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: r3.serialize(), sourceId: t3 }));
            const n2 = (i4) => {
              const o3 = (i4 ? "symbol:" : "other:") + t3, n3 = this._sourceCaches[o3] = new e2.SourceCache(o3, r3, i4);
              (i4 ? this._symbolSourceCaches : this._otherSourceCaches)[t3] = n3, n3.style = this, n3.onAdd(this.map);
            };
            n2(false), i3.type !== "vector" && i3.type !== "geojson" || n2(true), r3.onAdd && r3.onAdd(this.map), this._changed = true;
          }
          removeSource(t3) {
            this._checkLoaded();
            const i3 = this.getSource(t3);
            if (i3 === void 0)
              throw new Error("There is no source with this ID");
            for (const i4 in this._layers)
              if (this._layers[i4].source === t3)
                return this.fire(new e2.ErrorEvent(new Error(`Source "${t3}" cannot be removed while layer "${i4}" is using it.`)));
            if (this.terrain && this.terrain.get().source === t3)
              return this.fire(new e2.ErrorEvent(new Error(`Source "${t3}" cannot be removed while terrain is using it.`)));
            const o2 = this._getSourceCaches(t3);
            for (const t4 of o2)
              delete this._sourceCaches[t4.id], delete this._updatedSources[t4.id], t4.fire(new e2.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t4.getSource().id })), t4.setEventedParent(null), t4.clearTiles();
            delete this._otherSourceCaches[t3], delete this._symbolSourceCaches[t3], i3.setEventedParent(null), i3.onRemove && i3.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e3, t3) {
            this._checkLoaded(), this.getSource(e3).setData(t3), this._changed = true;
          }
          getSource(e3) {
            const t3 = this._getSourceCache(e3);
            return t3 && t3.getSource();
          }
          addLayer(t3, i3, o2 = {}) {
            this._checkLoaded();
            const r3 = t3.id;
            if (this.getLayer(r3))
              return void this.fire(new e2.ErrorEvent(new Error(`Layer with id "${r3}" already exists on this map`)));
            let n2;
            if (t3.type === "custom") {
              if (kt(this, e2.validateCustomStyleLayer(t3)))
                return;
              n2 = e2.createStyleLayer(t3);
            } else {
              if (typeof t3.source == "object" && (this.addSource(r3, t3.source), t3 = e2.clone$1(t3), t3 = e2.extend(t3, { source: r3 })), this._validate(e2.validateStyle.layer, `layers.${r3}`, t3, { arrayIndex: -1 }, o2))
                return;
              n2 = e2.createStyleLayer(t3), this._validateLayer(n2), n2.setEventedParent(this, { layer: { id: r3 } }), this._serializedLayers[n2.id] = n2.serialize(), this._updateLayerCount(n2, true);
            }
            const a2 = i3 ? this._order.indexOf(i3) : this._order.length;
            if (i3 && a2 === -1)
              return void this.fire(new e2.ErrorEvent(new Error(`Layer with id "${i3}" does not exist on this map.`)));
            this._order.splice(a2, 0, r3), this._layerOrderChanged = true, this._layers[r3] = n2;
            const s4 = this._getLayerSourceCache(n2);
            if (this._removedLayers[r3] && n2.source && s4 && n2.type !== "custom") {
              const e3 = this._removedLayers[r3];
              delete this._removedLayers[r3], e3.type !== n2.type ? this._updatedSources[n2.source] = "clear" : (this._updatedSources[n2.source] = "reload", s4.pause());
            }
            this._updateLayer(n2), n2.onAdd && n2.onAdd(this.map), this._updateDrapeFirstLayers();
          }
          moveLayer(t3, i3) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t3])
              return void this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be moved.`)));
            if (t3 === i3)
              return;
            const o2 = this._order.indexOf(t3);
            this._order.splice(o2, 1);
            const r3 = i3 ? this._order.indexOf(i3) : this._order.length;
            i3 && r3 === -1 ? this.fire(new e2.ErrorEvent(new Error(`Layer with id "${i3}" does not exist on this map.`))) : (this._order.splice(r3, 0, t3), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
          }
          removeLayer(t3) {
            this._checkLoaded();
            const i3 = this._layers[t3];
            if (!i3)
              return void this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be removed.`)));
            i3.setEventedParent(null), this._updateLayerCount(i3, false);
            const o2 = this._order.indexOf(t3);
            this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t3] = i3, delete this._layers[t3], delete this._serializedLayers[t3], delete this._updatedLayers[t3], delete this._updatedPaintProps[t3], i3.onRemove && i3.onRemove(this.map), this._updateDrapeFirstLayers();
          }
          getLayer(e3) {
            return this._layers[e3];
          }
          hasLayer(e3) {
            return e3 in this._layers;
          }
          hasLayerType(e3) {
            for (const t3 in this._layers)
              if (this._layers[t3].type === e3)
                return true;
            return false;
          }
          setLayerZoomRange(t3, i3, o2) {
            this._checkLoaded();
            const r3 = this.getLayer(t3);
            r3 ? r3.minzoom === i3 && r3.maxzoom === o2 || (i3 != null && (r3.minzoom = i3), o2 != null && (r3.maxzoom = o2), this._updateLayer(r3)) : this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot have zoom extent.`)));
          }
          setFilter(t3, i3, o2 = {}) {
            this._checkLoaded();
            const r3 = this.getLayer(t3);
            if (r3) {
              if (!n(r3.filter, i3))
                return i3 == null ? (r3.filter = void 0, void this._updateLayer(r3)) : void (this._validate(e2.validateStyle.filter, `layers.${r3.id}.filter`, i3, { layerType: r3.type }, o2) || (r3.filter = e2.clone$1(i3), this._updateLayer(r3)));
            } else
              this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be filtered.`)));
          }
          getFilter(t3) {
            return e2.clone$1(this.getLayer(t3).filter);
          }
          setLayoutProperty(t3, i3, o2, r3 = {}) {
            this._checkLoaded();
            const a2 = this.getLayer(t3);
            a2 ? n(a2.getLayoutProperty(i3), o2) || (a2.setLayoutProperty(i3, o2, r3), this._updateLayer(a2)) : this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be styled.`)));
          }
          getLayoutProperty(t3, i3) {
            const o2 = this.getLayer(t3);
            if (o2)
              return o2.getLayoutProperty(i3);
            this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style.`)));
          }
          setPaintProperty(t3, i3, o2, r3 = {}) {
            this._checkLoaded();
            const a2 = this.getLayer(t3);
            a2 ? n(a2.getPaintProperty(i3), o2) || (a2.setPaintProperty(i3, o2, r3) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[t3] = true) : this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be styled.`)));
          }
          getPaintProperty(e3, t3) {
            return this.getLayer(e3).getPaintProperty(t3);
          }
          setFeatureState(t3, i3) {
            this._checkLoaded();
            const o2 = t3.source, r3 = t3.sourceLayer, n2 = this.getSource(o2);
            if (n2 === void 0)
              return void this.fire(new e2.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const a2 = n2.type;
            if (a2 === "geojson" && r3)
              return void this.fire(new e2.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if (a2 === "vector" && !r3)
              return void this.fire(new e2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            t3.id === void 0 && this.fire(new e2.ErrorEvent(new Error("The feature id parameter must be provided.")));
            const s4 = this._getSourceCaches(o2);
            for (const e3 of s4)
              e3.setFeatureState(r3, t3.id, i3);
          }
          removeFeatureState(t3, i3) {
            this._checkLoaded();
            const o2 = t3.source, r3 = this.getSource(o2);
            if (r3 === void 0)
              return void this.fire(new e2.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
            const n2 = r3.type, a2 = n2 === "vector" ? t3.sourceLayer : void 0;
            if (n2 === "vector" && !a2)
              return void this.fire(new e2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i3 && typeof t3.id != "string" && typeof t3.id != "number")
              return void this.fire(new e2.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
            const s4 = this._getSourceCaches(o2);
            for (const e3 of s4)
              e3.removeFeatureState(a2, t3.id, i3);
          }
          getFeatureState(t3) {
            this._checkLoaded();
            const i3 = t3.source, o2 = t3.sourceLayer, r3 = this.getSource(i3);
            if (r3 !== void 0) {
              if (r3.type !== "vector" || o2)
                return t3.id === void 0 && this.fire(new e2.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i3)[0].getFeatureState(o2, t3.id);
              this.fire(new e2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new e2.ErrorEvent(new Error(`The source '${i3}' does not exist in the map's style.`)));
          }
          getTransition() {
            return e2.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            const t3 = {};
            for (const e3 in this._sourceCaches) {
              const i3 = this._sourceCaches[e3].getSource();
              t3[i3.id] || (t3[i3.id] = i3.serialize());
            }
            return e2.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.stylesheet.terrain, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t3, layers: this._serializeLayers(this._order) }, (e3) => e3 !== void 0);
          }
          _updateLayer(e3) {
            this._updatedLayers[e3.id] = true;
            const t3 = this._getLayerSourceCache(e3);
            e3.source && !this._updatedSources[e3.source] && t3 && t3.getSource().type !== "raster" && (this._updatedSources[e3.source] = "reload", t3.pause()), this._changed = true, e3.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e3) {
            const t3 = (e4) => this._layers[e4].type === "fill-extrusion", i3 = {}, o2 = [];
            for (let r4 = this._order.length - 1; r4 >= 0; r4--) {
              const n2 = this._order[r4];
              if (t3(n2)) {
                i3[n2] = r4;
                for (const t4 of e3) {
                  const e4 = t4[n2];
                  if (e4)
                    for (const t5 of e4)
                      o2.push(t5);
                }
              }
            }
            o2.sort((e4, t4) => t4.intersectionZ - e4.intersectionZ);
            const r3 = [];
            for (let n2 = this._order.length - 1; n2 >= 0; n2--) {
              const a2 = this._order[n2];
              if (t3(a2))
                for (let e4 = o2.length - 1; e4 >= 0; e4--) {
                  const t4 = o2[e4].feature;
                  if (i3[t4.layer.id] < n2)
                    break;
                  r3.push(t4), o2.pop();
                }
              else
                for (const t4 of e3) {
                  const e4 = t4[a2];
                  if (e4)
                    for (const t5 of e4)
                      r3.push(t5.feature);
                }
            }
            return r3;
          }
          queryRenderedFeatures(t3, i3, o2) {
            i3 && i3.filter && this._validate(e2.validateStyle.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
            const r3 = {};
            if (i3 && i3.layers) {
              if (!Array.isArray(i3.layers))
                return this.fire(new e2.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (const t4 of i3.layers) {
                const i4 = this._layers[t4];
                if (!i4)
                  return this.fire(new e2.ErrorEvent(new Error(`The layer '${t4}' does not exist in the map's style and cannot be queried for features.`))), [];
                r3[i4.source] = true;
              }
            }
            const n2 = [];
            i3.availableImages = this._availableImages;
            const a2 = i3 && i3.layers ? i3.layers.some((e3) => {
              const t4 = this.getLayer(e3);
              return t4 && t4.is3D();
            }) : this.has3DLayers(), s4 = pe.createFromScreenPoints(t3, o2);
            for (const e3 in this._sourceCaches) {
              const t4 = this._sourceCaches[e3].getSource().id;
              i3.layers && !r3[t4] || n2.push(Ce(this._sourceCaches[e3], this._layers, this._serializedLayers, s4, i3, o2, a2, !!this.map._showQueryGeometry));
            }
            return this.placement && n2.push(function(e3, t4, i4, o3, r4, n3, a3) {
              const s5 = {}, l2 = n3.queryRenderedSymbols(o3), c2 = [];
              for (const e4 of Object.keys(l2).map(Number))
                c2.push(a3[e4]);
              c2.sort(Se);
              for (const i5 of c2) {
                const o4 = i5.featureIndex.lookupSymbolFeatures(l2[i5.bucketInstanceId], t4, i5.bucketIndex, i5.sourceLayerIndex, r4.filter, r4.layers, r4.availableImages, e3);
                for (const e4 in o4) {
                  const t5 = s5[e4] = s5[e4] || [], r5 = o4[e4];
                  r5.sort((e5, t6) => {
                    const o5 = i5.featureSortOrder;
                    if (o5) {
                      const i6 = o5.indexOf(e5.featureIndex);
                      return o5.indexOf(t6.featureIndex) - i6;
                    }
                    return t6.featureIndex - e5.featureIndex;
                  });
                  for (const e5 of r5)
                    t5.push(e5);
                }
              }
              for (const t5 in s5)
                s5[t5].forEach((o4) => {
                  const r5 = o4.feature, n4 = i4(e3[t5]).getFeatureState(r5.layer["source-layer"], r5.id);
                  r5.source = r5.layer.source, r5.layer["source-layer"] && (r5.sourceLayer = r5.layer["source-layer"]), r5.state = n4;
                });
              return s5;
            }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s4.screenGeometry, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n2);
          }
          querySourceFeatures(t3, i3) {
            i3 && i3.filter && this._validate(e2.validateStyle.filter, "querySourceFeatures.filter", i3.filter, null, i3);
            const o2 = this._getSourceCaches(t3);
            let r3 = [];
            for (const e3 of o2)
              r3 = r3.concat(Me(e3, i3));
            return r3;
          }
          addSourceType(e3, t3, i3) {
            return Nt.getSourceType(e3) ? i3(new Error(`A source type called "${e3}" already exists.`)) : (Nt.setSourceType(e3, t3), t3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e3, url: t3.workerSourceURL }, i3) : i3(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t3, i3 = {}) {
            this._checkLoaded();
            const o2 = this.light.getLight();
            let r3 = false;
            for (const e3 in t3)
              if (!n(t3[e3], o2[e3])) {
                r3 = true;
                break;
              }
            if (!r3)
              return;
            const a2 = { now: e2.exported.now(), transition: e2.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t3, i3), this.light.updateTransitions(a2);
          }
          getTerrain() {
            return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          setTerrain(t3, i3 = 1) {
            if (this._checkLoaded(), !t3)
              return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            if (i3 === 1) {
              if (typeof t3.source == "object") {
                const i4 = "terrain-dem-src";
                this.addSource(i4, t3.source), t3 = e2.clone$1(t3), t3 = e2.extend(t3, { source: i4 });
              }
              if (this._validate(e2.validateStyle.terrain, "terrain", t3))
                return;
            }
            if (!this.terrain || this.terrain && i3 !== this.terrain.drapeRenderMode)
              this._createTerrain(t3, i3);
            else {
              const i4 = this.terrain, o2 = i4.get();
              for (const r3 in t3)
                if (!n(t3[r3], o2[r3])) {
                  i4.set(t3), this.stylesheet.terrain = t3;
                  const o3 = { now: e2.exported.now(), transition: e2.extend({ duration: 0 }, this.stylesheet.transition) };
                  i4.updateTransitions(o3);
                  break;
                }
            }
            this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(t3) {
            const i3 = this.fog = new E(t3, this.map.transform);
            this.stylesheet.fog = t3;
            const o2 = { now: e2.exported.now(), transition: e2.extend({ duration: 0 }, this.stylesheet.transition) };
            i3.updateTransitions(o2);
          }
          _updateMarkersOpacity() {
            this.map._markers.length !== 0 && this.map._requestDomTask(() => {
              for (const e3 of this.map._markers)
                e3._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(t3) {
            if (this._checkLoaded(), !t3)
              return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i3 = this.fog, o2 = i3.get();
              for (const r3 in t3)
                if (!n(t3[r3], o2[r3])) {
                  i3.set(t3), this.stylesheet.fog = t3;
                  const o3 = { now: e2.exported.now(), transition: e2.extend({ duration: 0 }, this.stylesheet.transition) };
                  i3.updateTransitions(o3);
                  break;
                }
            } else
              this._createFog(t3);
            this._markersNeedUpdate = true;
          }
          _updateDrapeFirstLayers() {
            if (!this.map._optimizeForTerrain || !this.terrain)
              return;
            const e3 = this._order.filter((e4) => this.isLayerDraped(this._layers[e4])), t3 = this._order.filter((e4) => !this.isLayerDraped(this._layers[e4]));
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e3), this._drapedFirstOrder.push(...t3);
          }
          _createTerrain(t3, i3) {
            const o2 = this.terrain = new x2(t3, i3);
            this.stylesheet.terrain = t3, this.dispatcher.broadcast("enableTerrain", true), this._force3DLayerUpdate();
            const r3 = { now: e2.exported.now(), transition: e2.extend({ duration: 0 }, this.stylesheet.transition) };
            o2.updateTransitions(r3);
          }
          _force3DLayerUpdate() {
            for (const e3 in this._layers) {
              const t3 = this._layers[e3];
              t3.type === "fill-extrusion" && this._updateLayer(t3);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e3 in this._layers) {
              const t3 = this._layers[e3];
              t3.type === "symbol" && this._updateLayer(t3);
            }
          }
          _validate(t3, i3, o2, r3, n2 = {}) {
            return (!n2 || n2.validate !== false) && kt(this, t3.call(e2.validateStyle, e2.extend({ key: i3, style: this.serialize(), value: o2, styleSpec: e2.spec }, r3)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e2.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e3 in this._layers)
              this._layers[e3].setEventedParent(null);
            for (const e3 in this._sourceCaches)
              this._sourceCaches[e3].clearTiles(), this._sourceCaches[e3].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }
          _clearSource(e3) {
            const t3 = this._getSourceCaches(e3);
            for (const e4 of t3)
              e4.clearTiles();
          }
          _reloadSource(e3) {
            const t3 = this._getSourceCaches(e3);
            for (const e4 of t3)
              e4.resume(), e4.reload();
          }
          _updateSources(e3) {
            for (const t3 in this._sourceCaches)
              this._sourceCaches[t3].update(e3);
          }
          _generateCollisionBoxes() {
            for (const e3 in this._sourceCaches) {
              const t3 = this._sourceCaches[e3];
              t3.resume(), t3.reload();
            }
          }
          _updatePlacement(t3, i3, o2, r3, n2 = false) {
            let a2 = false, s4 = false;
            const l2 = {};
            for (const e3 of this._order) {
              const i4 = this._layers[e3];
              if (i4.type !== "symbol")
                continue;
              if (!l2[i4.source]) {
                const e4 = this._getLayerSourceCache(i4);
                if (!e4)
                  continue;
                l2[i4.source] = e4.getRenderableIds(true).map((t4) => e4.getTileByID(t4)).sort((e5, t4) => t4.tileID.overscaledZ - e5.tileID.overscaledZ || (e5.tileID.isLessThan(t4.tileID) ? -1 : 1));
              }
              const o3 = this.crossTileSymbolIndex.addLayer(i4, l2[i4.source], t3.center.lng, t3.projection);
              a2 = a2 || o3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n2 = n2 || this._layerOrderChanged || o2 === 0, this._layerOrderChanged && this.fire(new e2.Event("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e2.exported.now(), t3.zoom)) && (this.pauseablePlacement = new zt(t3, this._order, n2, i3, o2, r3, this.placement, this.fog && t3.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e2.exported.now()), s4 = true), a2 && this.pauseablePlacement.placement.setStale()), s4 || a2)
              for (const e3 of this._order) {
                const t4 = this._layers[e3];
                t4.type === "symbol" && this.placement.updateLayerOpacities(t4, l2[t4.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e2.exported.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e3 in this._sourceCaches)
              this._sourceCaches[e3].releaseSymbolFadeTiles();
          }
          getImages(e3, t3, i3) {
            this.imageManager.getImages(t3.icons, i3), this._updateTilesForChangedImages();
            const o2 = (e4) => {
              e4 && e4.setDependencies(t3.tileID.key, t3.type, t3.icons);
            };
            o2(this._otherSourceCaches[t3.source]), o2(this._symbolSourceCaches[t3.source]);
          }
          getGlyphs(e3, t3, i3) {
            this.glyphManager.getGlyphs(t3.stacks, i3);
          }
          getResource(t3, i3, o2) {
            return e2.makeRequest(i3, o2);
          }
          _getSourceCache(e3) {
            return this._otherSourceCaches[e3];
          }
          _getLayerSourceCache(e3) {
            return e3.type === "symbol" ? this._symbolSourceCaches[e3.source] : this._otherSourceCaches[e3.source];
          }
          _getSourceCaches(e3) {
            const t3 = [];
            return this._otherSourceCaches[e3] && t3.push(this._otherSourceCaches[e3]), this._symbolSourceCaches[e3] && t3.push(this._symbolSourceCaches[e3]), t3;
          }
          has3DLayers() {
            return this._num3DLayers > 0;
          }
          hasSymbolLayers() {
            return this._numSymbolLayers > 0;
          }
          hasCircleLayers() {
            return this._numCircleLayers > 0;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Nt.getSourceType = function(e3) {
          return we[e3];
        }, Nt.setSourceType = function(e3, t3) {
          we[e3] = t3;
        }, Nt.registerForPluginStateChange = e2.registerForPluginStateChange;
        var Gt = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\n#endif", jt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}";
        let Zt = {}, Vt = {};
        Zt = $t("", "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nfloat unpack_depth(vec4 rgba_depth)\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", true), Vt = $t("#ifdef FOG\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", "#ifdef FOG\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", true);
        const Wt = $t("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef TERRAIN\nhighp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#endif", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#if defined(PROJECTION_GLOBE_VIEW) && !defined(PROJECTED_POS_ON_VIEWPORT)\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {\n#if defined(PROJECTION_GLOBE_VIEW) && !defined(PROJECTED_POS_ON_VIEWPORT)\nreturn mix(globe,mercator,t);\n#else\nreturn globe;\n#endif\n}\n#ifdef PROJECTION_GLOBE_VIEW\nmat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), qt = Gt;
        var Xt = { background: $t("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: $t("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: $t("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec2 scaled_extrude=extrude*a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=scaled_extrude.x*surface_vectors[0]+scaled_extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);vec4 world_center=vec4(pos,1);\n#else \nmat3 surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\n#if defined(SCALE_WITH_MAP) && defined(PROJECTION_GLOBE_VIEW)\nview_scale*=a_scale;\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: $t("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: $t("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nextrude*=a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\nvec3 pos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: $t("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: $t("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: $t("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: $t("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: $t("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: $t("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: $t("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: $t("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: $t("varying vec4 v_color;void main() {vec4 color=v_color;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);\n#else\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(pos.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: $t("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);\n#else\nvec3 p=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: $t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: $t("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: $t("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\n#ifdef RENDER_LINE_GRADIENT\nvec4 out_color=texture2D(u_gradient_image,v_uv);\n#else\nvec4 out_color=color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#ifdef RENDER_LINE_GRADIENT\nattribute vec3 a_packed;\n#else\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];float a_linesofar=a_packed[2];highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);\n#endif\n#ifdef RENDER_LINE_DASH\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: $t("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: $t("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: $t("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tileAnchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchorZ)+h,mercator_pos,u_zoom_transition);vec4 projectedPoint=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchorZ),mercator_pos,u_zoom_transition);\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: $t("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_tile_id;uniform float u_zoom_transition;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tileAnchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchorZ)+h,mercator_pos,u_zoom_transition);vec4 projectedPoint=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchorZ),mercator_pos,u_zoom_transition);\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: $t("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tileAnchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchorZ)+h,mercator_pos,u_zoom_transition);vec4 projectedPoint=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchorZ),mercator_pos,u_zoom_transition);\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: $t("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n}"), terrainDepth: $t("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: $t("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", jt), skyboxGradient: $t("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", jt), skyboxCapture: $t("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: $t("uniform sampler2D u_image0;varying vec2 v_pos0;void main() {gl_FragColor=texture2D(u_image0,v_pos0);\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;attribute vec3 a_globe_pos;attribute vec2 a_merc_pos;attribute vec2 a_uv;varying vec2 v_pos0;const float wireframeOffset=1e3;void main() {v_pos0=a_uv;vec2 uv=a_uv*EXTENT;vec4 up_vector=vec4(elevationVector(uv),1.0);float height=elevation(uv);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nvec4 globe=u_globe_matrix*vec4(a_globe_pos+up_vector.xyz*height,1.0);vec4 mercator=vec4(0.0);if (u_zoom_transition > 0.0) {mercator=vec4(a_merc_pos,height,1.0);mercator.xy-=u_merc_center;mercator.x=wrap(mercator.x,-0.5,0.5);mercator=u_merc_matrix*mercator;}vec3 position=mix(globe.xyz,mercator.xyz,u_zoom_transition);gl_Position=u_proj_matrix*vec4(position,1.0);}"), globeAtmosphere: $t("uniform vec2 u_center;uniform float u_radius;uniform vec2 u_screen_size;uniform float u_opacity;uniform highp float u_fadeout_range;uniform vec3 u_start_color;uniform vec3 u_end_color;uniform float u_pixel_ratio;void main() {highp vec2 fragCoord=gl_FragCoord.xy/u_pixel_ratio;fragCoord.y=u_screen_size.y-fragCoord.y;float distFromCenter=length(fragCoord-u_center);float normDistFromCenter=length(fragCoord-u_center)/u_radius;if (normDistFromCenter < 1.0)\ndiscard;float t=clamp(1.0-sqrt(normDistFromCenter-1.0)/u_fadeout_range,0.0,1.0);vec3 color=mix(u_start_color,u_end_color,1.0-t);gl_FragColor=vec4(color*t*u_opacity,u_opacity);}", "attribute vec3 a_pos;void main() {gl_Position=vec4(a_pos,1.0);}") };
        function $t(e3, t3, i3) {
          const o2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r3 = /uniform (highp |mediump |lowp )?([\w]+) ([\w]+)([\s]*)([\w]*)/g, n2 = t3.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), a2 = e3.match(r3), s4 = t3.match(r3), l2 = Gt.match(r3);
          let c2 = s4 ? s4.concat(a2) : a2;
          i3 || (Zt.staticUniforms && (c2 = Zt.staticUniforms.concat(c2)), Vt.staticUniforms && (c2 = Vt.staticUniforms.concat(c2))), c2 && (c2 = c2.concat(l2));
          const h3 = {};
          return { fragmentSource: e3 = e3.replace(o2, (e4, t4, i4, o3, r4) => (h3[r4] = true, t4 === "define" ? `
#ifndef HAS_UNIFORM_u_${r4}
varying ${i4} ${o3} ${r4};
#else
uniform ${i4} ${o3} u_${r4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${r4}
    ${i4} ${o3} ${r4} = u_${r4};
#endif
`)), vertexSource: t3 = t3.replace(o2, (e4, t4, i4, o3, r4) => {
            const n3 = o3 === "float" ? "vec2" : "vec4", a3 = r4.match(/color/) ? "color" : n3;
            return h3[r4] ? t4 === "define" ? `
#ifndef HAS_UNIFORM_u_${r4}
uniform lowp float u_${r4}_t;
attribute ${i4} ${n3} a_${r4};
varying ${i4} ${o3} ${r4};
#else
uniform ${i4} ${o3} u_${r4};
#endif
` : a3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${r4}
    ${r4} = a_${r4};
#else
    ${i4} ${o3} ${r4} = u_${r4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r4}
    ${r4} = unpack_mix_${a3}(a_${r4}, u_${r4}_t);
#else
    ${i4} ${o3} ${r4} = u_${r4};
#endif
` : t4 === "define" ? `
#ifndef HAS_UNIFORM_u_${r4}
uniform lowp float u_${r4}_t;
attribute ${i4} ${n3} a_${r4};
#else
uniform ${i4} ${o3} u_${r4};
#endif
` : a3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${r4}
    ${i4} ${o3} ${r4} = a_${r4};
#else
    ${i4} ${o3} ${r4} = u_${r4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r4}
    ${i4} ${o3} ${r4} = unpack_mix_${a3}(a_${r4}, u_${r4}_t);
#else
    ${i4} ${o3} ${r4} = u_${r4};
#endif
`;
          }), staticAttributes: n2, staticUniforms: c2 };
        }
        class Ht {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e3, t3, i3, o2, r3, n2, a2, s4) {
            this.context = e3;
            let l2 = this.boundPaintVertexBuffers.length !== o2.length;
            for (let e4 = 0; !l2 && e4 < o2.length; e4++)
              this.boundPaintVertexBuffers[e4] !== o2[e4] && (l2 = true);
            e3.extVertexArrayObject && this.vao && this.boundProgram === t3 && this.boundLayoutVertexBuffer === i3 && !l2 && this.boundIndexBuffer === r3 && this.boundVertexOffset === n2 && this.boundDynamicVertexBuffer === a2 && this.boundDynamicVertexBuffer2 === s4 ? (e3.bindVertexArrayOES.set(this.vao), a2 && a2.bind(), r3 && r3.dynamicDraw && r3.bind(), s4 && s4.bind()) : this.freshBind(t3, i3, o2, r3, n2, a2, s4);
          }
          freshBind(e3, t3, i3, o2, r3, n2, a2) {
            let s4;
            const l2 = e3.numAttributes, c2 = this.context, h3 = c2.gl;
            if (c2.extVertexArrayObject)
              this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), s4 = 0, this.boundProgram = e3, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = o2, this.boundVertexOffset = r3, this.boundDynamicVertexBuffer = n2, this.boundDynamicVertexBuffer2 = a2;
            else {
              s4 = c2.currentNumAttributes || 0;
              for (let e4 = l2; e4 < s4; e4++)
                h3.disableVertexAttribArray(e4);
            }
            t3.enableAttributes(h3, e3);
            for (const t4 of i3)
              t4.enableAttributes(h3, e3);
            n2 && n2.enableAttributes(h3, e3), a2 && a2.enableAttributes(h3, e3), t3.bind(), t3.setVertexAttribPointers(h3, e3, r3);
            for (const t4 of i3)
              t4.bind(), t4.setVertexAttribPointers(h3, e3, r3);
            n2 && (n2.bind(), n2.setVertexAttribPointers(h3, e3, r3)), o2 && o2.bind(), a2 && (a2.bind(), a2.setVertexAttribPointers(h3, e3, r3)), c2.currentNumAttributes = l2;
          }
          destroy() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          }
        }
        function Kt(t3, i3) {
          const o2 = Math.pow(2, i3.canonical.z), r3 = i3.canonical.y;
          return [new e2.MercatorCoordinate(0, r3 / o2).toLngLat().lat, new e2.MercatorCoordinate(0, (r3 + 1) / o2).toLngLat().lat];
        }
        function Yt(t3, i3, o2, r3, n2, a2, s4) {
          const l2 = t3.context, c2 = l2.gl, h3 = o2.fbo;
          if (!h3)
            return;
          t3.prepareDrawTile(i3);
          const u2 = t3.useProgram("hillshade");
          l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h3.colorAttachment.get());
          const _2 = ((e3, t4, i4, o3) => {
            const r4 = i4.paint.get("hillshade-shadow-color"), n3 = i4.paint.get("hillshade-highlight-color"), a3 = i4.paint.get("hillshade-accent-color");
            let s5 = i4.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            i4.paint.get("hillshade-illumination-anchor") === "viewport" && (s5 -= e3.transform.angle);
            const l3 = !e3.options.moving;
            return { u_matrix: o3 || e3.transform.calculateProjMatrix(t4.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Kt(0, t4.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), s5], u_shadow: r4, u_highlight: n3, u_accent: a3 };
          })(t3, o2, r3, t3.terrain ? i3.projMatrix : null);
          t3.prepareDrawProgram(l2, u2, i3.toUnwrapped());
          const { tileBoundsBuffer: d2, tileBoundsIndexBuffer: p2, tileBoundsSegments: m3 } = t3.getTileBoundsBuffers(o2);
          u2.draw(l2, c2.TRIANGLES, n2, a2, s4, e2.CullFaceMode.disabled, _2, r3.id, d2, p2, m3);
        }
        function Jt(t3, i3, o2) {
          if (!i3.needsDEMTextureUpload)
            return;
          const r3 = t3.context, n2 = r3.gl;
          r3.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || t3.getTileTexture(o2.stride);
          const a2 = o2.getPixels();
          i3.demTexture ? i3.demTexture.update(a2, { premultiply: false }) : i3.demTexture = new e2.Texture(r3, a2, n2.RGBA, { premultiply: false }), i3.needsDEMTextureUpload = false;
        }
        function Qt(t3, i3, o2, r3, n2, a2) {
          const s4 = t3.context, l2 = s4.gl;
          if (!i3.dem)
            return;
          const c2 = i3.dem;
          if (s4.activeTexture.set(l2.TEXTURE1), Jt(t3, i3, c2), !i3.demTexture)
            return;
          i3.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          const h3 = c2.dim;
          s4.activeTexture.set(l2.TEXTURE0);
          let u2 = i3.fbo;
          if (!u2) {
            const t4 = new e2.Texture(s4, { width: h3, height: h3, data: null }, l2.RGBA);
            t4.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), u2 = i3.fbo = s4.createFramebuffer(h3, h3, true), u2.colorAttachment.set(t4.texture);
          }
          s4.bindFramebuffer.set(u2.framebuffer), s4.viewport.set([0, 0, h3, h3]);
          const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d2, tileBoundsSegments: p2 } = t3.getMercatorTileBoundsBuffers();
          t3.useProgram("hillshadePrepare").draw(s4, l2.TRIANGLES, r3, n2, a2, e2.CullFaceMode.disabled, ((t4, i4) => {
            const o3 = i4.stride, r4 = e2.create();
            return e2.ortho(r4, 0, e2.EXTENT, -e2.EXTENT, 0, 0, 1), e2.translate(r4, r4, [0, -e2.EXTENT, 0]), { u_matrix: r4, u_image: 1, u_dimension: [o3, o3], u_zoom: t4.overscaledZ, u_unpack: i4.unpackVector };
          })(i3.tileID, c2), o2.id, _2, d2, p2), i3.needsHillshadePrepare = false;
        }
        const ei = (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_image0: new e2.Uniform1i(t3, i3.u_image0), u_skirt_height: new e2.Uniform1f(t3, i3.u_skirt_height) }), ti = (e3, t3) => ({ u_matrix: e3, u_image0: 0, u_skirt_height: t3 }), ii = (e3, t3, i3, o2, r3) => ({ u_proj_matrix: Float32Array.from(e3), u_globe_matrix: t3, u_merc_matrix: i3, u_zoom_transition: o2, u_merc_center: r3, u_image0: 0 });
        function oi(e3, t3) {
          return e3 != null && t3 != null && !(!e3.hasData() || !t3.hasData()) && e3.demTexture != null && t3.demTexture != null && e3.tileID.key !== t3.tileID.key;
        }
        const ri = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e3, t3, i3, o2, r3) {
            if (e3 in this.operations) {
              const t4 = this.operations[e3];
              t4.to.tileID.key !== i3.tileID.key && (t4.queued = i3);
            } else
              this.operations[e3] = { startTime: o2, phase: 0, duration: r3, from: t3, to: i3, queued: null };
          }
          getMorphValuesForProxy(e3) {
            if (!(e3 in this.operations))
              return null;
            const t3 = this.operations[e3];
            return { from: t3.from, to: t3.to, phase: t3.phase };
          }
          update(e3) {
            for (const t3 in this.operations) {
              const i3 = this.operations[t3];
              for (i3.phase = (e3 - i3.startTime) / i3.duration; i3.phase >= 1 || !this._validOp(i3); )
                if (!this._nextOp(i3, e3)) {
                  delete this.operations[t3];
                  break;
                }
            }
          }
          _nextOp(e3, t3) {
            return !!e3.queued && (e3.from = e3.to, e3.to = e3.queued, e3.queued = null, e3.phase = 0, e3.startTime = t3, true);
          }
          _validOp(e3) {
            return e3.from.hasData() && e3.to.hasData();
          }
        }(), ni = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
        function ai(e3, t3) {
          const i3 = 1 << e3.z;
          return !t3 && (e3.x === 0 || e3.x === i3 - 1) || e3.y === 0 || e3.y === i3 - 1;
        }
        const si = (e3) => ({ u_matrix: e3 });
        function li(t3, i3, o2, r3, n2) {
          if (n2 > 0) {
            const a2 = e2.exported.now(), s4 = (a2 - t3.timeAdded) / n2, l2 = i3 ? (a2 - i3.timeAdded) / n2 : -1, c2 = o2.getSource(), h3 = r3.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i3 || Math.abs(i3.tileID.overscaledZ - h3) > Math.abs(t3.tileID.overscaledZ - h3), _2 = u2 && t3.refreshedUponExpiration ? 1 : e2.clamp(u2 ? s4 : 1 - l2, 0, 1);
            return t3.refreshedUponExpiration && s4 >= 1 && (t3.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class ci extends e2.SourceCache {
          constructor(e3) {
            const t3 = { type: "raster-dem", maxzoom: e3.transform.maxZoom }, i3 = new C(Ae(), null), o2 = Te("mock-dem", t3, i3, e3.style);
            super("mock-dem", o2, false), o2.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e3, t3) {
            e3.state = "loaded", t3(null);
          }
        }
        class hi extends e2.SourceCache {
          constructor(e3) {
            const t3 = Te("proxy", { type: "geojson", maxzoom: e3.transform.maxZoom }, new C(Ae(), null), e3.style);
            super("proxy", t3, false), t3.setEventedParent(this), this.map = this.getSource().map = e3, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(t3, i3, o2) {
            if (t3.freezeTileCoverage)
              return;
            this.transform = t3;
            const r3 = t3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i4, o3) => {
              if (i4[o3.key] = "", !this._tiles[o3.key]) {
                const i5 = new e2.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t3.tileZoom);
                i5.state = "loaded", this._tiles[o3.key] = i5;
              }
              return i4;
            }, {});
            for (const e3 in this._tiles)
              e3 in r3 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
          }
          freeFBO(e3) {
            const t3 = this.proxyCachedFBO[e3];
            if (t3 !== void 0) {
              const i3 = Object.values(t3);
              this.renderCachePool.push(...i3), delete this.proxyCachedFBO[e3];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e3) => e3.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class ui extends e2.OverscaledTileID {
          constructor(e3, t3, i3) {
            super(e3.overscaledZ, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y), this.proxyTileKey = t3, this.projMatrix = i3;
          }
        }
        class _i extends e2.Elevation {
          constructor(t3, i3) {
            super(), this.painter = t3, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o2, r3, n2] = function(t4) {
              const i4 = new e2.StructArrayLayout4i8(), o3 = new e2.StructArrayLayout3ui6(), r4 = 131;
              i4.reserve(17161), o3.reserve(33800);
              const n3 = e2.EXTENT / 128, a3 = e2.EXTENT + n3 / 2, s5 = a3 + n3;
              for (let t5 = -n3; t5 < s5; t5 += n3)
                for (let o4 = -n3; o4 < s5; o4 += n3) {
                  const r5 = o4 < 0 || o4 > a3 || t5 < 0 || t5 > a3 ? 24575 : 0, n4 = e2.clamp(Math.round(o4), 0, e2.EXTENT), s6 = e2.clamp(Math.round(t5), 0, e2.EXTENT);
                  i4.emplaceBack(n4 + r5, s6, n4, s6);
                }
              const l2 = (e3, t5) => {
                const i5 = t5 * r4 + e3;
                o3.emplaceBack(i5 + 1, i5, i5 + r4), o3.emplaceBack(i5 + r4, i5 + r4 + 1, i5 + 1);
              };
              for (let e3 = 1; e3 < 129; e3++)
                for (let t5 = 1; t5 < 129; t5++)
                  l2(t5, e3);
              return [0, 129].forEach((e3) => {
                for (let t5 = 0; t5 < 130; t5++)
                  l2(t5, e3), l2(e3, t5);
              }), [i4, o3, 32768];
            }(), a2 = t3.context;
            this.gridBuffer = a2.createVertexBuffer(o2, e2.boundsAttributes.members), this.gridIndexBuffer = a2.createIndexBuffer(r3), this.gridSegments = e2.SegmentVector.simpleSegment(0, 0, o2.length, r3.length), this.gridNoSkirtSegments = e2.SegmentVector.simpleSegment(0, 0, o2.length, n2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new hi(i3.map), this.orthoMatrix = e2.create(), e2.ortho(this.orthoMatrix, 0, e2.EXTENT, 0, e2.EXTENT, 0, 1);
            const s4 = a2.gl;
            this._overlapStencilMode = new e2.StencilMode({ func: s4.GEQUAL, mask: 255 }, 0, 255, s4.KEEP, s4.KEEP, s4.REPLACE), this._previousZoom = t3.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i3, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new ci(i3.map);
          }
          set style(e3) {
            e3.on("data", this._onStyleDataEvent.bind(this)), e3.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e3, this._checkRenderCacheEfficiency();
          }
          update(t3, i3, o2) {
            if (t3 && t3.terrain) {
              this._style !== t3 && (this.style = t3), this.enabled = true;
              const r3 = t3.terrain.properties;
              this.sourceCache = t3.terrain.drapeRenderMode === 0 ? this._mockSourceCache : t3._getSourceCache(r3.get("source")), this._exaggeration = r3.get("exaggeration");
              const n2 = () => {
                this.sourceCache.used && e2.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t4 = this.getScaledDemTileSize();
                this.sourceCache.update(i3, t4, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n2(), this._initializing = true), n2(), i3.updateElevation(!o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i3), this._emptyDEMTextureDirty = true;
            } else
              this._disable();
          }
          resetTileLookupCache(e3) {
            this._findCoveringTileCache[e3] = {};
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _checkRenderCacheEfficiency() {
            const t3 = this.renderCacheEfficiency(this._style);
            this._style.map._optimizeForTerrain || t3.efficiency !== 100 && e2.warnOnce(`Terrain render cache efficiency is not optimal (${t3.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t3.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
          }
          _onStyleDataEvent(e3) {
            e3.coord && e3.dataType === "source" ? this._clearRenderCacheForTile(e3.sourceCacheId, e3.coord) : e3.dataType === "style" && (this._invalidateRenderCache = true);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
              for (const e3 in this._style._sourceCaches)
                this._style._sourceCaches[e3].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e3) => e3.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture);
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          exaggeration() {
            return this._exaggeration;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e3 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e3, e3];
          }
          set useVertexMorphing(e3) {
            this._useVertexMorphing = e3;
          }
          updateTileBinding(t3) {
            if (!this.enabled)
              return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i3 = this.proxySourceCache, o2 = this.painter.transform;
            this._initializing && (this._initializing = o2._centerAltitude === 0 && this.getAtPointOrZero(e2.MercatorCoordinate.fromLngLat(o2.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
            const r3 = this.proxyCoords = i3.getIds().map((e3) => {
              const t4 = i3.getTileByID(e3).tileID;
              return t4.projMatrix = o2.calculateProjMatrix(t4.toUnwrapped()), t4;
            });
            !function(t4, i4) {
              const o3 = i4.transform.pointCoordinate(i4.transform.getCameraPoint()), r4 = new e2.pointGeometry(o3.x, o3.y);
              t4.sort((t5, i5) => {
                if (i5.overscaledZ - t5.overscaledZ)
                  return i5.overscaledZ - t5.overscaledZ;
                const o4 = new e2.pointGeometry(t5.canonical.x + (1 << t5.canonical.z) * t5.wrap, t5.canonical.y), n3 = new e2.pointGeometry(i5.canonical.x + (1 << i5.canonical.z) * i5.wrap, i5.canonical.y), a3 = r4.mult(1 << t5.canonical.z);
                return a3.x -= 0.5, a3.y -= 0.5, a3.distSqr(o4) - a3.distSqr(n3);
              });
            }(r3, this.painter), this._previousZoom = o2.zoom;
            const n2 = this.proxyToSource || {};
            this.proxyToSource = {}, r3.forEach((e3) => {
              this.proxyToSource[e3.key] = {};
            }), this.terrainTileForTile = {};
            const a2 = this._style._sourceCaches;
            for (const e3 in a2) {
              const i4 = a2[e3];
              if (!i4.used)
                continue;
              if (i4 !== this.sourceCache && this.resetTileLookupCache(i4.id), this._setupProxiedCoordsForOrtho(i4, t3[e3], n2), i4.usedForTerrain)
                continue;
              const o3 = t3[e3];
              i4.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
            }
            this.proxiedCoords[i3.id] = r3.map((e3) => new ui(e3, e3.key, this.orthoMatrix)), this._assignTerrainTiles(r3), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n2), this.renderingToTexture = false, this._updateTimestamp = e2.exported.now();
            const s4 = {};
            this._visibleDemTiles = [];
            for (const e3 of this.proxyCoords) {
              const t4 = this.terrainTileForTile[e3.key];
              if (!t4)
                continue;
              const i4 = t4.tileID.key;
              i4 in s4 || (this._visibleDemTiles.push(t4), s4[i4] = i4);
            }
          }
          _assignTerrainTiles(e3) {
            this._initializing || e3.forEach((e4) => {
              if (this.terrainTileForTile[e4.key])
                return;
              const t3 = this._findTileCoveringTileID(e4, this.sourceCache);
              t3 && (this.terrainTileForTile[e4.key] = t3);
            });
          }
          _prepareDEMTextures() {
            const e3 = this.painter.context, t3 = e3.gl;
            for (const i3 in this.terrainTileForTile) {
              const o2 = this.terrainTileForTile[i3], r3 = o2.dem;
              !r3 || o2.demTexture && !o2.needsDEMTextureUpload || (e3.activeTexture.set(t3.TEXTURE1), Jt(this.painter, o2, r3));
            }
          }
          _prepareDemTileUniforms(e3, t3, i3, o2) {
            if (!t3 || t3.demTexture == null)
              return false;
            const r3 = e3.tileID.canonical, n2 = Math.pow(2, t3.tileID.canonical.z - r3.z), a2 = o2 || "";
            return i3[`u_dem_tl${a2}`] = [r3.x * n2 % 1, r3.y * n2 % 1], i3[`u_dem_scale${a2}`] = n2, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          get emptyDepthBufferTexture() {
            const t3 = this.painter.context, i3 = t3.gl;
            if (!this._emptyDepthBufferTexture) {
              const o2 = { width: 1, height: 1, data: new Uint8Array([255, 255, 255, 255]) };
              this._emptyDepthBufferTexture = new e2.Texture(t3, o2, i3.RGBA, { premultiply: false });
            }
            return this._emptyDepthBufferTexture;
          }
          _getLoadedAreaMinimum() {
            let e3 = 0;
            const t3 = this._visibleDemTiles.reduce((t4, i3) => {
              if (!i3.dem)
                return t4;
              const o2 = i3.dem.tree.minimums[0];
              return o2 > 0 && e3++, t4 + o2;
            }, 0);
            return e3 ? t3 / e3 : 0;
          }
          _updateEmptyDEMTexture() {
            const t3 = this.painter.context, i3 = t3.gl;
            t3.activeTexture.set(i3.TEXTURE2);
            const o2 = this._getLoadedAreaMinimum(), r3 = { width: 1, height: 1, data: new Uint8Array(e2.DEMData.pack(o2, this.sourceCache.getSource().encoding)) };
            this._emptyDEMTextureDirty = false;
            let n2 = this._emptyDEMTexture;
            return n2 ? n2.update(r3, { premultiply: false }) : n2 = this._emptyDEMTexture = new e2.Texture(t3, r3, i3.RGBA, { premultiply: false }), n2;
          }
          setupElevationDraw(t3, i3, o2) {
            const r3 = this.painter.context, n2 = r3.gl, a2 = (s4 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e2.DEMData.getUnpackVector(s4), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0, u_tile_tl_up: [0, 0, 1], u_tile_tr_up: [0, 0, 1], u_tile_br_up: [0, 0, 1], u_tile_bl_up: [0, 0, 1], u_tile_up_scale: 1 });
            var s4;
            a2.u_dem_size = this.sourceCache.getSource().tileSize, a2.u_exaggeration = this.exaggeration();
            const l2 = this.painter.transform, c2 = l2.projection.createTileTransform(l2, l2.worldSize), h3 = t3.tileID.canonical;
            a2.u_tile_tl_up = c2.upVector(h3, 0, 0), a2.u_tile_tr_up = c2.upVector(h3, e2.EXTENT, 0), a2.u_tile_br_up = c2.upVector(h3, e2.EXTENT, e2.EXTENT), a2.u_tile_bl_up = c2.upVector(h3, 0, e2.EXTENT), a2.u_tile_up_scale = c2.upVectorScale(h3);
            let u2 = null, _2 = null, d2 = 1;
            if (o2 && o2.morphing && this._useVertexMorphing) {
              const e3 = o2.morphing.srcDemTile, i4 = o2.morphing.dstDemTile;
              d2 = o2.morphing.phase, e3 && i4 && (this._prepareDemTileUniforms(t3, e3, a2, "_prev") && (_2 = e3), this._prepareDemTileUniforms(t3, i4, a2) && (u2 = i4));
            }
            if (_2 && u2 ? (r3.activeTexture.set(n2.TEXTURE2), u2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), r3.activeTexture.set(n2.TEXTURE4), _2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), a2.u_dem_lerp = d2) : (u2 = this.terrainTileForTile[t3.tileID.key], r3.activeTexture.set(n2.TEXTURE2), (this._prepareDemTileUniforms(t3, u2, a2) ? u2.demTexture : this.emptyDEMTexture).bind(n2.NEAREST, n2.CLAMP_TO_EDGE)), r3.activeTexture.set(n2.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), a2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height]) : (this.emptyDepthBufferTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE), a2.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && u2) {
              const t4 = (1 << u2.tileID.canonical.z) * e2.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              a2.u_meter_to_dem = t4;
            }
            o2 && o2.labelPlaneMatrixInv && (a2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i3.setTerrainUniformValues(r3, a2);
          }
          renderToBackBuffer(t3) {
            const i3 = this.painter, o2 = this.painter.context;
            t3.length !== 0 && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i3.width, i3.height]), this.renderingToTexture = false, function(t4, i4, o3, r3, n2) {
              if (t4.transform.projection.name === "globe")
                !function(t5, i5, o4, r4, n3) {
                  const a2 = t5.context, s4 = a2.gl;
                  let l2, c2;
                  const h3 = t5.options.showTerrainWireframe ? 2 : 0, u2 = (e3, i6) => {
                    if (c2 === e3)
                      return;
                    const o5 = [];
                    i6 && o5.push(ni[h3]), o5.push(ni[e3]), o5.push("PROJECTION_GLOBE_VIEW"), l2 = t5.useProgram("globeRaster", null, o5), c2 = e3;
                  }, _2 = t5.colorModeForRenderPass(), d2 = new e2.DepthMode(s4.LEQUAL, e2.DepthMode.ReadWrite, t5.depthRangeFor3D);
                  ri.update(n3);
                  const p2 = t5.transform, m3 = e2.calculateGlobeMatrix(p2, p2.worldSize), f4 = e2.calculateGlobeMercatorMatrix(p2), g2 = [e2.mercatorXfromLng(p2.center.lng), e2.mercatorYfromLat(p2.center.lat)], v2 = t5.globeSharedBuffers;
                  (h3 ? [false, true] : [false]).forEach((h4) => {
                    c2 = -1;
                    const x3 = h4 ? s4.LINES : s4.TRIANGLES;
                    for (const c3 of r4) {
                      const r5 = o4.getTile(c3), y2 = Math.pow(2, c3.canonical.z), [b2, w2] = e2.globeBuffersForTileMesh(t5, r5, c3, y2), T2 = e2.StencilMode.disabled, E2 = i5.prevTerrainTileForTile[c3.key], C2 = i5.terrainTileForTile[c3.key];
                      oi(E2, C2) && ri.newMorphing(c3.key, E2, C2, n3, 250), a2.activeTexture.set(s4.TEXTURE0), r5.texture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE);
                      const M2 = ri.getMorphValuesForProxy(c3.key), S3 = M2 ? 1 : 0, I2 = {};
                      M2 && e2.extend$1(I2, { morphing: { srcDemTile: M2.from, dstDemTile: M2.to, phase: e2.easeCubicInOut(M2.phase) } });
                      const z2 = e2.globeMatrixForTile(c3.canonical, m3), D2 = ii(p2.projMatrix, z2, f4, e2.globeToMercatorTransition(p2.zoom), g2);
                      if (u2(S3, h4), i5.setupElevationDraw(r5, l2, I2), t5.prepareDrawProgram(a2, l2, c3.toUnwrapped()), v2) {
                        const [i6, o5] = h4 ? v2.getWirefameBuffer(t5.context) : [v2.gridIndexBuffer, v2.gridSegments];
                        l2.draw(a2, x3, d2, T2, _2, e2.CullFaceMode.backCCW, D2, "globe_raster", b2, i6, o5);
                      }
                      if (!h4) {
                        const t6 = [c3.canonical.y === 0 ? e2.globePoleMatrixForTile(c3.canonical, false, p2) : null, c3.canonical.y === y2 - 1 ? e2.globePoleMatrixForTile(c3.canonical, true, p2) : null];
                        for (const i6 of t6) {
                          if (!i6)
                            continue;
                          const t7 = ii(p2.projMatrix, i6, i6, 0, g2);
                          v2 && l2.draw(a2, x3, d2, T2, _2, e2.CullFaceMode.disabled, t7, "globe_pole_raster", w2, v2.poleIndexBuffer, v2.poleSegments);
                        }
                      }
                    }
                  });
                }(t4, i4, o3, r3, n2);
              else {
                const a2 = t4.context, s4 = a2.gl;
                let l2, c2;
                const h3 = t4.options.showTerrainWireframe ? 2 : 0, u2 = (e3, i5) => {
                  if (c2 === e3)
                    return;
                  const o4 = [ni[e3]];
                  i5 && o4.push(ni[h3]), l2 = t4.useProgram("terrainRaster", null, o4), c2 = e3;
                }, _2 = t4.colorModeForRenderPass(), d2 = new e2.DepthMode(s4.LEQUAL, e2.DepthMode.ReadWrite, t4.depthRangeFor3D);
                ri.update(n2);
                const p2 = t4.transform, m3 = 6 * Math.pow(1.5, 22 - p2.zoom) * i4.exaggeration();
                (h3 ? [false, true] : [false]).forEach((h4) => {
                  c2 = -1;
                  const f4 = h4 ? s4.LINES : s4.TRIANGLES, [g2, v2] = h4 ? i4.getWirefameBuffer() : [i4.gridIndexBuffer, i4.gridSegments];
                  for (const c3 of r3) {
                    const r4 = o3.getTile(c3), x3 = e2.StencilMode.disabled, y2 = i4.prevTerrainTileForTile[c3.key], b2 = i4.terrainTileForTile[c3.key];
                    oi(y2, b2) && ri.newMorphing(c3.key, y2, b2, n2, 250), a2.activeTexture.set(s4.TEXTURE0), r4.texture.bind(s4.LINEAR, s4.CLAMP_TO_EDGE, s4.LINEAR_MIPMAP_NEAREST);
                    const w2 = ri.getMorphValuesForProxy(c3.key), T2 = w2 ? 1 : 0;
                    let E2;
                    w2 && (E2 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e2.easeCubicInOut(w2.phase) } });
                    const C2 = ti(c3.projMatrix, ai(c3.canonical, p2.renderWorldCopies) ? m3 / 10 : m3);
                    u2(T2, h4), i4.setupElevationDraw(r4, l2, E2), t4.prepareDrawProgram(a2, l2, c3.toUnwrapped()), l2.draw(a2, f4, d2, x3, _2, e2.CullFaceMode.backCCW, C2, "terrain_raster", i4.gridBuffer, g2, v2);
                  }
                });
              }
            }(i3, this, this.proxySourceCache, t3, this._updateTimestamp), this.renderingToTexture = true, t3.splice(0, t3.length));
          }
          renderBatch(t3) {
            if (this._drapedRenderBatches.length === 0)
              return t3 + 1;
            this.renderingToTexture = true;
            const i3 = this.painter, o2 = this.painter.context, r3 = this.proxySourceCache, n2 = this.proxiedCoords[r3.id], a2 = this._drapedRenderBatches.shift(), s4 = [], l2 = i3.style.order;
            let c2 = 0;
            for (const h3 of n2) {
              const n3 = r3.getTileByID(h3.proxyTileKey), u2 = r3.proxyCachedFBO[h3.key] ? r3.proxyCachedFBO[h3.key][t3] : void 0, _2 = u2 !== void 0 ? r3.renderCache[u2] : this.pool[c2++], d2 = u2 !== void 0;
              if (n3.texture = _2.tex, d2 && !_2.dirty) {
                s4.push(n3.tileID);
                continue;
              }
              let p2;
              o2.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o2.clear({ color: e2.Color.transparent, stencil: 0 }), _2.dirty = false);
              for (let e3 = a2.start; e3 <= a2.end; ++e3) {
                const t4 = i3.style._layers[l2[e3]];
                if (t4.isHidden(i3.transform.zoom))
                  continue;
                const r4 = i3.style._getLayerSourceCache(t4), n4 = r4 ? this.proxyToSource[h3.key][r4.id] : [h3];
                if (!n4)
                  continue;
                const a3 = n4;
                o2.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p2 !== (r4 ? r4.id : null) && (this._setupStencil(_2, n4, t4, r4), p2 = r4 ? r4.id : null), i3.renderLayer(i3, r4, t4, a3);
              }
              this.renderedToTile ? (_2.dirty = true, s4.push(n3.tileID)) : d2 || --c2, c2 === 5 && (c2 = 0, this.renderToBackBuffer(s4));
            }
            return this.renderToBackBuffer(s4), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i3.width, i3.height]), a2.end + 1;
          }
          postRender() {
          }
          renderCacheEfficiency(e3) {
            const t3 = e3.order.length;
            if (t3 === 0)
              return { efficiency: 100 };
            let i3, o2 = 0, r3 = 0, n2 = false;
            for (let a2 = 0; a2 < t3; ++a2) {
              const t4 = e3._layers[e3.order[a2]];
              this._style.isLayerDraped(t4) ? (n2 && ++o2, ++r3) : n2 || (n2 = true, i3 = t4.id);
            }
            return r3 === 0 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r3), firstUndrapedLayer: i3 };
          }
          getMinElevationBelowMSL() {
            let e3 = 0;
            return this._visibleDemTiles.filter((e4) => e4.dem).forEach((t3) => {
              e3 = Math.min(e3, t3.dem.tree.minimums[0]);
            }), e3 === 0 ? e3 : (e3 - 30) * this._exaggeration;
          }
          raycast(e3, t3, i3) {
            if (!this._visibleDemTiles)
              return null;
            const o2 = this._visibleDemTiles.filter((e4) => e4.dem).map((o3) => {
              const r3 = o3.tileID, n2 = Math.pow(2, r3.overscaledZ), { x: a2, y: s4 } = r3.canonical, l2 = a2 / n2, c2 = (a2 + 1) / n2, h3 = s4 / n2, u2 = (s4 + 1) / n2;
              return { minx: l2, miny: h3, maxx: c2, maxy: u2, t: o3.dem.tree.raycastRoot(l2, h3, c2, u2, e3, t3, i3), tile: o3 };
            });
            o2.sort((e4, t4) => (e4.t !== null ? e4.t : Number.MAX_VALUE) - (t4.t !== null ? t4.t : Number.MAX_VALUE));
            for (const r3 of o2) {
              if (r3.t == null)
                return null;
              const o3 = r3.tile.dem.tree.raycast(r3.minx, r3.miny, r3.maxx, r3.maxy, e3, t3, i3);
              if (o3 != null)
                return o3;
            }
            return null;
          }
          _createFBO() {
            const t3 = this.painter.context, i3 = t3.gl, o2 = this.drapeBufferSize;
            t3.activeTexture.set(i3.TEXTURE0);
            const r3 = new e2.Texture(t3, { width: o2[0], height: o2[1], data: null }, i3.RGBA);
            r3.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
            const n2 = t3.createFramebuffer(o2[0], o2[1], false);
            return n2.colorAttachment.set(r3.texture), n2.depthAttachment = new ue(t3, n2.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t3.createRenderbuffer(t3.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n2.depthAttachment.set(this._sharedDepthStencil), t3.clear({ stencil: 0 })) : n2.depthAttachment.set(this._sharedDepthStencil), t3.extTextureFilterAnisotropic && !t3.extTextureFilterAnisotropicForceOff && i3.texParameterf(i3.TEXTURE_2D, t3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t3.extTextureFilterAnisotropicMax), { fb: n2, tex: r3, dirty: false };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
              this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._style.light && this._style.light.hasTransition())
              return true;
            for (const e3 in this._style._sourceCaches)
              if (this._style._sourceCaches[e3].hasTransition())
                return true;
            return this._style.order.some((e3) => {
              const t3 = this._style._layers[e3], i3 = t3.isHidden(this.painter.transform.zoom), o2 = t3.getCrossfadeParameters(), r3 = !!o2 && o2.t !== 1, n2 = t3.hasTransition();
              return t3.type !== "custom" && !i3 && (r3 || n2);
            });
          }
          _clearRasterFadeFromRenderCache() {
            let e3 = false;
            for (const t3 in this._style._sourceCaches)
              if (this._style._sourceCaches[t3]._source instanceof ve) {
                e3 = true;
                break;
              }
            if (e3)
              for (let e4 = 0; e4 < this._style.order.length; ++e4) {
                const t3 = this._style._layers[this._style.order[e4]], i3 = t3.isHidden(this.painter.transform.zoom), o2 = this._style._getLayerSourceCache(t3);
                if (t3.type !== "raster" || i3 || !o2)
                  continue;
                const r3 = t3.paint.get("raster-fade-duration");
                for (const e5 of this.proxyCoords) {
                  const t4 = this.proxyToSource[e5.key][o2.id];
                  if (t4)
                    for (const e6 of t4) {
                      const t5 = li(o2.getTile(e6), o2.findLoadedParent(e6, 0), o2, this.painter.transform, r3);
                      (t5.opacity !== 1 || t5.mix !== 0) && this._clearRenderCacheForTile(o2.id, e6);
                    }
                }
              }
          }
          _setupDrapedRenderBatches() {
            const e3 = this._style.order, t3 = e3.length;
            if (t3 === 0)
              return;
            const i3 = [];
            let o2, r3 = 0, n2 = this._style._layers[e3[r3]];
            for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r3 < t3; )
              n2 = this._style._layers[e3[r3]];
            for (; r3 < t3; ++r3) {
              const t4 = this._style._layers[e3[r3]];
              t4.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t4) ? o2 === void 0 && (o2 = r3) : o2 !== void 0 && (i3.push({ start: o2, end: r3 - 1 }), o2 = void 0));
            }
            o2 !== void 0 && i3.push({ start: o2, end: r3 - 1 }), this._drapedRenderBatches = i3;
          }
          _setupRenderCache(e3) {
            const t3 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
              if (this._invalidateRenderCache = false, t3.renderCache.length > t3.renderCachePool.length) {
                const e4 = Object.values(t3.proxyCachedFBO);
                t3.proxyCachedFBO = {};
                for (let i4 = 0; i4 < e4.length; ++i4) {
                  const o3 = Object.values(e4[i4]);
                  t3.renderCachePool.push(...o3);
                }
              }
              return;
            }
            this._clearRasterFadeFromRenderCache();
            const i3 = this.proxyCoords, o2 = this._tilesDirty;
            for (let r4 = i3.length - 1; r4 >= 0; r4--) {
              const n2 = i3[r4];
              if (t3.getTileByID(n2.key), t3.proxyCachedFBO[n2.key] !== void 0) {
                const i4 = e3[n2.key], r5 = this.proxyToSource[n2.key];
                let a2 = 0;
                for (const e4 in r5) {
                  const t4 = r5[e4], n3 = i4[e4];
                  if (!n3 || n3.length !== t4.length || t4.some((t5, i5) => t5 !== n3[i5] || o2[e4] && o2[e4].hasOwnProperty(t5.key))) {
                    a2 = -1;
                    break;
                  }
                  ++a2;
                }
                for (const e4 in t3.proxyCachedFBO[n2.key])
                  t3.renderCache[t3.proxyCachedFBO[n2.key][e4]].dirty = a2 < 0 || a2 !== Object.values(i4).length;
              }
            }
            const r3 = [...this._drapedRenderBatches];
            r3.sort((e4, t4) => t4.end - t4.start - (e4.end - e4.start));
            for (const e4 of r3)
              for (const o3 of i3) {
                if (t3.proxyCachedFBO[o3.key])
                  continue;
                let i4 = t3.renderCachePool.pop();
                i4 === void 0 && t3.renderCache.length < 50 && (i4 = t3.renderCache.length, t3.renderCache.push(this._createFBO())), i4 !== void 0 && (t3.proxyCachedFBO[o3.key] = {}, t3.proxyCachedFBO[o3.key][e4.start] = i4, t3.renderCache[i4].dirty = true);
              }
            this._tilesDirty = {};
          }
          _setupStencil(e3, t3, i3, o2) {
            if (!o2 || !this._sourceTilesOverlap[o2.id])
              return void (this._overlapStencilType && (this._overlapStencilType = false));
            const r3 = this.painter.context, n2 = r3.gl;
            if (t3.length <= 1)
              return void (this._overlapStencilType = false);
            let a2;
            if (i3.isTileClipped())
              a2 = t3.length, this._overlapStencilMode.test = { func: n2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t3[0].overscaledZ > t3[t3.length - 1].overscaledZ))
                return void (this._overlapStencilType = false);
              a2 = 1, this._overlapStencilMode.test = { func: n2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + a2 > 255 && (r3.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += a2, this._overlapStencilMode.ref = this._stencilRef, i3.isTileClipped() && this._renderTileClippingMasks(t3, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
          }
          stencilModeForRTTOverlap(t3) {
            return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t3.key]), this._overlapStencilMode) : e2.StencilMode.disabled;
          }
          _renderTileClippingMasks(t3, i3) {
            const o2 = this.painter, r3 = this.painter.context, n2 = r3.gl;
            o2._tileClippingMaskIDs = {}, r3.setColorMode(e2.ColorMode.disabled), r3.setDepthMode(e2.DepthMode.disabled);
            const a2 = o2.useProgram("clippingMask");
            for (const s4 of t3) {
              const t4 = o2._tileClippingMaskIDs[s4.key] = --i3;
              a2.draw(r3, n2.TRIANGLES, e2.DepthMode.disabled, new e2.StencilMode({ func: n2.ALWAYS, mask: 0 }, t4, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e2.ColorMode.disabled, e2.CullFaceMode.disabled, si(s4.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
            }
          }
          pointCoordinate(t3) {
            const i3 = this.painter.transform;
            if (t3.x < 0 || t3.x > i3.width || t3.y < 0 || t3.y > i3.height)
              return null;
            const o2 = [t3.x, t3.y, 1, 1];
            e2.transformMat4$1(o2, o2, i3.pixelMatrixInverse), e2.scale$1(o2, o2, 1 / o2[3]), o2[0] /= i3.worldSize, o2[1] /= i3.worldSize;
            const r3 = i3._camera.position, n2 = e2.mercatorZfromAltitude(1, i3.center.lat), a2 = [r3[0], r3[1], r3[2] / n2, 0], s4 = e2.subtract([], o2.slice(0, 3), a2);
            e2.normalize(s4, s4);
            const l2 = this.raycast(a2, s4, this._exaggeration);
            return l2 !== null && l2 ? (e2.scaleAndAdd(a2, a2, s4, l2), a2[3] = a2[2], a2[2] *= n2, a2) : null;
          }
          drawDepth() {
            const t3 = this.painter, i3 = t3.context, o2 = this.proxySourceCache, r3 = Math.ceil(t3.width), n2 = Math.ceil(t3.height);
            if (!this._depthFBO || this._depthFBO.width === r3 && this._depthFBO.height === n2 || (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture), !this._depthFBO) {
              const t4 = i3.gl, o3 = i3.createFramebuffer(r3, n2, true);
              i3.activeTexture.set(t4.TEXTURE0);
              const a2 = new e2.Texture(i3, { width: r3, height: n2, data: null }, t4.RGBA);
              a2.bind(t4.NEAREST, t4.CLAMP_TO_EDGE), o3.colorAttachment.set(a2.texture);
              const s4 = i3.createRenderbuffer(i3.gl.DEPTH_COMPONENT16, r3, n2);
              o3.depthAttachment.set(s4), this._depthFBO = o3, this._depthTexture = a2;
            }
            i3.bindFramebuffer.set(this._depthFBO.framebuffer), i3.viewport.set([0, 0, r3, n2]), function(t4, i4, o3, r4) {
              if (t4.transform.projection.name === "globe")
                return;
              const n3 = t4.context, a2 = n3.gl;
              n3.clear({ depth: 1 });
              const s4 = t4.useProgram("terrainDepth"), l2 = new e2.DepthMode(a2.LESS, e2.DepthMode.ReadWrite, t4.depthRangeFor3D);
              for (const t5 of r4) {
                const r5 = o3.getTile(t5), c2 = ti(t5.projMatrix, 0);
                i4.setupElevationDraw(r5, s4), s4.draw(n3, a2.TRIANGLES, l2, e2.StencilMode.disabled, e2.ColorMode.unblended, e2.CullFaceMode.backCCW, c2, "terrain_depth", i4.gridBuffer, i4.gridIndexBuffer, i4.gridNoSkirtSegments);
              }
            }(t3, this, o2, this.proxyCoords);
          }
          _setupProxiedCoordsForOrtho(e3, t3, i3) {
            if (e3.getSource() instanceof be)
              return this._setupProxiedCoordsForImageSource(e3, t3, i3);
            this._findCoveringTileCache[e3.id] = this._findCoveringTileCache[e3.id] || {};
            const o2 = this.proxiedCoords[e3.id] = [], r3 = this.proxyCoords;
            for (let t4 = 0; t4 < r3.length; t4++) {
              const n3 = r3[t4], a2 = this._findTileCoveringTileID(n3, e3);
              if (a2) {
                const t5 = this._createProxiedId(n3, a2, i3[n3.key] && i3[n3.key][e3.id]);
                o2.push(t5), this.proxyToSource[n3.key][e3.id] = [t5];
              }
            }
            let n2 = false;
            for (let r4 = 0; r4 < t3.length; r4++) {
              const a2 = e3.getTile(t3[r4]);
              if (!a2 || !a2.hasData())
                continue;
              const s4 = this._findTileCoveringTileID(a2.tileID, this.proxySourceCache);
              if (s4 && s4.tileID.canonical.z !== a2.tileID.canonical.z) {
                const t4 = this.proxyToSource[s4.tileID.key][e3.id], r5 = this._createProxiedId(s4.tileID, a2, i3[s4.tileID.key] && i3[s4.tileID.key][e3.id]);
                t4 ? t4.splice(t4.length - 1, 0, r5) : this.proxyToSource[s4.tileID.key][e3.id] = [r5], o2.push(r5), n2 = true;
              }
            }
            this._sourceTilesOverlap[e3.id] = n2;
          }
          _setupProxiedCoordsForImageSource(t3, i3, o2) {
            if (!t3.getSource().loaded())
              return;
            const r3 = this.proxiedCoords[t3.id] = [], n2 = this.proxyCoords, a2 = t3.getSource(), s4 = new e2.pointGeometry(a2.tileID.x, a2.tileID.y)._div(1 << a2.tileID.z), l2 = a2.coordinates.map(e2.MercatorCoordinate.fromLngLat).reduce((e3, t4) => (e3.min.x = Math.min(e3.min.x, t4.x - s4.x), e3.min.y = Math.min(e3.min.y, t4.y - s4.y), e3.max.x = Math.max(e3.max.x, t4.x - s4.x), e3.max.y = Math.max(e3.max.y, t4.y - s4.y), e3), { min: new e2.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e2.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (t4, i4) => {
              const o3 = t4.wrap + t4.canonical.x / (1 << t4.canonical.z), r4 = t4.canonical.y / (1 << t4.canonical.z), n3 = e2.EXTENT / (1 << t4.canonical.z), a3 = i4.wrap + i4.canonical.x / (1 << i4.canonical.z), s5 = i4.canonical.y / (1 << i4.canonical.z);
              return o3 + n3 < a3 + l2.min.x || o3 > a3 + l2.max.x || r4 + n3 < s5 + l2.min.y || r4 > s5 + l2.max.y;
            };
            for (let e3 = 0; e3 < n2.length; e3++) {
              const a3 = n2[e3];
              for (let e4 = 0; e4 < i3.length; e4++) {
                const n3 = t3.getTile(i3[e4]);
                if (!n3 || !n3.hasData())
                  continue;
                if (c2(a3, n3.tileID))
                  continue;
                const s5 = this._createProxiedId(a3, n3, o2[a3.key] && o2[a3.key][t3.id]), l3 = this.proxyToSource[a3.key][t3.id];
                l3 ? l3.push(s5) : this.proxyToSource[a3.key][t3.id] = [s5], r3.push(s5);
              }
            }
          }
          _createProxiedId(t3, i3, o2) {
            let r3 = this.orthoMatrix;
            if (o2) {
              const e3 = o2.find((e4) => e4.key === i3.tileID.key);
              if (e3)
                return e3;
            }
            if (i3.tileID.key !== t3.key) {
              const o3 = t3.canonical.z - i3.tileID.canonical.z;
              let n2, a2, s4;
              r3 = e2.create();
              const l2 = i3.tileID.wrap - t3.wrap << t3.overscaledZ;
              o3 > 0 ? (n2 = e2.EXTENT >> o3, a2 = n2 * ((i3.tileID.canonical.x << o3) - t3.canonical.x + l2), s4 = n2 * ((i3.tileID.canonical.y << o3) - t3.canonical.y)) : (n2 = e2.EXTENT << -o3, a2 = e2.EXTENT * (i3.tileID.canonical.x - (t3.canonical.x + l2 << -o3)), s4 = e2.EXTENT * (i3.tileID.canonical.y - (t3.canonical.y << -o3))), e2.ortho(r3, 0, n2, 0, n2, 0, 1), e2.translate(r3, r3, [a2, s4, 0]);
            }
            return new ui(i3.tileID, t3.key, r3);
          }
          _findTileCoveringTileID(t3, i3) {
            let o2 = i3.getTile(t3);
            if (o2 && o2.hasData())
              return o2;
            const r3 = this._findCoveringTileCache[i3.id], n2 = r3[t3.key];
            if (o2 = n2 ? i3.getTileByID(n2) : null, o2 && o2.hasData() || n2 === null)
              return o2;
            let a2 = o2 ? o2.tileID : t3, s4 = a2.overscaledZ;
            const l2 = i3.getSource().minzoom, c2 = [];
            if (!n2) {
              const r4 = i3.getSource().maxzoom;
              if (t3.canonical.z >= r4) {
                const o3 = t3.canonical.z - r4;
                i3.getSource().reparseOverscaled ? (s4 = Math.max(t3.canonical.z + 2, i3.transform.tileZoom), a2 = new e2.OverscaledTileID(s4, t3.wrap, r4, t3.canonical.x >> o3, t3.canonical.y >> o3)) : o3 !== 0 && (s4 = r4, a2 = new e2.OverscaledTileID(s4, t3.wrap, r4, t3.canonical.x >> o3, t3.canonical.y >> o3));
              }
              a2.key !== t3.key && (c2.push(a2.key), o2 = i3.getTile(a2));
            }
            const h3 = (e3) => {
              c2.forEach((t4) => {
                r3[t4] = e3;
              }), c2.length = 0;
            };
            for (s4 -= 1; s4 >= l2 && (!o2 || !o2.hasData()); s4--) {
              o2 && h3(o2.tileID.key);
              const e3 = a2.calculateScaledKey(s4);
              if (o2 = i3.getTileByID(e3), o2 && o2.hasData())
                break;
              const t4 = r3[e3];
              if (t4 === null)
                break;
              t4 === void 0 ? c2.push(e3) : o2 = i3.getTileByID(t4);
            }
            return h3(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
          }
          findDEMTileFor(e3) {
            return this.enabled ? this._findTileCoveringTileID(e3, this.sourceCache) : null;
          }
          prepareDrawTile(e3) {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e3, t3) {
            let i3 = this._tilesDirty[e3];
            i3 || (i3 = this._tilesDirty[e3] = {}), i3[t3.key] = true;
          }
          getWirefameBuffer() {
            if (!this.wireframeSegments) {
              const t3 = function(t4) {
                let i3, o2, r3;
                const n2 = new e2.StructArrayLayout2ui4(), a2 = 131;
                for (o2 = 1; o2 < 129; o2++) {
                  for (i3 = 1; i3 < 129; i3++)
                    r3 = o2 * a2 + i3, n2.emplaceBack(r3, r3 + 1), n2.emplaceBack(r3, r3 + a2), n2.emplaceBack(r3 + 1, r3 + a2), o2 === 128 && n2.emplaceBack(r3 + a2, r3 + a2 + 1);
                  n2.emplaceBack(r3 + 1, r3 + 1 + a2);
                }
                return n2;
              }();
              this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t3), this.wireframeSegments = e2.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t3.length);
            }
            return [this.wireframeIndexBuffer, this.wireframeSegments];
          }
        }
        function di(e3) {
          const t3 = [];
          for (let i3 = 0; i3 < e3.length; i3++) {
            if (e3[i3] === null)
              continue;
            const o2 = e3[i3].split(" ");
            t3.push(o2.pop());
          }
          return t3;
        }
        class pi {
          static cacheKey(e3, t3, i3) {
            let o2 = `${e3}${i3 ? i3.cacheKey : ""}`;
            for (const e4 of t3)
              o2 += `/${e4}`;
            return o2;
          }
          constructor(t3, i3, o2, r3, n2, a2) {
            const s4 = t3.gl;
            this.program = s4.createProgram();
            const l2 = di(o2.staticAttributes), c2 = r3 ? r3.getBinderAttributes() : [], h3 = l2.concat(c2), u2 = o2.staticUniforms ? di(o2.staticUniforms) : [], _2 = r3 ? r3.getBinderUniforms() : [], d2 = u2.concat(_2), p2 = [];
            for (const e3 of d2)
              p2.indexOf(e3) < 0 && p2.push(e3);
            let m3 = r3 ? r3.defines() : [];
            m3 = m3.concat(a2.map((e3) => `#define ${e3}`));
            const f4 = m3.concat("\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", qt, Wt.fragmentSource, Vt.fragmentSource, o2.fragmentSource).join("\n"), g2 = m3.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", qt, Wt.vertexSource, Vt.vertexSource, Zt.vertexSource, o2.vertexSource).join("\n"), v2 = s4.createShader(s4.FRAGMENT_SHADER);
            if (s4.isContextLost())
              return void (this.failedToCreate = true);
            s4.shaderSource(v2, f4), s4.compileShader(v2), s4.attachShader(this.program, v2);
            const x3 = s4.createShader(s4.VERTEX_SHADER);
            if (s4.isContextLost())
              return void (this.failedToCreate = true);
            s4.shaderSource(x3, g2), s4.compileShader(x3), s4.attachShader(this.program, x3), this.attributes = {};
            const y2 = {};
            this.numAttributes = h3.length;
            for (let e3 = 0; e3 < this.numAttributes; e3++)
              h3[e3] && (s4.bindAttribLocation(this.program, e3, h3[e3]), this.attributes[h3[e3]] = e3);
            s4.linkProgram(this.program), s4.deleteShader(x3), s4.deleteShader(v2);
            for (let e3 = 0; e3 < p2.length; e3++) {
              const t4 = p2[e3];
              if (t4 && !y2[t4]) {
                const e4 = s4.getUniformLocation(this.program, t4);
                e4 && (y2[t4] = e4);
              }
            }
            this.fixedUniforms = n2(t3, y2), this.binderUniforms = r3 ? r3.getUniforms(t3, y2) : [], a2.indexOf("TERRAIN") !== -1 && (this.terrainUniforms = ((t4, i4) => ({ u_dem: new e2.Uniform1i(t4, i4.u_dem), u_dem_prev: new e2.Uniform1i(t4, i4.u_dem_prev), u_dem_unpack: new e2.Uniform4f(t4, i4.u_dem_unpack), u_dem_tl: new e2.Uniform2f(t4, i4.u_dem_tl), u_dem_scale: new e2.Uniform1f(t4, i4.u_dem_scale), u_dem_tl_prev: new e2.Uniform2f(t4, i4.u_dem_tl_prev), u_dem_scale_prev: new e2.Uniform1f(t4, i4.u_dem_scale_prev), u_dem_size: new e2.Uniform1f(t4, i4.u_dem_size), u_dem_lerp: new e2.Uniform1f(t4, i4.u_dem_lerp), u_exaggeration: new e2.Uniform1f(t4, i4.u_exaggeration), u_depth: new e2.Uniform1i(t4, i4.u_depth), u_depth_size_inv: new e2.Uniform2f(t4, i4.u_depth_size_inv), u_meter_to_dem: new e2.Uniform1f(t4, i4.u_meter_to_dem), u_label_plane_matrix_inv: new e2.UniformMatrix4f(t4, i4.u_label_plane_matrix_inv), u_tile_tl_up: new e2.Uniform3f(t4, i4.u_tile_tl_up), u_tile_tr_up: new e2.Uniform3f(t4, i4.u_tile_tr_up), u_tile_br_up: new e2.Uniform3f(t4, i4.u_tile_br_up), u_tile_bl_up: new e2.Uniform3f(t4, i4.u_tile_bl_up), u_tile_up_scale: new e2.Uniform1f(t4, i4.u_tile_up_scale) }))(t3, y2)), a2.indexOf("FOG") !== -1 && (this.fogUniforms = ((t4, i4) => ({ u_fog_matrix: new e2.UniformMatrix4f(t4, i4.u_fog_matrix), u_fog_range: new e2.Uniform2f(t4, i4.u_fog_range), u_fog_color: new e2.Uniform4f(t4, i4.u_fog_color), u_fog_horizon_blend: new e2.Uniform1f(t4, i4.u_fog_horizon_blend), u_fog_temporal_offset: new e2.Uniform1f(t4, i4.u_fog_temporal_offset) }))(t3, y2));
          }
          setTerrainUniformValues(e3, t3) {
            if (!this.terrainUniforms)
              return;
            const i3 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e3.program.set(this.program);
              for (const e4 in t3)
                i3[e4].set(t3[e4]);
            }
          }
          setFogUniformValues(e3, t3) {
            if (!this.fogUniforms)
              return;
            const i3 = this.fogUniforms;
            if (!this.failedToCreate) {
              e3.program.set(this.program);
              for (const e4 in t3)
                i3[e4].location && i3[e4].set(t3[e4]);
            }
          }
          draw(e3, t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2, m3) {
            const f4 = e3.gl;
            if (this.failedToCreate)
              return;
            e3.program.set(this.program), e3.setDepthMode(i3), e3.setStencilMode(o2), e3.setColorMode(r3), e3.setCullFace(n2);
            for (const e4 of Object.keys(this.fixedUniforms))
              this.fixedUniforms[e4].set(a2[e4]);
            d2 && d2.setUniforms(e3, this.binderUniforms, u2, { zoom: _2 });
            const g2 = { [f4.LINES]: 2, [f4.TRIANGLES]: 3, [f4.LINE_STRIP]: 1 }[t3];
            for (const i4 of h3.get()) {
              const o3 = i4.vaos || (i4.vaos = {});
              (o3[s4] || (o3[s4] = new Ht())).bind(e3, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, i4.vertexOffset, p2, m3), f4.drawElements(t3, i4.primitiveLength * g2, f4.UNSIGNED_SHORT, i4.primitiveOffset * g2 * 2);
            }
          }
        }
        function mi(e3, t3, i3) {
          const o2 = 1 / M(i3, 1, t3.transform.tileZoom), r3 = Math.pow(2, i3.tileID.overscaledZ), n2 = i3.tileSize * Math.pow(2, t3.transform.tileZoom) / r3, a2 = n2 * (i3.tileID.canonical.x + i3.tileID.wrap * r3), s4 = n2 * i3.tileID.canonical.y;
          return { u_image: 0, u_texsize: i3.imageAtlasTexture.size, u_scale: [o2, e3.fromScale, e3.toScale], u_fade: e3.t, u_pixel_coord_upper: [a2 >> 16, s4 >> 16], u_pixel_coord_lower: [65535 & a2, 65535 & s4] };
        }
        const fi = (t3, i3, o2, r3) => {
          const n2 = i3.style.light, a2 = n2.properties.get("position"), s4 = [a2.x, a2.y, a2.z], l2 = e2.create$1();
          n2.properties.get("anchor") === "viewport" && (e2.fromRotation(l2, -i3.transform.angle), e2.transformMat3(s4, s4, l2));
          const c2 = n2.properties.get("color");
          return { u_matrix: t3, u_lightpos: s4, u_lightintensity: n2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: r3 };
        }, gi = (t3, i3, o2, r3, n2, a2, s4) => e2.extend(fi(t3, i3, o2, r3), mi(a2, i3, s4), { u_height_factor: -Math.pow(2, n2.overscaledZ) / s4.tileSize / 8 }), vi = (e3) => ({ u_matrix: e3 }), xi = (t3, i3, o2, r3) => e2.extend(vi(t3), mi(o2, i3, r3)), yi = (e3, t3) => ({ u_matrix: e3, u_world: t3 }), bi = (t3, i3, o2, r3, n2) => e2.extend(xi(t3, i3, o2, r3), { u_world: n2 }), wi = (t3, i3, o2, r3) => {
          const n2 = t3.transform;
          let a2;
          return a2 = r3.paint.get("circle-pitch-alignment") === "map" ? n2.calculatePixelsToTileUnitsMatrix(o2) : new Float32Array([n2.pixelsToGLUnits[0], 0, 0, n2.pixelsToGLUnits[1]]), { u_camera_to_center_distance: n2.cameraToCenterDistance, u_matrix: t3.translatePosMatrix(i3.projMatrix, o2, r3.paint.get("circle-translate"), r3.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e2.exported.devicePixelRatio, u_extrude_scale: a2 };
        }, Ti = (e3) => {
          const t3 = [];
          return e3.paint.get("circle-pitch-alignment") === "map" && t3.push("PITCH_WITH_MAP"), e3.paint.get("circle-pitch-scale") === "map" && t3.push("SCALE_WITH_MAP"), t3;
        }, Ei = (t3, i3, o2) => {
          const r3 = e2.EXTENT / o2.tileSize;
          return { u_matrix: t3, u_camera_to_center_distance: i3.cameraToCenterDistance, u_extrude_scale: [i3.pixelsToGLUnits[0] / r3, i3.pixelsToGLUnits[1] / r3] };
        }, Ci = (e3, t3, i3 = 1) => ({ u_matrix: e3, u_color: t3, u_overlay: 0, u_overlay_scale: i3 }), Mi = (e3, t3, i3, o2) => ({ u_matrix: e3, u_extrude_scale: M(t3, 1, i3), u_intensity: o2 }), Si = (t3, i3, o2, r3, n2, a2) => {
          const s4 = t3.transform, l2 = s4.calculatePixelsToTileUnitsMatrix(i3), c2 = { u_matrix: Di(t3, i3, o2, n2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: e2.exported.devicePixelRatio, u_units_to_pixels: [1 / s4.pixelsToGLUnits[0], 1 / s4.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: a2, u_texsize: [0, 0], u_scale: [0, 0, 0], u_mix: 0, u_alpha_discard_threshold: 0 };
          if (Pi(o2)) {
            const e3 = zi(i3, t3.transform);
            c2.u_texsize = i3.lineAtlasTexture.size, c2.u_scale = [e3, r3.fromScale, r3.toScale], c2.u_mix = r3.t;
          }
          return c2;
        }, Ii = (t3, i3, o2, r3, n2) => {
          const a2 = t3.transform, s4 = zi(i3, a2);
          return { u_matrix: Di(t3, i3, o2, n2), u_texsize: i3.imageAtlasTexture.size, u_pixels_to_tile_units: a2.calculatePixelsToTileUnitsMatrix(i3), u_device_pixel_ratio: e2.exported.devicePixelRatio, u_image: 0, u_scale: [s4, r3.fromScale, r3.toScale], u_fade: r3.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
        };
        function zi(e3, t3) {
          return 1 / M(e3, 1, t3.tileZoom);
        }
        function Di(e3, t3, i3, o2) {
          return e3.translatePosMatrix(o2 || t3.tileID.projMatrix, t3, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
        }
        function Pi(e3) {
          const t3 = e3.paint.get("line-dasharray").value;
          return t3.value || t3.kind !== "constant";
        }
        const Ai = (e3, t3, i3, o2, r3, n2) => {
          return { u_matrix: e3, u_tl_parent: t3, u_scale_parent: i3, u_fade_t: o2.mix, u_opacity: o2.opacity * r3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r3.paint.get("raster-brightness-min"), u_brightness_high: r3.paint.get("raster-brightness-max"), u_saturation_factor: (s4 = r3.paint.get("raster-saturation"), s4 > 0 ? 1 - 1 / (1.001 - s4) : -s4), u_contrast_factor: (a2 = r3.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: Li(r3.paint.get("raster-hue-rotate")), u_perspective_transform: n2 };
          var a2, s4;
        };
        function Li(e3) {
          e3 *= Math.PI / 180;
          const t3 = Math.sin(e3), i3 = Math.cos(e3);
          return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * t3 - i3 + 1) / 3, (Math.sqrt(3) * t3 - i3 + 1) / 3];
        }
        const Ri = (e3, t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2) => {
          const p2 = r3.transform;
          return { u_is_size_zoom_constant: +(e3 === "constant" || e3 === "source"), u_is_size_feature_constant: +(e3 === "constant" || e3 === "camera"), u_size_t: t3 ? t3.uSizeT : 0, u_size: t3 ? t3.uSize : 0, u_camera_to_center_distance: p2.cameraToCenterDistance, u_pitch: p2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i3, u_aspect_ratio: p2.width / p2.height, u_fade_change: r3.options.fadeDuration ? r3.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: a2, u_coord_matrix: s4, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_tile_id: h3, u_zoom_transition: u2, u_inv_rot_matrix: _2, u_merc_center: d2, u_texture: 0 };
        }, ki = (t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2, m3) => {
          const { cameraToCenterDistance: f4, _pitch: g2 } = n2.transform;
          return e2.extend(Ri(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, _2, d2, p2, m3), { u_gamma_scale: r3 ? f4 * Math.cos(n2.terrain ? 0 : g2) : 1, u_device_pixel_ratio: e2.exported.devicePixelRatio, u_is_halo: +u2 });
        }, Oi = (t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2, d2, p2) => e2.extend(ki(t3, i3, o2, r3, n2, a2, s4, l2, true, c2, true, u2, _2, d2, p2), { u_texsize_icon: h3, u_texture_icon: 1 }), Bi = (e3, t3, i3) => ({ u_matrix: e3, u_opacity: t3, u_color: i3 }), Fi = (t3, i3, o2, r3, n2, a2) => e2.extend(function(e3, t4, i4, o3) {
          const r4 = i4.imageManager.getPattern(e3.from.toString()), n3 = i4.imageManager.getPattern(e3.to.toString()), { width: a3, height: s4 } = i4.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i4.transform.tileZoom) / l2, h3 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), u2 = c2 * o3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: r4.tl, u_pattern_br_a: r4.br, u_pattern_tl_b: n3.tl, u_pattern_br_b: n3.br, u_texsize: [a3, s4], u_mix: t4.t, u_pattern_size_a: r4.displaySize, u_pattern_size_b: n3.displaySize, u_scale_a: t4.fromScale, u_scale_b: t4.toScale, u_tile_units_to_pixels: 1 / M(o3, 1, i4.transform.tileZoom), u_pixel_coord_upper: [h3 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h3, 65535 & u2] };
        }(r3, a2, o2, n2), { u_matrix: t3, u_opacity: i3 }), Ui2 = { fillExtrusion: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_lightpos: new e2.Uniform3f(t3, i3.u_lightpos), u_lightintensity: new e2.Uniform1f(t3, i3.u_lightintensity), u_lightcolor: new e2.Uniform3f(t3, i3.u_lightcolor), u_vertical_gradient: new e2.Uniform1f(t3, i3.u_vertical_gradient), u_opacity: new e2.Uniform1f(t3, i3.u_opacity) }), fillExtrusionPattern: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_lightpos: new e2.Uniform3f(t3, i3.u_lightpos), u_lightintensity: new e2.Uniform1f(t3, i3.u_lightintensity), u_lightcolor: new e2.Uniform3f(t3, i3.u_lightcolor), u_vertical_gradient: new e2.Uniform1f(t3, i3.u_vertical_gradient), u_height_factor: new e2.Uniform1f(t3, i3.u_height_factor), u_image: new e2.Uniform1i(t3, i3.u_image), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_pixel_coord_upper: new e2.Uniform2f(t3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new e2.Uniform2f(t3, i3.u_pixel_coord_lower), u_scale: new e2.Uniform3f(t3, i3.u_scale), u_fade: new e2.Uniform1f(t3, i3.u_fade), u_opacity: new e2.Uniform1f(t3, i3.u_opacity) }), fill: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix) }), fillPattern: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_image: new e2.Uniform1i(t3, i3.u_image), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_pixel_coord_upper: new e2.Uniform2f(t3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new e2.Uniform2f(t3, i3.u_pixel_coord_lower), u_scale: new e2.Uniform3f(t3, i3.u_scale), u_fade: new e2.Uniform1f(t3, i3.u_fade) }), fillOutline: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_world: new e2.Uniform2f(t3, i3.u_world) }), fillOutlinePattern: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_world: new e2.Uniform2f(t3, i3.u_world), u_image: new e2.Uniform1i(t3, i3.u_image), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_pixel_coord_upper: new e2.Uniform2f(t3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new e2.Uniform2f(t3, i3.u_pixel_coord_lower), u_scale: new e2.Uniform3f(t3, i3.u_scale), u_fade: new e2.Uniform1f(t3, i3.u_fade) }), circle: (t3, i3) => ({ u_camera_to_center_distance: new e2.Uniform1f(t3, i3.u_camera_to_center_distance), u_extrude_scale: new e2.UniformMatrix2f(t3, i3.u_extrude_scale), u_device_pixel_ratio: new e2.Uniform1f(t3, i3.u_device_pixel_ratio), u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix) }), collisionBox: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_camera_to_center_distance: new e2.Uniform1f(t3, i3.u_camera_to_center_distance), u_extrude_scale: new e2.Uniform2f(t3, i3.u_extrude_scale) }), collisionCircle: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_inv_matrix: new e2.UniformMatrix4f(t3, i3.u_inv_matrix), u_camera_to_center_distance: new e2.Uniform1f(t3, i3.u_camera_to_center_distance), u_viewport_size: new e2.Uniform2f(t3, i3.u_viewport_size) }), debug: (t3, i3) => ({ u_color: new e2.UniformColor(t3, i3.u_color), u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_overlay: new e2.Uniform1i(t3, i3.u_overlay), u_overlay_scale: new e2.Uniform1f(t3, i3.u_overlay_scale) }), clippingMask: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix) }), heatmap: (t3, i3) => ({ u_extrude_scale: new e2.Uniform1f(t3, i3.u_extrude_scale), u_intensity: new e2.Uniform1f(t3, i3.u_intensity), u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix) }), heatmapTexture: (t3, i3) => ({ u_image: new e2.Uniform1i(t3, i3.u_image), u_color_ramp: new e2.Uniform1i(t3, i3.u_color_ramp), u_opacity: new e2.Uniform1f(t3, i3.u_opacity) }), hillshade: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_image: new e2.Uniform1i(t3, i3.u_image), u_latrange: new e2.Uniform2f(t3, i3.u_latrange), u_light: new e2.Uniform2f(t3, i3.u_light), u_shadow: new e2.UniformColor(t3, i3.u_shadow), u_highlight: new e2.UniformColor(t3, i3.u_highlight), u_accent: new e2.UniformColor(t3, i3.u_accent) }), hillshadePrepare: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_image: new e2.Uniform1i(t3, i3.u_image), u_dimension: new e2.Uniform2f(t3, i3.u_dimension), u_zoom: new e2.Uniform1f(t3, i3.u_zoom), u_unpack: new e2.Uniform4f(t3, i3.u_unpack) }), line: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_pixels_to_tile_units: new e2.UniformMatrix2f(t3, i3.u_pixels_to_tile_units), u_device_pixel_ratio: new e2.Uniform1f(t3, i3.u_device_pixel_ratio), u_units_to_pixels: new e2.Uniform2f(t3, i3.u_units_to_pixels), u_dash_image: new e2.Uniform1i(t3, i3.u_dash_image), u_gradient_image: new e2.Uniform1i(t3, i3.u_gradient_image), u_image_height: new e2.Uniform1f(t3, i3.u_image_height), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_scale: new e2.Uniform3f(t3, i3.u_scale), u_mix: new e2.Uniform1f(t3, i3.u_mix), u_alpha_discard_threshold: new e2.Uniform1f(t3, i3.u_alpha_discard_threshold) }), linePattern: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_pixels_to_tile_units: new e2.UniformMatrix2f(t3, i3.u_pixels_to_tile_units), u_device_pixel_ratio: new e2.Uniform1f(t3, i3.u_device_pixel_ratio), u_image: new e2.Uniform1i(t3, i3.u_image), u_units_to_pixels: new e2.Uniform2f(t3, i3.u_units_to_pixels), u_scale: new e2.Uniform3f(t3, i3.u_scale), u_fade: new e2.Uniform1f(t3, i3.u_fade), u_alpha_discard_threshold: new e2.Uniform1f(t3, i3.u_alpha_discard_threshold) }), raster: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_tl_parent: new e2.Uniform2f(t3, i3.u_tl_parent), u_scale_parent: new e2.Uniform1f(t3, i3.u_scale_parent), u_fade_t: new e2.Uniform1f(t3, i3.u_fade_t), u_opacity: new e2.Uniform1f(t3, i3.u_opacity), u_image0: new e2.Uniform1i(t3, i3.u_image0), u_image1: new e2.Uniform1i(t3, i3.u_image1), u_brightness_low: new e2.Uniform1f(t3, i3.u_brightness_low), u_brightness_high: new e2.Uniform1f(t3, i3.u_brightness_high), u_saturation_factor: new e2.Uniform1f(t3, i3.u_saturation_factor), u_contrast_factor: new e2.Uniform1f(t3, i3.u_contrast_factor), u_spin_weights: new e2.Uniform3f(t3, i3.u_spin_weights), u_perspective_transform: new e2.Uniform2f(t3, i3.u_perspective_transform) }), symbolIcon: (t3, i3) => ({ u_is_size_zoom_constant: new e2.Uniform1i(t3, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new e2.Uniform1i(t3, i3.u_is_size_feature_constant), u_size_t: new e2.Uniform1f(t3, i3.u_size_t), u_size: new e2.Uniform1f(t3, i3.u_size), u_camera_to_center_distance: new e2.Uniform1f(t3, i3.u_camera_to_center_distance), u_pitch: new e2.Uniform1f(t3, i3.u_pitch), u_rotate_symbol: new e2.Uniform1i(t3, i3.u_rotate_symbol), u_aspect_ratio: new e2.Uniform1f(t3, i3.u_aspect_ratio), u_fade_change: new e2.Uniform1f(t3, i3.u_fade_change), u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_label_plane_matrix: new e2.UniformMatrix4f(t3, i3.u_label_plane_matrix), u_coord_matrix: new e2.UniformMatrix4f(t3, i3.u_coord_matrix), u_is_text: new e2.Uniform1i(t3, i3.u_is_text), u_pitch_with_map: new e2.Uniform1i(t3, i3.u_pitch_with_map), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_tile_id: new e2.Uniform3f(t3, i3.u_tile_id), u_zoom_transition: new e2.Uniform1f(t3, i3.u_zoom_transition), u_inv_rot_matrix: new e2.UniformMatrix4f(t3, i3.u_inv_rot_matrix), u_merc_center: new e2.Uniform2f(t3, i3.u_merc_center), u_texture: new e2.Uniform1i(t3, i3.u_texture) }), symbolSDF: (t3, i3) => ({ u_is_size_zoom_constant: new e2.Uniform1i(t3, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new e2.Uniform1i(t3, i3.u_is_size_feature_constant), u_size_t: new e2.Uniform1f(t3, i3.u_size_t), u_size: new e2.Uniform1f(t3, i3.u_size), u_camera_to_center_distance: new e2.Uniform1f(t3, i3.u_camera_to_center_distance), u_pitch: new e2.Uniform1f(t3, i3.u_pitch), u_rotate_symbol: new e2.Uniform1i(t3, i3.u_rotate_symbol), u_aspect_ratio: new e2.Uniform1f(t3, i3.u_aspect_ratio), u_fade_change: new e2.Uniform1f(t3, i3.u_fade_change), u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_label_plane_matrix: new e2.UniformMatrix4f(t3, i3.u_label_plane_matrix), u_coord_matrix: new e2.UniformMatrix4f(t3, i3.u_coord_matrix), u_is_text: new e2.Uniform1i(t3, i3.u_is_text), u_pitch_with_map: new e2.Uniform1i(t3, i3.u_pitch_with_map), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_texture: new e2.Uniform1i(t3, i3.u_texture), u_gamma_scale: new e2.Uniform1f(t3, i3.u_gamma_scale), u_device_pixel_ratio: new e2.Uniform1f(t3, i3.u_device_pixel_ratio), u_tile_id: new e2.Uniform3f(t3, i3.u_tile_id), u_zoom_transition: new e2.Uniform1f(t3, i3.u_zoom_transition), u_inv_rot_matrix: new e2.UniformMatrix4f(t3, i3.u_inv_rot_matrix), u_merc_center: new e2.Uniform2f(t3, i3.u_merc_center), u_is_halo: new e2.Uniform1i(t3, i3.u_is_halo) }), symbolTextAndIcon: (t3, i3) => ({ u_is_size_zoom_constant: new e2.Uniform1i(t3, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new e2.Uniform1i(t3, i3.u_is_size_feature_constant), u_size_t: new e2.Uniform1f(t3, i3.u_size_t), u_size: new e2.Uniform1f(t3, i3.u_size), u_camera_to_center_distance: new e2.Uniform1f(t3, i3.u_camera_to_center_distance), u_pitch: new e2.Uniform1f(t3, i3.u_pitch), u_rotate_symbol: new e2.Uniform1i(t3, i3.u_rotate_symbol), u_aspect_ratio: new e2.Uniform1f(t3, i3.u_aspect_ratio), u_fade_change: new e2.Uniform1f(t3, i3.u_fade_change), u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_label_plane_matrix: new e2.UniformMatrix4f(t3, i3.u_label_plane_matrix), u_coord_matrix: new e2.UniformMatrix4f(t3, i3.u_coord_matrix), u_is_text: new e2.Uniform1i(t3, i3.u_is_text), u_pitch_with_map: new e2.Uniform1i(t3, i3.u_pitch_with_map), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_texsize_icon: new e2.Uniform2f(t3, i3.u_texsize_icon), u_texture: new e2.Uniform1i(t3, i3.u_texture), u_texture_icon: new e2.Uniform1i(t3, i3.u_texture_icon), u_gamma_scale: new e2.Uniform1f(t3, i3.u_gamma_scale), u_device_pixel_ratio: new e2.Uniform1f(t3, i3.u_device_pixel_ratio), u_is_halo: new e2.Uniform1i(t3, i3.u_is_halo) }), background: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_opacity: new e2.Uniform1f(t3, i3.u_opacity), u_color: new e2.UniformColor(t3, i3.u_color) }), backgroundPattern: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_opacity: new e2.Uniform1f(t3, i3.u_opacity), u_image: new e2.Uniform1i(t3, i3.u_image), u_pattern_tl_a: new e2.Uniform2f(t3, i3.u_pattern_tl_a), u_pattern_br_a: new e2.Uniform2f(t3, i3.u_pattern_br_a), u_pattern_tl_b: new e2.Uniform2f(t3, i3.u_pattern_tl_b), u_pattern_br_b: new e2.Uniform2f(t3, i3.u_pattern_br_b), u_texsize: new e2.Uniform2f(t3, i3.u_texsize), u_mix: new e2.Uniform1f(t3, i3.u_mix), u_pattern_size_a: new e2.Uniform2f(t3, i3.u_pattern_size_a), u_pattern_size_b: new e2.Uniform2f(t3, i3.u_pattern_size_b), u_scale_a: new e2.Uniform1f(t3, i3.u_scale_a), u_scale_b: new e2.Uniform1f(t3, i3.u_scale_b), u_pixel_coord_upper: new e2.Uniform2f(t3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new e2.Uniform2f(t3, i3.u_pixel_coord_lower), u_tile_units_to_pixels: new e2.Uniform1f(t3, i3.u_tile_units_to_pixels) }), terrainRaster: ei, terrainDepth: ei, skybox: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_sun_direction: new e2.Uniform3f(t3, i3.u_sun_direction), u_cubemap: new e2.Uniform1i(t3, i3.u_cubemap), u_opacity: new e2.Uniform1f(t3, i3.u_opacity), u_temporal_offset: new e2.Uniform1f(t3, i3.u_temporal_offset) }), skyboxGradient: (t3, i3) => ({ u_matrix: new e2.UniformMatrix4f(t3, i3.u_matrix), u_color_ramp: new e2.Uniform1i(t3, i3.u_color_ramp), u_center_direction: new e2.Uniform3f(t3, i3.u_center_direction), u_radius: new e2.Uniform1f(t3, i3.u_radius), u_opacity: new e2.Uniform1f(t3, i3.u_opacity), u_temporal_offset: new e2.Uniform1f(t3, i3.u_temporal_offset) }), skyboxCapture: (t3, i3) => ({ u_matrix_3f: new e2.UniformMatrix3f(t3, i3.u_matrix_3f), u_sun_direction: new e2.Uniform3f(t3, i3.u_sun_direction), u_sun_intensity: new e2.Uniform1f(t3, i3.u_sun_intensity), u_color_tint_r: new e2.Uniform4f(t3, i3.u_color_tint_r), u_color_tint_m: new e2.Uniform4f(t3, i3.u_color_tint_m), u_luminance: new e2.Uniform1f(t3, i3.u_luminance) }), globeRaster: (t3, i3) => ({ u_proj_matrix: new e2.UniformMatrix4f(t3, i3.u_proj_matrix), u_globe_matrix: new e2.UniformMatrix4f(t3, i3.u_globe_matrix), u_merc_matrix: new e2.UniformMatrix4f(t3, i3.u_merc_matrix), u_zoom_transition: new e2.Uniform1f(t3, i3.u_zoom_transition), u_merc_center: new e2.Uniform2f(t3, i3.u_merc_center), u_image0: new e2.Uniform1i(t3, i3.u_image0) }), globeAtmosphere: (t3, i3) => ({ u_center: new e2.Uniform2f(t3, i3.u_center), u_radius: new e2.Uniform1f(t3, i3.u_radius), u_screen_size: new e2.Uniform2f(t3, i3.u_screen_size), u_pixel_ratio: new e2.Uniform1f(t3, i3.u_pixel_ratio), u_opacity: new e2.Uniform1f(t3, i3.u_opacity), u_fadeout_range: new e2.Uniform1f(t3, i3.u_fadeout_range), u_start_color: new e2.Uniform3f(t3, i3.u_start_color), u_end_color: new e2.Uniform3f(t3, i3.u_end_color) }) };
        let Ni;
        function Gi(t3, i3, o2, r3, n2, a2, s4) {
          const l2 = t3.context, c2 = l2.gl, h3 = t3.useProgram("collisionBox"), u2 = [];
          let _2 = 0, d2 = 0;
          for (let p3 = 0; p3 < r3.length; p3++) {
            const m4 = r3[p3], f5 = i3.getTile(m4), g3 = f5.getBucket(o2);
            if (!g3)
              continue;
            let v3 = m4.projMatrix;
            n2[0] === 0 && n2[1] === 0 || (v3 = t3.translatePosMatrix(m4.projMatrix, f5, n2, a2));
            const x4 = s4 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
            if (y2.length > 0) {
              const i4 = e2.create(), o3 = v3;
              e2.mul(i4, g3.placementInvProjMatrix, t3.transform.glCoordMatrix), e2.mul(i4, i4, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: d2, transform: o3, invTransform: i4 }), _2 += y2.length / 4, d2 = _2;
            }
            x4 && (t3.terrain && t3.terrain.setupElevationDraw(f5, h3), h3.draw(l2, c2.LINES, e2.DepthMode.disabled, e2.StencilMode.disabled, t3.colorModeForRenderPass(), e2.CullFaceMode.disabled, Ei(v3, t3.transform, f5), o2.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, t3.transform.zoom, null, x4.collisionVertexBuffer, x4.collisionVertexBufferExt));
          }
          if (!s4 || !u2.length)
            return;
          const p2 = t3.useProgram("collisionCircle"), m3 = new e2.StructArrayLayout2f1f2i16();
          m3.resize(4 * _2), m3._trim();
          let f4 = 0;
          for (const e3 of u2)
            for (let t4 = 0; t4 < e3.circleArray.length / 4; t4++) {
              const i4 = 4 * t4, o3 = e3.circleArray[i4 + 0], r4 = e3.circleArray[i4 + 1], n3 = e3.circleArray[i4 + 2], a3 = e3.circleArray[i4 + 3];
              m3.emplace(f4++, o3, r4, n3, a3, 0), m3.emplace(f4++, o3, r4, n3, a3, 1), m3.emplace(f4++, o3, r4, n3, a3, 2), m3.emplace(f4++, o3, r4, n3, a3, 3);
            }
          (!Ni || Ni.length < 2 * _2) && (Ni = function(t4) {
            const i4 = 2 * t4, o3 = new e2.StructArrayLayout3ui6();
            o3.resize(i4), o3._trim();
            for (let e3 = 0; e3 < i4; e3++) {
              const t5 = 6 * e3;
              o3.uint16[t5 + 0] = 4 * e3 + 0, o3.uint16[t5 + 1] = 4 * e3 + 1, o3.uint16[t5 + 2] = 4 * e3 + 2, o3.uint16[t5 + 3] = 4 * e3 + 2, o3.uint16[t5 + 4] = 4 * e3 + 3, o3.uint16[t5 + 5] = 4 * e3 + 0;
            }
            return o3;
          }(_2));
          const g2 = l2.createIndexBuffer(Ni, true), v2 = l2.createVertexBuffer(m3, e2.collisionCircleLayout.members, true);
          for (const i4 of u2) {
            const r4 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (x3 = t3.transform).cameraToCenterDistance, u_viewport_size: [x3.width, x3.height] };
            p2.draw(l2, c2.TRIANGLES, e2.DepthMode.disabled, e2.StencilMode.disabled, t3.colorModeForRenderPass(), e2.CullFaceMode.disabled, r4, o2.id, v2, g2, e2.SegmentVector.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, t3.transform.zoom, null, null, null);
          }
          var x3;
          v2.destroy(), g2.destroy();
        }
        const ji = e2.identity(new Float32Array(16));
        function Zi(t3, i3, o2, r3, n2, a2) {
          const { horizontalAlign: s4, verticalAlign: l2 } = e2.getAnchorAlignment(t3), c2 = -(s4 - 0.5) * i3, h3 = -(l2 - 0.5) * o2, u2 = e2.evaluateVariableOffset(t3, r3);
          return new e2.pointGeometry((c2 / n2 + u2[0]) * a2, (h3 / n2 + u2[1]) * a2);
        }
        function Vi(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2) {
          const d2 = t3.text.placedSymbolArray, p2 = t3.text.dynamicLayoutVertexArray, m3 = t3.icon.dynamicLayoutVertexArray, f4 = {}, g2 = l2.projMatrix, v2 = a2.elevation, x3 = v2 ? v2.getAtTileOffsetFunc(l2, _2) : (e3) => [0, 0, 0];
          p2.clear();
          for (let l3 = 0; l3 < d2.length; l3++) {
            const _3 = d2.get(l3), m4 = t3.allowVerticalPlacement && !_3.placedOrientation, v3 = _3.hidden || !_3.crossTileID || m4 ? null : r3[_3.crossTileID];
            if (v3) {
              const r4 = new e2.pointGeometry(_3.tileAnchorX, _3.tileAnchorY), l4 = x3(r4), d3 = $e(r4, o2 ? g2 : s4, l4[2]), m5 = He(a2.cameraToCenterDistance, d3.signedDistanceFromCamera);
              let y2 = n2.evaluateSizeForFeature(t3.textSizeData, h3, _3) * m5 / e2.ONE_EM;
              o2 && (y2 *= t3.tilePixelRatio / c2);
              const { width: b2, height: w2, anchor: T2, textOffset: E2, textScale: C2 } = v3, M2 = Zi(T2, b2, w2, E2, C2, y2), S3 = o2 ? $e(r4.add(M2), s4, l4[2]).point : d3.point.add(i3 ? M2.rotate(-a2.angle) : M2), I2 = t3.allowVerticalPlacement && _3.placedOrientation === e2.WritingMode.vertical ? Math.PI / 2 : 0;
              for (let t4 = 0; t4 < _3.numGlyphs; t4++)
                e2.addDynamicAttributes(p2, S3, I2);
              u2 && _3.associatedIconIndex >= 0 && (f4[_3.associatedIconIndex] = { shiftedAnchor: S3, angle: I2 });
            } else
              nt(_3.numGlyphs, p2);
          }
          if (u2) {
            m3.clear();
            const i4 = t3.icon.placedSymbolArray;
            for (let t4 = 0; t4 < i4.length; t4++) {
              const o3 = i4.get(t4);
              if (o3.hidden)
                nt(o3.numGlyphs, m3);
              else {
                const i5 = f4[t4];
                if (i5)
                  for (let t5 = 0; t5 < o3.numGlyphs; t5++)
                    e2.addDynamicAttributes(m3, i5.shiftedAnchor, i5.angle);
                else
                  nt(o3.numGlyphs, m3);
              }
            }
            t3.icon.dynamicLayoutVertexBuffer.updateData(m3);
          }
          t3.text.dynamicLayoutVertexBuffer.updateData(p2);
        }
        function Wi(e3, t3, i3) {
          return i3.iconsInText && t3 ? "symbolTextAndIcon" : e3 ? "symbolSDF" : "symbolIcon";
        }
        function qi(t3, i3, o2, r3, n2, a2, s4, l2, c2, h3, u2, _2) {
          const d2 = t3.context, p2 = d2.gl, m3 = t3.transform, f4 = m3.projection.createTileTransform(m3, m3.worldSize), g2 = l2 === "map", v2 = c2 === "map", x3 = g2 && o2.layout.get("symbol-placement") !== "point", y2 = g2 && !v2 && !x3, b2 = o2.layout.get("symbol-sort-key").constantOr(1) !== void 0;
          let w2 = false;
          const T2 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), E2 = [e2.mercatorXfromLng(m3.center.lng), e2.mercatorYfromLat(m3.center.lat)], C2 = o2.layout.get("text-variable-anchor"), M2 = m3.projection.name === "globe", S3 = M2 ? e2.globeToMercatorTransition(m3.zoom) : 0, I2 = [], z2 = [];
          t3.terrain && v2 && z2.push("PITCH_WITH_MAP_TERRAIN"), M2 && z2.push("PROJECTION_GLOBE_VIEW"), x3 && z2.push("PROJECTED_POS_ON_VIEWPORT");
          for (const l3 of r3) {
            const r4 = i3.getTile(l3), c3 = r4.getBucket(o2);
            if (!c3 || c3.projection !== m3.projection.name)
              continue;
            const u3 = n2 ? c3.text : c3.icon;
            if (!u3 || c3.fullyClipped || !u3.segments.get().length)
              continue;
            const _3 = u3.programConfigurations.get(o2.id), d3 = n2 || c3.sdfIcons, T3 = n2 ? c3.textSizeData : c3.iconSizeData, M3 = v2 || m3.pitch !== 0, D2 = t3.useProgram(Wi(d3, n2, c3), _3, z2), P2 = e2.evaluateSizeForZoom(T3, m3.zoom), A3 = [l3.canonical.x, l3.canonical.y, 1 << l3.canonical.z];
            let L2, R2, k2, O2, B2 = [0, 0], F3 = null;
            if (n2) {
              if (R2 = r4.glyphAtlasTexture, k2 = p2.LINEAR, L2 = r4.glyphAtlasTexture.size, c3.iconsInText) {
                B2 = r4.imageAtlasTexture.size, F3 = r4.imageAtlasTexture;
                const e3 = T3.kind === "composite" || T3.kind === "camera";
                O2 = M3 || t3.options.rotating || t3.options.zooming || e3 ? p2.LINEAR : p2.NEAREST;
              }
            } else {
              const e3 = o2.layout.get("icon-size").constantOr(0) !== 1 || c3.iconsNeedLinear;
              R2 = r4.imageAtlasTexture, k2 = d3 || t3.options.rotating || t3.options.zooming || e3 || M3 ? p2.LINEAR : p2.NEAREST, L2 = r4.imageAtlasTexture.size;
            }
            const U2 = t3.transform.calculatePixelsToTileUnitsMatrix(r4), N2 = qe(l3.projMatrix, r4.tileID.canonical, v2, g2, t3.transform, U2), G2 = t3.terrain && v2 && x3 ? e2.invert(new Float32Array(16), N2) : ji, j2 = Xe(l3.projMatrix, r4.tileID.canonical, v2, g2, t3.transform, U2), Z3 = C2 && c3.hasTextData(), V2 = o2.layout.get("icon-text-fit") !== "none" && Z3 && c3.hasIconData();
            if (x3) {
              const e3 = m3.elevation, i4 = e3 ? e3.getAtTileOffsetFunc(l3, f4) : (e4) => [0, 0, 0];
              Ye(c3, l3.projMatrix, t3, n2, N2, j2, v2, h3, i4, l3);
            }
            const W2 = t3.translatePosMatrix(l3.projMatrix, r4, a2, s4), q2 = x3 || n2 && C2 || V2 ? ji : N2, X2 = t3.translatePosMatrix(j2, r4, a2, s4, true), $2 = d3 && o2.paint.get(n2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let H2;
            const K2 = f4.createInversionMatrix(l3.toUnwrapped());
            H2 = d3 ? c3.iconsInText ? Oi(T3.kind, P2, y2, v2, t3, W2, q2, X2, L2, B2, A3, S3, K2, E2) : ki(T3.kind, P2, y2, v2, t3, W2, q2, X2, n2, L2, true, A3, S3, K2, E2) : Ri(T3.kind, P2, y2, v2, t3, W2, q2, X2, n2, L2, A3, S3, K2, E2);
            const Y2 = { program: D2, buffers: u3, uniformValues: H2, atlasTexture: R2, atlasTextureIcon: F3, atlasInterpolation: k2, atlasInterpolationIcon: O2, isSDF: d3, hasHalo: $2, tile: r4, labelPlaneMatrixInv: G2 };
            if (b2 && c3.canOverlap) {
              w2 = true;
              const t4 = u3.segments.get();
              for (const i4 of t4)
                I2.push({ segments: new e2.SegmentVector([i4]), sortKey: i4.sortKey, state: Y2 });
            } else
              I2.push({ segments: u3.segments, sortKey: 0, state: Y2 });
          }
          w2 && I2.sort((e3, t4) => e3.sortKey - t4.sortKey);
          for (const e3 of I2) {
            const i4 = e3.state;
            if (t3.terrain && t3.terrain.setupElevationDraw(i4.tile, i4.program, { useDepthForOcclusion: !M2, labelPlaneMatrixInv: i4.labelPlaneMatrixInv }), d2.activeTexture.set(p2.TEXTURE0), i4.atlasTexture.bind(i4.atlasInterpolation, p2.CLAMP_TO_EDGE), i4.atlasTextureIcon && (d2.activeTexture.set(p2.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i4.isSDF) {
              const r4 = i4.uniformValues;
              i4.hasHalo && (r4.u_is_halo = 1, Xi(i4.buffers, e3.segments, o2, t3, i4.program, T2, u2, _2, r4)), r4.u_is_halo = 0;
            }
            Xi(i4.buffers, e3.segments, o2, t3, i4.program, T2, u2, _2, i4.uniformValues);
          }
        }
        function Xi(t3, i3, o2, r3, n2, a2, s4, l2, c2) {
          const h3 = r3.context;
          n2.draw(h3, h3.gl.TRIANGLES, a2, s4, l2, e2.CullFaceMode.disabled, c2, o2.id, t3.layoutVertexBuffer, t3.indexBuffer, i3, o2.paint, r3.transform.zoom, t3.programConfigurations.get(o2.id), t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer);
        }
        function $i(t3, i3, o2, r3, n2, a2, s4) {
          const l2 = t3.context.gl, c2 = o2.paint.get("fill-pattern"), h3 = c2 && c2.constantOr(1), u2 = o2.getCrossfadeParameters();
          let _2, d2, p2, m3, f4;
          s4 ? (d2 = h3 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", _2 = l2.LINES) : (d2 = h3 ? "fillPattern" : "fill", _2 = l2.TRIANGLES);
          for (const g2 of r3) {
            const r4 = i3.getTile(g2);
            if (h3 && !r4.patternsLoaded())
              continue;
            const v2 = r4.getBucket(o2);
            if (!v2)
              continue;
            t3.prepareDrawTile(g2);
            const x3 = v2.programConfigurations.get(o2.id), y2 = t3.useProgram(d2, x3);
            h3 && (t3.context.activeTexture.set(l2.TEXTURE0), r4.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), x3.updatePaintBuffers(u2));
            const b2 = c2.constantOr(null);
            if (b2 && r4.imageAtlas) {
              const e3 = r4.imageAtlas, t4 = e3.patternPositions[b2.to.toString()], i4 = e3.patternPositions[b2.from.toString()];
              t4 && i4 && x3.setConstantPatternPositions(t4, i4);
            }
            const w2 = t3.translatePosMatrix(g2.projMatrix, r4, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
            if (s4) {
              m3 = v2.indexBuffer2, f4 = v2.segments2;
              const e3 = t3.terrain && t3.terrain.renderingToTexture ? t3.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
              p2 = d2 === "fillOutlinePattern" && h3 ? bi(w2, t3, u2, r4, e3) : yi(w2, e3);
            } else
              m3 = v2.indexBuffer, f4 = v2.segments, p2 = h3 ? xi(w2, t3, u2, r4) : vi(w2);
            t3.prepareDrawProgram(t3.context, y2, g2.toUnwrapped()), y2.draw(t3.context, _2, n2, t3.stencilModeForClipping(g2), a2, e2.CullFaceMode.disabled, p2, o2.id, v2.layoutVertexBuffer, m3, f4, o2.paint, t3.transform.zoom, x3);
          }
        }
        function Hi(t3, i3, o2, r3, n2, a2, s4) {
          const l2 = t3.context, c2 = l2.gl, h3 = o2.paint.get("fill-extrusion-pattern"), u2 = h3.constantOr(1), _2 = o2.getCrossfadeParameters(), d2 = o2.paint.get("fill-extrusion-opacity");
          for (const p2 of r3) {
            const r4 = i3.getTile(p2), m3 = r4.getBucket(o2);
            if (!m3)
              continue;
            const f4 = m3.programConfigurations.get(o2.id), g2 = t3.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", f4);
            if (t3.terrain) {
              const e3 = t3.terrain;
              if (!m3.enableTerrain)
                continue;
              if (e3.setupElevationDraw(r4, g2, { useMeterToDem: true }), Ki(l2, i3, p2, m3, o2, e3), !m3.centroidVertexBuffer) {
                const e4 = g2.attributes.a_centroid_pos;
                e4 !== void 0 && c2.vertexAttrib2f(e4, 0, 0);
              }
            }
            u2 && (t3.context.activeTexture.set(c2.TEXTURE0), r4.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), f4.updatePaintBuffers(_2));
            const v2 = h3.constantOr(null);
            if (v2 && r4.imageAtlas) {
              const e3 = r4.imageAtlas, t4 = e3.patternPositions[v2.to.toString()], i4 = e3.patternPositions[v2.from.toString()];
              t4 && i4 && f4.setConstantPatternPositions(t4, i4);
            }
            const x3 = t3.translatePosMatrix(p2.projMatrix, r4, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), y2 = o2.paint.get("fill-extrusion-vertical-gradient"), b2 = u2 ? gi(x3, t3, y2, d2, p2, _2, r4) : fi(x3, t3, y2, d2);
            t3.prepareDrawProgram(l2, g2, p2.toUnwrapped()), g2.draw(l2, l2.gl.TRIANGLES, n2, a2, s4, e2.CullFaceMode.backCCW, b2, o2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, o2.paint, t3.transform.zoom, f4, t3.terrain ? m3.centroidVertexBuffer : null);
          }
        }
        function Ki(t3, i3, o2, r3, n2, a2) {
          const s4 = [(t4) => {
            let i4 = t4.canonical.x - 1, o3 = t4.wrap;
            return i4 < 0 && (i4 = (1 << t4.canonical.z) - 1, o3--), new e2.OverscaledTileID(t4.overscaledZ, o3, t4.canonical.z, i4, t4.canonical.y);
          }, (t4) => {
            let i4 = t4.canonical.x + 1, o3 = t4.wrap;
            return i4 === 1 << t4.canonical.z && (i4 = 0, o3++), new e2.OverscaledTileID(t4.overscaledZ, o3, t4.canonical.z, i4, t4.canonical.y);
          }, (t4) => new e2.OverscaledTileID(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, (t4.canonical.y === 0 ? 1 << t4.canonical.z : t4.canonical.y) - 1), (t4) => new e2.OverscaledTileID(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y === (1 << t4.canonical.z) - 1 ? 0 : t4.canonical.y + 1)], l2 = (e3) => {
            const t4 = i3.getSource().maxzoom, o3 = (e4) => {
              const t5 = i3.getTileByID(e4);
              if (t5 && t5.hasData())
                return t5.getBucket(n2);
            };
            let r4, a3, s5;
            return (e3.overscaledZ === e3.canonical.z || e3.overscaledZ >= t4) && (r4 = o3(e3.key)), e3.overscaledZ >= t4 && (a3 = o3(e3.calculateScaledKey(e3.overscaledZ + 1))), e3.overscaledZ > t4 && (s5 = o3(e3.calculateScaledKey(e3.overscaledZ - 1))), r4 || a3 || s5;
          }, c2 = [0, 0, 0], h3 = (t4, i4) => (c2[0] = Math.min(t4.min.y, i4.min.y), c2[1] = Math.max(t4.max.y, i4.max.y), c2[2] = e2.EXTENT - i4.min.x > t4.max.x ? i4.min.x - e2.EXTENT : t4.max.x, c2), u2 = (t4, i4) => (c2[0] = Math.min(t4.min.x, i4.min.x), c2[1] = Math.max(t4.max.x, i4.max.x), c2[2] = e2.EXTENT - i4.min.y > t4.max.y ? i4.min.y - e2.EXTENT : t4.max.y, c2), _2 = [(e3, t4) => h3(e3, t4), (e3, t4) => h3(t4, e3), (e3, t4) => u2(e3, t4), (e3, t4) => u2(t4, e3)], d2 = new e2.pointGeometry(0, 0);
          let p2, m3, f4;
          const g2 = (t4, i4, r4, n3, s5) => {
            const l3 = [[n3 ? r4 : t4, n3 ? t4 : r4, 0], [n3 ? r4 : i4, n3 ? i4 : r4, 0]], c3 = s5 < 0 ? e2.EXTENT + s5 : s5, h4 = [n3 ? c3 : (t4 + i4) / 2, n3 ? (t4 + i4) / 2 : c3, 0];
            return r4 === 0 && s5 < 0 || r4 !== 0 && s5 > 0 ? a2.getForTilePoints(f4, [h4], true, m3) : l3.push(h4), a2.getForTilePoints(o2, l3, true, p2), Math.max(l3[0][2], l3[1][2], h4[2]) / a2.exaggeration();
          };
          for (let t4 = 0; t4 < 4; t4++) {
            const i4 = r3.borders[t4];
            if (i4.length === 0 && (r3.borderDone[t4] = true), r3.borderDone[t4])
              continue;
            const n3 = f4 = s4[t4](o2), c3 = l2(n3);
            if (!c3 || !c3.enableTerrain)
              continue;
            if (m3 = a2.findDEMTileFor(n3), !m3 || !m3.dem)
              continue;
            if (!p2) {
              const e3 = a2.findDEMTileFor(o2);
              if (!e3 || !e3.dem)
                return;
              p2 = e3;
            }
            const h4 = (t4 < 2 ? 1 : 5) - t4, u3 = c3.borders[h4];
            let v2 = 0;
            for (let o3 = 0; o3 < i4.length; o3++) {
              const n4 = r3.featuresOnBorder[i4[o3]], a3 = n4.borders[t4];
              let s5;
              for (; v2 < u3.length && (s5 = c3.featuresOnBorder[u3[v2]], !(s5.borders[h4][1] > a3[0] + 3)); )
                c3.borderDone[h4] || c3.encodeCentroid(void 0, s5, false), v2++;
              if (s5 && v2 < u3.length) {
                const i5 = v2;
                let o4 = 0;
                for (; !(s5.borders[h4][0] > a3[1] - 3) && (o4++, ++v2 !== u3.length); )
                  s5 = c3.featuresOnBorder[u3[v2]];
                if (s5 = c3.featuresOnBorder[u3[i5]], n4.intersectsCount() > 1 || s5.intersectsCount() > 1 || o4 !== 1) {
                  o4 !== 1 && (v2 = i5), r3.encodeCentroid(void 0, n4, false), c3.borderDone[h4] || c3.encodeCentroid(void 0, s5, false);
                  continue;
                }
                const l3 = _2[t4](n4, s5), p3 = t4 % 2 ? e2.EXTENT - 1 : 0;
                d2.x = g2(l3[0], Math.min(e2.EXTENT - 1, l3[1]), p3, t4 < 2, l3[2]), d2.y = 0, r3.encodeCentroid(d2, n4, false), c3.borderDone[h4] || c3.encodeCentroid(d2, s5, false);
              } else
                r3.encodeCentroid(void 0, n4, false);
            }
            r3.borderDone[t4] = r3.needsCentroidUpdate = true, c3.borderDone[h4] || (c3.borderDone[h4] = c3.needsCentroidUpdate = true);
          }
          (r3.needsCentroidUpdate || !r3.centroidVertexBuffer && r3.centroidVertexArray.length !== 0) && r3.uploadCentroid(t3);
        }
        const Yi = new e2.Color(1, 0, 0, 1), Ji = new e2.Color(0, 1, 0, 1), Qi = new e2.Color(0, 0, 1, 1), eo = new e2.Color(1, 0, 1, 1), to = new e2.Color(0, 1, 1, 1);
        function io(e3, t3, i3, o2) {
          ro(e3, 0, t3 + i3 / 2, e3.transform.width, i3, o2);
        }
        function oo(e3, t3, i3, o2) {
          ro(e3, t3 - i3 / 2, 0, i3, e3.transform.height, o2);
        }
        function ro(t3, i3, o2, r3, n2, a2) {
          const s4 = t3.context, l2 = s4.gl;
          l2.enable(l2.SCISSOR_TEST), l2.scissor(i3 * e2.exported.devicePixelRatio, o2 * e2.exported.devicePixelRatio, r3 * e2.exported.devicePixelRatio, n2 * e2.exported.devicePixelRatio), s4.clear({ color: a2 }), l2.disable(l2.SCISSOR_TEST);
        }
        function no(t3, i3, o2) {
          const r3 = t3.context, n2 = r3.gl, a2 = o2.projMatrix, s4 = t3.useProgram("debug"), l2 = i3.getTileByID(o2.key);
          t3.terrain && t3.terrain.setupElevationDraw(l2, s4);
          const c2 = e2.DepthMode.disabled, h3 = e2.StencilMode.disabled, u2 = t3.colorModeForRenderPass(), _2 = "$debug";
          r3.activeTexture.set(n2.TEXTURE0), t3.emptyTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), l2._makeDebugTileBoundsBuffers(t3.context, t3.transform.projection);
          const d2 = l2._tileDebugBuffer || t3.debugBuffer, p2 = l2._tileDebugIndexBuffer || t3.debugIndexBuffer, m3 = l2._tileDebugSegments || t3.debugSegments;
          s4.draw(r3, n2.LINE_STRIP, c2, h3, u2, e2.CullFaceMode.disabled, Ci(a2, e2.Color.red), _2, d2, p2, m3);
          const f4 = l2.latestRawTileData, g2 = Math.floor((f4 && f4.byteLength || 0) / 1024), v2 = i3.getTile(o2).tileSize, x3 = 512 / Math.min(v2, 512) * (o2.overscaledZ / t3.transform.zoom) * 0.5;
          let y2 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (y2 += ` => ${o2.overscaledZ}`), function(e3, t4) {
            e3.initDebugOverlayCanvas();
            const i4 = e3.debugOverlayCanvas, o3 = e3.context.gl, r4 = e3.debugOverlayCanvas.getContext("2d");
            r4.clearRect(0, 0, i4.width, i4.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(t4, 5, 5), r4.strokeText(t4, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(t3, `${y2} ${g2}kb`), s4.draw(r3, n2.TRIANGLES, c2, h3, e2.ColorMode.alphaBlended, e2.CullFaceMode.disabled, Ci(a2, e2.Color.transparent, x3), _2, t3.debugBuffer, t3.quadTriangleIndexBuffer, t3.debugSegments);
        }
        const ao = e2.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: so } = ao;
        function lo(e3, t3, i3, o2) {
          e3.emplaceBack(t3, i3, o2);
        }
        class co {
          constructor(t3) {
            this.vertexArray = new e2.StructArrayLayout3f12(), this.indices = new e2.StructArrayLayout3ui6(), lo(this.vertexArray, -1, -1, 1), lo(this.vertexArray, 1, -1, 1), lo(this.vertexArray, -1, 1, 1), lo(this.vertexArray, 1, 1, 1), lo(this.vertexArray, -1, -1, -1), lo(this.vertexArray, 1, -1, -1), lo(this.vertexArray, -1, 1, -1), lo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t3.createVertexBuffer(this.vertexArray, so), this.indexBuffer = t3.createIndexBuffer(this.indices), this.segment = e2.SegmentVector.simpleSegment(0, 0, 36, 12);
          }
        }
        function ho(t3, i3, o2, r3, n2, a2) {
          const s4 = t3.gl, l2 = i3.paint.get("sky-atmosphere-color"), c2 = i3.paint.get("sky-atmosphere-halo-color"), h3 = i3.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e3, t4, i4, o3, r4) => ({ u_matrix_3f: e3, u_sun_direction: t4, u_sun_intensity: i4, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r4.r, r4.g, r4.b, r4.a], u_luminance: 5e-5 }))(e2.fromMat4([], r3), n2, h3, l2, c2);
          s4.framebufferTexture2D(s4.FRAMEBUFFER, s4.COLOR_ATTACHMENT0, s4.TEXTURE_CUBE_MAP_POSITIVE_X + a2, i3.skyboxTexture, 0), o2.draw(t3, s4.TRIANGLES, e2.DepthMode.disabled, e2.StencilMode.disabled, e2.ColorMode.unblended, e2.CullFaceMode.frontCW, u2, "skyboxCapture", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }
        const uo = { symbol: function(t3, i3, o2, r3, n2) {
          if (t3.renderPass !== "translucent")
            return;
          const a2 = e2.StencilMode.disabled, s4 = t3.colorModeForRenderPass();
          o2.layout.get("text-variable-anchor") && function(t4, i4, o3, r4, n3, a3, s5) {
            const l2 = i4.transform, c2 = n3 === "map", h3 = a3 === "map", u2 = l2.projection.createTileTransform(l2, l2.worldSize);
            for (const n4 of t4) {
              const t5 = r4.getTile(n4), a4 = t5.getBucket(o3);
              if (!a4 || a4.projection !== l2.projection.name || !a4.text || !a4.text.segments.get().length)
                continue;
              const _2 = e2.evaluateSizeForZoom(a4.textSizeData, l2.zoom), d2 = i4.transform.calculatePixelsToTileUnitsMatrix(t5), p2 = qe(n4.projMatrix, t5.tileID.canonical, h3, c2, i4.transform, d2), m3 = o3.layout.get("icon-text-fit") !== "none" && a4.hasIconData();
              if (_2) {
                const i5 = Math.pow(2, l2.zoom - t5.tileID.overscaledZ);
                Vi(a4, c2, h3, s5, e2.symbolSize, l2, p2, n4, i5, _2, m3, u2);
              }
            }
          }(r3, t3, o2, i3, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n2), o2.paint.get("icon-opacity").constantOr(1) !== 0 && qi(t3, i3, o2, r3, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), a2, s4), o2.paint.get("text-opacity").constantOr(1) !== 0 && qi(t3, i3, o2, r3, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), a2, s4), i3.map.showCollisionBoxes && (Gi(t3, i3, o2, r3, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Gi(t3, i3, o2, r3, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
        }, circle: function(t3, i3, o2, r3) {
          if (t3.renderPass !== "translucent")
            return;
          const n2 = o2.paint.get("circle-opacity"), a2 = o2.paint.get("circle-stroke-width"), s4 = o2.paint.get("circle-stroke-opacity"), l2 = o2.layout.get("circle-sort-key").constantOr(1) !== void 0;
          if (n2.constantOr(1) === 0 && (a2.constantOr(1) === 0 || s4.constantOr(1) === 0))
            return;
          const c2 = t3.context, h3 = c2.gl, u2 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), _2 = e2.StencilMode.disabled, d2 = t3.colorModeForRenderPass(), p2 = [];
          for (let n3 = 0; n3 < r3.length; n3++) {
            const a3 = r3[n3], s5 = i3.getTile(a3), c3 = s5.getBucket(o2);
            if (!c3)
              continue;
            const h4 = c3.programConfigurations.get(o2.id), u3 = Ti(o2), _3 = { programConfiguration: h4, program: t3.useProgram("circle", h4, u3), layoutVertexBuffer: c3.layoutVertexBuffer, indexBuffer: c3.indexBuffer, uniformValues: wi(t3, a3, s5, o2), tile: s5 };
            if (l2) {
              const t4 = c3.segments.get();
              for (const i4 of t4)
                p2.push({ segments: new e2.SegmentVector([i4]), sortKey: i4.sortKey, state: _3 });
            } else
              p2.push({ segments: c3.segments, sortKey: 0, state: _3 });
          }
          l2 && p2.sort((e3, t4) => e3.sortKey - t4.sortKey);
          const m3 = { useDepthForOcclusion: !(t3.transform.projection.name === "globe") };
          for (const i4 of p2) {
            const { programConfiguration: r4, program: n3, layoutVertexBuffer: a3, indexBuffer: s5, uniformValues: l3, tile: p3 } = i4.state, f4 = i4.segments;
            t3.terrain && t3.terrain.setupElevationDraw(p3, n3, m3), t3.prepareDrawProgram(c2, n3, p3.tileID.toUnwrapped()), n3.draw(c2, h3.TRIANGLES, u2, _2, d2, e2.CullFaceMode.disabled, l3, o2.id, a3, s5, f4, o2.paint, t3.transform.zoom, r4);
          }
        }, heatmap: function(t3, i3, o2, r3) {
          if (o2.paint.get("heatmap-opacity") !== 0)
            if (t3.renderPass === "offscreen") {
              const n2 = t3.context, a2 = n2.gl, s4 = e2.StencilMode.disabled, l2 = new e2.ColorMode([a2.ONE, a2.ONE], e2.Color.transparent, [true, true, true, true]);
              !function(e3, t4, i4) {
                const o3 = e3.gl;
                e3.activeTexture.set(o3.TEXTURE1), e3.viewport.set([0, 0, t4.width / 4, t4.height / 4]);
                let r4 = i4.heatmapFbo;
                if (r4)
                  o3.bindTexture(o3.TEXTURE_2D, r4.colorAttachment.get()), e3.bindFramebuffer.set(r4.framebuffer);
                else {
                  const n3 = o3.createTexture();
                  o3.bindTexture(o3.TEXTURE_2D, n3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r4 = i4.heatmapFbo = e3.createFramebuffer(t4.width / 4, t4.height / 4, false), function(e4, t5, i5, o4) {
                    const r5 = e4.gl;
                    r5.texImage2D(r5.TEXTURE_2D, 0, r5.RGBA, t5.width / 4, t5.height / 4, 0, r5.RGBA, e4.extRenderToTextureHalfFloat ? e4.extTextureHalfFloat.HALF_FLOAT_OES : r5.UNSIGNED_BYTE, null), o4.colorAttachment.set(i5);
                  }(e3, t4, n3, r4);
                }
              }(n2, t3, o2), n2.clear({ color: e2.Color.transparent });
              for (let c2 = 0; c2 < r3.length; c2++) {
                const h3 = r3[c2];
                if (i3.hasRenderableParent(h3))
                  continue;
                const u2 = i3.getTile(h3), _2 = u2.getBucket(o2);
                if (!_2)
                  continue;
                const d2 = _2.programConfigurations.get(o2.id), p2 = t3.useProgram("heatmap", d2), { zoom: m3 } = t3.transform;
                t3.terrain && t3.terrain.setupElevationDraw(u2, p2), t3.prepareDrawProgram(n2, p2, h3.toUnwrapped()), p2.draw(n2, a2.TRIANGLES, e2.DepthMode.disabled, s4, l2, e2.CullFaceMode.disabled, Mi(h3.projMatrix, u2, m3, o2.paint.get("heatmap-intensity")), o2.id, _2.layoutVertexBuffer, _2.indexBuffer, _2.segments, o2.paint, t3.transform.zoom, d2);
              }
              n2.viewport.set([0, 0, t3.width, t3.height]);
            } else
              t3.renderPass === "translucent" && (t3.context.setColorMode(t3.colorModeForRenderPass()), function(t4, i4) {
                const o3 = t4.context, r4 = o3.gl, n2 = i4.heatmapFbo;
                if (!n2)
                  return;
                o3.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, n2.colorAttachment.get()), o3.activeTexture.set(r4.TEXTURE1);
                let a2 = i4.colorRampTexture;
                a2 || (a2 = i4.colorRampTexture = new e2.Texture(o3, i4.colorRamp, r4.RGBA)), a2.bind(r4.LINEAR, r4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(o3, r4.TRIANGLES, e2.DepthMode.disabled, e2.StencilMode.disabled, t4.colorModeForRenderPass(), e2.CullFaceMode.disabled, ((e3, t5, i5, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t5.paint.get("heatmap-opacity") }))(0, i4), i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom);
              }(t3, o2));
        }, line: function(t3, i3, o2, r3) {
          if (t3.renderPass !== "translucent")
            return;
          const n2 = o2.paint.get("line-opacity"), a2 = o2.paint.get("line-width");
          if (n2.constantOr(1) === 0 || a2.constantOr(1) === 0)
            return;
          const s4 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), l2 = t3.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), h3 = c2.constantOr(1), u2 = o2.layout.get("line-cap"), _2 = o2.paint.get("line-pattern"), d2 = _2.constantOr(1), p2 = o2.paint.get("line-gradient"), m3 = o2.getCrossfadeParameters(), f4 = d2 ? "linePattern" : "line", g2 = t3.context, v2 = g2.gl, x3 = ((e3) => {
            const t4 = [];
            Pi(e3) && t4.push("RENDER_LINE_DASH"), e3.paint.get("line-gradient") && t4.push("RENDER_LINE_GRADIENT");
            const i4 = e3.paint.get("line-pattern").constantOr(1), o3 = e3.paint.get("line-opacity").constantOr(1) !== 1;
            return !i4 && o3 && t4.push("RENDER_LINE_ALPHA_DISCARD"), t4;
          })(o2);
          let y2 = x3.includes("RENDER_LINE_ALPHA_DISCARD");
          t3.terrain && t3.terrain.clipOrMaskOverlapStencilType() && (y2 = false);
          for (const n3 of r3) {
            const r4 = i3.getTile(n3);
            if (d2 && !r4.patternsLoaded())
              continue;
            const a3 = r4.getBucket(o2);
            if (!a3)
              continue;
            t3.prepareDrawTile(n3);
            const b2 = a3.programConfigurations.get(o2.id), w2 = t3.useProgram(f4, b2, x3), T2 = _2.constantOr(null);
            if (T2 && r4.imageAtlas) {
              const e3 = r4.imageAtlas, t4 = e3.patternPositions[T2.to.toString()], i4 = e3.patternPositions[T2.from.toString()];
              t4 && i4 && b2.setConstantPatternPositions(t4, i4);
            }
            const E2 = c2.constantOr(null), C2 = u2.constantOr(null);
            if (!d2 && E2 && C2 && r4.lineAtlas) {
              const e3 = r4.lineAtlas, t4 = e3.getDash(E2.to, C2), i4 = e3.getDash(E2.from, C2);
              t4 && i4 && b2.setConstantPatternPositions(t4, i4);
            }
            const M2 = t3.terrain ? n3.projMatrix : null, S3 = d2 ? Ii(t3, r4, o2, m3, M2) : Si(t3, r4, o2, m3, M2, a3.lineClipsArray.length);
            if (p2) {
              const r5 = a3.gradients[o2.id];
              let s5 = r5.texture;
              if (o2.gradientVersion !== r5.version) {
                let l3 = 256;
                if (o2.stepInterpolant) {
                  const o3 = i3.getSource().maxzoom, r6 = n3.canonical.z === o3 ? Math.ceil(1 << t3.transform.maxZoom - n3.canonical.z) : 1;
                  l3 = e2.clamp(e2.nextPowerOfTwo(a3.maxLineLength / e2.EXTENT * 1024 * r6), 256, g2.maxTextureSize);
                }
                r5.gradient = e2.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r5.gradient || void 0, clips: a3.lineClipsArray }), r5.texture ? r5.texture.update(r5.gradient) : r5.texture = new e2.Texture(g2, r5.gradient, v2.RGBA), r5.version = o2.gradientVersion, s5 = r5.texture;
              }
              g2.activeTexture.set(v2.TEXTURE1), s5.bind(o2.stepInterpolant ? v2.NEAREST : v2.LINEAR, v2.CLAMP_TO_EDGE);
            }
            h3 && (g2.activeTexture.set(v2.TEXTURE0), r4.lineAtlasTexture.bind(v2.LINEAR, v2.REPEAT), b2.updatePaintBuffers(m3)), d2 && (g2.activeTexture.set(v2.TEXTURE0), r4.imageAtlasTexture.bind(v2.LINEAR, v2.CLAMP_TO_EDGE), b2.updatePaintBuffers(m3)), t3.prepareDrawProgram(g2, w2, n3.toUnwrapped());
            const I2 = (i4) => {
              w2.draw(g2, v2.TRIANGLES, s4, i4, l2, e2.CullFaceMode.disabled, S3, o2.id, a3.layoutVertexBuffer, a3.indexBuffer, a3.segments, o2.paint, t3.transform.zoom, b2, a3.layoutVertexBuffer2);
            };
            if (y2) {
              const i4 = t3.stencilModeForClipping(n3).ref;
              i4 === 0 && t3.terrain && g2.clear({ stencil: 0 });
              const o3 = { func: v2.EQUAL, mask: 255 };
              S3.u_alpha_discard_threshold = 0.8, I2(new e2.StencilMode(o3, i4, 255, v2.KEEP, v2.KEEP, v2.INVERT)), S3.u_alpha_discard_threshold = 0, I2(new e2.StencilMode(o3, i4, 255, v2.KEEP, v2.KEEP, v2.KEEP));
            } else
              I2(t3.stencilModeForClipping(n3));
          }
          y2 && (t3.resetStencilClippingMasks(), t3.terrain && g2.clear({ stencil: 0 }));
        }, fill: function(t3, i3, o2, r3) {
          const n2 = o2.paint.get("fill-color"), a2 = o2.paint.get("fill-opacity");
          if (a2.constantOr(1) === 0)
            return;
          const s4 = t3.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = t3.opaquePassEnabledForLayer() && !l2.constantOr(1) && n2.constantOr(e2.Color.transparent).a === 1 && a2.constantOr(0) === 1 ? "opaque" : "translucent";
          if (t3.renderPass === c2) {
            const n3 = t3.depthModeForSublayer(1, t3.renderPass === "opaque" ? e2.DepthMode.ReadWrite : e2.DepthMode.ReadOnly);
            $i(t3, i3, o2, r3, n3, s4, false);
          }
          if (t3.renderPass === "translucent" && o2.paint.get("fill-antialias")) {
            const n3 = t3.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e2.DepthMode.ReadOnly);
            $i(t3, i3, o2, r3, n3, s4, true);
          }
        }, "fill-extrusion": function(t3, i3, o2, r3) {
          const n2 = o2.paint.get("fill-extrusion-opacity");
          if (n2 !== 0 && t3.renderPass === "translucent") {
            const a2 = new e2.DepthMode(t3.context.gl.LEQUAL, e2.DepthMode.ReadWrite, t3.depthRangeFor3D);
            if (n2 !== 1 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
              Hi(t3, i3, o2, r3, a2, e2.StencilMode.disabled, e2.ColorMode.disabled), Hi(t3, i3, o2, r3, a2, t3.stencilModeFor3D(), t3.colorModeForRenderPass()), t3.resetStencilClippingMasks();
            else {
              const n3 = t3.colorModeForRenderPass();
              Hi(t3, i3, o2, r3, a2, e2.StencilMode.disabled, n3);
            }
          }
        }, hillshade: function(t3, i3, o2, r3) {
          if (t3.renderPass !== "offscreen" && t3.renderPass !== "translucent")
            return;
          const n2 = t3.context, a2 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), s4 = t3.colorModeForRenderPass(), l2 = t3.terrain && t3.terrain.renderingToTexture, [c2, h3] = t3.renderPass !== "translucent" || l2 ? [{}, r3] : t3.stencilConfigForOverlap(r3);
          for (const r4 of h3) {
            const n3 = i3.getTile(r4);
            if (n3.needsHillshadePrepare && t3.renderPass === "offscreen")
              Qt(t3, n3, o2, a2, e2.StencilMode.disabled, s4);
            else if (t3.renderPass === "translucent") {
              const e3 = l2 && t3.terrain ? t3.terrain.stencilModeForRTTOverlap(r4) : c2[r4.overscaledZ];
              Yt(t3, r4, n3, o2, a2, e3, s4);
            }
          }
          n2.viewport.set([0, 0, t3.width, t3.height]), t3.resetStencilClippingMasks();
        }, raster: function(t3, i3, o2, r3, n2, a2) {
          if (t3.renderPass !== "translucent")
            return;
          if (o2.paint.get("raster-opacity") === 0)
            return;
          if (!r3.length)
            return;
          const s4 = t3.context, l2 = s4.gl, c2 = i3.getSource(), h3 = t3.useProgram("raster"), u2 = t3.colorModeForRenderPass(), _2 = t3.terrain && t3.terrain.renderingToTexture, [d2, p2] = c2 instanceof be || _2 ? [{}, r3] : t3.stencilConfigForOverlap(r3), m3 = p2[p2.length - 1].overscaledZ, f4 = !t3.options.moving;
          for (const r4 of p2) {
            const n3 = _2 ? e2.DepthMode.disabled : t3.depthModeForSublayer(r4.overscaledZ - m3, o2.paint.get("raster-opacity") === 1 ? e2.DepthMode.ReadWrite : e2.DepthMode.ReadOnly, l2.LESS), p3 = r4.toUnwrapped(), g2 = i3.getTile(r4);
            if (_2 && (!g2 || !g2.hasData()))
              continue;
            const v2 = _2 ? r4.projMatrix : t3.transform.calculateProjMatrix(p3, f4), x3 = t3.terrain && _2 ? t3.terrain.stencilModeForRTTOverlap(r4) : d2[r4.overscaledZ], y2 = a2 ? 0 : o2.paint.get("raster-fade-duration");
            g2.registerFadeDuration(y2);
            const b2 = i3.findLoadedParent(r4, 0), w2 = li(g2, b2, i3, t3.transform, y2);
            let T2, E2;
            t3.terrain && t3.terrain.prepareDrawTile(r4);
            const C2 = o2.paint.get("raster-resampling") === "nearest" ? l2.NEAREST : l2.LINEAR;
            s4.activeTexture.set(l2.TEXTURE0), g2.texture.bind(C2, l2.CLAMP_TO_EDGE), s4.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE), T2 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T2 % 1, g2.tileID.canonical.y * T2 % 1]) : g2.texture.bind(C2, l2.CLAMP_TO_EDGE);
            const M2 = Ai(v2, E2 || [0, 0], T2 || 1, w2, o2, c2 instanceof be ? c2.perspectiveTransform : [0, 0]);
            if (t3.prepareDrawProgram(s4, h3, p3), c2 instanceof be)
              h3.draw(s4, l2.TRIANGLES, n3, e2.StencilMode.disabled, u2, e2.CullFaceMode.disabled, M2, o2.id, c2.boundsBuffer, t3.quadTriangleIndexBuffer, c2.boundsSegments);
            else {
              const { tileBoundsBuffer: i4, tileBoundsIndexBuffer: r5, tileBoundsSegments: a3 } = t3.getTileBoundsBuffers(g2);
              h3.draw(s4, l2.TRIANGLES, n3, x3, u2, e2.CullFaceMode.disabled, M2, o2.id, i4, r5, a3);
            }
          }
          t3.resetStencilClippingMasks();
        }, background: function(t3, i3, o2, r3) {
          const n2 = o2.paint.get("background-color"), a2 = o2.paint.get("background-opacity");
          if (a2 === 0)
            return;
          const s4 = t3.context, l2 = s4.gl, c2 = t3.transform, h3 = c2.tileSize, u2 = o2.paint.get("background-pattern");
          if (t3.isPatternMissing(u2))
            return;
          const _2 = !u2 && n2.a === 1 && a2 === 1 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t3.renderPass !== _2)
            return;
          const d2 = e2.StencilMode.disabled, p2 = t3.depthModeForSublayer(0, _2 === "opaque" ? e2.DepthMode.ReadWrite : e2.DepthMode.ReadOnly), m3 = t3.colorModeForRenderPass(), f4 = t3.useProgram(u2 ? "backgroundPattern" : "background");
          let g2, v2 = r3;
          v2 || (g2 = t3.getBackgroundTiles(), v2 = Object.values(g2).map((e3) => e3.tileID)), u2 && (s4.activeTexture.set(l2.TEXTURE0), t3.imageManager.bind(t3.context));
          const x3 = o2.getCrossfadeParameters();
          for (const _3 of v2) {
            const v3 = _3.toUnwrapped(), y2 = r3 ? _3.projMatrix : t3.transform.calculateProjMatrix(v3);
            t3.prepareDrawTile(_3);
            const b2 = i3 ? i3.getTile(_3) : g2 ? g2[_3.key] : new e2.Tile(_3, h3, c2.zoom, t3), w2 = u2 ? Fi(y2, a2, t3, u2, { tileID: _3, tileSize: h3 }, x3) : Bi(y2, a2, n2);
            t3.prepareDrawProgram(s4, f4, v3);
            const { tileBoundsBuffer: T2, tileBoundsIndexBuffer: E2, tileBoundsSegments: C2 } = t3.getTileBoundsBuffers(b2);
            f4.draw(s4, l2.TRIANGLES, p2, d2, m3, e2.CullFaceMode.disabled, w2, o2.id, T2, E2, C2);
          }
        }, sky: function(t3, i3, o2) {
          const r3 = t3.transform, n2 = r3.projection.name === "mercator" || r3.projection.name === "globe" ? 1 : e2.smoothstep(7, 8, r3.zoom), a2 = o2.paint.get("sky-opacity") * n2;
          if (a2 === 0)
            return;
          const s4 = t3.context, l2 = o2.paint.get("sky-type"), c2 = new e2.DepthMode(s4.gl.LEQUAL, e2.DepthMode.ReadOnly, [0, 1]), h3 = t3.frameCounter / 1e3 % 1;
          l2 === "atmosphere" ? t3.renderPass === "offscreen" ? o2.needsSkyboxCapture(t3) && (function(t4, i4, o3, r4) {
            const n3 = t4.context, a3 = n3.gl;
            let s5 = i4.skyboxFbo;
            if (!s5) {
              s5 = i4.skyboxFbo = n3.createFramebuffer(32, 32, false), i4.skyboxGeometry = new co(n3), i4.skyboxTexture = n3.gl.createTexture(), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i4.skyboxTexture), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_S, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_T, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MIN_FILTER, a3.LINEAR), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MAG_FILTER, a3.LINEAR);
              for (let e3 = 0; e3 < 6; ++e3)
                a3.texImage2D(a3.TEXTURE_CUBE_MAP_POSITIVE_X + e3, 0, a3.RGBA, 32, 32, 0, a3.RGBA, a3.UNSIGNED_BYTE, null);
            }
            n3.bindFramebuffer.set(s5.framebuffer), n3.viewport.set([0, 0, 32, 32]);
            const l3 = i4.getCenter(t4, true), c3 = t4.useProgram("skyboxCapture"), h4 = new Float64Array(16);
            e2.identity(h4), e2.rotateY(h4, h4, 0.5 * -Math.PI), ho(n3, i4, c3, h4, l3, 0), e2.identity(h4), e2.rotateY(h4, h4, 0.5 * Math.PI), ho(n3, i4, c3, h4, l3, 1), e2.identity(h4), e2.rotateX(h4, h4, 0.5 * -Math.PI), ho(n3, i4, c3, h4, l3, 2), e2.identity(h4), e2.rotateX(h4, h4, 0.5 * Math.PI), ho(n3, i4, c3, h4, l3, 3), e2.identity(h4), ho(n3, i4, c3, h4, l3, 4), e2.identity(h4), e2.rotateY(h4, h4, Math.PI), ho(n3, i4, c3, h4, l3, 5), n3.viewport.set([0, 0, t4.width, t4.height]);
          }(t3, o2), o2.markSkyboxValid(t3)) : t3.renderPass === "sky" && function(t4, i4, o3, r4, n3) {
            const a3 = t4.context, s5 = a3.gl, l3 = t4.transform, c3 = t4.useProgram("skybox");
            a3.activeTexture.set(s5.TEXTURE0), s5.bindTexture(s5.TEXTURE_CUBE_MAP, i4.skyboxTexture);
            const h4 = ((e3, t5, i5, o4, r5) => ({ u_matrix: e3, u_sun_direction: t5, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r5 }))(l3.skyboxMatrix, i4.getCenter(t4, false), 0, r4, n3);
            t4.prepareDrawProgram(a3, c3), c3.draw(a3, s5.TRIANGLES, o3, e2.StencilMode.disabled, t4.colorModeForRenderPass(), e2.CullFaceMode.backCW, h4, "skybox", i4.skyboxGeometry.vertexBuffer, i4.skyboxGeometry.indexBuffer, i4.skyboxGeometry.segment);
          }(t3, o2, c2, a2, h3) : l2 === "gradient" && t3.renderPass === "sky" && function(t4, i4, o3, r4, n3) {
            const a3 = t4.context, s5 = a3.gl, l3 = t4.transform, c3 = t4.useProgram("skyboxGradient");
            i4.skyboxGeometry || (i4.skyboxGeometry = new co(a3)), a3.activeTexture.set(s5.TEXTURE0);
            let h4 = i4.colorRampTexture;
            h4 || (h4 = i4.colorRampTexture = new e2.Texture(a3, i4.colorRamp, s5.RGBA)), h4.bind(s5.LINEAR, s5.CLAMP_TO_EDGE);
            const u2 = ((t5, i5, o4, r5, n4) => ({ u_matrix: t5, u_color_ramp: 0, u_center_direction: i5, u_radius: e2.degToRad(o4), u_opacity: r5, u_temporal_offset: n4 }))(l3.skyboxMatrix, i4.getCenter(t4, false), i4.paint.get("sky-gradient-radius"), r4, n3);
            t4.prepareDrawProgram(a3, c3), c3.draw(a3, s5.TRIANGLES, o3, e2.StencilMode.disabled, t4.colorModeForRenderPass(), e2.CullFaceMode.backCW, u2, "skyboxGradient", i4.skyboxGeometry.vertexBuffer, i4.skyboxGeometry.indexBuffer, i4.skyboxGeometry.segment);
          }(t3, o2, c2, a2, h3);
        }, debug: function(e3, t3, i3) {
          for (let o2 = 0; o2 < i3.length; o2++)
            no(e3, t3, i3[o2]);
        }, custom: function(t3, i3, o2) {
          const r3 = t3.context, n2 = o2.implementation;
          if (t3.transform.projection.unsupportedLayers && t3.transform.projection.unsupportedLayers.includes("custom"))
            e2.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");
          else if (t3.renderPass === "offscreen") {
            const e3 = n2.prerender;
            e3 && (t3.setCustomLayerDefaults(), r3.setColorMode(t3.colorModeForRenderPass()), e3.call(n2, r3.gl, t3.transform.customLayerMatrix()), r3.setDirty(), t3.setBaseState());
          } else if (t3.renderPass === "translucent") {
            t3.setCustomLayerDefaults(), r3.setColorMode(t3.colorModeForRenderPass()), r3.setStencilMode(e2.StencilMode.disabled);
            const i4 = n2.renderingMode === "3d" ? new e2.DepthMode(t3.context.gl.LEQUAL, e2.DepthMode.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly);
            r3.setDepthMode(i4), n2.render(r3.gl, t3.transform.customLayerMatrix()), r3.setDirty(), t3.setBaseState(), r3.bindFramebuffer.set(null);
          }
        } };
        class _o {
          constructor(t3, i3) {
            this.context = new de(t3), this.transform = i3, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e2.SourceCache.maxUnderzooming + e2.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Rt(), this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
          }
          updateTerrain(e3, t3) {
            const i3 = !!e3 && !!e3.terrain && this.transform.projection.supportsTerrain;
            if (!(i3 || this._terrain && this._terrain.enabled))
              return;
            this._terrain || (this._terrain = new _i(this, e3));
            const o2 = this._terrain;
            this.transform.elevation = i3 ? o2 : null, o2.update(e3, this.transform, t3);
          }
          _updateFog(e3) {
            const t3 = e3.fog;
            if (!t3 || t3.getOpacity(this.transform.pitch) < 1 || t3.properties.get("horizon-blend") < 0.03)
              return void (this.transform.fogCullDistSq = null);
            const [i3, o2] = t3.getFovAdjustedRange(this.transform._fov);
            if (i3 > o2)
              return void (this.transform.fogCullDistSq = null);
            const r3 = i3 + 0.78 * (o2 - i3);
            this.transform.fogCullDistSq = r3 * r3;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
          }
          resize(t3, i3) {
            if (this.width = t3 * e2.exported.devicePixelRatio, this.height = i3 * e2.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const e3 of this.style.order)
                this.style._layers[e3].resize();
          }
          setup() {
            const t3 = this.context, i3 = new e2.StructArrayLayout2i4();
            i3.emplaceBack(0, 0), i3.emplaceBack(e2.EXTENT, 0), i3.emplaceBack(0, e2.EXTENT), i3.emplaceBack(e2.EXTENT, e2.EXTENT), this.tileExtentBuffer = t3.createVertexBuffer(i3, e2.posAttributes.members), this.tileExtentSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
            const o2 = new e2.StructArrayLayout2i4();
            o2.emplaceBack(0, 0), o2.emplaceBack(e2.EXTENT, 0), o2.emplaceBack(0, e2.EXTENT), o2.emplaceBack(e2.EXTENT, e2.EXTENT), this.debugBuffer = t3.createVertexBuffer(o2, e2.posAttributes.members), this.debugSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 5);
            const r3 = new e2.StructArrayLayout2i4();
            r3.emplaceBack(-1, -1), r3.emplaceBack(1, -1), r3.emplaceBack(-1, 1), r3.emplaceBack(1, 1), this.viewportBuffer = t3.createVertexBuffer(r3, e2.posAttributes.members), this.viewportSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
            const n2 = new e2.StructArrayLayout4i8();
            n2.emplaceBack(0, 0, 0, 0), n2.emplaceBack(e2.EXTENT, 0, e2.EXTENT, 0), n2.emplaceBack(0, e2.EXTENT, 0, e2.EXTENT), n2.emplaceBack(e2.EXTENT, e2.EXTENT, e2.EXTENT, e2.EXTENT), this.mercatorBoundsBuffer = t3.createVertexBuffer(n2, e2.boundsAttributes.members), this.mercatorBoundsSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
            const a2 = new e2.StructArrayLayout3ui6();
            a2.emplaceBack(0, 1, 2), a2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t3.createIndexBuffer(a2);
            const s4 = new e2.StructArrayLayout1ui2();
            for (const e3 of [0, 1, 3, 2, 0])
              s4.emplaceBack(e3);
            this.debugIndexBuffer = t3.createIndexBuffer(s4), this.emptyTexture = new e2.Texture(t3, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, t3.gl.RGBA), this.identityMat = e2.create();
            const l2 = this.context.gl;
            this.stencilClearMode = new e2.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e2.window.performance.now());
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e3) {
            return e3._makeTileBoundsBuffers(this.context, this.transform.projection), e3._tileBoundsBuffer ? { tileBoundsBuffer: e3._tileBoundsBuffer, tileBoundsIndexBuffer: e3._tileBoundsIndexBuffer, tileBoundsSegments: e3._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const t3 = this.context, i3 = t3.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t3, i3.TRIANGLES, e2.DepthMode.disabled, this.stencilClearMode, e2.ColorMode.disabled, e2.CullFaceMode.disabled, si(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(t3, i3, o2) {
            if (!i3 || this.currentStencilSource === i3.id || !t3.isTileClipped() || !o2 || o2.length === 0)
              return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e3 = false;
              for (const t4 of o2)
                if (this._tileClippingMaskIDs[t4.key] === void 0) {
                  e3 = true;
                  break;
                }
              if (!e3)
                return;
            }
            this.currentStencilSource = i3.id;
            const r3 = this.context, n2 = r3.gl;
            this.nextStencilID + o2.length > 256 && this.clearStencil(), r3.setColorMode(e2.ColorMode.disabled), r3.setDepthMode(e2.DepthMode.disabled);
            const a2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t4 of o2) {
              const o3 = i3.getTile(t4), s4 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, { tileBoundsBuffer: l2, tileBoundsIndexBuffer: c2, tileBoundsSegments: h3 } = this.getTileBoundsBuffers(o3);
              a2.draw(r3, n2.TRIANGLES, e2.DepthMode.disabled, new e2.StencilMode({ func: n2.ALWAYS, mask: 0 }, s4, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e2.ColorMode.disabled, e2.CullFaceMode.disabled, si(t4.projMatrix), "$clipping", l2, c2, h3);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t3 = this.nextStencilID++, i3 = this.context.gl;
            return new e2.StencilMode({ func: i3.NOTEQUAL, mask: 255 }, t3, 255, i3.KEEP, i3.KEEP, i3.REPLACE);
          }
          stencilModeForClipping(t3) {
            if (this.terrain)
              return this.terrain.stencilModeForRTTOverlap(t3);
            const i3 = this.context.gl;
            return new e2.StencilMode({ func: i3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, i3.KEEP, i3.KEEP, i3.REPLACE);
          }
          stencilConfigForOverlap(t3) {
            const i3 = this.context.gl, o2 = t3.sort((e3, t4) => t4.overscaledZ - e3.overscaledZ), r3 = o2[o2.length - 1].overscaledZ, n2 = o2[0].overscaledZ - r3 + 1;
            if (n2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + n2 > 256 && this.clearStencil();
              const t4 = {};
              for (let o3 = 0; o3 < n2; o3++)
                t4[o3 + r3] = new e2.StencilMode({ func: i3.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i3.KEEP, i3.KEEP, i3.REPLACE);
              return this.nextStencilID += n2, [t4, o2];
            }
            return [{ [r3]: e2.StencilMode.disabled }, o2];
          }
          colorModeForRenderPass() {
            const t3 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i3 = 1 / 8;
              return new e2.ColorMode([t3.CONSTANT_COLOR, t3.ONE], new e2.Color(i3, i3, i3, 0), [true, true, true, true]);
            }
            return this.renderPass === "opaque" ? e2.ColorMode.unblended : e2.ColorMode.alphaBlended;
          }
          depthModeForSublayer(t3, i3, o2) {
            if (!this.opaquePassEnabledForLayer())
              return e2.DepthMode.disabled;
            const r3 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
            return new e2.DepthMode(o2 || this.context.gl.LEQUAL, i3, [r3, r3]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t3, i3) {
            this.style = t3, this.options = i3, this.lineAtlas = t3.lineAtlas, this.imageManager = t3.imageManager, this.glyphManager = t3.glyphManager, this.symbolFadeChange = t3.placement.symbolFadeChange(e2.exported.now()), this.imageManager.beginFrame();
            const o2 = this.style.order, r3 = this.style._sourceCaches;
            for (const e3 in r3) {
              const t4 = r3[e3];
              t4.used && t4.prepare(this.context);
            }
            const n2 = {}, a2 = {}, s4 = {};
            for (const e3 in r3) {
              const t4 = r3[e3];
              n2[e3] = t4.getVisibleCoordinates(), a2[e3] = n2[e3].slice().reverse(), s4[e3] = t4.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e3 = 0; e3 < o2.length; e3++)
              if (this.style._layers[o2[e3]].is3D()) {
                this.opaquePassCutoff = e3;
                break;
              }
            if (this.terrain && (this.terrain.updateTileBinding(s4), this.opaquePassCutoff = 0), this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new e2.GlobeSharedBuffers(this.context)), !e2.isMapAuthenticated(this.context.gl))
              return;
            this.renderPass = "offscreen";
            for (const e3 of o2) {
              const i4 = this.style._layers[e3], o3 = t3._getLayerSourceCache(i4);
              if (!i4.hasOffscreenPass() || i4.isHidden(this.transform.zoom))
                continue;
              const r4 = o3 ? a2[o3.id] : void 0;
              (i4.type === "custom" || i4.isSky() || r4 && r4.length) && this.renderLayer(this, o3, i4, r4);
            }
            this.depthRangeFor3D = [0, 1 - (t3.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
            let l2 = e2.Color.transparent;
            if (this.style.fog && this.style.fog.getOpacity(this.transform.pitch) && (l2 = this.style.fog.properties.get("color")), this.context.clear({ color: i3.showOverdrawInspector ? e2.Color.black : l2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
              for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e3 = this.style._layers[o2[this.currentLayer]], i4 = t3._getLayerSourceCache(e3);
                if (e3.isSky())
                  continue;
                const r4 = i4 ? a2[i4.id] : void 0;
                this._renderTileClippingMasks(e3, i4, r4), this.renderLayer(this, i4, e3, r4);
              }
            if (this.renderPass = "sky", (e2.globeToMercatorTransition(this.transform.zoom) > 0 || this.transform.projection.name !== "globe") && this.transform.isHorizonVisible())
              for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                const e3 = this.style._layers[o2[this.currentLayer]], i4 = t3._getLayerSourceCache(e3);
                e3.isSky() && this.renderLayer(this, i4, e3, i4 ? a2[i4.id] : void 0);
              }
            for (this.transform.projection.name === "globe" && function(t4) {
              const i4 = t4.context, o3 = i4.gl, r4 = t4.transform, n3 = new e2.DepthMode(o3.LEQUAL, e2.DepthMode.ReadOnly, [0, 1]), a3 = t4.useProgram("globeAtmosphere"), s5 = r4._camera.getWorldToCamera(r4.worldSize, 1), l3 = r4._camera.getCameraToClipPerspective(r4._fov, r4.width / r4.height, r4._nearZ, r4._farZ), c2 = e2.mul([], s5, e2.calculateGlobeMatrix(r4, r4.worldSize)), h3 = e2.mul([], r4.labelPlaneMatrix, l3), u2 = e2.transformMat4([], [0, 0, 0], c2), _2 = e2.add([], u2, [r4.worldSize / Math.PI / 2, 0, 0]), d2 = e2.transformMat4([], u2, h3), p2 = e2.transformMat4([], _2, h3), m3 = e2.length(e2.sub([], p2, d2)), f4 = 1 - e2.globeToMercatorTransition(r4.zoom), g2 = { u_center: d2, u_radius: m3, u_screen_size: [r4.width, r4.height], u_pixel_ratio: e2.exported.devicePixelRatio, u_opacity: f4, u_fadeout_range: 2, u_start_color: [1, 1, 1], u_end_color: [0.0118, 0.7451, 0.9882] };
              t4.prepareDrawProgram(i4, a3);
              const v2 = t4.globeSharedBuffers;
              v2 && a3.draw(i4, o3.TRIANGLES, n3, e2.StencilMode.disabled, e2.ColorMode.alphaBlended, e2.CullFaceMode.backCW, g2, "skybox", v2.atmosphereVertexBuffer, v2.atmosphereIndexBuffer, v2.atmosphereSegments);
            }(this), this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
              const e3 = this.style._layers[o2[this.currentLayer]], i4 = t3._getLayerSourceCache(e3);
              if (e3.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e3)) {
                if (e3.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const r4 = i4 ? (e3.type === "symbol" ? s4 : a2)[i4.id] : void 0;
              this._renderTileClippingMasks(e3, i4, i4 ? n2[i4.id] : void 0), this.renderLayer(this, i4, e3, r4), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {
              let i4 = null;
              e2.values(this.style._layers).forEach((e3) => {
                const o3 = t3._getLayerSourceCache(e3);
                o3 && !e3.isHidden(this.transform.zoom) && (!i4 || i4.getSource().maxzoom < o3.getSource().maxzoom) && (i4 = o3);
              }), i4 && this.options.showTileBoundaries && uo.debug(this, i4, i4.getVisibleCoordinates());
            }
            this.options.showPadding && function(e3) {
              const t4 = e3.transform.padding;
              io(e3, e3.transform.height - (t4.top || 0), 3, Yi), io(e3, t4.bottom || 0, 3, Ji), oo(e3, t4.left || 0, 3, Qi), oo(e3, e3.transform.width - (t4.right || 0), 3, eo);
              const i4 = e3.transform.centerPoint;
              !function(e4, t5, i5, o3) {
                ro(e4, t5 - 1, i5 - 10, 2, 20, o3), ro(e4, t5 - 10, i5 - 1, 20, 2, o3);
              }(e3, i4.x, e3.transform.height - i4.y, to);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e2.window.performance.now()), this.saveCanvasCopy());
          }
          renderLayer(e3, t3, i3, o2) {
            i3.isHidden(this.transform.zoom) || (i3.type === "background" || i3.type === "sky" || i3.type === "custom" || o2 && o2.length) && (this.id = i3.id, this.gpuTimingStart(i3), e3.transform.projection.unsupportedLayers && e3.transform.projection.unsupportedLayers.includes(i3.type) || uo[i3.type](e3, t3, i3, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e3) {
            if (!this.options.gpuTiming)
              return;
            const t3 = this.context.extTimerQuery;
            let i3 = this.gpuTimers[e3.id];
            i3 || (i3 = this.gpuTimers[e3.id] = { calls: 0, cpuTime: 0, query: t3.createQueryEXT() }), i3.calls++, t3.beginQueryEXT(t3.TIME_ELAPSED_EXT, i3.query);
          }
          gpuTimingEnd() {
            if (!this.options.gpuTiming)
              return;
            const e3 = this.context.extTimerQuery;
            e3.endQueryEXT(e3.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e3 = this.gpuTimers;
            return this.gpuTimers = {}, e3;
          }
          queryGpuTimers(e3) {
            const t3 = {};
            for (const i3 in e3) {
              const o2 = e3[i3], r3 = this.context.extTimerQuery, n2 = r3.getQueryObjectEXT(o2.query, r3.QUERY_RESULT_EXT) / 1e6;
              r3.deleteQueryEXT(o2.query), t3[i3] = n2;
            }
            return t3;
          }
          translatePosMatrix(t3, i3, o2, r3, n2) {
            if (!o2[0] && !o2[1])
              return t3;
            const a2 = n2 ? r3 === "map" ? this.transform.angle : 0 : r3 === "viewport" ? -this.transform.angle : 0;
            if (a2) {
              const e3 = Math.sin(a2), t4 = Math.cos(a2);
              o2 = [o2[0] * t4 - o2[1] * e3, o2[0] * e3 + o2[1] * t4];
            }
            const s4 = [n2 ? o2[0] : M(i3, o2[0], this.transform.zoom), n2 ? o2[1] : M(i3, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return e2.translate(l2, t3, s4), l2;
          }
          saveTileTexture(e3) {
            const t3 = this._tileTextures[e3.size[0]];
            t3 ? t3.push(e3) : this._tileTextures[e3.size[0]] = [e3];
          }
          getTileTexture(e3) {
            const t3 = this._tileTextures[e3];
            return t3 && t3.length > 0 ? t3.pop() : null;
          }
          isPatternMissing(e3) {
            if (!e3)
              return false;
            if (!e3.from || !e3.to)
              return true;
            const t3 = this.imageManager.getPattern(e3.from.toString()), i3 = this.imageManager.getPattern(e3.to.toString());
            return !t3 || !i3;
          }
          currentGlobalDefines() {
            const e3 = this.terrain && this.terrain.renderingToTexture, t3 = this.style && this.style.fog, i3 = [];
            return this.terrain && !this.terrain.renderingToTexture && i3.push("TERRAIN"), t3 && !e3 && t3.getOpacity(this.transform.pitch) !== 0 && i3.push("FOG"), e3 && i3.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && i3.push("OVERDRAW_INSPECTOR"), i3;
          }
          useProgram(e3, t3, i3) {
            this.cache = this.cache || {};
            const o2 = i3 || [], r3 = this.currentGlobalDefines().concat(o2), n2 = pi.cacheKey(e3, r3, t3);
            return this.cache[n2] || (this.cache[n2] = new pi(this.context, e3, Xt[e3], t3, Ui2[e3], r3)), this.cache[n2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e3 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e3.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = e2.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e2.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          prepareDrawTile(e3) {
            this.terrain && this.terrain.prepareDrawTile(e3);
          }
          prepareDrawProgram(e3, t3, i3) {
            if (this.terrain && this.terrain.renderingToTexture)
              return;
            const o2 = this.style.fog;
            if (o2) {
              const r3 = o2.getOpacity(this.transform.pitch);
              r3 !== 0 && t3.setFogUniformValues(e3, ((e4, t4, i4, o3) => {
                const r4 = t4.properties.get("color"), n2 = e4.frameCounter / 1e3 % 1, a2 = [r4.r / r4.a, r4.g / r4.a, r4.b / r4.a, o3];
                return { u_fog_matrix: i4 ? e4.transform.calculateFogTileMatrix(i4) : e4.identityMat, u_fog_range: t4.getFovAdjustedRange(e4.transform._fov), u_fog_color: a2, u_fog_horizon_blend: t4.properties.get("horizon-blend"), u_fog_temporal_offset: n2 };
              })(this, o2, i3, r3));
            }
          }
          setTileLoadedFlag(e3) {
            this.tileLoaded = e3;
          }
          saveCanvasCopy() {
            this.frameCopies.push(this.canvasCopy()), this.tileLoaded = false;
          }
          canvasCopy() {
            const e3 = this.context.gl, t3 = e3.createTexture();
            return e3.bindTexture(e3.TEXTURE_2D, t3), e3.copyTexImage2D(e3.TEXTURE_2D, 0, e3.RGBA, 0, 0, e3.drawingBufferWidth, e3.drawingBufferHeight, 0), t3;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation)
              return false;
            const e3 = this.style && this.style.fog;
            return !!e3 && e3.getOpacity(this.transform.pitch) !== 0;
          }
          getBackgroundTiles() {
            const t3 = this._backgroundTiles, i3 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
            for (const r3 of o2)
              i3[r3.key] = t3[r3.key] || new e2.Tile(r3, 512, this.transform.tileZoom, this);
            return i3;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
        }
        class po {
          constructor(e3 = 0, t3 = 0, i3 = 0, o2 = 0) {
            if (isNaN(e3) || e3 < 0 || isNaN(t3) || t3 < 0 || isNaN(i3) || i3 < 0 || isNaN(o2) || o2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e3, this.bottom = t3, this.left = i3, this.right = o2;
          }
          interpolate(t3, i3, o2) {
            return i3.top != null && t3.top != null && (this.top = e2.number(t3.top, i3.top, o2)), i3.bottom != null && t3.bottom != null && (this.bottom = e2.number(t3.bottom, i3.bottom, o2)), i3.left != null && t3.left != null && (this.left = e2.number(t3.left, i3.left, o2)), i3.right != null && t3.right != null && (this.right = e2.number(t3.right, i3.right, o2)), this;
          }
          getCenter(t3, i3) {
            const o2 = e2.clamp((this.left + t3 - this.right) / 2, 0, t3), r3 = e2.clamp((this.top + i3 - this.bottom) / 2, 0, i3);
            return new e2.pointGeometry(o2, r3);
          }
          equals(e3) {
            return this.top === e3.top && this.bottom === e3.bottom && this.left === e3.left && this.right === e3.right;
          }
          clone() {
            return new po(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function mo(t3, i3) {
          const o2 = e2.getColumn(t3, 3);
          e2.fromQuat(t3, i3), e2.setColumn(t3, 3, o2);
        }
        function fo(t3, i3) {
          e2.setColumn(t3, 3, [i3[0], i3[1], i3[2], 1]);
        }
        function go(t3, i3) {
          const o2 = e2.identity$1([]);
          return e2.rotateZ$1(o2, o2, -i3), e2.rotateX$1(o2, o2, -t3), o2;
        }
        function vo(t3, i3) {
          const o2 = [t3[0], t3[1], 0], r3 = [i3[0], i3[1], 0];
          if (e2.length(o2) >= 1e-15) {
            const t4 = e2.normalize([], o2);
            e2.scale$2(r3, t4, e2.dot(r3, t4)), i3[0] = r3[0], i3[1] = r3[1];
          }
          const n2 = e2.cross([], i3, t3);
          if (e2.len(n2) < 1e-15)
            return null;
          const a2 = Math.atan2(-n2[1], n2[0]);
          return go(Math.atan2(Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]), -t3[2]), a2);
        }
        class xo {
          constructor(e3, t3) {
            this.position = e3, this.orientation = t3;
          }
          get position() {
            return this._position;
          }
          set position(t3) {
            this._position = this._renderWorldCopies ? function(t4) {
              if (!t4)
                return;
              const i3 = Array.isArray(t4) ? new e2.MercatorCoordinate(t4[0], t4[1], t4[2]) : t4;
              return i3.x = e2.wrap(i3.x, 0, 1), i3;
            }(t3) : t3;
          }
          lookAtPoint(t3, i3) {
            if (this.orientation = null, !this.position)
              return;
            const o2 = this._elevation ? this._elevation.getAtPointOrZero(e2.MercatorCoordinate.fromLngLat(t3)) : 0, r3 = this.position, n2 = e2.MercatorCoordinate.fromLngLat(t3, o2), a2 = [n2.x - r3.x, n2.y - r3.y, n2.z - r3.z];
            i3 || (i3 = [0, 0, 1]), i3[2] = Math.abs(i3[2]), this.orientation = vo(a2, i3);
          }
          setPitchBearing(t3, i3) {
            this.orientation = go(e2.degToRad(t3), e2.degToRad(-i3));
          }
        }
        class yo {
          constructor(t3, i3) {
            this._transform = e2.identity([]), this._orientation = e2.identity$1([]), i3 && (this._orientation = i3, mo(this._transform, this._orientation)), t3 && fo(this._transform, t3);
          }
          get mercatorPosition() {
            const t3 = this.position;
            return new e2.MercatorCoordinate(t3[0], t3[1], t3[2]);
          }
          get position() {
            const t3 = e2.getColumn(this._transform, 3);
            return [t3[0], t3[1], t3[2]];
          }
          set position(e3) {
            fo(this._transform, e3);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(e3) {
            this._orientation = e3, mo(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e3 = this.forward(), t3 = this.right();
            return { bearing: Math.atan2(-t3[1], t3[0]), pitch: Math.atan2(Math.sqrt(e3[0] * e3[0] + e3[1] * e3[1]), -e3[2]) };
          }
          setPitchBearing(e3, t3) {
            this._orientation = go(e3, t3), mo(this._transform, this._orientation);
          }
          forward() {
            const t3 = e2.getColumn(this._transform, 2);
            return [-t3[0], -t3[1], -t3[2]];
          }
          up() {
            const t3 = e2.getColumn(this._transform, 1);
            return [-t3[0], -t3[1], -t3[2]];
          }
          right() {
            const t3 = e2.getColumn(this._transform, 0);
            return [t3[0], t3[1], t3[2]];
          }
          getCameraToWorld(t3, i3) {
            const o2 = new Float64Array(16);
            return e2.invert(o2, this.getWorldToCamera(t3, i3)), o2;
          }
          getWorldToCameraPosition(t3, i3, o2) {
            const r3 = this.position;
            e2.scale$2(r3, r3, -t3);
            const n2 = new Float64Array(16);
            return e2.fromScaling(n2, [o2, o2, o2]), e2.translate(n2, n2, r3), n2[10] *= i3, n2;
          }
          getWorldToCamera(t3, i3) {
            const o2 = new Float64Array(16), r3 = new Float64Array(4), n2 = this.position;
            return e2.conjugate(r3, this._orientation), e2.scale$2(n2, n2, -t3), e2.fromQuat(o2, r3), e2.translate(o2, o2, n2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i3, o2[9] *= i3, o2[10] *= i3, o2[11] *= i3, o2;
          }
          getCameraToClipPerspective(t3, i3, o2, r3) {
            const n2 = new Float64Array(16);
            return e2.perspective(n2, t3, i3, o2, r3), n2;
          }
          getDistanceToElevation(t3) {
            const i3 = t3 === 0 ? 0 : e2.mercatorZfromAltitude(t3, this.position[1]), o2 = this.forward();
            return (i3 - this.position[2]) / o2[2];
          }
          clone() {
            return new yo([...this.position], [...this.orientation]);
          }
        }
        function bo(t3, i3) {
          const o2 = To(t3), r3 = function(t4, i4, o3, r4, n3) {
            const a2 = new e2.LngLat(o3.lng - 180 * Eo, o3.lat), s4 = new e2.LngLat(o3.lng + 180 * Eo, o3.lat), l2 = t4.project(a2.lng, a2.lat), c2 = t4.project(s4.lng, s4.lat), h3 = -Math.atan2(c2.y - l2.y, c2.x - l2.x), u2 = e2.MercatorCoordinate.fromLngLat(o3);
            u2.y = e2.clamp(u2.y, -0.999975, 0.999975);
            const _2 = u2.toLngLat(), d2 = t4.project(_2.lng, _2.lat), p2 = e2.MercatorCoordinate.fromLngLat(_2);
            p2.x += Eo;
            const m3 = p2.toLngLat(), f4 = t4.project(m3.lng, m3.lat), g2 = Mo(f4.x - d2.x, f4.y - d2.y, h3), v2 = e2.MercatorCoordinate.fromLngLat(_2);
            v2.y += Eo;
            const x3 = v2.toLngLat(), y2 = t4.project(x3.lng, x3.lat), b2 = Mo(y2.x - d2.x, y2.y - d2.y, h3), w2 = Math.abs(g2.x) / Math.abs(b2.y), T2 = e2.identity([]);
            e2.rotateZ(T2, T2, -h3 * (1 - (n3 ? 0 : r4)));
            const E2 = e2.identity([]);
            return e2.scale(E2, E2, [1, 1 - (1 - w2) * r4, 1]), E2[4] = -b2.x / b2.y * r4, e2.rotateZ(E2, E2, h3), e2.multiply$1(E2, T2, E2), E2;
          }(t3.projection, 0, t3.center, o2, i3), n2 = wo(t3);
          return e2.scale(r3, r3, [n2, n2, 1]), r3;
        }
        function wo(t3) {
          const i3 = t3.projection, o2 = To(t3), r3 = Co(i3, t3.center), n2 = Co(i3, e2.LngLat.convert(i3.center));
          return Math.pow(2, r3 * o2 + (1 - o2) * n2);
        }
        function To(t3) {
          const i3 = t3.projection.range;
          if (!i3)
            return 0;
          const o2 = Math.max(t3.width, t3.height), r3 = Math.log(o2 / 1024) / Math.LN2;
          return e2.smoothstep(i3[0] + r3, i3[1] + r3, t3.zoom);
        }
        const Eo = 1 / 4e4;
        function Co(t3, i3) {
          const o2 = e2.clamp(i3.lat, -e2.MAX_MERCATOR_LATITUDE, e2.MAX_MERCATOR_LATITUDE), r3 = new e2.LngLat(i3.lng - 180 * Eo, o2), n2 = new e2.LngLat(i3.lng + 180 * Eo, o2), a2 = t3.project(r3.lng, o2), s4 = t3.project(n2.lng, o2), l2 = e2.MercatorCoordinate.fromLngLat(r3), c2 = e2.MercatorCoordinate.fromLngLat(n2), h3 = s4.x - a2.x, u2 = s4.y - a2.y, _2 = c2.x - l2.x, d2 = c2.y - l2.y, p2 = Math.sqrt((_2 * _2 + d2 * d2) / (h3 * h3 + u2 * u2));
          return Math.log(p2) / Math.LN2;
        }
        function Mo(e3, t3, i3) {
          const o2 = Math.cos(i3), r3 = Math.sin(i3);
          return { x: e3 * o2 - t3 * r3, y: e3 * r3 + t3 * o2 };
        }
        class So {
          constructor(t3, i3, o2, r3, n2) {
            this.tileSize = 512, this._renderWorldCopies = n2 === void 0 || n2, this._minZoom = t3 || 0, this._maxZoom = i3 || 22, this._minPitch = o2 == null ? 0 : o2, this._maxPitch = r3 == null ? 60 : r3, this.setProjection(), this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e2.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new po(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new yo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._projectionScaler = 1, this._horizonShift = 0.1;
          }
          clone() {
            const e3 = new So(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return e3.setProjection(this.getProjection()), e3._elevation = this._elevation, e3._centerAltitude = this._centerAltitude, e3.tileSize = this.tileSize, e3.setMaxBounds(this.getMaxBounds()), e3.width = this.width, e3.height = this.height, e3.cameraElevationReference = this.cameraElevationReference, e3._center = this._center, e3._setZoom(this.zoom), e3._cameraZoom = this._cameraZoom, e3.angle = this.angle, e3._fov = this._fov, e3._pitch = this._pitch, e3._nearZ = this._nearZ, e3._farZ = this._farZ, e3._averageElevation = this._averageElevation, e3._unmodified = this._unmodified, e3._edgeInsets = this._edgeInsets.clone(), e3._camera = this._camera.clone(), e3._calcMatrices(), e3.freezeTileCoverage = this.freezeTileCoverage, e3;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e3) {
            this._elevation !== e3 && (this._elevation = e3, e3 ? this._updateCenterElevation() && this._updateCameraOnTerrain() : (this._cameraZoom = null, this._centerAltitude = 0), this._calcMatrices());
          }
          updateElevation(e3) {
            this._terrainEnabled() && this._cameraZoom == null && this._updateCenterElevation() && this._updateCameraOnTerrain(), e3 && this._constrainCameraAltitude(), this._calcMatrices();
          }
          getProjection() {
            return e2.pick(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(t3) {
            t3 == null && (t3 = { name: "mercator" }), this.projectionOptions = t3;
            const i3 = this.projection ? this.getProjection() : void 0;
            return this.projection = e2.getProjection(t3), !n(i3, this.getProjection()) && (this._calcMatrices(), true);
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e3) {
            this._minZoom !== e3 && (this._minZoom = e3, this.zoom = Math.max(this.zoom, e3));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e3) {
            this._maxZoom !== e3 && (this._maxZoom = e3, this.zoom = Math.min(this.zoom, e3));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e3) {
            this._minPitch !== e3 && (this._minPitch = e3, this.pitch = Math.max(this.pitch, e3));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e3) {
            this._maxPitch !== e3 && (this._maxPitch = e3, this.pitch = Math.min(this.pitch, e3));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && this.projection.supportsWorldCopies === true;
          }
          set renderWorldCopies(e3) {
            e3 === void 0 ? e3 = true : e3 === null && (e3 = false), this._renderWorldCopies = e3;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSize() {
            const e3 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e3));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.cameraWorldSize);
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e2.pointGeometry(this.width, this.height);
          }
          get bearing() {
            return e2.wrap(this.rotation, -180, 180);
          }
          set bearing(e3) {
            this.rotation = e3;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t3) {
            const i3 = -t3 * Math.PI / 180;
            var o2;
            this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = (o2 = new e2.ARRAY_TYPE(4), e2.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e3, t4, i4) {
              var o3 = t4[0], r3 = t4[1], n2 = t4[2], a2 = t4[3], s4 = Math.sin(i4), l2 = Math.cos(i4);
              e3[0] = o3 * l2 + n2 * s4, e3[1] = r3 * l2 + a2 * s4, e3[2] = o3 * -s4 + n2 * l2, e3[3] = r3 * -s4 + a2 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t3) {
            const i3 = e2.clamp(t3, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(e3) {
            e3 = Math.max(0.01, Math.min(60, e3)), this._fov !== e3 && (this._unmodified = false, this._fov = e3 / 180 * Math.PI, this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e3) {
            this._averageElevation = e3, this._calcFogMatrices();
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e3) {
            const t3 = Math.min(Math.max(e3, this.minZoom), this.maxZoom);
            this._zoom !== t3 && (this._unmodified = false, this._setZoom(t3), this._terrainEnabled() && this._updateCameraOnTerrain(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e3) {
            this._zoom = e3, this.scale = this.zoomScale(e3), this.tileZoom = Math.floor(e3), this.zoomFraction = e3 - this.tileZoom;
          }
          _updateCenterElevation() {
            if (!this._elevation)
              return false;
            const e3 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center), -1);
            return e3 === -1 ? (this._cameraZoom = null, false) : (this._centerAltitude = e3, true);
          }
          _updateCameraOnTerrain() {
            this._cameraZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);
          }
          sampleAverageElevation() {
            if (!this._elevation)
              return 0;
            const t3 = this._elevation, i3 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
            let r3 = 0, n2 = 0;
            for (let a2 = 0; a2 < i3.length; a2++) {
              const s4 = new e2.pointGeometry(i3[a2][0] * this.width, o2 + i3[a2][1] * (this.height - o2)), l2 = t3.pointCoordinate(s4);
              if (!l2)
                continue;
              const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
              r3 += l2[3] * c2, n2 += c2;
            }
            return n2 === 0 ? NaN : r3 / n2;
          }
          get center() {
            return this._center;
          }
          set center(e3) {
            e3.lat === this._center.lat && e3.lng === this._center.lng || (this._unmodified = false, this._center = e3, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCenterElevation() ? this._updateCameraOnTerrain() : this._cameraZoom = null : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (this._cameraZoom == null || !this._elevation)
              return;
            const e3 = this._cameraZoom, t3 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i3 = this.pixelsPerMeter / this.worldSize * t3, o2 = this._mercatorZfromZoom(e3), r3 = this._mercatorZfromZoom(this._maxZoom), n2 = Math.max(o2 - i3, r3);
            this._setZoom(this._zoomFromMercatorZ(n2));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e3) {
            this._edgeInsets.equals(e3) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e3, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t3) {
            const i3 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t3.toAltitude()));
            let o2;
            o2 = t3.z < this._camera.position[2] ? [i3.x, i3.y, i3.z] : [t3.x, t3.y, t3.z];
            const r3 = e2.length(e2.sub([], this._camera.position, o2));
            return e2.clamp(this._zoomFromMercatorZ(r3), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t3) {
            if (!this.height)
              return;
            if (!t3.position && !t3.orientation)
              return;
            this._updateCameraState();
            let i3 = false;
            if (t3.orientation && !e2.exactEquals(t3.orientation, this._camera.orientation) && (i3 = this._setCameraOrientation(t3.orientation)), t3.position) {
              const o2 = [t3.position.x, t3.position.y, t3.position.z];
              e2.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i3 = true);
            }
            i3 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t3 = this._camera.position, i3 = new xo();
            return i3.position = new e2.MercatorCoordinate(t3[0], t3[1], t3[2]), i3.orientation = this._camera.orientation, i3._elevation = this.elevation, i3._renderWorldCopies = this.renderWorldCopies, i3;
          }
          _setCameraOrientation(t3) {
            if (!e2.length$1(t3))
              return false;
            e2.normalize$1(t3, t3);
            const i3 = e2.transformQuat([], [0, 0, -1], t3), o2 = e2.transformQuat([], [0, -1, 0], t3);
            if (o2[2] < 0)
              return false;
            const r3 = vo(i3, o2);
            return !!r3 && (this._camera.orientation = r3, true);
          }
          _setCameraPosition(t3) {
            const i3 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r3 = this.cameraToCenterDistance;
            t3[2] = e2.clamp(t3[2], r3 / o2, r3 / i3), this._camera.position = t3;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e3) {
            return this._edgeInsets.equals(e3);
          }
          interpolatePadding(e3, t3, i3) {
            this._unmodified = false, this._edgeInsets.interpolate(e3, t3, i3), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e3) {
            const t3 = (e3.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e3.tileSize));
            return Math.max(0, t3);
          }
          getVisibleUnwrappedCoordinates(t3) {
            const i3 = [new e2.UnwrappedTileID(0, t3)];
            if (this.renderWorldCopies) {
              const o2 = this.pointCoordinate(new e2.pointGeometry(0, 0)), r3 = this.pointCoordinate(new e2.pointGeometry(this.width, 0)), n2 = this.pointCoordinate(new e2.pointGeometry(this.width, this.height)), a2 = this.pointCoordinate(new e2.pointGeometry(0, this.height)), s4 = Math.floor(Math.min(o2.x, r3.x, n2.x, a2.x)), l2 = Math.floor(Math.max(o2.x, r3.x, n2.x, a2.x)), c2 = 1;
              for (let o3 = s4 - c2; o3 <= l2 + c2; o3++)
                o3 !== 0 && i3.push(new e2.UnwrappedTileID(o3, t3));
            }
            return i3;
          }
          coveringTiles(t3) {
            let i3 = this.coveringZoomLevel(t3);
            const o2 = i3, r3 = this.elevation && !t3.isTerrainDEM, n2 = this.projection.name === "mercator";
            if (t3.minzoom !== void 0 && i3 < t3.minzoom)
              return [];
            t3.maxzoom !== void 0 && i3 > t3.maxzoom && (i3 = t3.maxzoom);
            const a2 = this.locationCoordinate(this.center), s4 = 1 << i3, l2 = [s4 * a2.x, s4 * a2.y, 0], c2 = e2.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i3, this.projection.name !== "globe"), h3 = this.pointCoordinate(this.getCameraPoint()), u2 = s4 * e2.mercatorZfromAltitude(1, this.center.lat), _2 = this._camera.position[2] / e2.mercatorZfromAltitude(1, this.center.lat), d2 = [s4 * h3.x, s4 * h3.y, _2], p2 = this.cameraToCenterDistance / t3.tileSize * (t3.roundZoom ? 1 : 0.502), m3 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i3 : 0, f4 = t3.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, g2 = t3.isTerrainDEM ? -f4 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, v2 = this.projection.isReprojectedInTileSpace ? wo(this) : 1, x3 = (t4) => {
              const i4 = 1 / 4e4, o3 = new e2.MercatorCoordinate(t4.x + i4, t4.y, t4.z), r4 = new e2.MercatorCoordinate(t4.x, t4.y + i4, t4.z), n3 = t4.toLngLat(), a3 = o3.toLngLat(), s5 = r4.toLngLat(), l3 = this.locationCoordinate(n3), c3 = this.locationCoordinate(a3), h4 = this.locationCoordinate(s5), u3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), _3 = Math.hypot(h4.x - l3.x, h4.y - l3.y);
              return Math.sqrt(u3 * _3) * v2 / i4;
            }, y2 = (t4) => {
              const i4 = f4, o3 = g2;
              return { aabb: e2.tileAABB(this, s4, 0, 0, 0, t4, o3, i4, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i4, wrap: t4, fullyVisible: false };
            }, b2 = [];
            let w2 = [];
            const T2 = i3, E2 = t3.reparseOverscaled ? o2 : i3, C2 = (e3) => e3 * e3, M2 = C2((_2 - this._centerAltitude) * u2), S3 = (e3) => {
              if (!this._elevation || !e3.tileID || !n2)
                return;
              const t4 = this._elevation.getMinMaxForTile(e3.tileID), i4 = e3.aabb;
              t4 ? (i4.min[2] = t4.min, i4.max[2] = t4.max, i4.center[2] = (i4.min[2] + i4.max[2]) / 2) : (e3.shouldSplit = I2(e3), e3.shouldSplit || (i4.min[2] = i4.max[2] = i4.center[2] = this._centerAltitude));
            }, I2 = (t4) => {
              if (t4.zoom < m3)
                return true;
              if (t4.zoom === T2)
                return false;
              if (t4.shouldSplit != null)
                return t4.shouldSplit;
              const i4 = t4.aabb.distanceX(d2), n3 = t4.aabb.distanceY(d2);
              let a3 = M2;
              r3 && (a3 = C2(t4.aabb.distanceZ(d2) * u2));
              let s5 = 1;
              if (this.projection.isReprojectedInTileSpace && o2 <= 5) {
                const i5 = Math.pow(2, t4.zoom), o3 = x3(new e2.MercatorCoordinate((t4.x + 0.5) / i5, (t4.y + 0.5) / i5));
                s5 = o3 > 0.85 ? 1 : o3;
              }
              const l3 = i4 * i4 + n3 * n3 + a3;
              return l3 < C2((1 << T2 - t4.zoom) * p2 * s5 * ((e3, t5) => {
                if (t5 * C2(0.707) < e3)
                  return 1;
                const i5 = Math.sqrt(t5 / e3);
                return i5 / (1.4144271570014144 + (Math.pow(1.1, i5 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(a3, M2), l3));
            };
            if (this.renderWorldCopies)
              for (let e3 = 1; e3 <= 3; e3++)
                b2.push(y2(-e3)), b2.push(y2(e3));
            for (b2.push(y2(0)); b2.length > 0; ) {
              const o3 = b2.pop(), a3 = o3.x, h4 = o3.y;
              let u3 = o3.fullyVisible;
              if (!u3) {
                const e3 = o3.aabb.intersects(c2);
                if (e3 === 0)
                  continue;
                u3 = e3 === 2;
              }
              if (o3.zoom !== T2 && I2(o3))
                for (let t4 = 0; t4 < 4; t4++) {
                  const i4 = (a3 << 1) + t4 % 2, l3 = (h4 << 1) + (t4 >> 1), c3 = { aabb: n2 ? o3.aabb.quadrant(t4) : e2.tileAABB(this, s4, o3.zoom + 1, i4, l3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i4, y: l3, wrap: o3.wrap, fullyVisible: u3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                  r3 && (c3.tileID = new e2.OverscaledTileID(o3.zoom + 1 === T2 ? E2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i4, l3), S3(c3)), b2.push(c3);
                }
              else {
                const r4 = o3.zoom === T2 ? E2 : o3.zoom;
                if (t3.minzoom && t3.minzoom > r4)
                  continue;
                const n3 = l2[0] - (0.5 + a3 + (o3.wrap << o3.zoom)) * (1 << i3 - o3.zoom), s5 = l2[1] - 0.5 - h4, c3 = o3.tileID ? o3.tileID : new e2.OverscaledTileID(r4, o3.wrap, o3.zoom, a3, h4);
                w2.push({ tileID: c3, distanceSq: n3 * n3 + s5 * s5 });
              }
            }
            if (this.fogCullDistSq) {
              const i4 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
              w2 = w2.filter((r4) => {
                const n3 = [0, 0, 0, 1], a3 = [e2.EXTENT, e2.EXTENT, 0, 1], s5 = this.calculateFogTileMatrix(r4.tileID.toUnwrapped());
                e2.transformMat4$1(n3, n3, s5), e2.transformMat4$1(a3, a3, s5);
                const l3 = e2.getAABBPointSquareDist(n3, a3);
                if (l3 === 0)
                  return true;
                let c3 = false;
                const h4 = this._elevation;
                if (h4 && l3 > i4 && o3 !== 0) {
                  const i5 = this.calculateProjMatrix(r4.tileID.toUnwrapped());
                  let n4;
                  t3.isTerrainDEM || (n4 = h4.getMinMaxForTile(r4.tileID)), n4 || (n4 = { min: g2, max: f4 });
                  const a4 = e2.furthestTileCorner(this.rotation), s6 = [a4[0] * e2.EXTENT, a4[1] * e2.EXTENT, n4.max];
                  e2.transformMat4(s6, s6, i5), c3 = (1 - s6[1]) * this.height * 0.5 < o3;
                }
                return l3 < i4 || c3;
              });
            }
            return w2.sort((e3, t4) => e3.distanceSq - t4.distanceSq).map((e3) => e3.tileID);
          }
          resize(e3, t3) {
            this.width = e3, this.height = t3, this.pixelsToGLUnits = [2 / e3, -2 / t3], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e3) {
            return Math.pow(2, e3);
          }
          scaleZoom(e3) {
            return Math.log(e3) / Math.LN2;
          }
          project(t3) {
            const i3 = e2.clamp(t3.lat, -e2.MAX_MERCATOR_LATITUDE, e2.MAX_MERCATOR_LATITUDE), o2 = this.projection.project(t3.lng, i3);
            return new e2.pointGeometry(o2.x * this.worldSize, o2.y * this.worldSize);
          }
          unproject(e3) {
            return this.projection.unproject(e3.x / this.worldSize, e3.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          setLocationAtPoint(t3, i3) {
            const o2 = this.pointCoordinate(i3), r3 = this.pointCoordinate(this.centerPoint), n2 = this.locationCoordinate(t3);
            this.setLocation(new e2.MercatorCoordinate(n2.x - (o2.x - r3.x), n2.y - (o2.y - r3.y)));
          }
          setLocation(e3) {
            this.center = this.coordinateLocation(e3), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e3) {
            return this.projection.locationPoint(this, e3);
          }
          locationPoint3D(e3) {
            return this._coordinatePoint(this.locationCoordinate(e3), true);
          }
          pointLocation(e3) {
            return this.coordinateLocation(this.pointCoordinate(e3));
          }
          pointLocation3D(e3) {
            return this.coordinateLocation(this.pointCoordinate3D(e3));
          }
          locationCoordinate(t3, i3) {
            const o2 = i3 ? e2.mercatorZfromAltitude(i3, t3.lat) : void 0, r3 = this.projection.project(t3.lng, t3.lat);
            return new e2.MercatorCoordinate(r3.x, r3.y, o2);
          }
          coordinateLocation(e3) {
            return this.projection.unproject(e3.x, e3.y);
          }
          pointRayIntersection(t3, i3) {
            const o2 = i3 != null ? i3 : this._centerAltitude, r3 = [t3.x, t3.y, 0, 1], n2 = [t3.x, t3.y, 1, 1];
            e2.transformMat4$1(r3, r3, this.pixelMatrixInverse), e2.transformMat4$1(n2, n2, this.pixelMatrixInverse);
            const a2 = n2[3];
            e2.scale$1(r3, r3, 1 / r3[3]), e2.scale$1(n2, n2, 1 / a2);
            const s4 = r3[2], l2 = n2[2];
            return { p0: r3, p1: n2, t: s4 === l2 ? 0 : (o2 - s4) / (l2 - s4) };
          }
          screenPointToMercatorRay(t3) {
            const i3 = [t3.x, t3.y, 0, 1], o2 = [t3.x, t3.y, 1, 1];
            return e2.transformMat4$1(i3, i3, this.pixelMatrixInverse), e2.transformMat4$1(o2, o2, this.pixelMatrixInverse), e2.scale$1(i3, i3, 1 / i3[3]), e2.scale$1(o2, o2, 1 / o2[3]), i3[2] = e2.mercatorZfromAltitude(i3[2], this._center.lat) * this.worldSize, o2[2] = e2.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e2.scale$1(i3, i3, 1 / this.worldSize), e2.scale$1(o2, o2, 1 / this.worldSize), new e2.Ray([i3[0], i3[1], i3[2]], e2.normalize([], e2.sub([], o2, i3)));
          }
          rayIntersectionCoordinate(t3) {
            const { p0: i3, p1: o2, t: r3 } = t3, n2 = e2.mercatorZfromAltitude(i3[2], this._center.lat), a2 = e2.mercatorZfromAltitude(o2[2], this._center.lat);
            return new e2.MercatorCoordinate(e2.number(i3[0], o2[0], r3) / this.worldSize, e2.number(i3[1], o2[1], r3) / this.worldSize, e2.number(n2, a2, r3));
          }
          pointCoordinate(e3, t3 = this._centerAltitude) {
            return this.projection.createTileTransform(this, this.worldSize).pointCoordinate(e3.x, e3.y, t3);
          }
          pointCoordinate3D(t3) {
            if (!this.elevation)
              return this.pointCoordinate(t3);
            const i3 = this.elevation;
            let o2 = this.elevation.pointCoordinate(t3);
            if (o2)
              return new e2.MercatorCoordinate(o2[0], o2[1], o2[2]);
            let r3 = 0, n2 = this.horizonLineFromTop();
            if (t3.y > n2)
              return this.pointCoordinate(t3);
            const a2 = 0.02 * n2, s4 = t3.clone();
            for (let t4 = 0; t4 < 10 && n2 - r3 > a2; t4++) {
              s4.y = e2.number(r3, n2, 0.66);
              const t5 = i3.pointCoordinate(s4);
              t5 ? (n2 = s4.y, o2 = t5) : r3 = s4.y;
            }
            return o2 ? new e2.MercatorCoordinate(o2[0], o2[1], o2[2]) : this.pointCoordinate(t3);
          }
          isPointAboveHorizon(e3) {
            if (this.elevation)
              return !this.elevation.pointCoordinate(e3);
            {
              const t3 = this.horizonLineFromTop();
              return e3.y < t3;
            }
          }
          _coordinatePoint(t3, i3) {
            const o2 = i3 && this.elevation ? this.elevation.getAtPointOrZero(t3, this._centerAltitude) : this._centerAltitude, r3 = [t3.x * this.worldSize, t3.y * this.worldSize, o2 + t3.toAltitude(), 1];
            return e2.transformMat4$1(r3, r3, this.pixelMatrix), r3[3] > 0 ? new e2.pointGeometry(r3[0] / r3[3], r3[1] / r3[3]) : new e2.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBounds(t3, i3) {
            const o2 = new e2.pointGeometry(this._edgeInsets.left, this._edgeInsets.top), r3 = new e2.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top), n2 = new e2.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom), a2 = new e2.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
            let s4 = this.pointCoordinate(o2, t3), l2 = this.pointCoordinate(r3, t3);
            const c2 = this.pointCoordinate(n2, i3), h3 = this.pointCoordinate(a2, i3), u2 = (e3, t4) => (t4.y - e3.y) / (t4.x - e3.x);
            return s4.y > 1 && l2.y >= 0 ? s4 = new e2.MercatorCoordinate((1 - h3.y) / u2(h3, s4) + h3.x, 1) : s4.y < 0 && l2.y <= 1 && (s4 = new e2.MercatorCoordinate(-h3.y / u2(h3, s4) + h3.x, 0)), l2.y > 1 && s4.y >= 0 ? l2 = new e2.MercatorCoordinate((1 - c2.y) / u2(c2, l2) + c2.x, 1) : l2.y < 0 && s4.y <= 1 && (l2 = new e2.MercatorCoordinate(-c2.y / u2(c2, l2) + c2.x, 0)), new e2.LngLatBounds().extend(this.coordinateLocation(s4)).extend(this.coordinateLocation(l2)).extend(this.coordinateLocation(h3)).extend(this.coordinateLocation(c2));
          }
          _getBounds3D() {
            const e3 = this.elevation;
            if (!e3.visibleDemTiles.length)
              return this._getBounds(0, 0);
            const t3 = e3.visibleDemTiles.reduce((e4, t4) => {
              if (t4.dem) {
                const i3 = t4.dem.tree;
                e4.min = Math.min(e4.min, i3.minimums[0]), e4.max = Math.max(e4.max, i3.maximums[0]);
              }
              return e4;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBounds(t3.min * e3.exaggeration(), t3.max * e3.exaggeration());
          }
          getBounds() {
            return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);
          }
          horizonLineFromTop(e3 = true) {
            const t3 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i3 = this.height / 2 - t3 * (1 - this._horizonShift);
            return e3 ? Math.max(0, i3) : i3;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t3) {
            this.maxBounds = t3, this.minLat = -e2.MAX_MERCATOR_LATITUDE, this.maxLat = e2.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t3 && (this.minLat = t3.getSouth(), this.maxLat = t3.getNorth(), this.minLng = t3.getWest(), this.maxLng = t3.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e2.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e2.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e2.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e2.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e3, t3) {
            return this.projection.createTileTransform(this, t3).createTileMatrix(e3);
          }
          calculateDistanceTileData(t3) {
            const i3 = t3.key, o2 = this._distanceTileDataCache;
            if (o2[i3])
              return o2[i3];
            const r3 = t3.canonical, n2 = 1 / this.height, a2 = this.cameraWorldSize / this.zoomScale(r3.z), s4 = (r3.x + Math.pow(2, r3.z) * t3.wrap) * a2, l2 = r3.y * a2, c2 = this.point, h3 = this.angle, u2 = Math.sin(-h3), _2 = -Math.cos(-h3);
            return o2[i3] = { bearing: [u2, _2], center: [(c2.x - s4) * n2, (c2.y - l2) * n2], scale: a2 / e2.EXTENT * n2 }, o2[i3];
          }
          calculateFogTileMatrix(t3) {
            const i3 = t3.key, o2 = this._fogTileMatrixCache;
            if (o2[i3])
              return o2[i3];
            const r3 = this.calculatePosMatrix(t3, this.cameraWorldSize);
            return e2.multiply$1(r3, this.worldToFogMatrix, r3), o2[i3] = new Float32Array(r3), o2[i3];
          }
          calculateProjMatrix(t3, i3 = false) {
            const o2 = t3.key, r3 = i3 ? this._alignedProjMatrixCache : this._projMatrixCache;
            if (r3[o2])
              return r3[o2];
            const n2 = this.calculatePosMatrix(t3, this.worldSize);
            return e2.multiply$1(n2, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i3 ? this.alignedProjMatrix : this.projMatrix, n2), r3[o2] = new Float32Array(n2), r3[o2];
          }
          calculatePixelsToTileUnitsMatrix(t3) {
            const i3 = t3.tileID.key, o2 = this._pixelsToTileUnitsCache;
            if (o2[i3])
              return o2[i3];
            const r3 = function(t4, i4) {
              const { scale: o3 } = t4.tileTransform, r4 = o3 * e2.EXTENT / (t4.tileSize * Math.pow(2, i4.zoom - t4.tileID.overscaledZ + t4.tileID.canonical.z));
              return n2 = new Float32Array(4), l2 = (a2 = i4.inverseAdjustmentMatrix)[1], c2 = a2[2], h3 = a2[3], _2 = (s4 = [r4, r4])[1], n2[0] = a2[0] * (u2 = s4[0]), n2[1] = l2 * u2, n2[2] = c2 * _2, n2[3] = h3 * _2, n2;
              var n2, a2, s4, l2, c2, h3, u2, _2;
            }(t3, this);
            return o2[i3] = r3, o2[i3];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          recenterOnTerrain() {
            if (!this._elevation)
              return;
            const t3 = this._elevation;
            this._updateCameraState();
            const i3 = e2.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i3), r3 = this._camera.forward(), n2 = e2.mercatorZfromAltitude(1, this._center.lat);
            o2[2] /= n2, r3[2] /= n2, e2.normalize(r3, r3);
            const a2 = t3.raycast(o2, r3, t3.exaggeration());
            if (a2) {
              const t4 = e2.scaleAndAdd([], o2, r3, a2), i4 = new e2.MercatorCoordinate(t4[0], t4[1], e2.mercatorZfromAltitude(t4[2], e2.latFromMercatorY(t4[1]))), s4 = (i4.z + e2.length([i4.x - o2[0], i4.y - o2[1], i4.z - o2[2] * n2])) * this._projectionScaler;
              this._cameraZoom = this._zoomFromMercatorZ(s4), this._centerAltitude = i4.toAltitude(), this._center = this.coordinateLocation(i4), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCameraAltitude() {
            if (!this._elevation)
              return;
            const t3 = this._elevation;
            this._updateCameraState();
            const i3 = e2.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i3), r3 = t3.getAtPointOrZero(new e2.MercatorCoordinate(...o2)), n2 = this._minimumHeightOverTerrain() * Math.cos(e2.degToRad(this._maxPitch)), a2 = this._camera.position[2] - this.pixelsPerMeter / this.worldSize * r3;
            if (a2 < n2) {
              const t4 = this.locationCoordinate(this._center, this._centerAltitude), i4 = [t4.x - o2[0], t4.y - o2[1], t4.z - o2[2]], r4 = e2.length(i4);
              i4[2] -= (n2 - a2) / this._projectionScaler;
              const s4 = e2.length(i4);
              if (s4 === 0)
                return;
              e2.scale$2(i4, i4, r4 / s4 * this._projectionScaler), this._camera.position = [t4.x - i4[0], t4.y - i4[1], t4.z * this._projectionScaler - i4[2]], this._camera.orientation = vo(i4, this._camera.up()), this._updateStateFromCamera();
            }
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            if (this._constraining = true, this.projection.isReprojectedInTileSpace) {
              const t4 = this.center;
              return t4.lat = e2.clamp(t4.lat, this.minLat, this.maxLat), !this.maxBounds && this.renderWorldCopies || (t4.lng = e2.clamp(t4.lng, this.minLng, this.maxLng)), this.center = t4, void (this._constraining = false);
            }
            const t3 = this._unmodified, { x: i3, y: o2 } = this.point;
            let r3 = 0, n2 = i3, a2 = o2;
            const s4 = this.width / 2, l2 = this.height / 2, c2 = this.worldMinY * this.scale, h3 = this.worldMaxY * this.scale;
            if (o2 - l2 < c2 && (a2 = c2 + l2), o2 + l2 > h3 && (a2 = h3 - l2), h3 - c2 < this.height && (r3 = Math.max(r3, this.height / (h3 - c2)), a2 = (h3 + c2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e3 = this.worldMinX * this.scale, t4 = this.worldMaxX * this.scale, o3 = this.worldSize / 2 - (e3 + t4) / 2;
              n2 = (i3 + o3 + this.worldSize) % this.worldSize - o3, n2 - s4 < e3 && (n2 = e3 + s4), n2 + s4 > t4 && (n2 = t4 - s4), t4 - e3 < this.width && (r3 = Math.max(r3, this.width / (t4 - e3)), n2 = (t4 + e3) / 2);
            }
            n2 === i3 && a2 === o2 || (this.center = this.unproject(new e2.pointGeometry(n2, a2))), r3 && (this.zoom += this.scaleZoom(r3)), this._constrainCameraAltitude(), this._unmodified = t3, this._constraining = false;
          }
          _minZoomForBounds() {
            let e3 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e3 = Math.max(e3, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e3;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const t3 = this._fov / 2, i3 = this.centerOffset, o2 = this.pixelsPerMeter;
            this._projectionScaler = o2 / (e2.mercatorZfromAltitude(1, this.center.lat) * this.worldSize), this.cameraToCenterDistance = 0.5 / Math.tan(t3) * this.height * this._projectionScaler, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const n2 = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? o2 : 1), a2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            a2[8] = 2 * -i3.x / this.width, a2[9] = 2 * i3.y / this.height;
            let s4 = e2.mul([], a2, n2);
            if (this.projection.isReprojectedInTileSpace) {
              const t4 = this.locationCoordinate(this.center), i4 = e2.identity([]);
              e2.translate(i4, i4, [t4.x * this.worldSize, t4.y * this.worldSize, 0]), e2.multiply$1(i4, i4, bo(this)), e2.translate(i4, i4, [-t4.x * this.worldSize, -t4.y * this.worldSize, 0]), e2.multiply$1(s4, s4, i4), this.inverseAdjustmentMatrix = function(e3) {
                const t5 = bo(e3, true);
                return r2([], [t5[0], t5[1], t5[4], t5[5]]);
              }(this);
            } else
              this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            this.mercatorMatrix = e2.scale([], s4, [this.worldSize, this.worldSize, this.worldSize / o2, 1]), this.projMatrix = s4, this.invProjMatrix = e2.invert(new Float64Array(16), this.projMatrix);
            const l2 = new Float32Array(16);
            e2.identity(l2), e2.scale(l2, l2, [1, -1, 1]), e2.rotateX(l2, l2, this._pitch), e2.rotateZ(l2, l2, this.angle);
            const c2 = e2.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), h3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            c2[8] = 2 * -i3.x / this.width, c2[9] = 2 * (i3.y + h3) / this.height, this.skyboxMatrix = e2.multiply$1(l2, c2, l2);
            const u2 = this.point, _2 = u2.x, d2 = u2.y, p2 = this.width % 2 / 2, m3 = this.height % 2 / 2, f4 = Math.cos(this.angle), g2 = Math.sin(this.angle), v2 = _2 - Math.round(_2) + f4 * p2 + g2 * m3, x3 = d2 - Math.round(d2) + f4 * m3 + g2 * p2, y2 = new Float64Array(s4);
            if (e2.translate(y2, y2, [v2 > 0.5 ? v2 - 1 : v2, x3 > 0.5 ? x3 - 1 : x3, 0]), this.alignedProjMatrix = y2, s4 = e2.create(), e2.scale(s4, s4, [this.width / 2, -this.height / 2, 1]), e2.translate(s4, s4, [1, -1, 0]), this.labelPlaneMatrix = s4, s4 = e2.create(), e2.scale(s4, s4, [1, -1, 1]), e2.translate(s4, s4, [-1, -1, 0]), e2.scale(s4, s4, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = s4, this.pixelMatrix = e2.multiply$1(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, s4 = e2.invert(new Float64Array(16), this.pixelMatrix), !s4)
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = s4, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t3 = this.cameraWorldSize, i3 = this.cameraPixelsPerMeter, o2 = this._camera.position, r3 = 1 / this.height, n2 = [t3, t3, i3];
            e2.scale$2(n2, n2, r3), e2.scale$2(o2, o2, -1), e2.multiply$2(o2, o2, n2);
            const a2 = e2.create();
            e2.translate(a2, a2, o2), e2.scale(a2, a2, n2), this.mercatorFogMatrix = a2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t3, i3, r3);
          }
          _computeCameraPosition(e3) {
            const t3 = (e3 = e3 || this.pixelsPerMeter) / this.pixelsPerMeter, i3 = this._camera.forward(), o2 = this.point, r3 = this._mercatorZfromZoom(this._cameraZoom ? this._cameraZoom : this._zoom) * t3 - e3 / this.worldSize * this._centerAltitude;
            return [o2.x / this.worldSize - i3[0] * r3, o2.y / this.worldSize - i3[1] * r3, e3 / this.worldSize * this._centerAltitude - i3[2] * r3];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t3) {
            const i3 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = t3[2];
            let r3 = 1;
            o2 > 0 && (r3 = Math.min((i3 - this._camera.position[2]) / o2, 1)), this._camera.position = e2.scaleAndAdd([], this._camera.position, t3, r3), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t3 = this._camera.position, i3 = this._camera.forward(), { pitch: o2, bearing: r3 } = this._camera.getPitchBearing(), n2 = e2.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._projectionScaler, a2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e2.degToRad(this._maxPitch)), s4 = Math.max((t3[2] - n2) / Math.cos(o2), a2), l2 = this._zoomFromMercatorZ(s4);
            e2.scaleAndAdd(t3, t3, i3, s4), this._pitch = e2.clamp(o2, e2.degToRad(this.minPitch), e2.degToRad(this.maxPitch)), this.angle = e2.wrap(r3, -Math.PI, Math.PI), this._setZoom(e2.clamp(l2, this._minZoom, this._maxZoom)), this._terrainEnabled() && this._updateCameraOnTerrain(), this._center = this.coordinateLocation(new e2.MercatorCoordinate(t3[0], t3[1], t3[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e3) {
            return Math.pow(2, e3) * this.tileSize;
          }
          _mercatorZfromZoom(e3) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e3);
          }
          _minimumHeightOverTerrain() {
            const e3 = Math.min((this._cameraZoom != null ? this._cameraZoom : this._zoom) + 2, this._maxZoom);
            return this._mercatorZfromZoom(e3);
          }
          _zoomFromMercatorZ(e3) {
            return this.scaleZoom(this.cameraToCenterDistance / (e3 * this.tileSize));
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e2.warnOnce("Terrain is not yet supported with alternate projections. Use mercator to enable terrain."), 1));
          }
          anyCornerOffEdge(t3, i3) {
            const o2 = Math.min(t3.x, i3.x), r3 = Math.max(t3.x, i3.x), n2 = Math.min(t3.y, i3.y), a2 = Math.max(t3.y, i3.y);
            if (n2 < this.horizonLineFromTop(false))
              return true;
            if (this.projection.name !== "mercator")
              return false;
            const s4 = [new e2.pointGeometry(o2, n2), new e2.pointGeometry(r3, a2), new e2.pointGeometry(o2, a2), new e2.pointGeometry(r3, n2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
            for (const e3 of s4) {
              const t4 = this.pointRayIntersection(e3);
              if (t4.t < 0)
                return true;
              const i4 = this.rayIntersectionCoordinate(t4);
              if (i4.x < l2 || i4.y < 0 || i4.x > c2 || i4.y > 1)
                return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e2.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e2.pointGeometry(0, 0), new e2.pointGeometry(this.width, this.height));
          }
          zoomDeltaToMovement(t3, i3) {
            const o2 = e2.length(e2.sub([], this._camera.position, t3)), r3 = this._zoomFromMercatorZ(o2) + i3;
            return o2 - this._mercatorZfromZoom(r3);
          }
          getCameraPoint() {
            const t3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e2.pointGeometry(0, t3));
          }
        }
        function Io(e3, t3) {
          let i3 = false, o2 = null;
          const r3 = () => {
            o2 = null, i3 && (e3(), o2 = setTimeout(r3, t3), i3 = false);
          };
          return () => (i3 = true, o2 || r3(), o2);
        }
        class zo {
          constructor(t3) {
            this._hashName = t3 && encodeURIComponent(t3), e2.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Io(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(t3) {
            return this._map = t3, e2.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return e2.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t3) {
            const i3 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r3 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n2 = Math.pow(10, r3), a2 = Math.round(i3.lng * n2) / n2, s4 = Math.round(i3.lat * n2) / n2, l2 = this._map.getBearing(), c2 = this._map.getPitch();
            let h3 = "";
            if (h3 += t3 ? `/${a2}/${s4}/${o2}` : `${o2}/${s4}/${a2}`, (l2 || c2) && (h3 += "/" + Math.round(10 * l2) / 10), c2 && (h3 += `/${Math.round(c2)}`), this._hashName) {
              const t4 = this._hashName;
              let i4 = false;
              const o3 = e2.window.location.hash.slice(1).split("&").map((e3) => {
                const o4 = e3.split("=")[0];
                return o4 === t4 ? (i4 = true, `${o4}=${h3}`) : e3;
              }).filter((e3) => e3);
              return i4 || o3.push(`${t4}=${h3}`), `#${o3.join("&")}`;
            }
            return `#${h3}`;
          }
          _getCurrentHash() {
            const t3 = e2.window.location.hash.replace("#", "");
            if (this._hashName) {
              let e3;
              return t3.split("&").map((e4) => e4.split("=")).forEach((t4) => {
                t4[0] === this._hashName && (e3 = t4);
              }), (e3 && e3[1] || "").split("/");
            }
            return t3.split("/");
          }
          _onHashChange() {
            const e3 = this._getCurrentHash();
            if (e3.length >= 3 && !e3.some((e4) => isNaN(e4))) {
              const t3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t3, pitch: +(e3[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            const t3 = e2.window.location.href.replace(/(#.+)?$/, this.getHashString());
            e2.window.history.replaceState(e2.window.history.state, null, t3);
          }
        }
        const Do = { linearity: 0.3, easing: e2.bezier(0, 0, 0.3, 1) }, Po = e2.extend({ deceleration: 2500, maxSpeed: 1400 }, Do), Ao = e2.extend({ deceleration: 20, maxSpeed: 1400 }, Do), Lo = e2.extend({ deceleration: 1e3, maxSpeed: 360 }, Do), Ro = e2.extend({ deceleration: 1e3, maxSpeed: 90 }, Do);
        class ko {
          constructor(e3) {
            this._map = e3, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t3) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e2.exported.now(), settings: t3 });
          }
          _drainInertiaBuffer() {
            const t3 = this._inertiaBuffer, i3 = e2.exported.now();
            for (; t3.length > 0 && i3 - t3[0].time > 160; )
              t3.shift();
          }
          _onMoveEnd(t3) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new e2.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e3 } of this._inertiaBuffer)
              i3.zoom += e3.zoomDelta || 0, i3.bearing += e3.bearingDelta || 0, i3.pitch += e3.pitchDelta || 0, e3.panDelta && i3.pan._add(e3.panDelta), e3.around && (i3.around = e3.around), e3.pinchAround && (i3.pinchAround = e3.pinchAround);
            const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r3 = {};
            if (i3.pan.mag()) {
              const n2 = Bo(i3.pan.mag(), o2, e2.extend({}, Po, t3 || {}));
              r3.offset = i3.pan.mult(n2.amount / i3.pan.mag()), r3.center = this._map.transform.center, Oo(r3, n2);
            }
            if (i3.zoom) {
              const e3 = Bo(i3.zoom, o2, Ao);
              r3.zoom = this._map.transform.zoom + e3.amount, Oo(r3, e3);
            }
            if (i3.bearing) {
              const t4 = Bo(i3.bearing, o2, Lo);
              r3.bearing = this._map.transform.bearing + e2.clamp(t4.amount, -179, 179), Oo(r3, t4);
            }
            if (i3.pitch) {
              const e3 = Bo(i3.pitch, o2, Ro);
              r3.pitch = this._map.transform.pitch + e3.amount, Oo(r3, e3);
            }
            if (r3.zoom || r3.bearing) {
              const e3 = i3.pinchAround === void 0 ? i3.around : i3.pinchAround;
              r3.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
            }
            return this.clear(), e2.extend(r3, { noMoveStart: true });
          }
        }
        function Oo(e3, t3) {
          (!e3.duration || e3.duration < t3.duration) && (e3.duration = t3.duration, e3.easing = t3.easing);
        }
        function Bo(t3, i3, o2) {
          const { maxSpeed: r3, linearity: n2, deceleration: a2 } = o2, s4 = e2.clamp(t3 * n2 / (i3 / 1e3), -r3, r3), l2 = Math.abs(s4) / (a2 * n2);
          return { easing: o2.easing, duration: 1e3 * l2, amount: s4 * (l2 / 2) };
        }
        class Fo extends e2.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i3, o2, r3 = {}) {
            const n2 = a.mousePos(i3.getCanvasContainer(), o2), s4 = i3.unproject(n2);
            super(t3, e2.extend({ point: n2, lngLat: s4, originalEvent: o2 }, r3)), this._defaultPrevented = false, this.target = i3;
          }
        }
        class Uo extends e2.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i3, o2) {
            const r3 = t3 === "touchend" ? o2.changedTouches : o2.touches, n2 = a.touchPos(i3.getCanvasContainer(), r3), s4 = n2.map((e3) => i3.unproject(e3)), l2 = n2.reduce((e3, t4, i4, o3) => e3.add(t4.div(o3.length)), new e2.pointGeometry(0, 0));
            super(t3, { points: n2, point: l2, lngLats: s4, lngLat: i3.unproject(l2), originalEvent: o2 }), this._defaultPrevented = false;
          }
        }
        class No extends e2.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e3, t3, i3) {
            super(e3, { originalEvent: i3 }), this._defaultPrevented = false;
          }
        }
        class Go {
          constructor(e3, t3) {
            this._map = e3, this._clickTolerance = t3.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e3) {
            return this._firePreventable(new No(e3.type, this._map, e3));
          }
          mousedown(e3, t3) {
            return this._mousedownPos = t3, this._firePreventable(new Fo(e3.type, this._map, e3));
          }
          mouseup(e3) {
            this._map.fire(new Fo(e3.type, this._map, e3));
          }
          preclick(t3) {
            const i3 = e2.extend({}, t3);
            i3.type = "preclick", this._map.fire(new Fo(i3.type, this._map, i3));
          }
          click(e3, t3) {
            this._mousedownPos && this._mousedownPos.dist(t3) >= this._clickTolerance || (this.preclick(e3), this._map.fire(new Fo(e3.type, this._map, e3)));
          }
          dblclick(e3) {
            return this._firePreventable(new Fo(e3.type, this._map, e3));
          }
          mouseover(e3) {
            this._map.fire(new Fo(e3.type, this._map, e3));
          }
          mouseout(e3) {
            this._map.fire(new Fo(e3.type, this._map, e3));
          }
          touchstart(e3) {
            return this._firePreventable(new Uo(e3.type, this._map, e3));
          }
          touchmove(e3) {
            this._map.fire(new Uo(e3.type, this._map, e3));
          }
          touchend(e3) {
            this._map.fire(new Uo(e3.type, this._map, e3));
          }
          touchcancel(e3) {
            this._map.fire(new Uo(e3.type, this._map, e3));
          }
          _firePreventable(e3) {
            if (this._map.fire(e3), e3.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class jo {
          constructor(e3) {
            this._map = e3;
          }
          reset() {
            this._delayContextMenu = false, delete this._contextMenuEvent;
          }
          mousemove(e3) {
            this._map.fire(new Fo(e3.type, this._map, e3));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Fo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e3) {
            this._delayContextMenu ? this._contextMenuEvent = e3 : this._map.fire(new Fo(e3.type, this._map, e3)), this._map.listens("contextmenu") && e3.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Zo {
          constructor(e3, t3) {
            this._map = e3, this._el = e3.getCanvasContainer(), this._container = e3.getContainer(), this._clickTolerance = t3.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e3, t3) {
            this.isEnabled() && e3.shiftKey && e3.button === 0 && (a.disableDrag(), this._startPos = this._lastPos = t3, this._active = true);
          }
          mousemoveWindow(e3, t3) {
            if (!this._active)
              return;
            const i3 = t3;
            if (this._lastPos.equals(i3) || !this._box && i3.dist(this._startPos) < this._clickTolerance)
              return;
            const o2 = this._startPos;
            this._lastPos = i3, this._box || (this._box = a.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e3));
            const r3 = Math.min(o2.x, i3.x), n2 = Math.max(o2.x, i3.x), s4 = Math.min(o2.y, i3.y), l2 = Math.max(o2.y, i3.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${r3}px,${s4}px)`, this._box.style.width = n2 - r3 + "px", this._box.style.height = l2 - s4 + "px");
            });
          }
          mouseupWindow(t3, i3) {
            if (!this._active)
              return;
            if (t3.button !== 0)
              return;
            const o2 = this._startPos, r3 = i3;
            if (this.reset(), a.suppressClick(), o2.x !== r3.x || o2.y !== r3.y)
              return this._map.fire(new e2.Event("boxzoomend", { originalEvent: t3 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(o2, r3, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", t3);
          }
          keydown(e3) {
            this._active && e3.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e3));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), a.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t3, i3) {
            return this._map.fire(new e2.Event(t3, { originalEvent: i3 }));
          }
        }
        function Vo(e3, t3) {
          const i3 = {};
          for (let o2 = 0; o2 < e3.length; o2++)
            i3[e3[o2].identifier] = t3[o2];
          return i3;
        }
        class Wo {
          constructor(e3) {
            this.reset(), this.numTouches = e3.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(t3, i3, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = t3.timeStamp), o2.length === this.numTouches && (this.centroid = function(t4) {
              const i4 = new e2.pointGeometry(0, 0);
              for (const e3 of t4)
                i4._add(e3);
              return i4.div(t4.length);
            }(i3), this.touches = Vo(o2, i3)));
          }
          touchmove(e3, t3, i3) {
            if (this.aborted || !this.centroid)
              return;
            const o2 = Vo(i3, t3);
            for (const e4 in this.touches) {
              const t4 = this.touches[e4], i4 = o2[e4];
              (!i4 || i4.dist(t4) > 30) && (this.aborted = true);
            }
          }
          touchend(e3, t3, i3) {
            if ((!this.centroid || e3.timeStamp - this.startTime > 500) && (this.aborted = true), i3.length === 0) {
              const e4 = !this.aborted && this.centroid;
              if (this.reset(), e4)
                return e4;
            }
          }
        }
        class qo {
          constructor(e3) {
            this.singleTap = new Wo(e3), this.numTaps = e3.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e3, t3, i3) {
            this.singleTap.touchstart(e3, t3, i3);
          }
          touchmove(e3, t3, i3) {
            this.singleTap.touchmove(e3, t3, i3);
          }
          touchend(e3, t3, i3) {
            const o2 = this.singleTap.touchend(e3, t3, i3);
            if (o2) {
              const t4 = e3.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (t4 && i4 || this.reset(), this.count++, this.lastTime = e3.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                return this.reset(), o2;
            }
          }
        }
        class Xo {
          constructor() {
            this._zoomIn = new qo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qo({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e3, t3, i3) {
            this._zoomIn.touchstart(e3, t3, i3), this._zoomOut.touchstart(e3, t3, i3);
          }
          touchmove(e3, t3, i3) {
            this._zoomIn.touchmove(e3, t3, i3), this._zoomOut.touchmove(e3, t3, i3);
          }
          touchend(e3, t3, i3) {
            const o2 = this._zoomIn.touchend(e3, t3, i3), r3 = this._zoomOut.touchend(e3, t3, i3);
            return o2 ? (this._active = true, e3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() + 1, around: t4.unproject(o2) }, { originalEvent: e3 }) }) : r3 ? (this._active = true, e3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() - 1, around: t4.unproject(r3) }, { originalEvent: e3 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const $o = { 0: 1, 2: 2 };
        class Ho {
          constructor(e3) {
            this.reset(), this._clickTolerance = e3.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
          }
          _correctButton(e3, t3) {
            return false;
          }
          _move(e3, t3) {
            return {};
          }
          mousedown(e3, t3) {
            if (this._lastPoint)
              return;
            const i3 = a.mouseButton(e3);
            this._correctButton(e3, i3) && (this._lastPoint = t3, this._eventButton = i3);
          }
          mousemoveWindow(e3, t3) {
            const i3 = this._lastPoint;
            if (i3) {
              if (e3.preventDefault(), function(e4, t4) {
                const i4 = $o[t4];
                return e4.buttons === void 0 || (e4.buttons & i4) !== i4;
              }(e3, this._eventButton))
                this.reset();
              else if (this._moved || !(t3.dist(i3) < this._clickTolerance))
                return this._moved = true, this._lastPoint = t3, this._move(i3, t3);
            }
          }
          mouseupWindow(e3) {
            this._lastPoint && a.mouseButton(e3) === this._eventButton && (this._moved && a.suppressClick(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ko extends Ho {
          mousedown(e3, t3) {
            super.mousedown(e3, t3), this._lastPoint && (this._active = true);
          }
          _correctButton(e3, t3) {
            return t3 === 0 && !e3.ctrlKey;
          }
          _move(e3, t3) {
            return { around: t3, panDelta: t3.sub(e3) };
          }
        }
        class Yo extends Ho {
          _correctButton(e3, t3) {
            return t3 === 0 && e3.ctrlKey || t3 === 2;
          }
          _move(e3, t3) {
            const i3 = 0.8 * (t3.x - e3.x);
            if (i3)
              return this._active = true, { bearingDelta: i3 };
          }
          contextmenu(e3) {
            e3.preventDefault();
          }
        }
        class Jo extends Ho {
          _correctButton(e3, t3) {
            return t3 === 0 && e3.ctrlKey || t3 === 2;
          }
          _move(e3, t3) {
            const i3 = -0.5 * (t3.y - e3.y);
            if (i3)
              return this._active = true, { pitchDelta: i3 };
          }
          contextmenu(e3) {
            e3.preventDefault();
          }
        }
        class Qo {
          constructor(t3, i3) {
            this._map = t3, this._el = t3.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i3.clickTolerance || 1, this.reset(), e2.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e2.pointGeometry(0, 0);
          }
          touchstart(e3, t3, i3) {
            return this._calculateTransform(e3, t3, i3);
          }
          touchmove(e3, t3, i3) {
            if (this._active && !(i3.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (i3.length === 1)
                  return void this._showTouchPanBlockerAlert();
                this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return e3.preventDefault(), this._calculateTransform(e3, t3, i3);
            }
          }
          touchend(e3, t3, i3) {
            this._calculateTransform(e3, t3, i3), this._active && i3.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t3, i3, o2) {
            o2.length > 0 && (this._active = true);
            const r3 = Vo(o2, i3), n2 = new e2.pointGeometry(0, 0), a2 = new e2.pointGeometry(0, 0);
            let s4 = 0;
            for (const e3 in r3) {
              const t4 = r3[e3], i4 = this._touches[e3];
              i4 && (n2._add(t4), a2._add(t4.sub(i4)), s4++, r3[e3] = t4);
            }
            if (this._touches = r3, s4 < this._minTouches || !a2.mag())
              return;
            const l2 = a2.div(s4);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n2.div(s4), panDelta: l2 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = a.create("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility === "hidden" && (this._alertContainer.style.visibility = "visible"), this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show");
            }, 500);
          }
        }
        class er {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          _start(e3) {
          }
          _move(e3, t3, i3) {
            return {};
          }
          touchstart(e3, t3, i3) {
            this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([t3[0], t3[1]]));
          }
          touchmove(e3, t3, i3) {
            if (!this._firstTwoTouches)
              return;
            e3.preventDefault();
            const [o2, r3] = this._firstTwoTouches, n2 = tr(i3, t3, o2), a2 = tr(i3, t3, r3);
            if (!n2 || !a2)
              return;
            const s4 = this._aroundCenter ? null : n2.add(a2).div(2);
            return this._move([n2, a2], s4, e3);
          }
          touchend(e3, t3, i3) {
            if (!this._firstTwoTouches)
              return;
            const [o2, r3] = this._firstTwoTouches, n2 = tr(i3, t3, o2), s4 = tr(i3, t3, r3);
            n2 && s4 || (this._active && a.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e3) {
            this._enabled = true, this._aroundCenter = !!e3 && e3.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function tr(e3, t3, i3) {
          for (let o2 = 0; o2 < e3.length; o2++)
            if (e3[o2].identifier === i3)
              return t3[o2];
        }
        function ir(e3, t3) {
          return Math.log(e3 / t3) / Math.LN2;
        }
        class or extends er {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e3) {
            this._startDistance = this._distance = e3[0].dist(e3[1]);
          }
          _move(e3, t3) {
            const i3 = this._distance;
            if (this._distance = e3[0].dist(e3[1]), this._active || !(Math.abs(ir(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: ir(this._distance, i3), pinchAround: t3 };
          }
        }
        function rr(e3, t3) {
          return 180 * e3.angleWith(t3) / Math.PI;
        }
        class nr extends er {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e3) {
            this._startVector = this._vector = e3[0].sub(e3[1]), this._minDiameter = e3[0].dist(e3[1]);
          }
          _move(e3, t3) {
            const i3 = this._vector;
            if (this._vector = e3[0].sub(e3[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = true, { bearingDelta: rr(this._vector, i3), pinchAround: t3 };
          }
          _isBelowThreshold(e3) {
            this._minDiameter = Math.min(this._minDiameter, e3.mag());
            const t3 = 25 / (Math.PI * this._minDiameter) * 360, i3 = rr(e3, this._startVector);
            return Math.abs(i3) < t3;
          }
        }
        function ar(e3) {
          return Math.abs(e3.y) > Math.abs(e3.x);
        }
        class sr extends er {
          constructor(e3) {
            super(), this._map = e3;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          _start(e3) {
            this._lastPoints = e3, ar(e3[0].sub(e3[1])) && (this._valid = false);
          }
          _move(e3, t3, i3) {
            const o2 = e3[0].sub(this._lastPoints[0]), r3 = e3[1].sub(this._lastPoints[1]);
            if (!(this._map._cooperativeGestures && i3.touches.length < 3) && (this._valid = this.gestureBeginsVertically(o2, r3, i3.timeStamp), this._valid))
              return this._lastPoints = e3, this._active = true, { pitchDelta: (o2.y + r3.y) / 2 * -0.5 };
          }
          gestureBeginsVertically(e3, t3, i3) {
            if (this._valid !== void 0)
              return this._valid;
            const o2 = e3.mag() >= 2, r3 = t3.mag() >= 2;
            if (!o2 && !r3)
              return;
            if (!o2 || !r3)
              return this._firstMove === void 0 && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
            const n2 = e3.y > 0 == t3.y > 0;
            return ar(e3) && ar(t3) && n2;
          }
        }
        const lr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class cr {
          constructor() {
            const e3 = lr;
            this._panStep = e3.panStep, this._bearingStep = e3.bearingStep, this._pitchStep = e3.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e3) {
            if (e3.altKey || e3.ctrlKey || e3.metaKey)
              return;
            let t3 = 0, i3 = 0, o2 = 0, r3 = 0, n2 = 0;
            switch (e3.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t3 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t3 = -1;
                break;
              case 37:
                e3.shiftKey ? i3 = -1 : (e3.preventDefault(), r3 = -1);
                break;
              case 39:
                e3.shiftKey ? i3 = 1 : (e3.preventDefault(), r3 = 1);
                break;
              case 38:
                e3.shiftKey ? o2 = 1 : (e3.preventDefault(), n2 = -1);
                break;
              case 40:
                e3.shiftKey ? o2 = -1 : (e3.preventDefault(), n2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i3 = 0, o2 = 0), { cameraAnimation: (a2) => {
              const s4 = a2.getZoom();
              a2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: hr, zoom: t3 ? Math.round(s4) + t3 * (e3.shiftKey ? 2 : 1) : s4, bearing: a2.getBearing() + i3 * this._bearingStep, pitch: a2.getPitch() + o2 * this._pitchStep, offset: [-r3 * this._panStep, -n2 * this._panStep], center: a2.getCenter() }, { originalEvent: e3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function hr(e3) {
          return e3 * (2 - e3);
        }
        const ur = 4.000244140625;
        class _r {
          constructor(t3, i3) {
            this._map = t3, this._el = t3.getCanvasContainer(), this._handler = i3, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e2.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert", "_isFullscreen"], this);
          }
          setZoomRate(e3) {
            this._defaultZoomRate = e3;
          }
          setWheelZoomRate(e3) {
            this._wheelZoomRate = e3;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e3) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e3 && e3.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t3) {
            if (!this.isEnabled())
              return;
            if (this._map._cooperativeGestures) {
              if (!(t3.ctrlKey || t3.metaKey || this.isZooming() || this._isFullscreen()))
                return void this._showBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i3 = t3.deltaMode === e2.window.WheelEvent.DOM_DELTA_LINE ? 40 * t3.deltaY : t3.deltaY;
            const o2 = e2.exported.now(), r3 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, i3 !== 0 && i3 % ur == 0 ? this._type = "wheel" : i3 !== 0 && Math.abs(i3) < 4 ? this._type = "trackpad" : r3 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, t3)) : this._type || (this._type = Math.abs(r3 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), t3.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = t3, this._delta -= i3, this._active || this._start(t3)), t3.preventDefault();
          }
          _onTimeout(e3) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
          }
          _start(e3) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t3 = a.mousePos(this._el, e3);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t3, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const t3 = this._map.transform, i3 = () => t3._terrainEnabled() && this._aroundCoord ? t3.computeZoomRelativeTo(this._aroundCoord) : t3.zoom;
            if (this._delta !== 0) {
              const e3 = this._type === "wheel" && Math.abs(this._delta) > ur ? this._wheelZoomRate : this._defaultZoomRate;
              let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e3)));
              this._delta < 0 && o3 !== 0 && (o3 = 1 / o3);
              const r4 = i3(), n3 = Math.pow(2, r4), a3 = typeof this._targetZoom == "number" ? t3.zoomScale(this._targetZoom) : n3;
              this._targetZoom = Math.min(t3.maxZoom, Math.max(t3.minZoom, t3.scaleZoom(a3 * o3))), this._type === "wheel" && (this._startZoom = i3(), this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const o2 = typeof this._targetZoom == "number" ? this._targetZoom : i3(), r3 = this._startZoom, n2 = this._easing;
            let a2, s4 = false;
            if (this._type === "wheel" && r3 && n2) {
              const t4 = Math.min((e2.exported.now() - this._lastWheelEventTime) / 200, 1), i4 = n2(t4);
              a2 = e2.number(r3, o2, i4), t4 < 1 ? this._frameId || (this._frameId = true) : s4 = true;
            } else
              a2 = o2, s4 = true;
            return this._active = true, s4 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !s4, zoomDelta: a2 - i3(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t3) {
            let i3 = e2.ease;
            if (this._prevEase) {
              const t4 = this._prevEase, o2 = (e2.exported.now() - t4.start) / t4.duration, r3 = t4.easing(o2 + 0.01) - t4.easing(o2), n2 = 0.27 / Math.sqrt(r3 * r3 + 1e-4) * 0.01, a2 = Math.sqrt(0.0729 - n2 * n2);
              i3 = e2.bezier(n2, a2, 0.25, 1);
            }
            return this._prevEase = { start: e2.exported.now(), duration: t3, easing: i3 }, i3;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = a.create("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e2.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _isFullscreen() {
            return !!e2.window.document.fullscreenElement || !!e2.window.document.webkitFullscreenElement;
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility === "hidden" && (this._alertContainer.style.visibility = "visible"), this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show");
            }, 200);
          }
        }
        class dr {
          constructor(e3, t3) {
            this._clickZoom = e3, this._tapZoom = t3;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class pr {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e3, t3) {
            return e3.preventDefault(), { cameraAnimation: (i3) => {
              i3.easeTo({ duration: 300, zoom: i3.getZoom() + (e3.shiftKey ? -1 : 1), around: i3.unproject(t3) }, { originalEvent: e3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class mr {
          constructor() {
            this._tap = new qo({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
          }
          touchstart(e3, t3, i3) {
            this._swipePoint || (this._tapTime && e3.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i3.length > 0 && (this._swipePoint = t3[0], this._swipeTouch = i3[0].identifier) : this._tap.touchstart(e3, t3, i3));
          }
          touchmove(e3, t3, i3) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i3[0].identifier !== this._swipeTouch)
                  return;
                const o2 = t3[0], r3 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, e3.preventDefault(), this._active = true, { zoomDelta: r3 / 128 };
              }
            } else
              this._tap.touchmove(e3, t3, i3);
          }
          touchend(e3, t3, i3) {
            this._tapTime ? this._swipePoint && i3.length === 0 && this.reset() : this._tap.touchend(e3, t3, i3) && (this._tapTime = e3.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class fr {
          constructor(e3, t3, i3) {
            this._el = e3, this._mousePan = t3, this._touchPan = i3;
          }
          enable(e3) {
            this._inertiaOptions = e3 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class gr {
          constructor(e3, t3, i3) {
            this._pitchWithRotate = e3.pitchWithRotate, this._mouseRotate = t3, this._mousePitch = i3;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class vr {
          constructor(e3, t3, i3, o2) {
            this._el = e3, this._touchZoom = t3, this._touchRotate = i3, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e3) {
            this._touchZoom.enable(e3), this._rotationDisabled || this._touchRotate.enable(e3), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const xr = (e3) => e3.zoom || e3.drag || e3.pitch || e3.rotate;
        class yr extends e2.Event {
        }
        class br {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t3, i3) {
            const o2 = e2.sub([], i3, t3);
            this.radius = e2.length(o2[2] < 0 ? e2.div([], o2, this.constants) : [o2[0], o2[1], 0]);
          }
          projectRay(t3) {
            e2.div(t3, t3, this.constants), e2.normalize(t3, t3), e2.mul$1(t3, t3, this.constants);
            const i3 = e2.scale$2([], t3, this.radius);
            if (i3[2] > 0) {
              const t4 = e2.scale$2([], [0, 0, 1], e2.dot(i3, [0, 0, 1])), o2 = e2.scale$2([], e2.normalize([], [i3[0], i3[1], 0]), this.radius), r3 = e2.add([], i3, e2.scale$2([], e2.sub([], e2.add([], o2, t4), i3), 2));
              i3[0] = r3[0], i3[1] = r3[1];
            }
            return i3;
          }
        }
        function wr(e3) {
          return e3.panDelta && e3.panDelta.mag() || e3.zoomDelta || e3.bearingDelta || e3.pitchDelta;
        }
        class Tr {
          constructor(t3, i3) {
            this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ko(t3), this._bearingSnap = i3.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new br(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i3), e2.bindAll(["handleEvent", "handleWindowEvent"], this);
            const o2 = this._el;
            this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e2.window.document, "mousemove", { capture: true }], [e2.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e2.window, "blur", void 0]];
            for (const [t4, i4, o3] of this._listeners)
              t4.addEventListener(i4, t4 === e2.window.document ? this.handleWindowEvent : this.handleEvent, o3);
          }
          destroy() {
            for (const [t3, i3, o2] of this._listeners)
              t3.removeEventListener(i3, t3 === e2.window.document ? this.handleWindowEvent : this.handleEvent, o2);
          }
          _addDefaultHandlers(e3) {
            const t3 = this._map, i3 = t3.getCanvasContainer();
            this._add("mapEvent", new Go(t3, e3));
            const o2 = t3.boxZoom = new Zo(t3, e3);
            this._add("boxZoom", o2);
            const r3 = new Xo(), n2 = new pr();
            t3.doubleClickZoom = new dr(n2, r3), this._add("tapZoom", r3), this._add("clickZoom", n2);
            const a2 = new mr();
            this._add("tapDragZoom", a2);
            const s4 = t3.touchPitch = new sr(t3);
            this._add("touchPitch", s4);
            const l2 = new Yo(e3), c2 = new Jo(e3);
            t3.dragRotate = new gr(e3, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
            const h3 = new Ko(e3), u2 = new Qo(t3, e3);
            t3.dragPan = new fr(i3, h3, u2), this._add("mousePan", h3), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
            const _2 = new nr(), d2 = new or();
            t3.touchZoomRotate = new vr(i3, d2, _2, a2), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new jo(t3));
            const p2 = t3.scrollZoom = new _r(t3, this);
            this._add("scrollZoom", p2, ["mousePan"]);
            const m3 = t3.keyboard = new cr();
            this._add("keyboard", m3);
            for (const i4 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
              e3.interactive && e3[i4] && t3[i4].enable(e3[i4]);
          }
          _add(e3, t3, i3) {
            this._handlers.push({ handlerName: e3, handler: t3, allowed: i3 }), this._handlersById[e3] = t3;
          }
          stop(e3) {
            if (!this._updatingCamera) {
              for (const { handler: e4 } of this._handlers)
                e4.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e3), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e3 } of this._handlers)
              if (e3.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(xr(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(e3, t3, i3) {
            for (const o2 in e3)
              if (o2 !== i3 && (!t3 || t3.indexOf(o2) < 0))
                return true;
            return false;
          }
          handleWindowEvent(e3) {
            this.handleEvent(e3, `${e3.type}Window`);
          }
          _getMapTouches(e3) {
            const t3 = [];
            for (const i3 of e3)
              this._el.contains(i3.target) && t3.push(i3);
            return t3;
          }
          handleEvent(e3, t3) {
            this._updatingCamera = true;
            const i3 = e3.type === "renderFrame", o2 = i3 ? void 0 : e3, r3 = { needsRenderFrame: false }, n2 = {}, s4 = {}, l2 = e3.touches ? this._getMapTouches(e3.touches) : void 0, c2 = l2 ? a.touchPos(this._el, l2) : i3 ? void 0 : a.mousePos(this._el, e3);
            for (const { handlerName: i4, handler: a2, allowed: h4 } of this._handlers) {
              if (!a2.isEnabled())
                continue;
              let u3;
              this._blockedByActive(s4, h4, i4) ? a2.reset() : a2[t3 || e3.type] && (u3 = a2[t3 || e3.type](e3, c2, l2), this.mergeHandlerResult(r3, n2, u3, i4, o2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || a2.isActive()) && (s4[i4] = a2);
            }
            const h3 = {};
            for (const e4 in this._previousActiveHandlers)
              s4[e4] || (h3[e4] = o2);
            this._previousActiveHandlers = s4, (Object.keys(h3).length || wr(r3)) && (this._changes.push([r3, n2, h3]), this._triggerRenderFrame()), (Object.keys(s4).length || wr(r3)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: u2 } = r3;
            u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
          }
          mergeHandlerResult(t3, i3, o2, r3, n2) {
            if (!o2)
              return;
            e2.extend(t3, o2);
            const a2 = { handlerName: r3, originalEvent: o2.originalEvent || n2 };
            o2.zoomDelta !== void 0 && (i3.zoom = a2), o2.panDelta !== void 0 && (i3.drag = a2), o2.pitchDelta !== void 0 && (i3.pitch = a2), o2.bearingDelta !== void 0 && (i3.rotate = a2);
          }
          _applyChanges() {
            const t3 = {}, i3 = {}, o2 = {};
            for (const [r3, n2, a2] of this._changes)
              r3.panDelta && (t3.panDelta = (t3.panDelta || new e2.pointGeometry(0, 0))._add(r3.panDelta)), r3.zoomDelta && (t3.zoomDelta = (t3.zoomDelta || 0) + r3.zoomDelta), r3.bearingDelta && (t3.bearingDelta = (t3.bearingDelta || 0) + r3.bearingDelta), r3.pitchDelta && (t3.pitchDelta = (t3.pitchDelta || 0) + r3.pitchDelta), r3.around !== void 0 && (t3.around = r3.around), r3.aroundCoord !== void 0 && (t3.aroundCoord = r3.aroundCoord), r3.pinchAround !== void 0 && (t3.pinchAround = r3.pinchAround), r3.noInertia && (t3.noInertia = r3.noInertia), e2.extend(i3, n2), e2.extend(o2, a2);
            this._updateMapTransform(t3, i3, o2), this._changes = [];
          }
          _updateMapTransform(t3, i3, o2) {
            const r3 = this._map, n2 = r3.transform, a2 = (e3) => [e3.x, e3.y, e3.z];
            if (((e3) => {
              const t4 = this._eventsInProgress.drag;
              return t4 && !this._handlersById[t4.handlerName].isActive();
            })() && !wr(t3)) {
              const e3 = n2.zoom;
              n2.cameraElevationReference = "sea", n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", e3 !== n2.zoom && this._map._update(true);
            }
            if (!wr(t3))
              return this._fireEvents(i3, o2, true);
            let { panDelta: s4, zoomDelta: l2, bearingDelta: c2, pitchDelta: h3, around: u2, aroundCoord: _2, pinchAround: d2 } = t3;
            d2 !== void 0 && (u2 = d2), ((e3) => i3.drag && !this._eventsInProgress.drag)() && u2 && (this._dragOrigin = a2(n2.pointCoordinate3D(u2)), this._trackingEllipsoid.setup(n2._camera.position, this._dragOrigin)), n2.cameraElevationReference = "sea", r3._stop(true), u2 = u2 || r3.transform.centerPoint, c2 && (n2.bearing += c2), h3 && (n2.pitch += h3), n2._updateCameraState();
            const p2 = [0, 0, 0];
            if (s4) {
              const e3 = n2.pointCoordinate(u2), t4 = n2.pointCoordinate(u2.sub(s4));
              e3 && t4 && (p2[0] = t4.x - e3.x, p2[1] = t4.y - e3.y);
            }
            const m3 = n2.zoom, f4 = [0, 0, 0];
            if (l2) {
              const t4 = a2(_2 || n2.pointCoordinate3D(u2)), i4 = { dir: e2.normalize([], e2.sub([], t4, n2._camera.position)) };
              if (i4.dir[2] < 0) {
                const o3 = n2.zoomDeltaToMovement(t4, l2);
                e2.scale$2(f4, i4.dir, o3);
              }
            }
            const g2 = e2.add(p2, p2, f4);
            n2._translateCameraConstrained(g2), l2 && Math.abs(n2.zoom - m3) > 1e-4 && n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(i3, o2, true);
          }
          _fireEvents(t3, i3, o2) {
            const r3 = xr(this._eventsInProgress), n2 = xr(t3), a2 = {};
            for (const e3 in t3) {
              const { originalEvent: i4 } = t3[e3];
              this._eventsInProgress[e3] || (a2[`${e3}start`] = i4), this._eventsInProgress[e3] = t3[e3];
            }
            !r3 && n2 && this._fireEvent("movestart", n2.originalEvent);
            for (const e3 in a2)
              this._fireEvent(e3, a2[e3]);
            n2 && this._fireEvent("move", n2.originalEvent);
            for (const e3 in t3) {
              const { originalEvent: i4 } = t3[e3];
              this._fireEvent(e3, i4);
            }
            const s4 = {};
            let l2;
            for (const e3 in this._eventsInProgress) {
              const { handlerName: t4, originalEvent: o3 } = this._eventsInProgress[e3];
              this._handlersById[t4].isActive() || (delete this._eventsInProgress[e3], l2 = i3[t4] || o3, s4[`${e3}end`] = l2);
            }
            for (const e3 in s4)
              this._fireEvent(e3, s4[e3]);
            const c2 = xr(this._eventsInProgress);
            if (o2 && (r3 || n2) && !c2) {
              this._updatingCamera = true;
              const t4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (e3) => e3 !== 0 && -this._bearingSnap < e3 && e3 < this._bearingSnap;
              t4 ? (i4(t4.bearing || this._map.getBearing()) && (t4.bearing = 0), this._map.easeTo(t4, { originalEvent: l2 })) : (this._map.fire(new e2.Event("moveend", { originalEvent: l2 })), i4(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t3, i3) {
            this._map.fire(new e2.Event(t3, i3 ? { originalEvent: i3 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e3) => {
              delete this._frameId, this.handleEvent(new yr("renderFrame", { timeStamp: e3 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        const Er = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Cr extends e2.Evented {
          constructor(t3, i3) {
            super(), this._moving = false, this._zooming = false, this.transform = t3, this._bearingSnap = i3.bearingSnap, e2.bindAll(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e2.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e3, t3) {
            return this.jumpTo({ center: e3 }, t3);
          }
          panBy(t3, i3, o2) {
            return t3 = e2.pointGeometry.convert(t3).mult(-1), this.panTo(this.transform.center, e2.extend({ offset: t3 }, i3), o2);
          }
          panTo(t3, i3, o2) {
            return this.easeTo(e2.extend({ center: t3 }, i3), o2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e3, t3) {
            return this.jumpTo({ zoom: e3 }, t3), this;
          }
          zoomTo(t3, i3, o2) {
            return this.easeTo(e2.extend({ zoom: t3 }, i3), o2);
          }
          zoomIn(e3, t3) {
            return this.zoomTo(this.getZoom() + 1, e3, t3), this;
          }
          zoomOut(e3, t3) {
            return this.zoomTo(this.getZoom() - 1, e3, t3), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e3, t3) {
            return this.jumpTo({ bearing: e3 }, t3), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e3, t3) {
            return this.jumpTo({ padding: e3 }, t3), this;
          }
          rotateTo(t3, i3, o2) {
            return this.easeTo(e2.extend({ bearing: t3 }, i3), o2);
          }
          resetNorth(t3, i3) {
            return this.rotateTo(0, e2.extend({ duration: 1e3 }, t3), i3), this;
          }
          resetNorthPitch(t3, i3) {
            return this.easeTo(e2.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t3), i3), this;
          }
          snapToNorth(e3, t3) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e3, t3) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e3, t3) {
            return this.jumpTo({ pitch: e3 }, t3), this;
          }
          cameraForBounds(t3, i3) {
            t3 = e2.LngLatBounds.convert(t3);
            const o2 = i3 && i3.bearing || 0;
            return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), o2, i3);
          }
          _extendCameraOptions(t3) {
            const i3 = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (t3 = e2.extend({ padding: i3, offset: [0, 0], maxZoom: this.transform.maxZoom }, t3)).padding == "number") {
              const e3 = t3.padding;
              t3.padding = { top: e3, bottom: e3, right: e3, left: e3 };
            }
            return t3.padding = e2.extend(i3, t3.padding), t3;
          }
          _cameraForBoxAndBearing(t3, i3, o2, r3) {
            const n2 = this._extendCameraOptions(r3), a2 = this.transform, s4 = a2.padding, l2 = a2.project(e2.LngLat.convert(t3)), c2 = a2.project(e2.LngLat.convert(i3)), h3 = l2.rotate(-e2.degToRad(o2)), u2 = c2.rotate(-e2.degToRad(o2)), _2 = new e2.pointGeometry(Math.max(h3.x, u2.x), Math.max(h3.y, u2.y)), d2 = new e2.pointGeometry(Math.min(h3.x, u2.x), Math.min(h3.y, u2.y)), p2 = _2.sub(d2), m3 = (a2.width - (s4.left + s4.right + n2.padding.left + n2.padding.right)) / p2.x, f4 = (a2.height - (s4.top + s4.bottom + n2.padding.top + n2.padding.bottom)) / p2.y;
            if (f4 < 0 || m3 < 0)
              return void e2.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const g2 = Math.min(a2.scaleZoom(a2.scale * Math.min(m3, f4)), n2.maxZoom), v2 = typeof n2.offset.x == "number" ? new e2.pointGeometry(n2.offset.x, n2.offset.y) : e2.pointGeometry.convert(n2.offset), x3 = new e2.pointGeometry((n2.padding.left - n2.padding.right) / 2, (n2.padding.top - n2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y2 = v2.add(x3).mult(a2.scale / a2.zoomScale(g2));
            return { center: a2.unproject(l2.add(c2).div(2).sub(y2)), zoom: g2, bearing: o2 };
          }
          _cameraForBox(t3, i3, o2, r3, n2) {
            const a2 = this._extendCameraOptions(n2);
            o2 = o2 || 0, r3 = r3 || 0, t3 = e2.LngLat.convert(t3), i3 = e2.LngLat.convert(i3);
            const s4 = this.transform.clone();
            s4.padding = a2.padding;
            const l2 = this.getFreeCameraOptions(), c2 = new e2.LngLat(0.5 * (t3.lng + i3.lng), 0.5 * (t3.lat + i3.lat)), h3 = 0.5 * (o2 + r3);
            if (s4._camera.position[2] < e2.mercatorZfromAltitude(h3, c2.lat))
              return void e2.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            l2.lookAtPoint(c2), s4.setFreeCameraOptions(l2);
            const u2 = e2.MercatorCoordinate.fromLngLat(t3), _2 = e2.MercatorCoordinate.fromLngLat(i3), d2 = s4.pointRayIntersection(s4.centerPoint, h3), p2 = [(m3 = s4.rayIntersectionCoordinate(d2)).x, m3.y, m3.z];
            var m3;
            const f4 = s4.screenPointToMercatorRay(s4.centerPoint), g2 = s4.projection.name !== "globe";
            let v2, x3 = 0;
            do {
              const t4 = Math.floor(s4.zoom), i4 = 1 << t4, n3 = Math.min(i4 * u2.x, i4 * _2.x), a3 = Math.min(i4 * u2.y, i4 * _2.y), l3 = Math.max(i4 * u2.x, i4 * _2.x), c3 = Math.max(i4 * u2.y, i4 * _2.y), h4 = new e2.Aabb([n3, a3, o2], [l3, c3, r3]), d3 = e2.Frustum.fromInvProjectionMatrix(s4.invProjMatrix, s4.worldSize, t4, g2);
              if (h4.intersects(d3) !== 2) {
                v2 && (s4._camera.position = e2.scaleAndAdd([], s4._camera.position, f4.dir, -v2), s4._updateStateFromCamera());
                break;
              }
              const m4 = e2.sub([], s4._camera.position, p2);
              v2 = 0.5 * e2.length(m4), s4._camera.position = e2.scaleAndAdd([], s4._camera.position, f4.dir, v2);
              try {
                s4._updateStateFromCamera();
              } catch (t5) {
                return void e2.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              }
            } while (++x3 < 10);
            return { center: s4.center, zoom: s4.zoom, bearing: s4.bearing, pitch: s4.pitch };
          }
          fitBounds(e3, t3, i3) {
            return this._fitInternal(this.cameraForBounds(e3, t3), t3, i3);
          }
          _raycastElevationBox(t3, i3) {
            const o2 = this.transform.elevation;
            if (!o2)
              return;
            const r3 = new e2.pointGeometry(t3.x, i3.y), n2 = new e2.pointGeometry(i3.x, t3.y), a2 = o2.pointCoordinate(t3);
            if (!a2)
              return;
            const s4 = o2.pointCoordinate(i3);
            if (!s4)
              return;
            const l2 = o2.pointCoordinate(r3);
            if (!l2)
              return;
            const c2 = o2.pointCoordinate(n2);
            if (!c2)
              return;
            const h3 = new e2.MercatorCoordinate(a2[0], a2[1]).toLngLat(), u2 = new e2.MercatorCoordinate(s4[0], s4[1]).toLngLat(), _2 = new e2.MercatorCoordinate(l2[0], l2[1]).toLngLat(), d2 = new e2.MercatorCoordinate(c2[0], c2[1]).toLngLat(), p2 = Math.min(h3.lng, Math.min(u2.lng, Math.min(_2.lng, d2.lng))), m3 = Math.min(h3.lat, Math.min(u2.lat, Math.min(_2.lat, d2.lat))), f4 = Math.max(h3.lng, Math.max(u2.lng, Math.max(_2.lng, d2.lng))), g2 = Math.max(h3.lat, Math.max(u2.lat, Math.max(_2.lat, d2.lat))), v2 = Math.min(a2[3], Math.min(s4[3], Math.min(l2[3], c2[3]))), x3 = Math.max(a2[3], Math.max(s4[3], Math.max(l2[3], c2[3])));
            return { minLngLat: new e2.LngLat(p2, m3), maxLngLat: new e2.LngLat(f4, g2), minAltitude: v2, maxAltitude: x3 };
          }
          fitScreenCoordinates(t3, i3, o2, r3, n2) {
            let a2, s4, l2, c2;
            const h3 = e2.pointGeometry.convert(t3), u2 = e2.pointGeometry.convert(i3), _2 = this._raycastElevationBox(h3, u2);
            if (_2)
              a2 = _2.minLngLat, s4 = _2.maxLngLat, l2 = _2.minAltitude, c2 = _2.maxAltitude;
            else {
              if (this.transform.anyCornerOffEdge(h3, u2))
                return this;
              a2 = this.transform.pointLocation(h3), s4 = this.transform.pointLocation(u2);
            }
            return this._fitInternal(this.transform.pitch === 0 ? this._cameraForBoxAndBearing(this.transform.pointLocation(e2.pointGeometry.convert(t3)), this.transform.pointLocation(e2.pointGeometry.convert(i3)), o2, r3) : this._cameraForBox(a2, s4, l2, c2, r3), r3, n2);
          }
          _fitInternal(t3, i3, o2) {
            return t3 ? (delete (i3 = e2.extend(t3, i3)).padding, i3.linear ? this.easeTo(i3, o2) : this.flyTo(i3, o2)) : this;
          }
          jumpTo(t3, i3) {
            this.stop();
            const o2 = t3.preloadOnly ? this.transform.clone() : this.transform;
            let r3 = false, n2 = false, a2 = false;
            return "zoom" in t3 && o2.zoom !== +t3.zoom && (r3 = true, o2.zoom = +t3.zoom), t3.center !== void 0 && (o2.center = e2.LngLat.convert(t3.center)), "bearing" in t3 && o2.bearing !== +t3.bearing && (n2 = true, o2.bearing = +t3.bearing), "pitch" in t3 && o2.pitch !== +t3.pitch && (a2 = true, o2.pitch = +t3.pitch), t3.padding == null || o2.isPaddingEqual(t3.padding) || (o2.padding = t3.padding), t3.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e2.Event("movestart", i3)).fire(new e2.Event("move", i3)), r3 && this.fire(new e2.Event("zoomstart", i3)).fire(new e2.Event("zoom", i3)).fire(new e2.Event("zoomend", i3)), n2 && this.fire(new e2.Event("rotatestart", i3)).fire(new e2.Event("rotate", i3)).fire(new e2.Event("rotateend", i3)), a2 && this.fire(new e2.Event("pitchstart", i3)).fire(new e2.Event("pitch", i3)).fire(new e2.Event("pitchend", i3)), this.fire(new e2.Event("moveend", i3)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e2.warnOnce(Er), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t3, i3) {
            const o2 = this.transform;
            if (!o2.projection.supportsFreeCamera)
              return void e2.warnOnce(Er);
            this.stop();
            const r3 = o2.zoom, n2 = o2.pitch, a2 = o2.bearing;
            o2.setFreeCameraOptions(t3);
            const s4 = r3 !== o2.zoom, l2 = n2 !== o2.pitch, c2 = a2 !== o2.bearing;
            return this.fire(new e2.Event("movestart", i3)).fire(new e2.Event("move", i3)), s4 && this.fire(new e2.Event("zoomstart", i3)).fire(new e2.Event("zoom", i3)).fire(new e2.Event("zoomend", i3)), c2 && this.fire(new e2.Event("rotatestart", i3)).fire(new e2.Event("rotate", i3)).fire(new e2.Event("rotateend", i3)), l2 && this.fire(new e2.Event("pitchstart", i3)).fire(new e2.Event("pitch", i3)).fire(new e2.Event("pitchend", i3)), this.fire(new e2.Event("moveend", i3)), this;
          }
          easeTo(t3, i3) {
            this._stop(false, t3.easeId), ((t3 = e2.extend({ offset: [0, 0], duration: 500, easing: e2.ease }, t3)).animate === false || !t3.essential && e2.exported.prefersReducedMotion) && (t3.duration = 0);
            const o2 = this.transform, r3 = this.getZoom(), n2 = this.getBearing(), a2 = this.getPitch(), s4 = this.getPadding(), l2 = "zoom" in t3 ? +t3.zoom : r3, c2 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, n2) : n2, h3 = "pitch" in t3 ? +t3.pitch : a2, u2 = "padding" in t3 ? t3.padding : o2.padding, _2 = e2.pointGeometry.convert(t3.offset);
            let d2 = o2.centerPoint.add(_2);
            const p2 = o2.projection.name === "globe" ? o2.pointCoordinate(d2).toLngLat() : o2.pointLocation(d2), m3 = e2.LngLat.convert(t3.center || p2);
            this._normalizeCenter(m3);
            const f4 = o2.project(p2), g2 = o2.project(m3).sub(f4), v2 = o2.zoomScale(l2 - r3);
            let x3, y2;
            t3.around && (x3 = e2.LngLat.convert(t3.around), y2 = o2.locationPoint(x3));
            const b2 = this._zooming || l2 !== r3, w2 = this._rotating || n2 !== c2, T2 = this._pitching || h3 !== a2, E2 = !o2.isPaddingEqual(u2), C2 = (o3) => (p3) => {
              if (b2 && (o3.zoom = e2.number(r3, l2, p3)), w2 && (o3.bearing = e2.number(n2, c2, p3)), T2 && (o3.pitch = e2.number(a2, h3, p3)), E2 && (o3.interpolatePadding(s4, u2, p3), d2 = o3.centerPoint.add(_2)), x3)
                o3.setLocationAtPoint(x3, y2);
              else {
                const e3 = o3.zoomScale(o3.zoom - r3), t4 = l2 > r3 ? Math.min(2, v2) : Math.max(0.5, v2), i4 = Math.pow(t4, 1 - p3), n3 = o3.unproject(f4.add(g2.mult(p3 * i4)).mult(e3));
                o3.setLocationAtPoint(o3.renderWorldCopies ? n3.wrap() : n3, d2);
              }
              return t3.preloadOnly || this._fireMoveEvents(i3), o3;
            };
            if (t3.preloadOnly) {
              const e3 = this._emulate(C2, t3.duration, o2);
              return this._preloadTiles(e3), this;
            }
            const M2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = b2, this._rotating = w2, this._pitching = T2, this._padding = E2, this._easeId = t3.easeId, this._prepareEase(i3, t3.noMoveStart, M2), this._ease(C2(o2), (e3) => {
              o2.recenterOnTerrain(), this._afterEase(i3, e3);
            }, t3), this;
          }
          _prepareEase(t3, i3, o2 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", i3 || o2.moving || this.fire(new e2.Event("movestart", t3)), this._zooming && !o2.zooming && this.fire(new e2.Event("zoomstart", t3)), this._rotating && !o2.rotating && this.fire(new e2.Event("rotatestart", t3)), this._pitching && !o2.pitching && this.fire(new e2.Event("pitchstart", t3));
          }
          _fireMoveEvents(t3) {
            this.fire(new e2.Event("move", t3)), this._zooming && this.fire(new e2.Event("zoom", t3)), this._rotating && this.fire(new e2.Event("rotate", t3)), this._pitching && this.fire(new e2.Event("pitch", t3));
          }
          _afterEase(t3, i3) {
            if (this._easeId && i3 && this._easeId === i3)
              return;
            delete this._easeId, this.transform.cameraElevationReference = "ground";
            const o2 = this._zooming, r3 = this._rotating, n2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e2.Event("zoomend", t3)), r3 && this.fire(new e2.Event("rotateend", t3)), n2 && this.fire(new e2.Event("pitchend", t3)), this.fire(new e2.Event("moveend", t3));
          }
          flyTo(t3, i3) {
            if (!t3.essential && e2.exported.prefersReducedMotion) {
              const o3 = e2.pick(t3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o3, i3);
            }
            this.stop(), t3 = e2.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e2.ease }, t3);
            const o2 = this.transform, r3 = this.getZoom(), n2 = this.getBearing(), a2 = this.getPitch(), s4 = this.getPadding(), l2 = "zoom" in t3 ? e2.clamp(+t3.zoom, o2.minZoom, o2.maxZoom) : r3, c2 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, n2) : n2, h3 = "pitch" in t3 ? +t3.pitch : a2, u2 = "padding" in t3 ? t3.padding : o2.padding, _2 = o2.zoomScale(l2 - r3), d2 = e2.pointGeometry.convert(t3.offset);
            let p2 = o2.centerPoint.add(d2);
            const m3 = o2.pointLocation(p2), f4 = e2.LngLat.convert(t3.center || m3);
            this._normalizeCenter(f4);
            const g2 = o2.project(m3), v2 = o2.project(f4).sub(g2);
            let x3 = t3.curve;
            const y2 = Math.max(o2.width, o2.height), b2 = y2 / _2, w2 = v2.mag();
            if ("minZoom" in t3) {
              const i4 = e2.clamp(Math.min(t3.minZoom, r3, l2), o2.minZoom, o2.maxZoom), n3 = y2 / o2.zoomScale(i4 - r3);
              x3 = Math.sqrt(n3 / w2 * 2);
            }
            const T2 = x3 * x3;
            function E2(e3) {
              const t4 = (b2 * b2 - y2 * y2 + (e3 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e3 ? b2 : y2) * T2 * w2);
              return Math.log(Math.sqrt(t4 * t4 + 1) - t4);
            }
            function C2(e3) {
              return (Math.exp(e3) - Math.exp(-e3)) / 2;
            }
            function M2(e3) {
              return (Math.exp(e3) + Math.exp(-e3)) / 2;
            }
            const S3 = E2(0);
            let I2 = function(e3) {
              return M2(S3) / M2(S3 + x3 * e3);
            }, z2 = function(e3) {
              return y2 * ((M2(S3) * (C2(t4 = S3 + x3 * e3) / M2(t4)) - C2(S3)) / T2) / w2;
              var t4;
            }, D2 = (E2(1) - S3) / x3;
            if (Math.abs(w2) < 1e-6 || !isFinite(D2)) {
              if (Math.abs(y2 - b2) < 1e-6)
                return this.easeTo(t3, i3);
              const e3 = b2 < y2 ? -1 : 1;
              D2 = Math.abs(Math.log(b2 / y2)) / x3, z2 = function() {
                return 0;
              }, I2 = function(t4) {
                return Math.exp(e3 * x3 * t4);
              };
            }
            t3.duration = "duration" in t3 ? +t3.duration : 1e3 * D2 / ("screenSpeed" in t3 ? +t3.screenSpeed / x3 : +t3.speed), t3.maxDuration && t3.duration > t3.maxDuration && (t3.duration = 0);
            const P2 = n2 !== c2, A3 = h3 !== a2, L2 = !o2.isPaddingEqual(u2), R2 = (o3) => (_3) => {
              const m4 = _3 * D2, x4 = 1 / I2(m4);
              o3.zoom = _3 === 1 ? l2 : r3 + o3.scaleZoom(x4), P2 && (o3.bearing = e2.number(n2, c2, _3)), A3 && (o3.pitch = e2.number(a2, h3, _3)), L2 && (o3.interpolatePadding(s4, u2, _3), p2 = o3.centerPoint.add(d2));
              const y3 = _3 === 1 ? f4 : o3.unproject(g2.add(v2.mult(z2(m4))).mult(x4));
              return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p2), o3._updateCenterElevation(), t3.preloadOnly || this._fireMoveEvents(i3), o3;
            };
            if (t3.preloadOnly) {
              const e3 = this._emulate(R2, t3.duration, o2);
              return this._preloadTiles(e3), this;
            }
            return this._zooming = true, this._rotating = P2, this._pitching = A3, this._padding = L2, this._prepareEase(i3, false), this._ease(R2(o2), () => this._afterEase(i3), t3), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e3, t3) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const e4 = this._onEaseEnd;
              delete this._onEaseEnd, e4.call(this, t3);
            }
            if (!e3) {
              const e4 = this.handlers;
              e4 && e4.stop(false);
            }
            return this;
          }
          _ease(t3, i3, o2) {
            o2.animate === false || o2.duration === 0 ? (t3(1), i3()) : (this._easeStart = e2.exported.now(), this._easeOptions = o2, this._onEaseFrame = t3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t3 = Math.min((e2.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(t3)), t3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t3, i3) {
            t3 = e2.wrap(t3, -180, 180);
            const o2 = Math.abs(t3 - i3);
            return Math.abs(t3 - 360 - i3) < o2 && (t3 -= 360), Math.abs(t3 + 360 - i3) < o2 && (t3 += 360), t3;
          }
          _normalizeCenter(e3) {
            const t3 = this.transform;
            if (!t3.renderWorldCopies || t3.maxBounds)
              return;
            const i3 = e3.lng - t3.center.lng;
            e3.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
          }
          _emulate(e3, t3, i3) {
            const o2 = Math.ceil(15 * t3 / 1e3), r3 = [], n2 = e3(i3.clone());
            for (let e4 = 0; e4 <= o2; e4++) {
              const t4 = n2(e4 / o2);
              r3.push(t4.clone());
            }
            return r3;
          }
        }
        class Mr {
          constructor(t3 = {}) {
            this.options = t3, e2.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e3) {
            const t3 = this.options && this.options.compact;
            return this._map = e3, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = a.create("button", "mapboxgl-ctrl-attrib-button", this._container), a.create("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", true), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = a.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t3 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), t3 === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e3, t3) {
            const i3 = this._map._getUIString(`AttributionControl.${t3}`);
            e3.setAttribute("aria-label", i3), e3.removeAttribute("title"), e3.firstElementChild && e3.firstElementChild.setAttribute("title", i3);
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t3 = this._editLink;
            t3 || (t3 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i3 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e2.config.ACCESS_TOKEN }];
            if (t3) {
              const o2 = i3.reduce((e3, t4, o3) => (t4.value && (e3 += `${t4.key}=${t4.value}${o3 < i3.length - 1 ? "&" : ""}`), e3), "?");
              t3.href = `${e2.config.FEEDBACK_URL}/${o2}${this._map._hash ? this._map._hash.getHashString(true) : ""}`, t3.rel = "noopener nofollow", this._setElementTitle(t3, "MapFeedback");
            }
          }
          _updateData(e3) {
            !e3 || e3.sourceDataType !== "metadata" && e3.sourceDataType !== "visibility" && e3.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let e3 = [];
            if (this._map.style.stylesheet) {
              const e4 = this._map.style.stylesheet;
              this.styleOwner = e4.owner, this.styleId = e4.id;
            }
            const t3 = this._map.style._sourceCaches;
            for (const i4 in t3) {
              const o2 = t3[i4];
              if (o2.used) {
                const t4 = o2.getSource();
                t4.attribution && e3.indexOf(t4.attribution) < 0 && e3.push(t4.attribution);
              }
            }
            e3.sort((e4, t4) => e4.length - t4.length), e3 = e3.filter((t4, i4) => {
              for (let o2 = i4 + 1; o2 < e3.length; o2++)
                if (e3[o2].indexOf(t4) >= 0)
                  return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e3 = [...this.options.customAttribution, ...e3] : e3.unshift(this.options.customAttribution));
            const i3 = e3.join(" | ");
            i3 !== this._attribHTML && (this._attribHTML = i3, e3.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class Sr {
          constructor() {
            e2.bindAll(["_updateLogo"], this), e2.bindAll(["_updateCompact"], this);
          }
          onAdd(e3) {
            this._map = e3, this._container = a.create("div", "mapboxgl-ctrl");
            const t3 = a.create("a", "mapboxgl-ctrl-logo");
            return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://www.mapbox.com/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e3) {
            e3 && e3.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style)
              return true;
            const e3 = this._map.style._sourceCaches;
            if (Object.entries(e3).length === 0)
              return true;
            for (const t3 in e3) {
              const i3 = e3[t3].getSource();
              if (i3.hasOwnProperty("mapbox_logo") && !i3.mapbox_logo)
                return false;
            }
            return true;
          }
          _updateCompact() {
            const e3 = this._container.children;
            if (e3.length) {
              const t3 = e3[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t3.classList.add("mapboxgl-compact") : t3.classList.remove("mapboxgl-compact");
            }
          }
        }
        class Ir {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e3) {
            const t3 = ++this._id;
            return this._queue.push({ callback: e3, id: t3, cancelled: false }), t3;
          }
          remove(e3) {
            const t3 = this._currentlyRunning, i3 = t3 ? this._queue.concat(t3) : this._queue;
            for (const t4 of i3)
              if (t4.id === e3)
                return void (t4.cancelled = true);
          }
          run(e3 = 0) {
            const t3 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i3 of t3)
              if (!i3.cancelled && (i3.callback(e3), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        function zr(t3, i3, o2) {
          if (t3 = new e2.LngLat(t3.lng, t3.lat), i3) {
            const r3 = new e2.LngLat(t3.lng - 360, t3.lat), n2 = new e2.LngLat(t3.lng + 360, t3.lat), a2 = 360 * Math.ceil(Math.abs(t3.lng - o2.center.lng) / 360), s4 = o2.locationPoint(t3).distSqr(i3), l2 = i3.x < 0 || i3.y < 0 || i3.x > o2.width || i3.y > o2.height;
            o2.locationPoint(r3).distSqr(i3) < s4 && (l2 || Math.abs(r3.lng - o2.center.lng) < a2) ? t3 = r3 : o2.locationPoint(n2).distSqr(i3) < s4 && (l2 || Math.abs(n2.lng - o2.center.lng) < a2) && (t3 = n2);
          }
          for (; Math.abs(t3.lng - o2.center.lng) > 180; ) {
            const e3 = o2.locationPoint(t3);
            if (e3.x >= 0 && e3.y >= 0 && e3.x <= o2.width && e3.y <= o2.height)
              break;
            t3.lng > o2.center.lng ? t3.lng -= 360 : t3.lng += 360;
          }
          return t3;
        }
        const Dr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class Pr extends e2.Evented {
          constructor(t3, i3) {
            if (super(), (t3 instanceof e2.window.HTMLElement || i3) && (t3 = e2.extend({ element: t3 }, i3)), e2.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t3 && t3.anchor || "center", this._color = t3 && t3.color || "#3FB1CE", this._scale = t3 && t3.scale || 1, this._draggable = t3 && t3.draggable || false, this._clickTolerance = t3 && t3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t3 && t3.rotation || 0, this._rotationAlignment = t3 && t3.rotationAlignment || "auto", this._pitchAlignment = t3 && t3.pitchAlignment && t3.pitchAlignment !== "auto" ? t3.pitchAlignment : this._rotationAlignment, this._updateMoving = () => this._update(true), t3 && t3.element)
              this._element = t3.element, this._offset = e2.pointGeometry.convert(t3 && t3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = a.create("div");
              const i4 = 41, o3 = 27, r3 = a.createSVG("svg", { display: "block", height: i4 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i4}` }, this._element), n2 = a.createSVG("radialGradient", { id: "shadowGradient" }, a.createSVG("defs", {}, r3));
              a.createSVG("stop", { offset: "10%", "stop-opacity": 0.4 }, n2), a.createSVG("stop", { offset: "100%", "stop-opacity": 0.05 }, n2), a.createSVG("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), a.createSVG("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), a.createSVG("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), a.createSVG("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e2.pointGeometry.convert(t3 && t3.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e3) => {
              e3.preventDefault();
            }), this._element.addEventListener("mousedown", (e3) => {
              e3.preventDefault();
            });
            const o2 = this._element.classList;
            for (const e3 in Dr)
              o2.remove(`mapboxgl-marker-anchor-${e3}`);
            o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
          }
          addTo(e3) {
            return e3 === this._map || (this.remove(), this._map = e3, e3.getCanvasContainer().appendChild(this._element), e3.on("move", this._updateMoving), e3.on("moveend", this._update), e3.on("remove", this._clearFadeTimer), e3._addMarker(this), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick)), this;
          }
          remove() {
            return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._updateMoving), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._map.off("remove", this._clearFadeTimer), this._map._removeMarker(this), delete this._map), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            return this._lngLat = e2.LngLat.convert(t3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e3) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e3) {
              if (!("offset" in e3.options)) {
                const t3 = 38.1, i3 = 13.5, o2 = Math.sqrt(Math.pow(i3, 2) / 2);
                e3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t3], "bottom-left": [o2, -1 * (t3 - i3 + o2)], "bottom-right": [-o2, -1 * (t3 - i3 + o2)], left: [i3, -1 * (t3 - i3)], right: [-i3, -1 * (t3 - i3)] } : this._offset;
              }
              this._popup = e3, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e3) {
            const t3 = e3.code, i3 = e3.charCode || e3.keyCode;
            t3 !== "Space" && t3 !== "Enter" && i3 !== 32 && i3 !== 13 || this.togglePopup();
          }
          _onMapClick(e3) {
            const t3 = e3.originalEvent.target, i3 = this._element;
            this._popup && (t3 === i3 || i3.contains(t3)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e3 = this._popup;
            return e3 ? (e3.isOpen() ? (e3.remove(), this._element.setAttribute("aria-expanded", "false")) : (e3.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _evaluateOpacity() {
            const e3 = this._pos ? this._pos.sub(this._transformedOffset()) : null;
            if (!this._withinScreenBounds(e3))
              return void this._clearFadeTimer();
            const t3 = this._map.unproject(e3);
            let i3 = false;
            if (this._map.transform._terrainEnabled() && this._map.getTerrain()) {
              const e4 = this._map.getFreeCameraOptions();
              if (e4.position) {
                const o3 = e4.position.toLngLat();
                i3 = o3.distanceTo(t3) < 0.9 * o3.distanceTo(this._lngLat);
              }
            }
            const o2 = (1 - this._map._queryFogOpacity(t3)) * (i3 ? 0.2 : 1);
            this._element.style.opacity = `${o2}`, this._popup && this._popup._setOpacity(`${o2}`), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _withinScreenBounds(e3) {
            const t3 = this._map.transform;
            return !!e3 && e3.x >= 0 && e3.x < t3.width && e3.y >= 0 && e3.y < t3.height;
          }
          _updateDOM() {
            const t3 = this._pos || new e2.pointGeometry(0, 0), i3 = this._calculatePitch(), o2 = this._calculateRotation();
            this._element.style.transform = `${Dr[this._anchor]} translate(${t3.x}px, ${t3.y}px) rotateX(${i3}deg) rotateZ(${o2}deg)`;
          }
          _calculatePitch() {
            return this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? 0 : this._pitchAlignment === "map" ? this._map.getPitch() : 0;
          }
          _calculateRotation() {
            return this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? this._rotation : this._rotationAlignment === "map" ? this._rotation - this._map.getBearing() : 0;
          }
          _update(t3) {
            e2.window.cancelAnimationFrame(this._updateFrameId), this._map && (this._map.transform.renderWorldCopies && (this._lngLat = zr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._transformedOffset()), t3 === true ? this._updateFrameId = e2.window.requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), this._map._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), !this._map.getTerrain() && !this._map.getFog() || this._fadeTimer || (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          _transformedOffset() {
            if (!this._defaultMarker)
              return this._offset;
            const e3 = this._map.transform, t3 = this._offset.mult(this._scale);
            return this._rotationAlignment === "map" && t3._rotate(e3.angle), this._pitchAlignment === "map" && (t3.y *= Math.cos(e3._pitch)), t3;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t3) {
            return this._offset = e2.pointGeometry.convert(t3), this._update(), this;
          }
          _onMove(t3) {
            if (!this._isDragging) {
              const e3 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = t3.point.dist(this._pointerdownPos) >= e3;
            }
            this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new e2.Event("dragstart"))), this.fire(new e2.Event("drag")));
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new e2.Event("dragend")), this._state = "inactive";
          }
          _addDragHandler(e3) {
            this._element.contains(e3.originalEvent.target) && (e3.preventDefault(), this._positionDelta = e3.point.sub(this._pos).add(this._transformedOffset()), this._pointerdownPos = e3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }
          setDraggable(e3) {
            return this._draggable = !!e3, this._map && (e3 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e3) {
            return this._rotation = e3 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e3) {
            return this._rotationAlignment = e3 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e3) {
            return this._pitchAlignment = e3 && e3 !== "auto" ? e3 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
        }
        class Ar {
          constructor(e3) {
            this.jumpTo(e3);
          }
          getValue(t3) {
            if (t3 <= this._startTime)
              return this._start;
            if (t3 >= this._endTime)
              return this._end;
            const i3 = e2.easeCubicInOut((t3 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i3) + this._end * i3;
          }
          isEasing(e3) {
            return e3 >= this._startTime && e3 <= this._endTime;
          }
          jumpTo(e3) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e3, this._end = e3;
          }
          easeTo(e3, t3, i3) {
            this._start = this.getValue(t3), this._end = e3, this._startTime = t3, this._endTime = t3 + i3;
          }
        }
        const Lr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, { HTMLImageElement: Rr, HTMLElement: kr, ImageBitmap: Or } = e2.window, Br = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true };
        function Fr(e3) {
          e3.parentNode && e3.parentNode.removeChild(e3);
        }
        const Ur = { showCompass: true, showZoom: true, visualizePitch: false };
        class Nr {
          constructor(t3, i3, o2 = false) {
            this._clickTolerance = 10, this.element = i3, this.mouseRotate = new Yo({ clickTolerance: t3.dragRotate._mouseRotate._clickTolerance }), this.map = t3, o2 && (this.mousePitch = new Jo({ clickTolerance: t3.dragRotate._mousePitch._clickTolerance })), e2.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i3.addEventListener("mousedown", this.mousedown), i3.addEventListener("touchstart", this.touchstart, { passive: false }), i3.addEventListener("touchmove", this.touchmove), i3.addEventListener("touchend", this.touchend), i3.addEventListener("touchcancel", this.reset);
          }
          down(e3, t3) {
            this.mouseRotate.mousedown(e3, t3), this.mousePitch && this.mousePitch.mousedown(e3, t3), a.disableDrag();
          }
          move(e3, t3) {
            const i3 = this.map, o2 = this.mouseRotate.mousemoveWindow(e3, t3);
            if (o2 && o2.bearingDelta && i3.setBearing(i3.getBearing() + o2.bearingDelta), this.mousePitch) {
              const o3 = this.mousePitch.mousemoveWindow(e3, t3);
              o3 && o3.pitchDelta && i3.setPitch(i3.getPitch() + o3.pitchDelta);
            }
          }
          off() {
            const e3 = this.element;
            e3.removeEventListener("mousedown", this.mousedown), e3.removeEventListener("touchstart", this.touchstart, { passive: false }), e3.removeEventListener("touchmove", this.touchmove), e3.removeEventListener("touchend", this.touchend), e3.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            a.enableDrag(), e2.window.removeEventListener("mousemove", this.mousemove), e2.window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t3) {
            this.down(e2.extend({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), a.mousePos(this.element, t3)), e2.window.addEventListener("mousemove", this.mousemove), e2.window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e3) {
            this.move(e3, a.mousePos(this.element, e3));
          }
          mouseup(e3) {
            this.mouseRotate.mouseupWindow(e3), this.mousePitch && this.mousePitch.mouseupWindow(e3), this.offTemp();
          }
          touchstart(e3) {
            e3.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = a.touchPos(this.element, e3.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e3.preventDefault() }, this._startPos));
          }
          touchmove(e3) {
            e3.targetTouches.length !== 1 ? this.reset() : (this._lastPos = a.touchPos(this.element, e3.targetTouches)[0], this.move({ preventDefault: () => e3.preventDefault() }, this._lastPos));
          }
          touchend(e3) {
            e3.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        const Gr = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false };
        let jr, Zr = 0, Vr = false;
        const Wr = { maxWidth: 100, unit: "metric" };
        function qr(e3, t3, i3) {
          const o2 = i3 && i3.maxWidth || 100, r3 = e3._containerHeight / 2, n2 = e3.unproject([0, r3]), a2 = e3.unproject([o2, r3]), s4 = n2.distanceTo(a2);
          if (i3 && i3.unit === "imperial") {
            const i4 = 3.2808 * s4;
            i4 > 5280 ? Xr(t3, o2, i4 / 5280, e3._getUIString("ScaleControl.Miles"), e3) : Xr(t3, o2, i4, e3._getUIString("ScaleControl.Feet"), e3);
          } else
            i3 && i3.unit === "nautical" ? Xr(t3, o2, s4 / 1852, e3._getUIString("ScaleControl.NauticalMiles"), e3) : s4 >= 1e3 ? Xr(t3, o2, s4 / 1e3, e3._getUIString("ScaleControl.Kilometers"), e3) : Xr(t3, o2, s4, e3._getUIString("ScaleControl.Meters"), e3);
        }
        function Xr(e3, t3, i3, o2, r3) {
          const n2 = function(e4) {
            const t4 = Math.pow(10, `${Math.floor(e4)}`.length - 1);
            let i4 = e4 / t4;
            return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(e5) {
              const t5 = Math.pow(10, Math.ceil(-Math.log(e5) / Math.LN10));
              return Math.round(e5 * t5) / t5;
            }(i4), t4 * i4;
          }(i3), a2 = n2 / i3;
          r3._requestDomTask(() => {
            e3.style.width = t3 * a2 + "px", e3.innerHTML = `${n2}&nbsp;${o2}`;
          });
        }
        const $r = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Hr = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Kr = { version: e2.version, supported: t2, setRTLTextPlugin: e2.setRTLTextPlugin, getRTLTextPluginStatus: e2.getRTLTextPluginStatus, Map: class extends Cr {
          constructor(t3) {
            if ((t3 = e2.extend({}, Br, t3)).minZoom != null && t3.maxZoom != null && t3.minZoom > t3.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (t3.minPitch != null && t3.maxPitch != null && t3.minPitch > t3.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (t3.minPitch != null && t3.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t3.maxPitch != null && t3.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3.antialias && e2.isSafariWithAntialiasingBug(e2.window) && (t3.antialias = false, e2.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new So(t3.minZoom, t3.maxZoom, t3.minPitch, t3.maxPitch, t3.renderWorldCopies), t3), this._interactive = t3.interactive, this._minTileCacheSize = t3.minTileCacheSize, this._maxTileCacheSize = t3.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t3.preserveDrawingBuffer, this._antialias = t3.antialias, this._trackResize = t3.trackResize, this._bearingSnap = t3.bearingSnap, this._refreshExpiredTiles = t3.refreshExpiredTiles, this._fadeDuration = t3.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t3.collectResourceTiming, this._optimizeForTerrain = t3.optimizeForTerrain, this._renderTaskQueue = new Ir(), this._domRenderTaskQueue = new Ir(), this._controls = [], this._markers = [], this._mapId = e2.uniqueId(), this._locale = e2.extend({}, Lr, t3.locale), this._clickTolerance = t3.clickTolerance, this._cooperativeGestures = t3.cooperativeGestures, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevation = new Ar(0), this._requestManager = new e2.RequestManager(t3.transformRequest, t3.accessToken, t3.testMode), this._silenceAuthErrors = !!t3.testMode, typeof t3.container == "string") {
              if (this._container = e2.window.document.getElementById(t3.container), !this._container)
                throw new Error(`Container '${t3.container}' not found.`);
            } else {
              if (!(t3.container instanceof kr))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t3.container;
            }
            if (this._container.childNodes.length > 0 && e2.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t3.maxBounds && this.setMaxBounds(t3.maxBounds), e2.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), e2.window !== void 0 && (e2.window.addEventListener("online", this._onWindowOnline, false), e2.window.addEventListener("resize", this._onWindowResize, false), e2.window.addEventListener("orientationchange", this._onWindowResize, false), e2.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false)), this.handlers = new Tr(this, t3), this._localFontFamily = t3.localFontFamily, this._localIdeographFontFamily = t3.localIdeographFontFamily, t3.style && this.setStyle(t3.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t3.projection && this.setProjection(t3.projection), this._hash = t3.hash && new zo(typeof t3.hash == "string" && t3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t3.center, zoom: t3.zoom, bearing: t3.bearing, pitch: t3.pitch }), t3.bounds && (this.resize(), this.fitBounds(t3.bounds, e2.extend({}, t3.fitBoundsOptions, { duration: 0 })))), this.resize(), t3.attributionControl && this.addControl(new Mr({ customAttribution: t3.customAttribution })), this._logoControl = new Sr(), this.addControl(this._logoControl, t3.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t4) => {
              this._update(t4.dataType === "style"), this.fire(new e2.Event(`${t4.dataType}data`, t4));
            }), this.on("dataloading", (t4) => {
              this.fire(new e2.Event(`${t4.dataType}dataloading`, t4));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t3, i3) {
            if (i3 === void 0 && (i3 = t3.getDefaultPosition ? t3.getDefaultPosition() : "top-right"), !t3 || !t3.onAdd)
              return this.fire(new e2.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o2 = t3.onAdd(this);
            this._controls.push(t3);
            const r3 = this._controlPositions[i3];
            return i3.indexOf("bottom") !== -1 ? r3.insertBefore(o2, r3.firstChild) : r3.appendChild(o2), this;
          }
          removeControl(t3) {
            if (!t3 || !t3.onRemove)
              return this.fire(new e2.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i3 = this._controls.indexOf(t3);
            return i3 > -1 && this._controls.splice(i3, 1), t3.onRemove(this), this;
          }
          hasControl(e3) {
            return this._controls.indexOf(e3) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t3) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
              return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i3 = !this._moving;
            return i3 && this.fire(new e2.Event("movestart", t3)).fire(new e2.Event("move", t3)), this.fire(new e2.Event("resize", t3)), i3 && this.fire(new e2.Event("moveend", t3)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t3) {
            return this.transform.setMaxBounds(e2.LngLatBounds.convert(t3)), this._update();
          }
          setMinZoom(t3) {
            if ((t3 = t3 == null ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom)
              return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 ? this.setZoom(t3) : this.fire(new e2.Event("zoomstart")).fire(new e2.Event("zoom")).fire(new e2.Event("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t3) {
            if ((t3 = t3 == null ? 22 : t3) >= this.transform.minZoom)
              return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 ? this.setZoom(t3) : this.fire(new e2.Event("zoomstart")).fire(new e2.Event("zoom")).fire(new e2.Event("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t3) {
            if ((t3 = t3 == null ? 0 : t3) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t3 >= 0 && t3 <= this.transform.maxPitch)
              return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 ? this.setPitch(t3) : this.fire(new e2.Event("pitchstart")).fire(new e2.Event("pitch")).fire(new e2.Event("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t3) {
            if ((t3 = t3 == null ? 85 : t3) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3 >= this.transform.minPitch)
              return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 ? this.setPitch(t3) : this.fire(new e2.Event("pitchstart")).fire(new e2.Event("pitch")).fire(new e2.Event("pitchend")), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e3) {
            return this.transform.renderWorldCopies = e3, this._update();
          }
          getProjection() {
            return this.transform.getProjection();
          }
          setProjection(e3) {
            return this._lazyInitEmptyStyle(), typeof e3 == "string" && (e3 = { name: e3 }), this._runtimeProjection = e3, this.style.updateProjection(), this._transitionFromGlobe = false, this;
          }
          project(t3) {
            return this.transform.locationPoint3D(e2.LngLat.convert(t3));
          }
          unproject(t3) {
            return this.transform.pointLocation3D(e2.pointGeometry.convert(t3));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving();
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming();
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating();
          }
          _createDelegatedListener(e3, t3, i3) {
            if (e3 === "mouseenter" || e3 === "mouseover") {
              let o2 = false;
              const r3 = (r4) => {
                const n3 = t3.filter((e4) => this.getLayer(e4)), a2 = n3.length ? this.queryRenderedFeatures(r4.point, { layers: n3 }) : [];
                a2.length ? o2 || (o2 = true, i3.call(this, new Fo(e3, this, r4.originalEvent, { features: a2 }))) : o2 = false;
              }, n2 = () => {
                o2 = false;
              };
              return { layers: new Set(t3), listener: i3, delegates: { mousemove: r3, mouseout: n2 } };
            }
            if (e3 === "mouseleave" || e3 === "mouseout") {
              let o2 = false;
              const r3 = (r4) => {
                const n3 = t3.filter((e4) => this.getLayer(e4));
                (n3.length ? this.queryRenderedFeatures(r4.point, { layers: n3 }) : []).length ? o2 = true : o2 && (o2 = false, i3.call(this, new Fo(e3, this, r4.originalEvent)));
              }, n2 = (t4) => {
                o2 && (o2 = false, i3.call(this, new Fo(e3, this, t4.originalEvent)));
              };
              return { layers: new Set(t3), listener: i3, delegates: { mousemove: r3, mouseout: n2 } };
            }
            {
              const o2 = (e4) => {
                const o3 = t3.filter((e5) => this.getLayer(e5)), r3 = o3.length ? this.queryRenderedFeatures(e4.point, { layers: o3 }) : [];
                r3.length && (e4.features = r3, i3.call(this, e4), delete e4.features);
              };
              return { layers: new Set(t3), listener: i3, delegates: { [e3]: o2 } };
            }
          }
          on(e3, t3, i3) {
            if (i3 === void 0)
              return super.on(e3, t3);
            Array.isArray(t3) || (t3 = [t3]);
            const o2 = this._createDelegatedListener(e3, t3, i3);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e3] = this._delegatedListeners[e3] || [], this._delegatedListeners[e3].push(o2);
            for (const e4 in o2.delegates)
              this.on(e4, o2.delegates[e4]);
            return this;
          }
          once(e3, t3, i3) {
            if (i3 === void 0)
              return super.once(e3, t3);
            Array.isArray(t3) || (t3 = [t3]);
            const o2 = this._createDelegatedListener(e3, t3, i3);
            for (const e4 in o2.delegates)
              this.once(e4, o2.delegates[e4]);
            return this;
          }
          off(e3, t3, i3) {
            if (i3 === void 0)
              return super.off(e3, t3);
            t3 = new Set(Array.isArray(t3) ? t3 : [t3]);
            const o2 = (e4, t4) => {
              if (e4.size !== t4.size)
                return false;
              for (const i4 of e4)
                if (!t4.has(i4))
                  return false;
              return true;
            }, r3 = this._delegatedListeners ? this._delegatedListeners[e3] : void 0;
            return r3 && ((e4) => {
              for (let r4 = 0; r4 < e4.length; r4++) {
                const n2 = e4[r4];
                if (n2.listener === i3 && o2(n2.layers, t3)) {
                  for (const e5 in n2.delegates)
                    this.off(e5, n2.delegates[e5]);
                  return e4.splice(r4, 1), this;
                }
              }
            })(r3), this;
          }
          queryRenderedFeatures(t3, i3) {
            return this.style ? (i3 !== void 0 || t3 === void 0 || t3 instanceof e2.pointGeometry || Array.isArray(t3) || (i3 = t3, t3 = void 0), this.style.queryRenderedFeatures(t3 = t3 || [[0, 0], [this.transform.width, this.transform.height]], i3 = i3 || {}, this.transform)) : [];
          }
          querySourceFeatures(e3, t3) {
            return this.style.querySourceFeatures(e3, t3);
          }
          queryTerrainElevation(t3, i3) {
            const o2 = this.transform.elevation;
            return o2 ? (i3 = e2.extend({}, { exaggerated: true }, i3), o2.getAtPoint(e2.MercatorCoordinate.fromLngLat(t3), null, i3.exaggerated)) : null;
          }
          setStyle(t3, i3) {
            return (i3 = e2.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i3)).diff !== false && i3.localIdeographFontFamily === this._localIdeographFontFamily && i3.localFontFamily === this._localFontFamily && this.style && t3 ? (this._diffStyle(t3, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._localFontFamily = i3.localFontFamily, this._updateStyle(t3, i3));
          }
          _getUIString(e3) {
            const t3 = this._locale[e3];
            if (t3 == null)
              throw new Error(`Missing UI string '${e3}'`);
            return t3;
          }
          _updateStyle(e3, t3) {
            return this.style && (this.style.setEventedParent(null), this.style._remove(), delete this.style), e3 && (this.style = new Nt(this, t3 || {}), this.style.setEventedParent(this, { style: this.style }), typeof e3 == "string" ? this.style.loadURL(e3) : this.style.loadJSON(e3)), this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Nt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t3, i3) {
            if (typeof t3 == "string") {
              const o2 = this._requestManager.normalizeStyleURL(t3), r3 = this._requestManager.transformRequest(o2, e2.ResourceType.Style);
              e2.getJSON(r3, (t4, o3) => {
                t4 ? this.fire(new e2.ErrorEvent(t4)) : o3 && this._updateDiff(o3, i3);
              });
            } else
              typeof t3 == "object" && this._updateDiff(t3, i3);
          }
          _updateDiff(t3, i3) {
            try {
              this.style.setState(t3) && this._update(true);
            } catch (o2) {
              e2.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t3, i3);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : e2.warnOnce("There is no style added to the map.");
          }
          addSource(e3, t3) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e3, t3), this._update(true);
          }
          isSourceLoaded(t3) {
            const i3 = this.style && this.style._getSourceCaches(t3);
            if (i3.length !== 0)
              return i3.every((e3) => e3.loaded());
            this.fire(new e2.ErrorEvent(new Error(`There is no source with ID '${t3}'`)));
          }
          areTilesLoaded() {
            const e3 = this.style && this.style._sourceCaches;
            for (const t3 in e3) {
              const i3 = e3[t3]._tiles;
              for (const e4 in i3) {
                const t4 = i3[e4];
                if (t4.state !== "loaded" && t4.state !== "errored")
                  return false;
              }
            }
            return true;
          }
          addSourceType(e3, t3, i3) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(e3, t3, i3);
          }
          removeSource(e3) {
            return this.style.removeSource(e3), this._updateTerrain(), this._update(true);
          }
          getSource(e3) {
            return this.style.getSource(e3);
          }
          addImage(t3, i3, { pixelRatio: o2 = 1, sdf: r3 = false, stretchX: n2, stretchY: a2, content: s4 } = {}) {
            if (this._lazyInitEmptyStyle(), i3 instanceof Rr || Or && i3 instanceof Or) {
              const { width: l2, height: c2, data: h3 } = e2.exported.getImageData(i3);
              this.style.addImage(t3, { data: new e2.RGBAImage({ width: l2, height: c2 }, h3), pixelRatio: o2, stretchX: n2, stretchY: a2, content: s4, sdf: r3, version: 0 });
            } else {
              if (i3.width === void 0 || i3.height === void 0)
                return this.fire(new e2.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: l2, height: c2, data: h3 } = i3, u2 = i3;
                this.style.addImage(t3, { data: new e2.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h3)), pixelRatio: o2, stretchX: n2, stretchY: a2, content: s4, sdf: r3, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, t3);
              }
            }
          }
          updateImage(t3, i3) {
            const o2 = this.style.getImage(t3);
            if (!o2)
              return this.fire(new e2.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r3 = i3 instanceof Rr || Or && i3 instanceof Or ? e2.exported.getImageData(i3) : i3, { width: n2, height: a2, data: s4 } = r3;
            return n2 === void 0 || a2 === void 0 ? this.fire(new e2.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : n2 !== o2.data.width || a2 !== o2.data.height ? this.fire(new e2.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o2.data.replace(s4, !(i3 instanceof Rr || Or && i3 instanceof Or)), void this.style.updateImage(t3, o2));
          }
          hasImage(t3) {
            return t3 ? !!this.style.getImage(t3) : (this.fire(new e2.ErrorEvent(new Error("Missing required image id"))), false);
          }
          removeImage(e3) {
            this.style.removeImage(e3);
          }
          loadImage(t3, i3) {
            e2.getImage(this._requestManager.transformRequest(t3, e2.ResourceType.Image), (t4, o2) => {
              i3(t4, o2 instanceof Rr ? e2.exported.getImageData(o2) : o2);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e3, t3) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e3, t3), this._update(true);
          }
          moveLayer(e3, t3) {
            return this.style.moveLayer(e3, t3), this._update(true);
          }
          removeLayer(e3) {
            return this.style.removeLayer(e3), this._update(true);
          }
          getLayer(e3) {
            return this.style.getLayer(e3);
          }
          setLayerZoomRange(e3, t3, i3) {
            return this.style.setLayerZoomRange(e3, t3, i3), this._update(true);
          }
          setFilter(e3, t3, i3 = {}) {
            return this.style.setFilter(e3, t3, i3), this._update(true);
          }
          getFilter(e3) {
            return this.style.getFilter(e3);
          }
          setPaintProperty(e3, t3, i3, o2 = {}) {
            return this.style.setPaintProperty(e3, t3, i3, o2), this._update(true);
          }
          getPaintProperty(e3, t3) {
            return this.style.getPaintProperty(e3, t3);
          }
          setLayoutProperty(e3, t3, i3, o2 = {}) {
            return this.style.setLayoutProperty(e3, t3, i3, o2), this._update(true);
          }
          getLayoutProperty(e3, t3) {
            return this.style.getLayoutProperty(e3, t3);
          }
          setLight(e3, t3 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e3, t3), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setTerrain(e3) {
            return this._lazyInitEmptyStyle(), !e3 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e3), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          _updateProjection() {
            this.transform.projection.name === "globe" && this.transform.zoom >= e2.GLOBE_ZOOM_THRESHOLD_MAX && !this._transitionFromGlobe && (this.setProjection({ name: "mercator" }), this._transitionFromGlobe = true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e3) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e3), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          _queryFogOpacity(t3) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e2.LngLat.convert(t3), this.transform) : 0;
          }
          setFeatureState(e3, t3) {
            return this.style.setFeatureState(e3, t3), this._update();
          }
          removeFeatureState(e3, t3) {
            return this.style.removeFeatureState(e3, t3), this._update();
          }
          getFeatureState(e3) {
            return this.style.getFeatureState(e3);
          }
          _updateContainerDimensions() {
            if (!this._container)
              return;
            const t3 = this._container.getBoundingClientRect().width || 400, i3 = this._container.getBoundingClientRect().height || 300;
            let o2, r3 = this._container;
            for (; r3 && !o2; ) {
              const t4 = e2.window.getComputedStyle(r3).transform;
              t4 && t4 !== "none" && (o2 = t4.match(/matrix.*\((.+)\)/)[1].split(", ")), r3 = r3.parentElement;
            }
            o2 ? (this._containerWidth = o2[0] && o2[0] !== "0" ? Math.abs(t3 / o2[0]) : t3, this._containerHeight = o2[3] && o2[3] !== "0" ? Math.abs(i3 / o2[3]) : i3) : (this._containerWidth = t3, this._containerHeight = i3);
          }
          _detectMissingCSS() {
            e2.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && e2.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e3 = this._container;
            e3.classList.add("mapboxgl-map"), (this._missingCSSCanary = a.create("div", "mapboxgl-canary", e3)).style.visibility = "hidden", this._detectMissingCSS();
            const t3 = this._canvasContainer = a.create("div", "mapboxgl-canvas-container", e3);
            this._interactive && t3.classList.add("mapboxgl-interactive"), this._canvas = a.create("canvas", "mapboxgl-canvas", t3), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i3 = this._controlContainer = a.create("div", "mapboxgl-control-container", e3), o2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e4) => {
              o2[e4] = a.create("div", `mapboxgl-ctrl-${e4}`, i3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t3, i3) {
            const o2 = e2.exported.devicePixelRatio || 1;
            this._canvas.width = o2 * Math.ceil(t3), this._canvas.height = o2 * Math.ceil(i3), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${i3}px`;
          }
          _addMarker(e3) {
            this._markers.push(e3);
          }
          _removeMarker(e3) {
            const t3 = this._markers.indexOf(e3);
            t3 !== -1 && this._markers.splice(t3, 1);
          }
          _setupPainter() {
            const i3 = e2.extend({}, t2.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", i3) || this._canvas.getContext("experimental-webgl", i3);
            o2 ? (e2.storeAuthState(o2, true), this.painter = new _o(o2, this.transform), this.on("data", (e3) => {
              e3.dataType === "source" && this.painter.setTileLoadedFlag(true);
            }), e2.exported$1.testSupport(o2)) : this.fire(new e2.ErrorEvent(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t3) {
            t3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e2.Event("webglcontextlost", { originalEvent: t3 }));
          }
          _contextRestored(t3) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e2.Event("webglcontextrestored", { originalEvent: t3 }));
          }
          _onMapScroll(e3) {
            if (e3.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e3) {
            return this.style ? (this._styleDirty = this._styleDirty || e3, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e3) {
            return this._update(), this._renderTaskQueue.add(e3);
          }
          _cancelRenderFrame(e3) {
            this._renderTaskQueue.remove(e3);
          }
          _requestDomTask(e3) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e3() : this._domRenderTaskQueue.add(e3);
          }
          _render(t3) {
            let i3;
            const o2 = this.painter.context.extTimerQuery, r3 = e2.exported.now();
            this.listens("gpu-timing-frame") && (i3 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i3));
            let n2 = this._updateAverageElevation(r3);
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t3), this._domRenderTaskQueue.run(t3), this._removed)
              return;
            this._updateProjection();
            let a2 = false;
            const s4 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t4 = this.transform.zoom, i4 = this.transform.pitch, o3 = e2.exported.now();
              this.style.zoomHistory.update(t4, o3);
              const r4 = new e2.EvaluationParameters(t4, { now: o3, fadeDuration: s4, pitch: i4, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), n3 = r4.crossFadingFactor();
              n3 === 1 && n3 === this._crossFadingFactor || (a2 = true, this._crossFadingFactor = n3), this.style.update(r4);
            }
            if (this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true), this.style && this._sourcesDirty && (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), this.style._updateSources(this.transform), this._forceMarkerUpdate()), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s4, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: s4, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e2.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e2.Event("load"))), this.style && (this.style.hasTransitions() || a2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
              const t4 = e2.exported.now() - r3;
              o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i3), setTimeout(() => {
                const r4 = o2.getQueryObjectEXT(i3, o2.QUERY_RESULT_EXT) / 1e6;
                o2.deleteQueryEXT(i3), this.fire(new e2.Event("gpu-timing-frame", { cpuTime: t4, gpuTime: r4 }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t4 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i4 = this.painter.queryGpuTimers(t4);
                this.fire(new e2.Event("gpu-timing-layer", { layerTimes: i4 }));
              }, 50);
            }
            const l2 = this._sourcesDirty || this._styleDirty || this._placementDirty || n2;
            if (l2 || this._repaint)
              this.triggerRepaint();
            else {
              const t4 = !this.isMoving() && this.loaded();
              if (t4 && (n2 = this._updateAverageElevation(r3, true)), n2)
                this.triggerRepaint();
              else if (this._triggerFrame(false), t4 && (this.fire(new e2.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t5 = this._calculateSpeedIndex();
                this.fire(new e2.Event("speedindexcompleted", { speedIndex: t5 })), this.speedIndexTiming = false;
              }
            }
            return !this._loaded || this._fullyLoaded || l2 || (this._fullyLoaded = true, this._authenticate()), this;
          }
          _forceMarkerUpdate() {
            for (const e3 of this._markers)
              e3._update();
          }
          _updateAverageElevation(e3, t3 = false) {
            const i3 = (e4) => (this.transform.averageElevation = e4, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing())
              return this.transform.averageElevation !== 0 && i3(0);
            if ((t3 || e3 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e3)) {
              const t4 = this.transform.averageElevation;
              let o2 = this.transform.sampleAverageElevation();
              isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e3;
              const r3 = Math.abs(t4 - o2);
              if (r3 > 1) {
                if (this._isInitialLoad)
                  return this._averageElevation.jumpTo(o2), i3(o2);
                this._averageElevation.easeTo(o2, e3, 300);
              } else if (r3 > 1e-4)
                return this._averageElevation.jumpTo(o2), i3(o2);
            }
            return !!this._averageElevation.isEasing(e3) && i3(this._averageElevation.getValue(e3));
          }
          _authenticate() {
            e2.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t3) => {
              if (t3 && (t3.message === e2.AUTH_ERR_MSG || t3.status === 401)) {
                const t4 = this.painter.context.gl;
                e2.storeAuthState(t4, false), this._logoControl instanceof Sr && this._logoControl._updateLogo(), t4 && t4.clear(t4.DEPTH_BUFFER_BIT | t4.COLOR_BUFFER_BIT | t4.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e2.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), e2.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _updateTerrain() {
            this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());
          }
          _calculateSpeedIndex() {
            const e3 = this.painter.canvasCopy(), t3 = this.painter.getCanvasCopiesAndTimestamps();
            t3.timeStamps.push(performance.now());
            const i3 = this.painter.context.gl, o2 = i3.createFramebuffer();
            function r3(e4) {
              i3.framebufferTexture2D(i3.FRAMEBUFFER, i3.COLOR_ATTACHMENT0, i3.TEXTURE_2D, e4, 0);
              const t4 = new Uint8Array(i3.drawingBufferWidth * i3.drawingBufferHeight * 4);
              return i3.readPixels(0, 0, i3.drawingBufferWidth, i3.drawingBufferHeight, i3.RGBA, i3.UNSIGNED_BYTE, t4), t4;
            }
            return i3.bindFramebuffer(i3.FRAMEBUFFER, o2), this._canvasPixelComparison(r3(e3), t3.canvasCopies.map(r3), t3.timeStamps);
          }
          _canvasPixelComparison(e3, t3, i3) {
            let o2 = i3[1] - i3[0];
            const r3 = e3.length / 4;
            for (let n2 = 0; n2 < t3.length; n2++) {
              const a2 = t3[n2];
              let s4 = 0;
              for (let t4 = 0; t4 < a2.length; t4 += 4)
                a2[t4] === e3[t4] && a2[t4 + 1] === e3[t4 + 1] && a2[t4 + 2] === e3[t4 + 2] && a2[t4 + 3] === e3[t4 + 3] && (s4 += 1);
              o2 += (i3[n2 + 2] - i3[n2 + 1]) * (1 - s4 / r3);
            }
            return o2;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e3 of this._controls)
              e3.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), e2.window !== void 0 && (e2.window.removeEventListener("resize", this._onWindowResize, false), e2.window.removeEventListener("orientationchange", this._onWindowResize, false), e2.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e2.window.removeEventListener("online", this._onWindowOnline, false));
            const t3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t3 && t3.loseContext(), Fr(this._canvasContainer), Fr(this._controlContainer), Fr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), e2.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e2.Event("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t3) {
            this._renderNextFrame = this._renderNextFrame || t3, this.style && !this._frame && (this._frame = e2.exported.frame((e3) => {
              const t4 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t4 && this._render(e3);
            }));
          }
          _preloadTiles(t3) {
            const i3 = this.style && Object.values(this.style._sourceCaches) || [];
            return e2.asyncAll(i3, (e3, i4) => e3._preloadTiles(t3, i4), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e3) {
            this._trackResize && this.resize({ originalEvent: e3 })._update();
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e3) {
            this._showTileBoundaries !== e3 && (this._showTileBoundaries = e3, this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e3) {
            this._showTerrainWireframe !== e3 && (this._showTerrainWireframe = e3, this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e3) {
            this._speedIndexTiming !== e3 && (this._speedIndexTiming = e3, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e3) {
            this._showPadding !== e3 && (this._showPadding = e3, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e3) {
            this._showCollisionBoxes !== e3 && (this._showCollisionBoxes = e3, e3 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e3) {
            this._showOverdrawInspector !== e3 && (this._showOverdrawInspector = e3, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e3) {
            this._repaint !== e3 && (this._repaint = e3, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e3) {
            this._vertices = e3, this._update();
          }
          _setCacheLimits(t3, i3) {
            e2.setCacheLimits(t3, i3);
          }
          get version() {
            return e2.version;
          }
        }, NavigationControl: class {
          constructor(t3) {
            this.options = e2.extend({}, Ur, t3), this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this.options.showZoom && (e2.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e3) => this._map.zoomIn({}, { originalEvent: e3 })), a.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e3) => this._map.zoomOut({}, { originalEvent: e3 })), a.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (e2.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e3) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e3 }) : this._map.resetNorth({}, { originalEvent: e3 });
            }), this._compassIcon = a.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
          }
          _updateZoomButtons() {
            const e3 = this._map.getZoom(), t3 = e3 === this._map.getMaxZoom(), i3 = e3 === this._map.getMinZoom();
            this._zoomInButton.disabled = t3, this._zoomOutButton.disabled = i3, this._zoomInButton.setAttribute("aria-disabled", t3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i3.toString());
          }
          _rotateCompassArrow() {
            const e3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._map._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = e3);
            });
          }
          onAdd(e3) {
            return this._map = e3, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Nr(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            this._container.remove(), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(e3, t3) {
            const i3 = a.create("button", e3, this._container);
            return i3.type = "button", i3.addEventListener("click", t3), i3;
          }
          _setButtonTitle(e3, t3) {
            const i3 = this._map._getUIString(`NavigationControl.${t3}`);
            e3.setAttribute("aria-label", i3), e3.firstElementChild && e3.firstElementChild.setAttribute("title", i3);
          }
        }, GeolocateControl: class extends e2.Evented {
          constructor(t3) {
            super(), this.options = e2.extend({}, Gr, t3), e2.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation"], this), this._onDeviceOrientationListener = this._onDeviceOrientation.bind(this), this._updateMarkerRotationThrottled = Io(this._updateMarkerRotation, 20);
          }
          onAdd(t3) {
            var i3;
            return this._map = t3, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), i3 = this._setupUI, jr !== void 0 ? i3(jr) : e2.window.navigator.permissions !== void 0 ? e2.window.navigator.permissions.query({ name: "geolocation" }).then((e3) => {
              jr = e3.state !== "denied", i3(jr);
            }) : (jr = !!e2.window.navigator.geolocation, i3(jr)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (e2.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, Zr = 0, Vr = false;
          }
          _isOutOfMapMaxBounds(e3) {
            const t3 = this._map.getMaxBounds(), i3 = e3.coords;
            return t3 && (i3.longitude < t3.getWest() || i3.longitude > t3.getEast() || i3.latitude < t3.getSouth() || i3.latitude > t3.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t3) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t3))
                return this._setErrorState(), this.fire(new e2.Event("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = t3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t3), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e2.Event("geolocate", t3)), this._finish();
            }
          }
          _updateCamera(t3) {
            const i3 = new e2.LngLat(t3.coords.longitude, t3.coords.latitude), o2 = t3.coords.accuracy, r3 = this._map.getBearing(), n2 = e2.extend({ bearing: r3 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i3.toBounds(o2), n2, { geolocateSource: true });
          }
          _updateMarker(t3) {
            if (t3) {
              const i3 = new e2.LngLat(t3.coords.longitude, t3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const e3 = this._map._containerHeight / 2, t3 = this._map.unproject([0, e3]), i3 = this._map.unproject([100, e3]), o2 = t3.distanceTo(i3) / 100, r3 = Math.ceil(2 * this._accuracy / o2);
            this._circleElement.style.width = `${r3}px`, this._circleElement.style.height = `${r3}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t3) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (t3.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (t3.code === 3 && Vr)
                    return;
                  this._setErrorState();
                }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e2.Event("error", t3)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(t3) {
            if (this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this._geolocateButton = a.create("button", "mapboxgl-ctrl-geolocate", this._container), a.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", t3 === false) {
              e2.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t4);
            } else {
              const e3 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = a.create("div", "mapboxgl-user-location"), this._dotElement.appendChild(a.create("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(a.create("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Pr({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = a.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Pr({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
              t4.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t4.originalEvent && t4.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e2.Event("trackuserlocationend")));
            });
          }
          _onDeviceOrientation(e3) {
            this._userLocationDotMarker && (e3.webkitCompassHeading ? this._heading = e3.webkitCompassHeading : e3.absolute === true && (this._heading = -1 * e3.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup)
              return e2.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e2.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Zr--, Vr = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e2.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e2.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let t3;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Zr++, Zr > 1 ? (t3 = { maximumAge: 6e5, timeout: 0 }, Vr = true) : (t3 = this.options.positionOptions, Vr = false), this._geolocationWatchID = e2.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t3), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else
              e2.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _addDeviceOrientationListener() {
            const t3 = () => {
              e2.window.addEventListener("ondeviceorientationabsolute" in e2.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientationListener);
            };
            e2.window.DeviceMotionEvent !== void 0 && typeof e2.window.DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((e3) => {
              e3 === "granted" && t3();
            }).catch(console.error) : t3();
          }
          _clearWatch() {
            e2.window.navigator.geolocation.clearWatch(this._geolocationWatchID), e2.window.removeEventListener("deviceorientation", this._onDeviceOrientationListener), e2.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientationListener), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Mr, ScaleControl: class {
          constructor(t3) {
            this.options = e2.extend({}, Wr, t3), e2.bindAll(["_onMove", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _onMove() {
            qr(this._map, this._container, this.options);
          }
          onAdd(e3) {
            return this._map = e3, this._container = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e3.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._onMove), this._map = void 0;
          }
          setUnit(e3) {
            this.options.unit = e3, qr(this._map, this._container, this.options);
          }
        }, FullscreenControl: class {
          constructor(t3) {
            this._fullscreen = false, t3 && t3.container && (t3.container instanceof e2.window.HTMLElement ? this._container = t3.container : e2.warnOnce("Full screen control 'container' must be a DOM element.")), e2.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e2.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e2.window.document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t3) {
            return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = a.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e2.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, e2.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!e2.window.document.fullscreenEnabled && !e2.window.document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const t3 = this._fullscreenButton = a.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            a.create("span", "mapboxgl-ctrl-icon", t3).setAttribute("aria-hidden", true), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e2.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e3 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e3), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e3);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (e2.window.document.fullscreenElement || e2.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? e2.window.document.exitFullscreen ? e2.window.document.exitFullscreen() : e2.window.document.webkitCancelFullScreen && e2.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends e2.Evented {
          constructor(t3) {
            super(), this.options = e2.extend(Object.create($r), t3), e2.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this), this._classList = new Set(t3 && t3.className ? t3.className.trim().split(/\s+/) : []);
          }
          addTo(t3) {
            return this._map && this.remove(), this._map = t3, this.options.closeOnClick && this._map.on("preclick", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new e2.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            return this._content && this._content.remove(), this._container && (this._container.remove(), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new e2.Event("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            return this._lngLat = e2.LngLat.convert(t3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t3) {
            return this.setDOMContent(e2.window.document.createTextNode(t3));
          }
          setHTML(t3) {
            const i3 = e2.window.document.createDocumentFragment(), o2 = e2.window.document.createElement("body");
            let r3;
            for (o2.innerHTML = t3; r3 = o2.firstChild, r3; )
              i3.appendChild(r3);
            return this.setDOMContent(i3);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e3) {
            return this.options.maxWidth = e3, this._update(), this;
          }
          setDOMContent(e3) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = a.create("div", "mapboxgl-popup-content", this._container);
            return this._content.appendChild(e3), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(e3) {
            return this._classList.add(e3), this._container && this._updateClassList(), this;
          }
          removeClassName(e3) {
            return this._classList.delete(e3), this._container && this._updateClassList(), this;
          }
          setOffset(e3) {
            return this.options.offset = e3, this._update(), this;
          }
          toggleClassName(e3) {
            let t3;
            return this._classList.delete(e3) ? t3 = false : (this._classList.add(e3), t3 = true), this._container && this._updateClassList(), t3;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = a.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.setAttribute("aria-hidden", "true"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _onMouseUp(e3) {
            this._update(e3.point);
          }
          _onMouseMove(e3) {
            this._update(e3.point);
          }
          _onDrag(e3) {
            this._update(e3.point);
          }
          _getAnchor(e3) {
            if (this.options.anchor)
              return this.options.anchor;
            const t3 = this._pos, i3 = this._container.offsetWidth, o2 = this._container.offsetHeight;
            let r3;
            return r3 = t3.y + e3.bottom.y < o2 ? ["top"] : t3.y > this._map.transform.height - o2 ? ["bottom"] : [], t3.x < i3 / 2 ? r3.push("left") : t3.x > this._map.transform.width - i3 / 2 && r3.push("right"), r3.length === 0 ? "bottom" : r3.join("-");
          }
          _updateClassList() {
            const e3 = [...this._classList];
            e3.push("mapboxgl-popup"), this._anchor && e3.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && e3.push("mapboxgl-popup-track-pointer"), this._container.className = e3.join(" ");
          }
          _update(t3) {
            if (this._map && (this._lngLat || this._trackPointer) && this._content) {
              if (this._container || (this._container = a.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = a.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content)), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = zr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || t3) {
                const i3 = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat), o2 = function(t4) {
                  if (t4 || (t4 = new e2.pointGeometry(0, 0)), typeof t4 == "number") {
                    const i4 = Math.round(Math.sqrt(0.5 * Math.pow(t4, 2)));
                    return { center: new e2.pointGeometry(0, 0), top: new e2.pointGeometry(0, t4), "top-left": new e2.pointGeometry(i4, i4), "top-right": new e2.pointGeometry(-i4, i4), bottom: new e2.pointGeometry(0, -t4), "bottom-left": new e2.pointGeometry(i4, -i4), "bottom-right": new e2.pointGeometry(-i4, -i4), left: new e2.pointGeometry(t4, 0), right: new e2.pointGeometry(-t4, 0) };
                  }
                  if (t4 instanceof e2.pointGeometry || Array.isArray(t4)) {
                    const i4 = e2.pointGeometry.convert(t4);
                    return { center: i4, top: i4, "top-left": i4, "top-right": i4, bottom: i4, "bottom-left": i4, "bottom-right": i4, left: i4, right: i4 };
                  }
                  return { center: e2.pointGeometry.convert(t4.center || [0, 0]), top: e2.pointGeometry.convert(t4.top || [0, 0]), "top-left": e2.pointGeometry.convert(t4["top-left"] || [0, 0]), "top-right": e2.pointGeometry.convert(t4["top-right"] || [0, 0]), bottom: e2.pointGeometry.convert(t4.bottom || [0, 0]), "bottom-left": e2.pointGeometry.convert(t4["bottom-left"] || [0, 0]), "bottom-right": e2.pointGeometry.convert(t4["bottom-right"] || [0, 0]), left: e2.pointGeometry.convert(t4.left || [0, 0]), right: e2.pointGeometry.convert(t4.right || [0, 0]) };
                }(this.options.offset), r3 = this._anchor = this._getAnchor(o2), n2 = i3.add(o2[r3]).round();
                this._map._requestDomTask(() => {
                  this._container && r3 && (this._container.style.transform = `${Dr[r3]} translate(${n2.x}px,${n2.y}px)`);
                });
              }
              this._updateClassList();
            }
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const e3 = this._container.querySelector(Hr);
            e3 && e3.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e3) {
            this._content && (this._content.style.opacity = e3), this._tip && (this._tip.style.opacity = e3);
          }
        }, Marker: Pr, Style: Nt, LngLat: e2.LngLat, LngLatBounds: e2.LngLatBounds, Point: e2.pointGeometry, MercatorCoordinate: e2.MercatorCoordinate, FreeCameraOptions: xo, Evented: e2.Evented, config: e2.config, prewarm: function() {
          Ae().acquire(ze);
        }, clearPrewarmedResources: function() {
          const e3 = Pe;
          e3 && (e3.isPreloaded() && e3.numActive() === 1 ? (e3.release(ze), Pe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get accessToken() {
          return e2.config.ACCESS_TOKEN;
        }, set accessToken(t3) {
          e2.config.ACCESS_TOKEN = t3;
        }, get baseApiUrl() {
          return e2.config.API_URL;
        }, set baseApiUrl(t3) {
          e2.config.API_URL = t3;
        }, get workerCount() {
          return De.workerCount;
        }, set workerCount(e3) {
          De.workerCount = e3;
        }, get maxParallelImageRequests() {
          return e2.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t3) {
          e2.config.MAX_PARALLEL_IMAGE_REQUESTS = t3;
        }, clearStorage(t3) {
          e2.clearTileCache(t3);
        }, workerUrl: "", workerClass: null, setNow: e2.exported.setNow, restoreNow: e2.exported.restoreNow };
        return Kr;
      });
      var mapboxgl$1 = mapboxgl2;
      return mapboxgl$1;
    });
  }
});

// node_modules/@firebase/util/dist/node-esm/index.node.esm.js
function isIndexedDBAvailable() {
  return typeof indexedDB === "object";
}
function validateIndexedDBOpenable() {
  return new Promise((resolve2, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve2(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || "");
      };
    } catch (error2) {
      reject(error2);
    }
  });
}
function replaceTemplate(template2, data) {
  return template2.replace(PATTERN, (_, key2) => {
    const value = data[key2];
    return value != null ? String(value) : `<${key2}?>`;
  });
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  for (const k of aKeys) {
    if (!bKeys.includes(k)) {
      return false;
    }
    const aProp = a[k];
    const bProp = b[k];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k of bKeys) {
    if (!aKeys.includes(k)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
function promisifyRequest(request, errorMessage) {
  return new Promise((resolve2, reject) => {
    request.onsuccess = (event) => {
      resolve2(event.target.result);
    };
    request.onerror = (event) => {
      var _a;
      reject(`${errorMessage}: ${(_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message}`);
    };
  });
}
function openDB(dbName, dbVersion, upgradeCallback) {
  return new Promise((resolve2, reject) => {
    try {
      const request = indexedDB.open(dbName, dbVersion);
      request.onsuccess = (event) => {
        resolve2(new DBWrapper(event.target.result));
      };
      request.onerror = (event) => {
        var _a;
        reject(`Error opening indexedDB: ${(_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message}`);
      };
      request.onupgradeneeded = (event) => {
        upgradeCallback(new DBWrapper(request.result), event.oldVersion, event.newVersion, new TransactionWrapper(request.transaction));
      };
    } catch (e2) {
      reject(`Error opening indexedDB: ${e2.message}`);
    }
  });
}
var CONSTANTS, stringToByteArray$1, byteArrayToString, base64, base64Encode, base64urlEncodeWithoutPadding, Deferred, ERROR_NAME, FirebaseError, ErrorFactory, PATTERN, MAX_VALUE_MILLIS, DBWrapper, TransactionWrapper, ObjectStoreWrapper, IndexWrapper;
var init_index_node_esm = __esm({
  "node_modules/@firebase/util/dist/node-esm/index.node.esm.js"() {
    CONSTANTS = {
      NODE_CLIENT: false,
      NODE_ADMIN: false,
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    stringToByteArray$1 = function(str) {
      const out = [];
      let p = 0;
      for (let i2 = 0; i2 < str.length; i2++) {
        let c = str.charCodeAt(i2);
        if (c < 128) {
          out[p++] = c;
        } else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = c & 63 | 128;
        } else if ((c & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        } else {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        }
      }
      return out;
    };
    byteArrayToString = function(bytes) {
      const out = [];
      let pos = 0, c = 0;
      while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          const c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          const c2 = bytes[pos++];
          const c3 = bytes[pos++];
          const c4 = bytes[pos++];
          const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (u & 1023));
        } else {
          const c2 = bytes[pos++];
          const c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    base64 = {
      byteToCharMap_: null,
      charToByteMap_: null,
      byteToCharMapWebSafe_: null,
      charToByteMapWebSafe_: null,
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        const output = [];
        for (let i2 = 0; i2 < input.length; i2 += 3) {
          const byte1 = input[i2];
          const haveByte2 = i2 + 1 < input.length;
          const byte2 = haveByte2 ? input[i2 + 1] : 0;
          const haveByte3 = i2 + 2 < input.length;
          const byte3 = haveByte3 ? input[i2 + 2] : 0;
          const outByte1 = byte1 >> 2;
          const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          let outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      encodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
      },
      decodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
      },
      decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        const output = [];
        for (let i2 = 0; i2 < input.length; ) {
          const byte1 = charToByteMap[input.charAt(i2++)];
          const haveByte2 = i2 < input.length;
          const byte2 = haveByte2 ? charToByteMap[input.charAt(i2)] : 0;
          ++i2;
          const haveByte3 = i2 < input.length;
          const byte3 = haveByte3 ? charToByteMap[input.charAt(i2)] : 64;
          ++i2;
          const haveByte4 = i2 < input.length;
          const byte4 = haveByte4 ? charToByteMap[input.charAt(i2)] : 64;
          ++i2;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw Error();
          }
          const outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              const outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      init_() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (let i2 = 0; i2 < this.ENCODED_VALS.length; i2++) {
            this.byteToCharMap_[i2] = this.ENCODED_VALS.charAt(i2);
            this.charToByteMap_[this.byteToCharMap_[i2]] = i2;
            this.byteToCharMapWebSafe_[i2] = this.ENCODED_VALS_WEBSAFE.charAt(i2);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i2]] = i2;
            if (i2 >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i2)] = i2;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i2)] = i2;
            }
          }
        }
      }
    };
    base64Encode = function(str) {
      const utf8Bytes = stringToByteArray$1(str);
      return base64.encodeByteArray(utf8Bytes, true);
    };
    base64urlEncodeWithoutPadding = function(str) {
      return base64Encode(str).replace(/\./g, "");
    };
    Deferred = class {
      constructor() {
        this.reject = () => {
        };
        this.resolve = () => {
        };
        this.promise = new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
        });
      }
      wrapCallback(callback) {
        return (error2, value) => {
          if (error2) {
            this.reject(error2);
          } else {
            this.resolve(value);
          }
          if (typeof callback === "function") {
            this.promise.catch(() => {
            });
            if (callback.length === 1) {
              callback(error2);
            } else {
              callback(error2, value);
            }
          }
        };
      }
    };
    ERROR_NAME = "FirebaseError";
    FirebaseError = class extends Error {
      constructor(code, message, customData) {
        super(message);
        this.code = code;
        this.customData = customData;
        this.name = ERROR_NAME;
        Object.setPrototypeOf(this, FirebaseError.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
      }
    };
    ErrorFactory = class {
      constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template2 = this.errors[code];
        const message = template2 ? replaceTemplate(template2, customData) : "Error";
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error2 = new FirebaseError(fullCode, fullMessage, customData);
        return error2;
      }
    };
    PATTERN = /\{\$([^}]+)}/g;
    MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
    DBWrapper = class {
      constructor(_db) {
        this._db = _db;
        this.objectStoreNames = this._db.objectStoreNames;
      }
      transaction(storeNames, mode) {
        return new TransactionWrapper(this._db.transaction.call(this._db, storeNames, mode));
      }
      createObjectStore(storeName, options) {
        return new ObjectStoreWrapper(this._db.createObjectStore(storeName, options));
      }
      close() {
        this._db.close();
      }
    };
    TransactionWrapper = class {
      constructor(_transaction) {
        this._transaction = _transaction;
        this.complete = new Promise((resolve2, reject) => {
          this._transaction.oncomplete = function() {
            resolve2();
          };
          this._transaction.onerror = () => {
            reject(this._transaction.error);
          };
          this._transaction.onabort = () => {
            reject(this._transaction.error);
          };
        });
      }
      objectStore(storeName) {
        return new ObjectStoreWrapper(this._transaction.objectStore(storeName));
      }
    };
    ObjectStoreWrapper = class {
      constructor(_store) {
        this._store = _store;
      }
      index(name4) {
        return new IndexWrapper(this._store.index(name4));
      }
      createIndex(name4, keypath, options) {
        return new IndexWrapper(this._store.createIndex(name4, keypath, options));
      }
      get(key2) {
        const request = this._store.get(key2);
        return promisifyRequest(request, "Error reading from IndexedDB");
      }
      put(value, key2) {
        const request = this._store.put(value, key2);
        return promisifyRequest(request, "Error writing to IndexedDB");
      }
      delete(key2) {
        const request = this._store.delete(key2);
        return promisifyRequest(request, "Error deleting from IndexedDB");
      }
      clear() {
        const request = this._store.clear();
        return promisifyRequest(request, "Error clearing IndexedDB object store");
      }
    };
    IndexWrapper = class {
      constructor(_index) {
        this._index = _index;
      }
      get(key2) {
        const request = this._index.get(key2);
        return promisifyRequest(request, "Error reading from IndexedDB");
      }
    };
    CONSTANTS.NODE_CLIENT = true;
  }
});

// node_modules/@firebase/component/dist/esm/index.esm2017.js
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
var Component, DEFAULT_ENTRY_NAME, Provider, ComponentContainer;
var init_index_esm2017 = __esm({
  "node_modules/@firebase/component/dist/esm/index.esm2017.js"() {
    init_index_node_esm();
    Component = class {
      constructor(name4, instanceFactory, type) {
        this.name = name4;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        this.serviceProps = {};
        this.instantiationMode = "LAZY";
        this.onInstanceCreated = null;
      }
      setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
      }
      setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      }
      setServiceProps(props) {
        this.serviceProps = props;
        return this;
      }
      setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
      }
    };
    DEFAULT_ENTRY_NAME = "[DEFAULT]";
    Provider = class {
      constructor(name4, container) {
        this.name = name4;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
      }
      get(identifier) {
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
          const deferred = new Deferred();
          this.instancesDeferred.set(normalizedIdentifier, deferred);
          if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
            try {
              const instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e2) {
            }
          }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
      }
      getImmediate(options) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            return this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
          } catch (e2) {
            if (optional) {
              return null;
            } else {
              throw e2;
            }
          }
        } else {
          if (optional) {
            return null;
          } else {
            throw Error(`Service ${this.name} is not available`);
          }
        }
      }
      getComponent() {
        return this.component;
      }
      setComponent(component) {
        if (component.name !== this.name) {
          throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        }
        if (this.component) {
          throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component;
        if (!this.shouldAutoInitialize()) {
          return;
        }
        if (isComponentEager(component)) {
          try {
            this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
          } catch (e2) {
          }
        }
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
          const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          try {
            const instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            instanceDeferred.resolve(instance);
          } catch (e2) {
          }
        }
      }
      clearInstance(identifier = DEFAULT_ENTRY_NAME) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
      }
      async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
          ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
          ...services.filter((service) => "_delete" in service).map((service) => service._delete())
        ]);
      }
      isComponentSet() {
        return this.component != null;
      }
      isInitialized(identifier = DEFAULT_ENTRY_NAME) {
        return this.instances.has(identifier);
      }
      getOptions(identifier = DEFAULT_ENTRY_NAME) {
        return this.instancesOptions.get(identifier) || {};
      }
      initialize(opts = {}) {
        const { options = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
          throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
          throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier,
          options
        });
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
          const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          if (normalizedIdentifier === normalizedDeferredIdentifier) {
            instanceDeferred.resolve(instance);
          }
        }
        return instance;
      }
      onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
          callback(existingInstance, normalizedIdentifier);
        }
        return () => {
          existingCallbacks.delete(callback);
        };
      }
      invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
          return;
        }
        for (const callback of callbacks) {
          try {
            callback(instance, identifier);
          } catch (_a) {
          }
        }
      }
      getOrInitializeService({ instanceIdentifier, options = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
          instance = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
            options
          });
          this.instances.set(instanceIdentifier, instance);
          this.instancesOptions.set(instanceIdentifier, options);
          this.invokeOnInitCallbacks(instance, instanceIdentifier);
          if (this.component.onInstanceCreated) {
            try {
              this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_a) {
            }
          }
        }
        return instance || null;
      }
      normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
        if (this.component) {
          return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        } else {
          return identifier;
        }
      }
      shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT";
      }
    };
    ComponentContainer = class {
      constructor(name4) {
        this.name = name4;
        this.providers = new Map();
      }
      addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component);
      }
      addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          this.providers.delete(component.name);
        }
        this.addComponent(component);
      }
      getProvider(name4) {
        if (this.providers.has(name4)) {
          return this.providers.get(name4);
        }
        const provider = new Provider(name4, this);
        this.providers.set(name4, provider);
        return provider;
      }
      getProviders() {
        return Array.from(this.providers.values());
      }
    };
  }
});

// node_modules/@firebase/logger/dist/esm/index.esm2017.js
var instances, LogLevel, levelStringToEnum, defaultLogLevel, ConsoleMethod, defaultLogHandler, Logger;
var init_index_esm20172 = __esm({
  "node_modules/@firebase/logger/dist/esm/index.esm2017.js"() {
    instances = [];
    (function(LogLevel2) {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
      LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
    })(LogLevel || (LogLevel = {}));
    levelStringToEnum = {
      "debug": LogLevel.DEBUG,
      "verbose": LogLevel.VERBOSE,
      "info": LogLevel.INFO,
      "warn": LogLevel.WARN,
      "error": LogLevel.ERROR,
      "silent": LogLevel.SILENT
    };
    defaultLogLevel = LogLevel.INFO;
    ConsoleMethod = {
      [LogLevel.DEBUG]: "log",
      [LogLevel.VERBOSE]: "log",
      [LogLevel.INFO]: "info",
      [LogLevel.WARN]: "warn",
      [LogLevel.ERROR]: "error"
    };
    defaultLogHandler = (instance, logType, ...args) => {
      if (logType < instance.logLevel) {
        return;
      }
      const now = new Date().toISOString();
      const method = ConsoleMethod[logType];
      if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
      } else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
      }
    };
    Logger = class {
      constructor(name4) {
        this.name = name4;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        this._userLogHandler = null;
        instances.push(this);
      }
      get logLevel() {
        return this._logLevel;
      }
      set logLevel(val) {
        if (!(val in LogLevel)) {
          throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
      }
      setLogLevel(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
      }
      get logHandler() {
        return this._logHandler;
      }
      set logHandler(val) {
        if (typeof val !== "function") {
          throw new TypeError("Value assigned to `logHandler` must be a function");
        }
        this._logHandler = val;
      }
      get userLogHandler() {
        return this._userLogHandler;
      }
      set userLogHandler(val) {
        this._userLogHandler = val;
      }
      debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
      }
      log(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
      }
      info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
      }
      warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
      }
      error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
      }
    };
  }
});

// node_modules/@firebase/app/dist/esm/index.esm2017.js
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
function _addComponent(app2, component) {
  try {
    app2.container.addComponent(component);
  } catch (e2) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app2.name}`, e2);
  }
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app2 of _apps.values()) {
    _addComponent(app2, component);
  }
  return true;
}
function _getProvider(app2, name4) {
  const heartbeatController = app2.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app2.container.getProvider(name4);
}
function initializeApp(options, rawConfig = {}) {
  if (typeof rawConfig !== "object") {
    const name5 = rawConfig;
    rawConfig = { name: name5 };
  }
  const config = Object.assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: false }, rawConfig);
  const name4 = config.name;
  if (typeof name4 !== "string" || !name4) {
    throw ERROR_FACTORY.create("bad-app-name", {
      appName: String(name4)
    });
  }
  const existingApp = _apps.get(name4);
  if (existingApp) {
    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name4 });
    }
  }
  const container = new ComponentContainer(name4);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options, config, container);
  _apps.set(name4, newApp);
  return newApp;
}
function getApp(name4 = DEFAULT_ENTRY_NAME2) {
  const app2 = _apps.get(name4);
  if (!app2) {
    throw ERROR_FACTORY.create("no-app", { appName: name4 });
  }
  return app2;
}
function registerVersion(libraryKeyOrName, version4, variant) {
  var _a;
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version4.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version4}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version4}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({ library, version: version4 }), "VERSION"));
}
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, (db, oldVersion) => {
      switch (oldVersion) {
        case 0:
          db.createObjectStore(STORE_NAME);
      }
    }).catch((e2) => {
      throw ERROR_FACTORY.create("storage-open", {
        originalErrorMessage: e2.message
      });
    });
  }
  return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app2) {
  try {
    const db = await getDbPromise();
    return db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app2));
  } catch (e2) {
    throw ERROR_FACTORY.create("storage-get", {
      originalErrorMessage: e2.message
    });
  }
}
async function writeHeartbeatsToIndexedDB(app2, heartbeatObject) {
  try {
    const db = await getDbPromise();
    const tx = db.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app2));
    return tx.complete;
  } catch (e2) {
    throw ERROR_FACTORY.create("storage-set", {
      originalErrorMessage: e2.message
    });
  }
}
function computeKey(app2) {
  return `${app2.name}!${app2.options.appId}`;
}
function getUTCDateString() {
  const today = new Date();
  return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb) => hb.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
function countBytes(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;
}
function registerCoreComponents(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  _registerComponent(new Component("heartbeat", (container) => new HeartbeatServiceImpl(container), "PRIVATE"));
  registerVersion(name$o, version$1, variant);
  registerVersion(name$o, version$1, "esm2017");
  registerVersion("fire-js", "");
}
var PlatformLoggerServiceImpl, name$o, version$1, logger, name$n, name$m, name$l, name$k, name$j, name$i, name$h, name$g, name$f, name$e, name$d, name$c, name$b, name$a, name$9, name$8, name$7, name$6, name$5, name$4, name$3, name$2, name$1, name, version, DEFAULT_ENTRY_NAME2, PLATFORM_LOG_STRING, _apps, _components, ERRORS, ERROR_FACTORY, FirebaseAppImpl, SDK_VERSION, DB_NAME, DB_VERSION, STORE_NAME, dbPromise, MAX_HEADER_BYTES, STORED_HEARTBEAT_RETENTION_MAX_MILLIS, HeartbeatServiceImpl, HeartbeatStorageImpl;
var init_index_esm20173 = __esm({
  "node_modules/@firebase/app/dist/esm/index.esm2017.js"() {
    init_index_esm2017();
    init_index_esm20172();
    init_index_node_esm();
    init_index_node_esm();
    PlatformLoggerServiceImpl = class {
      constructor(container) {
        this.container = container;
      }
      getPlatformInfoString() {
        const providers = this.container.getProviders();
        return providers.map((provider) => {
          if (isVersionServiceProvider(provider)) {
            const service = provider.getImmediate();
            return `${service.library}/${service.version}`;
          } else {
            return null;
          }
        }).filter((logString) => logString).join(" ");
      }
    };
    name$o = "@firebase/app";
    version$1 = "0.7.20";
    logger = new Logger("@firebase/app");
    name$n = "@firebase/app-compat";
    name$m = "@firebase/analytics-compat";
    name$l = "@firebase/analytics";
    name$k = "@firebase/app-check-compat";
    name$j = "@firebase/app-check";
    name$i = "@firebase/auth";
    name$h = "@firebase/auth-compat";
    name$g = "@firebase/database";
    name$f = "@firebase/database-compat";
    name$e = "@firebase/functions";
    name$d = "@firebase/functions-compat";
    name$c = "@firebase/installations";
    name$b = "@firebase/installations-compat";
    name$a = "@firebase/messaging";
    name$9 = "@firebase/messaging-compat";
    name$8 = "@firebase/performance";
    name$7 = "@firebase/performance-compat";
    name$6 = "@firebase/remote-config";
    name$5 = "@firebase/remote-config-compat";
    name$4 = "@firebase/storage";
    name$3 = "@firebase/storage-compat";
    name$2 = "@firebase/firestore";
    name$1 = "@firebase/firestore-compat";
    name = "firebase";
    version = "9.6.10";
    DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
    PLATFORM_LOG_STRING = {
      [name$o]: "fire-core",
      [name$n]: "fire-core-compat",
      [name$l]: "fire-analytics",
      [name$m]: "fire-analytics-compat",
      [name$j]: "fire-app-check",
      [name$k]: "fire-app-check-compat",
      [name$i]: "fire-auth",
      [name$h]: "fire-auth-compat",
      [name$g]: "fire-rtdb",
      [name$f]: "fire-rtdb-compat",
      [name$e]: "fire-fn",
      [name$d]: "fire-fn-compat",
      [name$c]: "fire-iid",
      [name$b]: "fire-iid-compat",
      [name$a]: "fire-fcm",
      [name$9]: "fire-fcm-compat",
      [name$8]: "fire-perf",
      [name$7]: "fire-perf-compat",
      [name$6]: "fire-rc",
      [name$5]: "fire-rc-compat",
      [name$4]: "fire-gcs",
      [name$3]: "fire-gcs-compat",
      [name$2]: "fire-fst",
      [name$1]: "fire-fst-compat",
      "fire-js": "fire-js",
      [name]: "fire-js-all"
    };
    _apps = new Map();
    _components = new Map();
    ERRORS = {
      ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
      ["bad-app-name"]: "Illegal App name: '{$appName}",
      ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
      ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
      ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
      ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.",
      ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
      ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
      ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
      ["storage-delete"]: "Error thrown when deleting from storage. Original error: {$originalErrorMessage}."
    };
    ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
    FirebaseAppImpl = class {
      constructor(options, config, container) {
        this._isDeleted = false;
        this._options = Object.assign({}, options);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component("app", () => this, "PUBLIC"));
      }
      get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
      }
      set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
      }
      get name() {
        this.checkDestroyed();
        return this._name;
      }
      get options() {
        this.checkDestroyed();
        return this._options;
      }
      get config() {
        this.checkDestroyed();
        return this._config;
      }
      get container() {
        return this._container;
      }
      get isDeleted() {
        return this._isDeleted;
      }
      set isDeleted(val) {
        this._isDeleted = val;
      }
      checkDestroyed() {
        if (this.isDeleted) {
          throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
        }
      }
    };
    SDK_VERSION = version;
    DB_NAME = "firebase-heartbeat-database";
    DB_VERSION = 1;
    STORE_NAME = "firebase-heartbeat-store";
    dbPromise = null;
    MAX_HEADER_BYTES = 1024;
    STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;
    HeartbeatServiceImpl = class {
      constructor(container) {
        this.container = container;
        this._heartbeatsCache = null;
        const app2 = this.container.getProvider("app").getImmediate();
        this._storage = new HeartbeatStorageImpl(app2);
        this._heartbeatsCachePromise = this._storage.read().then((result) => {
          this._heartbeatsCache = result;
          return result;
        });
      }
      async triggerHeartbeat() {
        const platformLogger = this.container.getProvider("platform-logger").getImmediate();
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) {
          this._heartbeatsCache = await this._heartbeatsCachePromise;
        }
        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
          return;
        } else {
          this._heartbeatsCache.heartbeats.push({ date, agent });
        }
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {
          const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
          const now = Date.now();
          return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
      }
      async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null) {
          await this._heartbeatsCachePromise;
        }
        if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) {
          return "";
        }
        const date = getUTCDateString();
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
          this._heartbeatsCache.heartbeats = unsentEntries;
          await this._storage.overwrite(this._heartbeatsCache);
        } else {
          this._heartbeatsCache.heartbeats = [];
          void this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
      }
    };
    HeartbeatStorageImpl = class {
      constructor(app2) {
        this.app = app2;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
      }
      async runIndexedDBEnvironmentCheck() {
        if (!isIndexedDBAvailable()) {
          return false;
        } else {
          return validateIndexedDBOpenable().then(() => true).catch(() => false);
        }
      }
      async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
          return { heartbeats: [] };
        } else {
          const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
          return idbHeartbeatObject || { heartbeats: [] };
        }
      }
      async overwrite(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
          return;
        } else {
          const existingHeartbeatsObject = await this.read();
          return writeHeartbeatsToIndexedDB(this.app, {
            lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
            heartbeats: heartbeatsObject.heartbeats
          });
        }
      }
      async add(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
          return;
        } else {
          const existingHeartbeatsObject = await this.read();
          return writeHeartbeatsToIndexedDB(this.app, {
            lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
            heartbeats: [
              ...existingHeartbeatsObject.heartbeats,
              ...heartbeatsObject.heartbeats
            ]
          });
        }
      }
    };
    registerCoreComponents("");
  }
});

// node_modules/firebase/app/dist/index.mjs
var name2, version2;
var init_dist = __esm({
  "node_modules/firebase/app/dist/index.mjs"() {
    init_index_esm20173();
    init_index_esm20173();
    name2 = "firebase";
    version2 = "9.6.10";
    registerVersion(name2, version2, "app");
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports2.Propagate = exports2.LogVerbosity = exports2.Status = void 0;
    var Status;
    (function(Status2) {
      Status2[Status2["OK"] = 0] = "OK";
      Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
      Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
      Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
      Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      Status2[Status2["ABORTED"] = 10] = "ABORTED";
      Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
      Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
      Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(Status = exports2.Status || (exports2.Status = {}));
    var LogVerbosity;
    (function(LogVerbosity2) {
      LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
      LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
      LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
      LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
    })(LogVerbosity = exports2.LogVerbosity || (exports2.LogVerbosity = {}));
    var Propagate;
    (function(Propagate2) {
      Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
      Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
      Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
      Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
      Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
    })(Propagate = exports2.Propagate || (exports2.Propagate = {}));
    exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
  }
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/logging.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracerEnabled = exports2.trace = exports2.log = exports2.setLoggerVerbosity = exports2.setLogger = exports2.getLogger = void 0;
    var constants_1 = require_constants();
    var DEFAULT_LOGGER = {
      error: (message, ...optionalParams) => {
        console.error("E " + message, ...optionalParams);
      },
      info: (message, ...optionalParams) => {
        console.error("I " + message, ...optionalParams);
      },
      debug: (message, ...optionalParams) => {
        console.error("D " + message, ...optionalParams);
      }
    };
    var _logger = DEFAULT_LOGGER;
    var _logVerbosity = constants_1.LogVerbosity.ERROR;
    var verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : "";
    switch (verbosityString.toUpperCase()) {
      case "DEBUG":
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
      case "INFO":
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
      case "ERROR":
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
      case "NONE":
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
      default:
    }
    exports2.getLogger = () => {
      return _logger;
    };
    exports2.setLogger = (logger2) => {
      _logger = logger2;
    };
    exports2.setLoggerVerbosity = (verbosity) => {
      _logVerbosity = verbosity;
    };
    exports2.log = (severity, ...args) => {
      let logFunction;
      if (severity >= _logVerbosity) {
        switch (severity) {
          case constants_1.LogVerbosity.DEBUG:
            logFunction = _logger.debug;
            break;
          case constants_1.LogVerbosity.INFO:
            logFunction = _logger.info;
            break;
          case constants_1.LogVerbosity.ERROR:
            logFunction = _logger.error;
            break;
        }
        if (!logFunction) {
          logFunction = _logger.error;
        }
        if (logFunction) {
          logFunction.bind(_logger)(...args);
        }
      }
    };
    var tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : "";
    var enabledTracers = new Set();
    var disabledTracers = new Set();
    for (const tracerName of tracersString.split(",")) {
      if (tracerName.startsWith("-")) {
        disabledTracers.add(tracerName.substring(1));
      } else {
        enabledTracers.add(tracerName);
      }
    }
    var allEnabled = enabledTracers.has("all");
    function trace(severity, tracer, text) {
      if (isTracerEnabled(tracer)) {
        exports2.log(severity, new Date().toISOString() + " | " + tracer + " | " + text);
      }
    }
    exports2.trace = trace;
    function isTracerEnabled(tracer) {
      return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));
    }
    exports2.isTracerEnabled = isTracerEnabled;
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
    var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
    function isLegalKey(key2) {
      return LEGAL_KEY_REGEX.test(key2);
    }
    function isLegalNonBinaryValue(value) {
      return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
    }
    function isBinaryKey(key2) {
      return key2.endsWith("-bin");
    }
    function isCustomMetadata(key2) {
      return !key2.startsWith("grpc-");
    }
    function normalizeKey(key2) {
      return key2.toLowerCase();
    }
    function validate(key2, value) {
      if (!isLegalKey(key2)) {
        throw new Error('Metadata key "' + key2 + '" contains illegal characters');
      }
      if (value !== null && value !== void 0) {
        if (isBinaryKey(key2)) {
          if (!(value instanceof Buffer)) {
            throw new Error("keys that end with '-bin' must have Buffer values");
          }
        } else {
          if (value instanceof Buffer) {
            throw new Error("keys that don't end with '-bin' must have String values");
          }
          if (!isLegalNonBinaryValue(value)) {
            throw new Error('Metadata string value "' + value + '" contains illegal characters');
          }
        }
      }
    }
    var Metadata2 = class {
      constructor(options) {
        this.internalRepr = new Map();
        if (options === void 0) {
          this.options = {};
        } else {
          this.options = options;
        }
      }
      set(key2, value) {
        key2 = normalizeKey(key2);
        validate(key2, value);
        this.internalRepr.set(key2, [value]);
      }
      add(key2, value) {
        key2 = normalizeKey(key2);
        validate(key2, value);
        const existingValue = this.internalRepr.get(key2);
        if (existingValue === void 0) {
          this.internalRepr.set(key2, [value]);
        } else {
          existingValue.push(value);
        }
      }
      remove(key2) {
        key2 = normalizeKey(key2);
        validate(key2);
        this.internalRepr.delete(key2);
      }
      get(key2) {
        key2 = normalizeKey(key2);
        validate(key2);
        return this.internalRepr.get(key2) || [];
      }
      getMap() {
        const result = {};
        this.internalRepr.forEach((values, key2) => {
          if (values.length > 0) {
            const v = values[0];
            result[key2] = v instanceof Buffer ? v.slice() : v;
          }
        });
        return result;
      }
      clone() {
        const newMetadata = new Metadata2(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        this.internalRepr.forEach((value, key2) => {
          const clonedValue = value.map((v) => {
            if (v instanceof Buffer) {
              return Buffer.from(v);
            } else {
              return v;
            }
          });
          newInternalRepr.set(key2, clonedValue);
        });
        return newMetadata;
      }
      merge(other) {
        other.internalRepr.forEach((values, key2) => {
          const mergedValue = (this.internalRepr.get(key2) || []).concat(values);
          this.internalRepr.set(key2, mergedValue);
        });
      }
      setOptions(options) {
        this.options = options;
      }
      getOptions() {
        return this.options;
      }
      toHttp2Headers() {
        const result = {};
        this.internalRepr.forEach((values, key2) => {
          result[key2] = values.map((value) => {
            if (value instanceof Buffer) {
              return value.toString("base64");
            } else {
              return value;
            }
          });
        });
        return result;
      }
      _getCoreRepresentation() {
        return this.internalRepr;
      }
      toJSON() {
        const result = {};
        for (const [key2, values] of this.internalRepr.entries()) {
          result[key2] = values;
        }
        return result;
      }
      static fromHttp2Headers(headers) {
        const result = new Metadata2();
        Object.keys(headers).forEach((key2) => {
          if (key2.charAt(0) === ":") {
            return;
          }
          const values = headers[key2];
          try {
            if (isBinaryKey(key2)) {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key2, Buffer.from(value, "base64"));
                });
              } else if (values !== void 0) {
                if (isCustomMetadata(key2)) {
                  values.split(",").forEach((v) => {
                    result.add(key2, Buffer.from(v.trim(), "base64"));
                  });
                } else {
                  result.add(key2, Buffer.from(values, "base64"));
                }
              }
            } else {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key2, value);
                });
              } else if (values !== void 0) {
                result.add(key2, values);
              }
            }
          } catch (error2) {
            const message = `Failed to add metadata entry ${key2}: ${values}. ${error2.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
            logging_1.log(constants_1.LogVerbosity.ERROR, message);
          }
        });
        return result;
      }
    };
    exports2.Metadata = Metadata2;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentials = void 0;
    var metadata_1 = require_metadata();
    function isCurrentOauth2Client(client) {
      return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
    }
    var CallCredentials = class {
      static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
      }
      static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options, callback) => {
          let getHeaders;
          if (isCurrentOauth2Client(googleCredentials)) {
            getHeaders = googleCredentials.getRequestHeaders(options.service_url);
          } else {
            getHeaders = new Promise((resolve2, reject) => {
              googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                if (err) {
                  reject(err);
                  return;
                }
                resolve2(headers);
              });
            });
          }
          getHeaders.then((headers) => {
            const metadata = new metadata_1.Metadata();
            for (const key2 of Object.keys(headers)) {
              metadata.add(key2, headers[key2]);
            }
            callback(null, metadata);
          }, (err) => {
            callback(err);
          });
        });
      }
      static createEmpty() {
        return new EmptyCallCredentials();
      }
    };
    exports2.CallCredentials = CallCredentials;
    var ComposedCallCredentials = class extends CallCredentials {
      constructor(creds) {
        super();
        this.creds = creds;
      }
      async generateMetadata(options) {
        const base2 = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
        for (const gen of generated) {
          base2.merge(gen);
        }
        return base2;
      }
      compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedCallCredentials) {
          return this.creds.every((value, index) => value._equals(other.creds[index]));
        } else {
          return false;
        }
      }
    };
    var SingleCallCredentials = class extends CallCredentials {
      constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
      }
      generateMetadata(options) {
        return new Promise((resolve2, reject) => {
          this.metadataGenerator(options, (err, metadata) => {
            if (metadata !== void 0) {
              resolve2(metadata);
            } else {
              reject(err);
            }
          });
        });
      }
      compose(other) {
        return new ComposedCallCredentials([this, other]);
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SingleCallCredentials) {
          return this.metadataGenerator === other.metadataGenerator;
        } else {
          return false;
        }
      }
    };
    var EmptyCallCredentials = class extends CallCredentials {
      generateMetadata(options) {
        return Promise.resolve(new metadata_1.Metadata());
      }
      compose(other) {
        return other;
      }
      _equals(other) {
        return other instanceof EmptyCallCredentials;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/stream-decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamDecoder = void 0;
    var ReadState;
    (function(ReadState2) {
      ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
      ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
      ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
    })(ReadState || (ReadState = {}));
    var StreamDecoder = class {
      constructor() {
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
      }
      write(data) {
        let readHead = 0;
        let toRead;
        const result = [];
        while (readHead < data.length) {
          switch (this.readState) {
            case ReadState.NO_DATA:
              this.readCompressFlag = data.slice(readHead, readHead + 1);
              readHead += 1;
              this.readState = ReadState.READING_SIZE;
              this.readPartialSize.fill(0);
              this.readSizeRemaining = 4;
              this.readMessageSize = 0;
              this.readMessageRemaining = 0;
              this.readPartialMessage = [];
              break;
            case ReadState.READING_SIZE:
              toRead = Math.min(data.length - readHead, this.readSizeRemaining);
              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
              this.readSizeRemaining -= toRead;
              readHead += toRead;
              if (this.readSizeRemaining === 0) {
                this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                this.readMessageRemaining = this.readMessageSize;
                if (this.readMessageRemaining > 0) {
                  this.readState = ReadState.READING_MESSAGE;
                } else {
                  const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                  this.readState = ReadState.NO_DATA;
                  result.push(message);
                }
              }
              break;
            case ReadState.READING_MESSAGE:
              toRead = Math.min(data.length - readHead, this.readMessageRemaining);
              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
              this.readMessageRemaining -= toRead;
              readHead += toRead;
              if (this.readMessageRemaining === 0) {
                const framedMessageBuffers = [
                  this.readCompressFlag,
                  this.readPartialSize
                ].concat(this.readPartialMessage);
                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                this.readState = ReadState.NO_DATA;
                result.push(framedMessage);
              }
              break;
            default:
              throw new Error("Unexpected read state");
          }
        }
        return result;
      }
    };
    exports2.StreamDecoder = StreamDecoder;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-stream.js
var require_call_stream = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2CallStream = exports2.InterceptingListenerImpl = exports2.isInterceptingListener = void 0;
    var http22 = require("http2");
    var os = require("os");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var constants_2 = require_constants();
    var TRACER_NAME = "call_stream";
    var { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http22.constants;
    function getSystemErrorName(errno) {
      for (const [name4, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
          return name4;
        }
      }
      return "Unknown system error " + errno;
    }
    function getMinDeadline(deadlineList) {
      let minValue = Infinity;
      for (const deadline of deadlineList) {
        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
        if (deadlineMsecs < minValue) {
          minValue = deadlineMsecs;
        }
      }
      return minValue;
    }
    function isInterceptingListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    exports2.isInterceptingListener = isInterceptingListener;
    var InterceptingListenerImpl = class {
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.processingMessage = false;
        this.pendingStatus = null;
      }
      processPendingMessage() {
        if (this.hasPendingMessage) {
          this.nextListener.onReceiveMessage(this.pendingMessage);
          this.pendingMessage = null;
          this.hasPendingMessage = false;
        }
      }
      processPendingStatus() {
        if (this.pendingStatus) {
          this.nextListener.onReceiveStatus(this.pendingStatus);
        }
      }
      onReceiveMetadata(metadata) {
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, (metadata2) => {
          this.processingMetadata = false;
          this.nextListener.onReceiveMetadata(metadata2);
          this.processPendingMessage();
          this.processPendingStatus();
        });
      }
      onReceiveMessage(message) {
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessage = msg;
            this.hasPendingMessage = true;
          } else {
            this.nextListener.onReceiveMessage(msg);
            this.processPendingStatus();
          }
        });
      }
      onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingStatus = processedStatus;
          } else {
            this.nextListener.onReceiveStatus(processedStatus);
          }
        });
      }
    };
    exports2.InterceptingListenerImpl = InterceptingListenerImpl;
    var Http2CallStream = class {
      constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {
        this.methodName = methodName;
        this.channel = channel;
        this.options = options;
        this.channelCallCredentials = channelCallCredentials;
        this.callNumber = callNumber;
        this.http2Stream = null;
        this.pendingRead = false;
        this.isWriteFilterPending = false;
        this.pendingWrite = null;
        this.pendingWriteCallback = null;
        this.writesClosed = false;
        this.decoder = new stream_decoder_1.StreamDecoder();
        this.isReadFilterPending = false;
        this.canPush = false;
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.unfilteredReadMessages = [];
        this.mappedStatusCode = constants_1.Status.UNKNOWN;
        this.finalStatus = null;
        this.subchannel = null;
        this.listener = null;
        this.internalError = null;
        this.configDeadline = Infinity;
        this.statusWatchers = [];
        this.streamEndWatchers = [];
        this.callStatsTracker = null;
        this.filterStack = filterStackFactory.createFilter(this);
        this.credentials = channelCallCredentials;
        this.disconnectListener = () => {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: "Connection dropped",
            metadata: new metadata_1.Metadata()
          });
        };
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {
          this.options.parentCall.on("cancelled", () => {
            this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
          });
        }
      }
      outputStatus() {
        if (this.listener && !this.statusOutput) {
          this.statusOutput = true;
          const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);
          this.trace("ended with status: code=" + filteredStatus.code + ' details="' + filteredStatus.details + '"');
          this.statusWatchers.forEach((watcher) => watcher(filteredStatus));
          process.nextTick(() => {
            var _a;
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
          });
          if (this.subchannel) {
            this.subchannel.callUnref();
            this.subchannel.removeDisconnectListener(this.disconnectListener);
          }
        }
      }
      trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      endCall(status) {
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
          this.finalStatus = status;
          this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
      }
      maybeOutputStatus() {
        if (this.finalStatus !== null) {
          if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {
            this.outputStatus();
          }
        }
      }
      push(message) {
        this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        process.nextTick(() => {
          var _a;
          if (this.statusOutput) {
            return;
          }
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);
          this.maybeOutputStatus();
        });
      }
      handleFilterError(error2) {
        this.cancelWithStatus(constants_1.Status.INTERNAL, error2.message);
      }
      handleFilteredRead(message) {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.maybeOutputStatus();
          return;
        }
        this.isReadFilterPending = false;
        if (this.canPush) {
          this.http2Stream.pause();
          this.push(message);
        } else {
          this.trace("unpushedReadMessages.push message of length " + message.length);
          this.unpushedReadMessages.push(message);
        }
        if (this.unfilteredReadMessages.length > 0) {
          const nextMessage = this.unfilteredReadMessages.shift();
          this.filterReceivedMessage(nextMessage);
        }
      }
      filterReceivedMessage(framedMessage) {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.maybeOutputStatus();
          return;
        }
        this.trace("filterReceivedMessage of length " + framedMessage.length);
        this.isReadFilterPending = true;
        this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));
      }
      tryPush(messageBytes) {
        if (this.isReadFilterPending) {
          this.trace("unfilteredReadMessages.push message of length " + (messageBytes && messageBytes.length));
          this.unfilteredReadMessages.push(messageBytes);
        } else {
          this.filterReceivedMessage(messageBytes);
        }
      }
      handleTrailers(headers) {
        this.streamEndWatchers.forEach((watcher) => watcher(true));
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        this.trace("Received server trailers:\n" + headersString);
        let metadata;
        try {
          metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        } catch (e2) {
          metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let code = this.mappedStatusCode;
        if (code === constants_1.Status.UNKNOWN && typeof metadataMap["grpc-status"] === "string") {
          const receivedStatus = Number(metadataMap["grpc-status"]);
          if (receivedStatus in constants_1.Status) {
            code = receivedStatus;
            this.trace("received status code " + receivedStatus + " from server");
          }
          metadata.remove("grpc-status");
        }
        let details = "";
        if (typeof metadataMap["grpc-message"] === "string") {
          details = decodeURI(metadataMap["grpc-message"]);
          metadata.remove("grpc-message");
          this.trace('received status details string "' + details + '" from server');
        }
        const status = { code, details, metadata };
        this.endCall(status);
      }
      writeMessageToStream(message, callback) {
        var _a;
        (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();
        this.http2Stream.write(message, callback);
      }
      attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {
        this.filterStack.push(extraFilters);
        if (this.finalStatus !== null) {
          stream.close(NGHTTP2_CANCEL);
        } else {
          this.trace("attachHttp2Stream from subchannel " + subchannel.getAddress());
          this.http2Stream = stream;
          this.subchannel = subchannel;
          this.callStatsTracker = callStatsTracker;
          subchannel.addDisconnectListener(this.disconnectListener);
          subchannel.callRef();
          stream.on("response", (headers, flags) => {
            var _a;
            let headersString = "";
            for (const header of Object.keys(headers)) {
              headersString += "		" + header + ": " + headers[header] + "\n";
            }
            this.trace("Received server headers:\n" + headersString);
            switch (headers[":status"]) {
              case 400:
                this.mappedStatusCode = constants_1.Status.INTERNAL;
                break;
              case 401:
                this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
                break;
              case 403:
                this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
                break;
              case 404:
                this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
                break;
              case 429:
              case 502:
              case 503:
              case 504:
                this.mappedStatusCode = constants_1.Status.UNAVAILABLE;
                break;
              default:
                this.mappedStatusCode = constants_1.Status.UNKNOWN;
            }
            if (flags & http22.constants.NGHTTP2_FLAG_END_STREAM) {
              this.handleTrailers(headers);
            } else {
              let metadata;
              try {
                metadata = metadata_1.Metadata.fromHttp2Headers(headers);
              } catch (error2) {
                this.endCall({
                  code: constants_1.Status.UNKNOWN,
                  details: error2.message,
                  metadata: new metadata_1.Metadata()
                });
                return;
              }
              try {
                const finalMetadata = this.filterStack.receiveMetadata(metadata);
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);
              } catch (error2) {
                this.endCall({
                  code: constants_1.Status.UNKNOWN,
                  details: error2.message,
                  metadata: new metadata_1.Metadata()
                });
              }
            }
          });
          stream.on("trailers", this.handleTrailers.bind(this));
          stream.on("data", (data) => {
            this.trace("receive HTTP/2 data frame of length " + data.length);
            const messages = this.decoder.write(data);
            for (const message of messages) {
              this.trace("parsed message of length " + message.length);
              this.callStatsTracker.addMessageReceived();
              this.tryPush(message);
            }
          });
          stream.on("end", () => {
            this.readsClosed = true;
            this.maybeOutputStatus();
          });
          stream.on("close", () => {
            process.nextTick(() => {
              var _a;
              this.trace("HTTP/2 stream closed with code " + stream.rstCode);
              if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                return;
              }
              let code;
              let details = "";
              switch (stream.rstCode) {
                case http22.constants.NGHTTP2_NO_ERROR:
                  if (this.finalStatus !== null) {
                    return;
                  }
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${stream.rstCode}`;
                  break;
                case http22.constants.NGHTTP2_REFUSED_STREAM:
                  code = constants_1.Status.UNAVAILABLE;
                  details = "Stream refused by server";
                  break;
                case http22.constants.NGHTTP2_CANCEL:
                  code = constants_1.Status.CANCELLED;
                  details = "Call cancelled";
                  break;
                case http22.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                  code = constants_1.Status.RESOURCE_EXHAUSTED;
                  details = "Bandwidth exhausted or memory limit exceeded";
                  break;
                case http22.constants.NGHTTP2_INADEQUATE_SECURITY:
                  code = constants_1.Status.PERMISSION_DENIED;
                  details = "Protocol not secure enough";
                  break;
                case http22.constants.NGHTTP2_INTERNAL_ERROR:
                  code = constants_1.Status.INTERNAL;
                  if (this.internalError === null) {
                    details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;
                  } else {
                    if (this.internalError.code === "ECONNRESET" || this.internalError.code === "ETIMEDOUT") {
                      code = constants_1.Status.UNAVAILABLE;
                      details = this.internalError.message;
                    } else {
                      details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                    }
                  }
                  break;
                default:
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${stream.rstCode}`;
              }
              this.endCall({ code, details, metadata: new metadata_1.Metadata() });
            });
          });
          stream.on("error", (err) => {
            if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
              this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
              this.internalError = err;
            }
            this.streamEndWatchers.forEach((watcher) => watcher(false));
          });
          if (!this.pendingRead) {
            stream.pause();
          }
          if (this.pendingWrite) {
            if (!this.pendingWriteCallback) {
              throw new Error("Invalid state in write handling code");
            }
            this.trace("sending data chunk of length " + this.pendingWrite.length + " (deferred)");
            try {
              this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);
            } catch (error2) {
              this.endCall({
                code: constants_1.Status.UNAVAILABLE,
                details: `Write failed with error ${error2.message}`,
                metadata: new metadata_1.Metadata()
              });
            }
          }
          this.maybeCloseWrites();
        }
      }
      start(metadata, listener) {
        this.trace("Sending metadata");
        this.listener = listener;
        this.channel._startCallStream(this, metadata);
        this.maybeOutputStatus();
      }
      destroyHttp2Stream() {
        var _a;
        if (this.http2Stream !== null && !this.http2Stream.destroyed) {
          let code;
          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
            code = http22.constants.NGHTTP2_NO_ERROR;
          } else {
            code = http22.constants.NGHTTP2_CANCEL;
          }
          this.trace("close http2 stream with code " + code);
          this.http2Stream.close(code);
        }
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
      }
      getDeadline() {
        const deadlineList = [this.options.deadline];
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {
          deadlineList.push(this.options.parentCall.getDeadline());
        }
        if (this.configDeadline) {
          deadlineList.push(this.configDeadline);
        }
        return getMinDeadline(deadlineList);
      }
      getCredentials() {
        return this.credentials;
      }
      setCredentials(credentials2) {
        this.credentials = this.channelCallCredentials.compose(credentials2);
      }
      getStatus() {
        return this.finalStatus;
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
      }
      getMethod() {
        return this.methodName;
      }
      getHost() {
        return this.options.host;
      }
      setConfigDeadline(configDeadline) {
        this.configDeadline = configDeadline;
      }
      addStatusWatcher(watcher) {
        this.statusWatchers.push(watcher);
      }
      addStreamEndWatcher(watcher) {
        this.streamEndWatchers.push(watcher);
      }
      addFilters(extraFilters) {
        this.filterStack.push(extraFilters);
      }
      getCallNumber() {
        return this.callNumber;
      }
      startRead() {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.readsClosed = true;
          this.maybeOutputStatus();
          return;
        }
        this.canPush = true;
        if (this.http2Stream === null) {
          this.pendingRead = true;
        } else {
          if (this.unpushedReadMessages.length > 0) {
            const nextMessage = this.unpushedReadMessages.shift();
            this.push(nextMessage);
            return;
          }
          this.http2Stream.resume();
        }
      }
      maybeCloseWrites() {
        if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {
          this.trace("calling end() on HTTP/2 stream");
          this.http2Stream.end();
        }
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        const writeObj = {
          message,
          flags: context.flags
        };
        const cb = (error2) => {
          var _a, _b;
          let code = constants_1.Status.UNAVAILABLE;
          if (((_a = error2) === null || _a === void 0 ? void 0 : _a.code) === "ERR_STREAM_WRITE_AFTER_END") {
            code = constants_1.Status.INTERNAL;
          }
          if (error2) {
            this.cancelWithStatus(code, `Write error: ${error2.message}`);
          }
          (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);
        };
        this.isWriteFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message2) => {
          this.isWriteFilterPending = false;
          if (this.http2Stream === null) {
            this.trace("deferring writing data chunk of length " + message2.message.length);
            this.pendingWrite = message2.message;
            this.pendingWriteCallback = cb;
          } else {
            this.trace("sending data chunk of length " + message2.message.length);
            try {
              this.writeMessageToStream(message2.message, cb);
            } catch (error2) {
              this.endCall({
                code: constants_1.Status.UNAVAILABLE,
                details: `Write failed with error ${error2.message}`,
                metadata: new metadata_1.Metadata()
              });
            }
            this.maybeCloseWrites();
          }
        }, this.handleFilterError.bind(this));
      }
      halfClose() {
        this.trace("end() called");
        this.writesClosed = true;
        this.maybeCloseWrites();
      }
    };
    exports2.Http2CallStream = Http2CallStream;
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/tls-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultRootsData = exports2.CIPHER_SUITES = void 0;
    var fs = require("fs");
    exports2.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
    var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
    var defaultRootsData = null;
    function getDefaultRootsData() {
      if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
          defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
      }
      return null;
    }
    exports2.getDefaultRootsData = getDefaultRootsData;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelCredentials = void 0;
    var tls_1 = require("tls");
    var call_credentials_1 = require_call_credentials();
    var tls_helpers_1 = require_tls_helpers();
    function verifyIsBufferOrNull(obj, friendlyName) {
      if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
      }
    }
    var ChannelCredentials = class {
      constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
      }
      _getCallCredentials() {
        return this.callCredentials;
      }
      static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        var _a;
        verifyIsBufferOrNull(rootCerts, "Root certificate");
        verifyIsBufferOrNull(privateKey, "Private key");
        verifyIsBufferOrNull(certChain, "Certificate chain");
        if (privateKey && !certChain) {
          throw new Error("Private key must be given with accompanying certificate chain");
        }
        if (!privateKey && certChain) {
          throw new Error("Certificate chain must be given with accompanying private key");
        }
        const secureContext = tls_1.createSecureContext({
          ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : tls_helpers_1.getDefaultRootsData()) !== null && _a !== void 0 ? _a : void 0,
          key: privateKey !== null && privateKey !== void 0 ? privateKey : void 0,
          cert: certChain !== null && certChain !== void 0 ? certChain : void 0,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      static createFromSecureContext(secureContext, verifyOptions) {
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      static createInsecure() {
        return new InsecureChannelCredentialsImpl();
      }
    };
    exports2.ChannelCredentials = ChannelCredentials;
    var InsecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(callCredentials) {
        super(callCredentials);
      }
      compose(callCredentials) {
        throw new Error("Cannot compose insecure credentials");
      }
      _getConnectionOptions() {
        return null;
      }
      _isSecure() {
        return false;
      }
      _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
      }
    };
    var SecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(secureContext, verifyOptions) {
        super();
        this.secureContext = secureContext;
        this.verifyOptions = verifyOptions;
        this.connectionOptions = {
          secureContext
        };
        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {
          this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return Object.assign({}, this.connectionOptions);
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
          return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
        } else {
          return false;
        }
      }
    };
    var ComposedChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
          return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateLoadBalancingConfig = exports2.getFirstUsableConfig = exports2.isLoadBalancerNameRegistered = exports2.createLoadBalancer = exports2.registerDefaultLoadBalancerType = exports2.registerLoadBalancerType = exports2.createChildChannelControlHelper = void 0;
    function createChildChannelControlHelper(parent, overrides) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      return {
        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),
        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),
        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),
        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),
        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)
      };
    }
    exports2.createChildChannelControlHelper = createChildChannelControlHelper;
    var registeredLoadBalancerTypes = {};
    var defaultLoadBalancerType = null;
    function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
      registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
      };
    }
    exports2.registerLoadBalancerType = registerLoadBalancerType;
    function registerDefaultLoadBalancerType(typeName) {
      defaultLoadBalancerType = typeName;
    }
    exports2.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
    function createLoadBalancer(config, channelControlHelper) {
      const typeName = config.getLoadBalancerName();
      if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
      } else {
        return null;
      }
    }
    exports2.createLoadBalancer = createLoadBalancer;
    function isLoadBalancerNameRegistered(typeName) {
      return typeName in registeredLoadBalancerTypes;
    }
    exports2.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
    function getFirstUsableConfig(configs, fallbackTodefault = false) {
      for (const config of configs) {
        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {
          return config;
        }
      }
      if (fallbackTodefault) {
        if (defaultLoadBalancerType) {
          return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
        } else {
          return null;
        }
      } else {
        return null;
      }
    }
    exports2.getFirstUsableConfig = getFirstUsableConfig;
    function validateLoadBalancingConfig(obj) {
      if (!(obj !== null && typeof obj === "object")) {
        throw new Error("Load balancing config must be an object");
      }
      const keys = Object.keys(obj);
      if (keys.length !== 1) {
        throw new Error("Provided load balancing config has multiple conflicting entries");
      }
      const typeName = keys[0];
      if (typeName in registeredLoadBalancerTypes) {
        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);
      } else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
      }
    }
    exports2.validateLoadBalancingConfig = validateLoadBalancingConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/service-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractAndSelectServiceConfig = exports2.validateServiceConfig = void 0;
    var os = require("os");
    var load_balancer_1 = require_load_balancer();
    var TIMEOUT_REGEX = /^\d+(\.\d{1,9})?s$/;
    var CLIENT_LANGUAGE_STRING = "node";
    function validateName(obj) {
      if (!("service" in obj) || typeof obj.service !== "string") {
        throw new Error("Invalid method config name: invalid service");
      }
      const result = {
        service: obj.service
      };
      if ("method" in obj) {
        if (typeof obj.method === "string") {
          result.method = obj.method;
        } else {
          throw new Error("Invalid method config name: invalid method");
        }
      }
      return result;
    }
    function validateMethodConfig(obj) {
      var _a;
      const result = {
        name: []
      };
      if (!("name" in obj) || !Array.isArray(obj.name)) {
        throw new Error("Invalid method config: invalid name array");
      }
      for (const name4 of obj.name) {
        result.name.push(validateName(name4));
      }
      if ("waitForReady" in obj) {
        if (typeof obj.waitForReady !== "boolean") {
          throw new Error("Invalid method config: invalid waitForReady");
        }
        result.waitForReady = obj.waitForReady;
      }
      if ("timeout" in obj) {
        if (typeof obj.timeout === "object") {
          if (!("seconds" in obj.timeout) || !(typeof obj.timeout.seconds === "number")) {
            throw new Error("Invalid method config: invalid timeout.seconds");
          }
          if (!("nanos" in obj.timeout) || !(typeof obj.timeout.nanos === "number")) {
            throw new Error("Invalid method config: invalid timeout.nanos");
          }
          result.timeout = obj.timeout;
        } else if (typeof obj.timeout === "string" && TIMEOUT_REGEX.test(obj.timeout)) {
          const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(".");
          result.timeout = {
            seconds: timeoutParts[0] | 0,
            nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0
          };
        } else {
          throw new Error("Invalid method config: invalid timeout");
        }
      }
      if ("maxRequestBytes" in obj) {
        if (typeof obj.maxRequestBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxRequestBytes = obj.maxRequestBytes;
      }
      if ("maxResponseBytes" in obj) {
        if (typeof obj.maxResponseBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxResponseBytes = obj.maxResponseBytes;
      }
      return result;
    }
    function validateServiceConfig(obj) {
      const result = {
        loadBalancingConfig: [],
        methodConfig: []
      };
      if ("loadBalancingPolicy" in obj) {
        if (typeof obj.loadBalancingPolicy === "string") {
          result.loadBalancingPolicy = obj.loadBalancingPolicy;
        } else {
          throw new Error("Invalid service config: invalid loadBalancingPolicy");
        }
      }
      if ("loadBalancingConfig" in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
          for (const config of obj.loadBalancingConfig) {
            result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));
          }
        } else {
          throw new Error("Invalid service config: invalid loadBalancingConfig");
        }
      }
      if ("methodConfig" in obj) {
        if (Array.isArray(obj.methodConfig)) {
          for (const methodConfig of obj.methodConfig) {
            result.methodConfig.push(validateMethodConfig(methodConfig));
          }
        }
      }
      const seenMethodNames = [];
      for (const methodConfig of result.methodConfig) {
        for (const name4 of methodConfig.name) {
          for (const seenName of seenMethodNames) {
            if (name4.service === seenName.service && name4.method === seenName.method) {
              throw new Error(`Invalid service config: duplicate name ${name4.service}/${name4.method}`);
            }
          }
          seenMethodNames.push(name4);
        }
      }
      return result;
    }
    exports2.validateServiceConfig = validateServiceConfig;
    function validateCanaryConfig(obj) {
      if (!("serviceConfig" in obj)) {
        throw new Error("Invalid service config choice: missing service config");
      }
      const result = {
        serviceConfig: validateServiceConfig(obj.serviceConfig)
      };
      if ("clientLanguage" in obj) {
        if (Array.isArray(obj.clientLanguage)) {
          result.clientLanguage = [];
          for (const lang of obj.clientLanguage) {
            if (typeof lang === "string") {
              result.clientLanguage.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientLanguage");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientLanguage");
        }
      }
      if ("clientHostname" in obj) {
        if (Array.isArray(obj.clientHostname)) {
          result.clientHostname = [];
          for (const lang of obj.clientHostname) {
            if (typeof lang === "string") {
              result.clientHostname.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientHostname");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientHostname");
        }
      }
      if ("percentage" in obj) {
        if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
          result.percentage = obj.percentage;
        } else {
          throw new Error("Invalid service config choice: invalid percentage");
        }
      }
      const allowedFields = [
        "clientLanguage",
        "percentage",
        "clientHostname",
        "serviceConfig"
      ];
      for (const field in obj) {
        if (!allowedFields.includes(field)) {
          throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
      }
      return result;
    }
    function validateAndSelectCanaryConfig(obj, percentage) {
      if (!Array.isArray(obj)) {
        throw new Error("Invalid service config list");
      }
      for (const config of obj) {
        const validatedConfig = validateCanaryConfig(config);
        if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
          continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
          let hostnameMatched = false;
          for (const hostname of validatedConfig.clientHostname) {
            if (hostname === os.hostname()) {
              hostnameMatched = true;
            }
          }
          if (!hostnameMatched) {
            continue;
          }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
          let languageMatched = false;
          for (const language of validatedConfig.clientLanguage) {
            if (language === CLIENT_LANGUAGE_STRING) {
              languageMatched = true;
            }
          }
          if (!languageMatched) {
            continue;
          }
        }
        return validatedConfig.serviceConfig;
      }
      throw new Error("No matching service config found");
    }
    function extractAndSelectServiceConfig(txtRecord, percentage) {
      for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith("grpc_config=")) {
          const recordString = record.join("").substring("grpc_config=".length);
          const recordJson = JSON.parse(recordString);
          return validateAndSelectCanaryConfig(recordJson, percentage);
        }
      }
      return null;
    }
    exports2.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/connectivity-state.js
var require_connectivity_state = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/connectivity-state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectivityState = void 0;
    var ConnectivityState;
    (function(ConnectivityState2) {
      ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
      ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
      ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
      ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
    })(ConnectivityState = exports2.ConnectivityState || (exports2.ConnectivityState = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/uri-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriToString = exports2.splitHostPort = exports2.parseUri = void 0;
    var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
    function parseUri(uriString) {
      const parsedUri = URI_REGEX.exec(uriString);
      if (parsedUri === null) {
        return null;
      }
      return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3]
      };
    }
    exports2.parseUri = parseUri;
    var NUMBER_REGEX = /^\d+$/;
    function splitHostPort(path2) {
      if (path2.startsWith("[")) {
        const hostEnd = path2.indexOf("]");
        if (hostEnd === -1) {
          return null;
        }
        const host = path2.substring(1, hostEnd);
        if (host.indexOf(":") === -1) {
          return null;
        }
        if (path2.length > hostEnd + 1) {
          if (path2[hostEnd + 1] === ":") {
            const portString = path2.substring(hostEnd + 2);
            if (NUMBER_REGEX.test(portString)) {
              return {
                host,
                port: +portString
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else {
          return {
            host
          };
        }
      } else {
        const splitPath = path2.split(":");
        if (splitPath.length === 2) {
          if (NUMBER_REGEX.test(splitPath[1])) {
            return {
              host: splitPath[0],
              port: +splitPath[1]
            };
          } else {
            return null;
          }
        } else {
          return {
            host: path2
          };
        }
      }
    }
    exports2.splitHostPort = splitHostPort;
    function uriToString(uri) {
      let result = "";
      if (uri.scheme !== void 0) {
        result += uri.scheme + ":";
      }
      if (uri.authority !== void 0) {
        result += "//" + uri.authority + "/";
      }
      result += uri.path;
      return result;
    }
    exports2.uriToString = uriToString;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapUriDefaultScheme = exports2.getDefaultAuthority = exports2.createResolver = exports2.registerDefaultScheme = exports2.registerResolver = void 0;
    var uri_parser_1 = require_uri_parser();
    var registeredResolvers = {};
    var defaultScheme = null;
    function registerResolver(scheme2, resolverClass) {
      registeredResolvers[scheme2] = resolverClass;
    }
    exports2.registerResolver = registerResolver;
    function registerDefaultScheme(scheme2) {
      defaultScheme = scheme2;
    }
    exports2.registerDefaultScheme = registerDefaultScheme;
    function createResolver(target, listener, options) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
      } else {
        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);
      }
    }
    exports2.createResolver = createResolver;
    function getDefaultAuthority(target) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
      } else {
        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);
      }
    }
    exports2.getDefaultAuthority = getDefaultAuthority;
    function mapUriDefaultScheme(target) {
      if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
          return {
            scheme: defaultScheme,
            authority: void 0,
            path: uri_parser_1.uriToString(target)
          };
        } else {
          return null;
        }
      }
      return target;
    }
    exports2.mapUriDefaultScheme = mapUriDefaultScheme;
  }
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/picker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuePicker = exports2.UnavailablePicker = exports2.PickResultType = void 0;
    var metadata_1 = require_metadata();
    var constants_1 = require_constants();
    var PickResultType;
    (function(PickResultType2) {
      PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
      PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
      PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
      PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
    })(PickResultType = exports2.PickResultType || (exports2.PickResultType = {}));
    var UnavailablePicker = class {
      constructor(status) {
        if (status !== void 0) {
          this.status = status;
        } else {
          this.status = {
            code: constants_1.Status.UNAVAILABLE,
            details: "No connection established",
            metadata: new metadata_1.Metadata()
          };
        }
      }
      pick(pickArgs) {
        return {
          pickResultType: PickResultType.TRANSIENT_FAILURE,
          subchannel: null,
          status: this.status,
          extraFilterFactories: [],
          onCallStarted: null
        };
      }
    };
    exports2.UnavailablePicker = UnavailablePicker;
    var QueuePicker = class {
      constructor(loadBalancer) {
        this.loadBalancer = loadBalancer;
        this.calledExitIdle = false;
      }
      pick(pickArgs) {
        if (!this.calledExitIdle) {
          process.nextTick(() => {
            this.loadBalancer.exitIdle();
          });
          this.calledExitIdle = true;
        }
        return {
          pickResultType: PickResultType.QUEUE,
          subchannel: null,
          status: null,
          extraFilterFactories: [],
          onCallStarted: null
        };
      }
    };
    exports2.QueuePicker = QueuePicker;
  }
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BackoffTimeout = void 0;
    var INITIAL_BACKOFF_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.6;
    var MAX_BACKOFF_MS = 12e4;
    var BACKOFF_JITTER = 0.2;
    function uniformRandom(min, max) {
      return Math.random() * (max - min) + min;
    }
    var BackoffTimeout = class {
      constructor(callback, options) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        this.startTime = new Date();
        if (options) {
          if (options.initialDelay) {
            this.initialDelay = options.initialDelay;
          }
          if (options.multiplier) {
            this.multiplier = options.multiplier;
          }
          if (options.jitter) {
            this.jitter = options.jitter;
          }
          if (options.maxDelay) {
            this.maxDelay = options.maxDelay;
          }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => {
        }, 0);
        clearTimeout(this.timerId);
      }
      runTimer(delay) {
        var _a, _b;
        this.timerId = setTimeout(() => {
          this.callback();
          this.running = false;
        }, delay);
        if (!this.hasRef) {
          (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      runOnce() {
        this.running = true;
        this.startTime = new Date();
        this.runTimer(this.nextDelay);
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
      }
      stop() {
        clearTimeout(this.timerId);
        this.running = false;
      }
      reset() {
        this.nextDelay = this.initialDelay;
        if (this.running) {
          const now = new Date();
          const newEndTime = this.startTime;
          newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
          clearTimeout(this.timerId);
          if (now < newEndTime) {
            this.runTimer(newEndTime.getTime() - now.getTime());
          } else {
            this.running = false;
          }
        }
      }
      isRunning() {
        return this.running;
      }
      ref() {
        var _a, _b;
        this.hasRef = true;
        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      unref() {
        var _a, _b;
        this.hasRef = false;
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    };
    exports2.BackoffTimeout = BackoffTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChildLoadBalancerHandler = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var TYPE_NAME = "child_load_balancer_helper";
    var ChildLoadBalancerHandler = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.currentChild = null;
        this.pendingChild = null;
        this.ChildPolicyHelper = class {
          constructor(parent) {
            this.parent = parent;
            this.child = null;
          }
          createSubchannel(subchannelAddress, subchannelArgs) {
            return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
          }
          updateState(connectivityState, picker) {
            var _a;
            if (this.calledByPendingChild()) {
              if (connectivityState !== connectivity_state_1.ConnectivityState.READY) {
                return;
              }
              (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
              this.parent.currentChild = this.parent.pendingChild;
              this.parent.pendingChild = null;
            } else if (!this.calledByCurrentChild()) {
              return;
            }
            this.parent.channelControlHelper.updateState(connectivityState, picker);
          }
          requestReresolution() {
            var _a;
            const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
            if (this.child === latestChild) {
              this.parent.channelControlHelper.requestReresolution();
            }
          }
          setChild(newChild) {
            this.child = newChild;
          }
          addChannelzChild(child) {
            this.parent.channelControlHelper.addChannelzChild(child);
          }
          removeChannelzChild(child) {
            this.parent.channelControlHelper.removeChannelzChild(child);
          }
          calledByPendingChild() {
            return this.child === this.parent.pendingChild;
          }
          calledByCurrentChild() {
            return this.child === this.parent.currentChild;
          }
        };
      }
      updateAddressList(addressList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {
          const newHelper = new this.ChildPolicyHelper(this);
          const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);
          newHelper.setChild(newChild);
          if (this.currentChild === null) {
            this.currentChild = newChild;
            childToUpdate = this.currentChild;
          } else {
            if (this.pendingChild) {
              this.pendingChild.destroy();
            }
            this.pendingChild = newChild;
            childToUpdate = this.pendingChild;
          }
        } else {
          if (this.pendingChild === null) {
            childToUpdate = this.currentChild;
          } else {
            childToUpdate = this.pendingChild;
          }
        }
        childToUpdate.updateAddressList(addressList, lbConfig, attributes);
      }
      exitIdle() {
        if (this.currentChild) {
          this.currentChild.exitIdle();
          if (this.pendingChild) {
            this.pendingChild.exitIdle();
          }
        }
      }
      resetBackoff() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      destroy() {
        if (this.currentChild) {
          this.currentChild.destroy();
          this.currentChild = null;
        }
        if (this.pendingChild) {
          this.pendingChild.destroy();
          this.pendingChild = null;
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolvingLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var service_config_1 = require_service_config();
    var connectivity_state_1 = require_connectivity_state();
    var resolver_1 = require_resolver();
    var picker_1 = require_picker();
    var backoff_timeout_1 = require_backoff_timeout();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var TRACER_NAME = "resolving_load_balancer";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getDefaultConfigSelector(serviceConfig) {
      return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split("/").filter((x2) => x2.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : "";
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const methodConfig of serviceConfig.methodConfig) {
            for (const name4 of methodConfig.name) {
              if (name4.service === service && (name4.method === void 0 || name4.method === method)) {
                return {
                  methodConfig,
                  pickInformation: {},
                  status: constants_1.Status.OK,
                  dynamicFilterFactories: []
                };
              }
            }
          }
        }
        return {
          methodConfig: { name: [] },
          pickInformation: {},
          status: constants_1.Status.OK,
          dynamicFilterFactories: []
        };
      };
    }
    var ResolvingLoadBalancer = class {
      constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.channelOptions = channelOptions;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
        if (channelOptions["grpc.service_config"]) {
          this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions["grpc.service_config"]));
        } else {
          this.defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: []
          };
        }
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
          createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
          requestReresolution: () => {
            if (this.backoffTimeout.isRunning()) {
              this.continueResolving = true;
            } else {
              this.updateResolution();
            }
          },
          updateState: (newState, picker) => {
            this.latestChildState = newState;
            this.latestChildPicker = picker;
            this.updateState(newState, picker);
          },
          addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
          removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)
        });
        this.innerResolver = resolver_1.createResolver(target, {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {
            var _a;
            let workingServiceConfig = null;
            if (serviceConfig === null) {
              if (serviceConfigError === null) {
                this.previousServiceConfig = null;
                workingServiceConfig = this.defaultServiceConfig;
              } else {
                if (this.previousServiceConfig === null) {
                  this.handleResolutionFailure(serviceConfigError);
                } else {
                  workingServiceConfig = this.previousServiceConfig;
                }
              }
            } else {
              workingServiceConfig = serviceConfig;
              this.previousServiceConfig = serviceConfig;
            }
            const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
            const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);
            if (loadBalancingConfig === null) {
              this.handleResolutionFailure({
                code: constants_1.Status.UNAVAILABLE,
                details: "All load balancer options in service config are not compatible",
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);
            const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
            this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
          },
          onError: (error2) => {
            this.handleResolutionFailure(error2);
          }
        }, channelOptions);
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.updateResolution();
            this.continueResolving = false;
          } else {
            this.updateState(this.latestChildState, this.latestChildPicker);
          }
        }, backoffOptions);
        this.backoffTimeout.unref();
      }
      updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
      }
      updateState(connectivityState, picker) {
        trace(uri_parser_1.uriToString(this.target) + " " + connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[connectivityState]);
        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
          picker = new picker_1.QueuePicker(this);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
      }
      handleResolutionFailure(error2) {
        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error2));
          this.onFailedResolution(error2);
        }
        this.backoffTimeout.runOnce();
      }
      exitIdle() {
        this.childLoadBalancer.exitIdle();
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
      }
      updateAddressList(addressList, lbConfig) {
        throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
      }
      destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());
      }
      getTypeName() {
        return "resolving_load_balancer";
      }
    };
    exports2.ResolvingLoadBalancer = ResolvingLoadBalancer;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.channelOptionsEqual = exports2.recognizedOptions = void 0;
    exports2.recognizedOptions = {
      "grpc.ssl_target_name_override": true,
      "grpc.primary_user_agent": true,
      "grpc.secondary_user_agent": true,
      "grpc.default_authority": true,
      "grpc.keepalive_time_ms": true,
      "grpc.keepalive_timeout_ms": true,
      "grpc.keepalive_permit_without_calls": true,
      "grpc.service_config": true,
      "grpc.max_concurrent_streams": true,
      "grpc.initial_reconnect_backoff_ms": true,
      "grpc.max_reconnect_backoff_ms": true,
      "grpc.use_local_subchannel_pool": true,
      "grpc.max_send_message_length": true,
      "grpc.max_receive_message_length": true,
      "grpc.enable_http_proxy": true,
      "grpc.enable_channelz": true,
      "grpc.dns_min_time_between_resolutions_ms": true,
      "grpc-node.max_session_memory": true
    };
    function channelOptionsEqual(options1, options2) {
      const keys1 = Object.keys(options1).sort();
      const keys2 = Object.keys(options2).sort();
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i2 = 0; i2 < keys1.length; i2 += 1) {
        if (keys1[i2] !== keys2[i2]) {
          return false;
        }
        if (options1[keys1[i2]] !== options2[keys2[i2]]) {
          return false;
        }
      }
      return true;
    }
    exports2.channelOptionsEqual = channelOptionsEqual;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-address.js
var require_subchannel_address = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToSubchannelAddress = exports2.subchannelAddressToString = exports2.subchannelAddressEqual = exports2.isTcpSubchannelAddress = void 0;
    var net_1 = require("net");
    function isTcpSubchannelAddress(address) {
      return "port" in address;
    }
    exports2.isTcpSubchannelAddress = isTcpSubchannelAddress;
    function subchannelAddressEqual(address1, address2) {
      if (isTcpSubchannelAddress(address1)) {
        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
      } else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
      }
    }
    exports2.subchannelAddressEqual = subchannelAddressEqual;
    function subchannelAddressToString(address) {
      if (isTcpSubchannelAddress(address)) {
        return address.host + ":" + address.port;
      } else {
        return address.path;
      }
    }
    exports2.subchannelAddressToString = subchannelAddressToString;
    var DEFAULT_PORT = 443;
    function stringToSubchannelAddress(addressString, port2) {
      if (net_1.isIP(addressString)) {
        return {
          host: addressString,
          port: port2 !== null && port2 !== void 0 ? port2 : DEFAULT_PORT
        };
      } else {
        return {
          path: addressString
        };
      }
    }
    exports2.stringToSubchannelAddress = stringToSubchannelAddress;
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/http_proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProxiedConnection = exports2.mapProxyName = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var resolver_1 = require_resolver();
    var http3 = require("http");
    var tls = require("tls");
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var url_1 = require("url");
    var TRACER_NAME = "proxy";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getProxyInfo() {
      let proxyEnv = "";
      let envVar = "";
      if (process.env.grpc_proxy) {
        envVar = "grpc_proxy";
        proxyEnv = process.env.grpc_proxy;
      } else if (process.env.https_proxy) {
        envVar = "https_proxy";
        proxyEnv = process.env.https_proxy;
      } else if (process.env.http_proxy) {
        envVar = "http_proxy";
        proxyEnv = process.env.http_proxy;
      } else {
        return {};
      }
      let proxyUrl;
      try {
        proxyUrl = new url_1.URL(proxyEnv);
      } catch (e2) {
        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
      }
      if (proxyUrl.protocol !== "http:") {
        logging_1.log(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
      }
      let userCred = null;
      if (proxyUrl.username) {
        if (proxyUrl.password) {
          logging_1.log(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
          userCred = `${proxyUrl.username}:${proxyUrl.password}`;
        } else {
          userCred = proxyUrl.username;
        }
      }
      const hostname = proxyUrl.hostname;
      let port2 = proxyUrl.port;
      if (port2 === "") {
        port2 = "80";
      }
      const result = {
        address: `${hostname}:${port2}`
      };
      if (userCred) {
        result.creds = userCred;
      }
      trace("Proxy server " + result.address + " set by environment variable " + envVar);
      return result;
    }
    function getNoProxyHostList() {
      let noProxyStr = process.env.no_grpc_proxy;
      let envVar = "no_grpc_proxy";
      if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = "no_proxy";
      }
      if (noProxyStr) {
        trace("No proxy server list set by environment variable " + envVar);
        return noProxyStr.split(",");
      } else {
        return [];
      }
    }
    function mapProxyName(target, options) {
      var _a;
      const noProxyResult = {
        target,
        extraOptions: {}
      };
      if (((_a = options["grpc.enable_http_proxy"]) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
      }
      if (target.scheme === "unix") {
        return noProxyResult;
      }
      const proxyInfo = getProxyInfo();
      if (!proxyInfo.address) {
        return noProxyResult;
      }
      const hostPort = uri_parser_1.splitHostPort(target.path);
      if (!hostPort) {
        return noProxyResult;
      }
      const serverHost = hostPort.host;
      for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
          trace("Not using proxy for target in no_proxy list: " + uri_parser_1.uriToString(target));
          return noProxyResult;
        }
      }
      const extraOptions = {
        "grpc.http_connect_target": uri_parser_1.uriToString(target)
      };
      if (proxyInfo.creds) {
        extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
      }
      return {
        target: {
          scheme: "dns",
          path: proxyInfo.address
        },
        extraOptions
      };
    }
    exports2.mapProxyName = mapProxyName;
    function getProxiedConnection(address, channelOptions, connectionOptions) {
      if (!("grpc.http_connect_target" in channelOptions)) {
        return Promise.resolve({});
      }
      const realTarget = channelOptions["grpc.http_connect_target"];
      const parsedTarget = uri_parser_1.parseUri(realTarget);
      if (parsedTarget === null) {
        return Promise.resolve({});
      }
      const options = {
        method: "CONNECT",
        path: parsedTarget.path
      };
      const headers = {
        Host: parsedTarget.path
      };
      if (subchannel_address_1.isTcpSubchannelAddress(address)) {
        options.host = address.host;
        options.port = address.port;
      } else {
        options.socketPath = address.path;
      }
      if ("grpc.http_connect_creds" in channelOptions) {
        headers["Proxy-Authorization"] = "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64");
      }
      options.headers = headers;
      const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);
      trace("Using proxy " + proxyAddressString + " to connect to " + options.path);
      return new Promise((resolve2, reject) => {
        const request = http3.request(options);
        request.once("connect", (res, socket, head) => {
          var _a;
          request.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode === 200) {
            trace("Successfully connected to " + options.path + " through proxy " + proxyAddressString);
            if ("secureContext" in connectionOptions) {
              const targetPath = resolver_1.getDefaultAuthority(parsedTarget);
              const hostPort = uri_parser_1.splitHostPort(targetPath);
              const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
              const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket }, connectionOptions), () => {
                trace("Successfully established a TLS connection to " + options.path + " through proxy " + proxyAddressString);
                resolve2({ socket: cts, realTarget: parsedTarget });
              });
              cts.on("error", (error2) => {
                trace("Failed to establish a TLS connection to " + options.path + " through proxy " + proxyAddressString + " with error " + error2.message);
                reject();
              });
            } else {
              trace("Successfully established a plaintext connection to " + options.path + " through proxy " + proxyAddressString);
              resolve2({
                socket,
                realTarget: parsedTarget
              });
            }
          } else {
            logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
            reject();
          }
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
          reject();
        });
        request.end();
      });
    }
    exports2.getProxiedConnection = getProxiedConnection;
  }
});

// node_modules/@grpc/grpc-js/build/src/admin.js
var require_admin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addAdminServicesToServer = exports2.registerAdminService = void 0;
    var registeredAdminServices = [];
    function registerAdminService(getServiceDefinition, getHandlers) {
      registeredAdminServices.push({ getServiceDefinition, getHandlers });
    }
    exports2.registerAdminService = registerAdminService;
    function addAdminServicesToServer(server2) {
      for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
        server2.addService(getServiceDefinition(), getHandlers());
      }
    }
    exports2.addAdminServicesToServer = addAdminServicesToServer;
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientDuplexStreamImpl = exports2.ClientWritableStreamImpl = exports2.ClientReadableStreamImpl = exports2.ClientUnaryCallImpl = exports2.callErrorFromStatus = void 0;
    var events_1 = require("events");
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    function callErrorFromStatus(status) {
      const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
      return Object.assign(new Error(message), status);
    }
    exports2.callErrorFromStatus = callErrorFromStatus;
    var ClientUnaryCallImpl = class extends events_1.EventEmitter {
      constructor() {
        super();
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
    };
    exports2.ClientUnaryCallImpl = ClientUnaryCallImpl;
    var ClientReadableStreamImpl = class extends stream_1.Readable {
      constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
    };
    exports2.ClientReadableStreamImpl = ClientReadableStreamImpl;
    var ClientWritableStreamImpl = class extends stream_1.Writable {
      constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientWritableStreamImpl = ClientWritableStreamImpl;
    var ClientDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client-interceptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInterceptingCall = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.InterceptorConfigurationError = void 0;
    var metadata_1 = require_metadata();
    var call_stream_1 = require_call_stream();
    var constants_1 = require_constants();
    var InterceptorConfigurationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InterceptorConfigurationError";
        Error.captureStackTrace(this, InterceptorConfigurationError);
      }
    };
    exports2.InterceptorConfigurationError = InterceptorConfigurationError;
    var ListenerBuilder = class {
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveStatus: this.status
        };
      }
    };
    exports2.ListenerBuilder = ListenerBuilder;
    var RequesterBuilder = class {
      constructor() {
        this.start = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
      }
      withCancel(cancel) {
        this.cancel = cancel;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMessage: this.message,
          halfClose: this.halfClose,
          cancel: this.cancel
        };
      }
    };
    exports2.RequesterBuilder = RequesterBuilder;
    var defaultListener = {
      onReceiveMetadata: (metadata, next) => {
        next(metadata);
      },
      onReceiveMessage: (message, next) => {
        next(message);
      },
      onReceiveStatus: (status, next) => {
        next(status);
      }
    };
    var defaultRequester = {
      start: (metadata, listener, next) => {
        next(metadata, listener);
      },
      sendMessage: (message, next) => {
        next(message);
      },
      halfClose: (next) => {
        next();
      },
      cancel: (next) => {
        next();
      }
    };
    var InterceptingCall = class {
      constructor(nextCall, requester) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.pendingMessageContext = null;
        this.processingMessage = false;
        this.pendingHalfClose = false;
        if (requester) {
          this.requester = {
            start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
            sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
            halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
            cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel
          };
        } else {
          this.requester = defaultRequester;
        }
      }
      cancelWithStatus(status, details) {
        this.requester.cancel(() => {
          this.nextCall.cancelWithStatus(status, details);
        });
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      processPendingMessage() {
        if (this.pendingMessageContext) {
          this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
          this.pendingMessageContext = null;
          this.pendingMessage = null;
        }
      }
      processPendingHalfClose() {
        if (this.pendingHalfClose) {
          this.nextCall.halfClose();
        }
      }
      start(metadata, interceptingListener) {
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = {
          onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message) => {
          },
          onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status) => {
          }
        };
        this.processingMetadata = true;
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
          var _a2, _b2, _c2;
          this.processingMetadata = false;
          let finalInterceptingListener;
          if (call_stream_1.isInterceptingListener(listener)) {
            finalInterceptingListener = listener;
          } else {
            const fullListener = {
              onReceiveMetadata: (_a2 = listener.onReceiveMetadata) !== null && _a2 !== void 0 ? _a2 : defaultListener.onReceiveMetadata,
              onReceiveMessage: (_b2 = listener.onReceiveMessage) !== null && _b2 !== void 0 ? _b2 : defaultListener.onReceiveMessage,
              onReceiveStatus: (_c2 = listener.onReceiveStatus) !== null && _c2 !== void 0 ? _c2 : defaultListener.onReceiveStatus
            };
            finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          }
          this.nextCall.start(md, finalInterceptingListener);
          this.processPendingMessage();
          this.processPendingHalfClose();
        });
      }
      sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessageContext = context;
            this.pendingMessage = message;
          } else {
            this.nextCall.sendMessageWithContext(context, finalMessage);
            this.processPendingHalfClose();
          }
        });
      }
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      startRead() {
        this.nextCall.startRead();
      }
      halfClose() {
        this.requester.halfClose(() => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingHalfClose = true;
          } else {
            this.nextCall.halfClose();
          }
        });
      }
      setCredentials(credentials2) {
        this.nextCall.setCredentials(credentials2);
      }
    };
    exports2.InterceptingCall = InterceptingCall;
    function getCall(channel, path2, options) {
      var _a, _b;
      const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
      const host = options.host;
      const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
      const propagateFlags = options.propagate_flags;
      const credentials2 = options.credentials;
      const call = channel.createCall(path2, deadline, host, parent, propagateFlags);
      if (credentials2) {
        call.setCredentials(credentials2);
      }
      return call;
    }
    var BaseInterceptingCall = class {
      constructor(call, methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
      }
      cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
      }
      getPeer() {
        return this.call.getPeer();
      }
      setCredentials(credentials2) {
        this.call.setCredentials(credentials2);
      }
      sendMessageWithContext(context, message) {
        let serialized;
        try {
          serialized = this.methodDefinition.requestSerialize(message);
        } catch (e2) {
          this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e2.message}`);
          return;
        }
        this.call.sendMessageWithContext(context, serialized);
      }
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
          onReceiveMetadata: (metadata2) => {
            var _a;
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata2);
          },
          onReceiveMessage: (message) => {
            var _a;
            let deserialized;
            try {
              deserialized = this.methodDefinition.responseDeserialize(message);
            } catch (e2) {
              readError = {
                code: constants_1.Status.INTERNAL,
                details: `Response message parsing error: ${e2.message}`,
                metadata: new metadata_1.Metadata()
              };
              this.call.cancelWithStatus(readError.code, readError.details);
              return;
            }
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
          },
          onReceiveStatus: (status) => {
            var _a, _b;
            if (readError) {
              (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
            } else {
              (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
            }
          }
        });
      }
      startRead() {
        this.call.startRead();
      }
      halfClose() {
        this.call.halfClose();
      }
    };
    var BaseUnaryInterceptingCall = class extends BaseInterceptingCall {
      constructor(call, methodDefinition) {
        super(call, methodDefinition);
      }
      start(metadata, listener) {
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = {
          onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (message) => {
            var _a2;
            receivedMessage = true;
            (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, message);
          },
          onReceiveStatus: (status) => {
            var _a2, _b2;
            if (!receivedMessage) {
              (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, null);
            }
            (_b2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b2 === void 0 ? void 0 : _b2.call(listener, status);
          }
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
      }
    };
    var BaseStreamingInterceptingCall = class extends BaseInterceptingCall {
    };
    function getBottomInterceptingCall(channel, options, methodDefinition) {
      const call = getCall(channel, methodDefinition.path, options);
      if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
      } else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
      }
    }
    function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
      if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
      }
      let interceptors = [];
      if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      } else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      }
      const interceptorOptions = Object.assign({}, options, {
        method_definition: methodDefinition
      });
      const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
      }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
      return getCall2(interceptorOptions);
    }
    exports2.getInterceptingCall = getInterceptingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var call_1 = require_call();
    var channel_1 = require_channel();
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var client_interceptors_1 = require_client_interceptors();
    var CHANNEL_SYMBOL = Symbol();
    var INTERCEPTOR_SYMBOL = Symbol();
    var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
    var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
    function isFunction(arg) {
      return typeof arg === "function";
    }
    var Client = class {
      constructor(address, credentials2, options = {}) {
        var _a, _b;
        options = Object.assign({}, options);
        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
          throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) {
          this[CHANNEL_SYMBOL] = options.channelOverride;
        } else if (options.channelFactoryOverride) {
          const channelFactoryOverride = options.channelFactoryOverride;
          delete options.channelFactoryOverride;
          this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials2, options);
        } else {
          this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials2, options);
        }
      }
      close() {
        this[CHANNEL_SYMBOL].close();
      }
      getChannel() {
        return this[CHANNEL_SYMBOL];
      }
      waitForReady(deadline, callback) {
        const checkState = (err) => {
          if (err) {
            callback(new Error("Failed to connect before the deadline"));
            return;
          }
          let newState;
          try {
            newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          } catch (e2) {
            callback(new Error("The channel has been closed"));
            return;
          }
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            callback();
          } else {
            try {
              this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
            } catch (e2) {
              callback(new Error("The channel has been closed"));
            }
          }
        };
        setImmediate(checkState);
      }
      checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
          return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        } else if (isFunction(arg2)) {
          if (arg1 instanceof metadata_1.Metadata) {
            return { metadata: arg1, options: {}, callback: arg2 };
          } else {
            return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
          }
        } else {
          if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {
            throw new Error("Incorrect arguments passed");
          }
          return { metadata: arg1, options: arg2, callback: arg3 };
        }
      }
      makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientUnaryCallImpl(),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              callProperties.callback(null, responseMessage);
            } else {
              callProperties.callback(call_1.callErrorFromStatus(status));
            }
            emitter.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
      }
      makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientWritableStreamImpl(serialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              callProperties.callback(null, responseMessage);
            } else {
              callProperties.callback(call_1.callErrorFromStatus(status));
            }
            emitter.emit("status", status);
          }
        });
        return emitter;
      }
      checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
          metadata = arg1;
          if (arg2) {
            options = arg2;
          } else {
            options = {};
          }
        } else {
          if (arg1) {
            options = arg1;
          } else {
            options = {};
          }
          metadata = new metadata_1.Metadata();
        }
        return { metadata, options };
      }
      makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientReadableStreamImpl(deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              stream.emit("error", call_1.callErrorFromStatus(status));
            }
            stream.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
      }
      makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              stream.emit("error", call_1.callErrorFromStatus(status));
            }
            stream.emit("status", status);
          }
        });
        return stream;
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/make-client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadPackageDefinition = exports2.makeClientConstructor = void 0;
    var client_1 = require_client();
    var requesterFuncs = {
      unary: client_1.Client.prototype.makeUnaryRequest,
      server_stream: client_1.Client.prototype.makeServerStreamRequest,
      client_stream: client_1.Client.prototype.makeClientStreamRequest,
      bidi: client_1.Client.prototype.makeBidiStreamRequest
    };
    function isPrototypePolluted(key2) {
      return ["__proto__", "prototype", "constructor"].includes(key2);
    }
    function makeClientConstructor(methods, serviceName, classOptions) {
      if (!classOptions) {
        classOptions = {};
      }
      class ServiceClientImpl extends client_1.Client {
      }
      Object.keys(methods).forEach((name4) => {
        if (isPrototypePolluted(name4)) {
          return;
        }
        const attrs = methods[name4];
        let methodType;
        if (typeof name4 === "string" && name4.charAt(0) === "$") {
          throw new Error("Method names cannot start with $");
        }
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "client_stream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "server_stream";
          } else {
            methodType = "unary";
          }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name4] = methodFunc;
        Object.assign(ServiceClientImpl.prototype[name4], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
          ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name4];
        }
      });
      ServiceClientImpl.service = methods;
      ServiceClientImpl.serviceName = serviceName;
      return ServiceClientImpl;
    }
    exports2.makeClientConstructor = makeClientConstructor;
    function partial(fn, path2, serialize, deserialize) {
      return function(...args) {
        return fn.call(this, path2, serialize, deserialize, ...args);
      };
    }
    function isProtobufTypeDefinition(obj) {
      return "format" in obj;
    }
    function loadPackageDefinition2(packageDef) {
      const result = {};
      for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
          const service = packageDef[serviceFqn];
          const nameComponents = serviceFqn.split(".");
          if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
            continue;
          }
          const serviceName = nameComponents[nameComponents.length - 1];
          let current = result;
          for (const packageName of nameComponents.slice(0, -1)) {
            if (!current[packageName]) {
              current[packageName] = {};
            }
            current = current[packageName];
          }
          if (isProtobufTypeDefinition(service)) {
            current[serviceName] = service;
          } else {
            current[serviceName] = makeClientConstructor(service, serviceName, {});
          }
        }
      }
      return result;
    }
    exports2.loadPackageDefinition = loadPackageDefinition2;
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key2) {
        return object == null ? void 0 : object[key2];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve2, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve2.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base643 = exports2;
    base643.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i2 = 0; i2 < 64; )
      s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
    var i2;
    base643.encode = function encode2(buffer, start, end) {
      var parts = null, chunk = [];
      var i3 = 0, j = 0, t2;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i3++] = b64[b >> 2];
            t2 = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i3++] = b64[t2 | b >> 4];
            t2 = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i3++] = b64[t2 | b >> 6];
            chunk[i3++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i3 = 0;
        }
      }
      if (j) {
        chunk[i3++] = b64[t2];
        chunk[i3++] = 61;
        if (j === 1)
          chunk[i3++] = 61;
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i3));
    };
    var invalidEncoding = "invalid encoding";
    base643.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t2;
      for (var i3 = 0; i3 < string.length; ) {
        var c = string.charCodeAt(i3++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t2 = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t2 << 2 | (c & 48) >> 4;
            t2 = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t2 & 15) << 4 | (c & 60) >> 2;
            t2 = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t2 & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base643.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i2 = 0; i2 < listeners.length; )
            if (listeners[i2].fn === fn)
              listeners.splice(i2, 1);
            else
              ++i2;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i2 = 1;
        for (; i2 < arguments.length; )
          args.push(arguments[i2++]);
        for (i2 = 0; i2 < listeners.length; )
          listeners[i2].fn.apply(listeners[i2++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i2 = 0; i2 < string.length; ++i2) {
        c = string.charCodeAt(i2);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i2 + 1) & 64512) === 56320) {
          ++i2;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i2 = 0, t2;
      while (start < end) {
        t2 = buffer[start++];
        if (t2 < 128)
          chunk[i2++] = t2;
        else if (t2 > 191 && t2 < 224)
          chunk[i2++] = (t2 & 31) << 6 | buffer[start++] & 63;
        else if (t2 > 239 && t2 < 365) {
          t2 = ((t2 & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i2++] = 55296 + (t2 >> 10);
          chunk[i2++] = 56320 + (t2 & 1023);
        } else
          chunk[i2++] = (t2 & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i2 = 0; i2 < string.length; ++i2) {
        c1 = string.charCodeAt(i2);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i2 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i2;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e2) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src[keys[i2]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name4) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name4;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name4) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name4)
            delete this[fieldNames[i2]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base643 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop3() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop3, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i2 = 0; i2 < val.length; ++i2)
        buf[pos + i2] = val[i2];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base643.length(value));
        base643.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop3, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop3, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i2 = 0; i2 < val.length; )
            buf[pos++] = val[i2++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i2 = 0;
      if (this.len - this.pos > 4) {
        for (; i2 < 4; ++i2) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i2 = 0;
      } else {
        for (; i2 < 3; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i2 < 5; ++i2) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i2 < 5; ++i2) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch3;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch3(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch3, this, filename, options);
      if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch3.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch3.xhr(filename, options, callback);
    }
    fetch3.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i2 = 0; i2 < xhr.responseText.length; ++i2)
              buffer.push(xhr.responseText.charCodeAt(i2) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path2 = exports2;
    var isAbsolute = path2.isAbsolute = function isAbsolute2(path3) {
      return /^(?:\/|\w+:)/.test(path3);
    };
    var normalize2 = path2.normalize = function normalize3(path3) {
      path3 = path3.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var parts = path3.split("/"), absolute2 = isAbsolute(path3), prefix = "";
      if (absolute2)
        prefix = parts.shift() + "/";
      for (var i2 = 0; i2 < parts.length; ) {
        if (parts[i2] === "..") {
          if (i2 > 0 && parts[i2 - 1] !== "..")
            parts.splice(--i2, 2);
          else if (absolute2)
            parts.splice(i2, 1);
          else
            ++i2;
        } else if (parts[i2] === ".")
          parts.splice(i2, 1);
        else
          ++i2;
      }
      return prefix + parts.join("/");
    };
    path2.resolve = function resolve2(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize2(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize2(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize2(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types2 = exports2;
    var util = require_util();
    var s3 = [
      "double",
      "float",
      "int32",
      "uint32",
      "sint32",
      "fixed32",
      "sfixed32",
      "int64",
      "uint64",
      "sint64",
      "fixed64",
      "sfixed64",
      "bool",
      "string",
      "bytes"
    ];
    function bake(values, offset) {
      var i2 = 0, o = {};
      offset |= 0;
      while (i2 < values.length)
        o[s3[i2 + offset]] = values[i2++];
      return o;
    }
    types2.basic = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2,
      2
    ]);
    types2.defaults = bake([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      false,
      "",
      util.emptyArray,
      null
    ]);
    types2.long = bake([
      0,
      0,
      0,
      1,
      1
    ], 7);
    types2.mapKey = bake([
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2
    ], 2);
    types2.packed = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON2(name4, json) {
      return new Field(name4, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name4, id, type, rule, extend, options, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name4, options);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types2.long[type] !== void 0 : false;
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name4, value, ifNotSet) {
      if (name4 === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name4, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types2.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name4, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name4, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON2(name4, json) {
      return new OneOf(name4, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i2 = 0; i2 < oneof.fieldsArray.length; ++i2)
          if (!oneof.fieldsArray[i2].parent)
            oneof.parent.add(oneof.fieldsArray[i2]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i2 = 0; i2 < this.oneof.length; ++i2) {
        var field = parent.get(this.oneof[i2]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i2 = 0, field; i2 < this.fieldsArray.length; ++i2)
        if ((field = this.fieldsArray[i2]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON2(name4, json) {
      return new Namespace(name4, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i2 = 0; i2 < array.length; ++i2)
        obj[array[i2].name] = array[i2].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved2, id) {
      if (reserved2) {
        for (var i2 = 0; i2 < reserved2.length; ++i2)
          if (typeof reserved2[i2] !== "string" && reserved2[i2][0] <= id && reserved2[i2][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved2, name4) {
      if (reserved2) {
        for (var i2 = 0; i2 < reserved2.length; ++i2)
          if (reserved2[i2] === name4)
            return true;
      }
      return false;
    };
    function Namespace(name4, options) {
      ReflectionObject.call(this, name4, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i2 = 0, nested; i2 < names.length; ++i2) {
          nested = nestedJson[names[i2]];
          ns.add((nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i2], nested));
        }
      }
      return this;
    };
    Namespace.prototype.get = function get(name4) {
      return this.nested && this.nested[name4] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name4) {
      if (this.nested && this.nested[name4] instanceof Enum)
        return this.nested[name4].values;
      throw Error("no such enum: " + name4);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i2 = 0; i2 < nested.length; ++i2)
              object.add(nested[i2]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path2, json) {
      if (util.isString(path2))
        path2 = path2.split(".");
      else if (!Array.isArray(path2))
        throw TypeError("illegal path");
      if (path2 && path2.length && path2[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path2.length > 0) {
        var part = path2.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i2 = 0;
      while (i2 < nested.length)
        if (nested[i2] instanceof Namespace)
          nested[i2++].resolveAll();
        else
          nested[i2++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path2, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path2) && path2.length) {
        if (path2 === ".")
          return this.root;
        path2 = path2.split(".");
      } else if (!path2.length)
        return this;
      if (path2[0] === "")
        return this.root.lookup(path2.slice(1), filterTypes);
      var found = this.get(path2[0]);
      if (found) {
        if (path2.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path2.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i2 = 0; i2 < this.nestedArray.length; ++i2)
          if (this._nestedArray[i2] instanceof Namespace && (found = this._nestedArray[i2].lookup(path2, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path2, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path2) {
      var found = this.lookup(path2, [Type]);
      if (!found)
        throw Error("no such type: " + path2);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path2) {
      var found = this.lookup(path2, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path2) {
      var found = this.lookup(path2, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path2) {
      var found = this.lookup(path2, [Service]);
      if (!found)
        throw Error("no such Service '" + path2 + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types2 = require_types();
    var util = require_util();
    function MapField(name4, id, keyType, type, options, comment) {
      Field.call(this, name4, id, type, void 0, void 0, options, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON2(name4, json) {
      return new MapField(name4, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if (types2.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name4, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name4, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON2(name4, json) {
      return new Method(name4, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name4, options) {
      Namespace.call(this, name4, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON2(name4, json) {
      var service = new Service(name4, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i2 = 0; i2 < names.length; ++i2)
          service.add(Method.fromJSON(names[i2], json.methods[names[i2]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name4) {
      return this.methods[name4] || Namespace.prototype.get.call(this, name4);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i2 = 0; i2 < methods.length; ++i2)
        methods[i2].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i2 = 0, method; i2 < this.methodsArray.length; ++i2) {
        var methodName = util.lcFirst((method = this._methodsArray[i2]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i2 = 0; i2 < keys.length; ++i2)
          this[keys[i2]] = properties[keys[i2]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode2(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options) {
      return this.$type.toObject(message, options);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group)
        gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i2 = 0;
      for (; i2 < mtype.fieldsArray.length; ++i2) {
        var field = mtype._fieldsArray[i2].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i:", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types2.defaults[field.keyType] !== void 0)
            gen("k=%j", types2.defaults[field.keyType]);
          else
            gen("k=null");
          if (types2.defaults[type] !== void 0)
            gen("value=%j", types2.defaults[type]);
          else
            gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types2.basic[type] === void 0)
            gen("value=types[%i].decode(r,r.uint32())", i2);
          else
            gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types2.long[field.keyType] !== void 0)
            gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else
            gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types2.packed[type] !== void 0)
            gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types2.basic[type] === void 0)
            gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i2);
          else
            gen("%s.push(r.%s())", ref, type);
        } else if (types2.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i2);
        else
          gen("%s=r.%s()", ref, type);
        gen("break");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i2 = 0; i2 < mtype._fieldsArray.length; ++i2) {
        var rfield = mtype._fieldsArray[i2];
        if (rfield.required)
          gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
            gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length)
        gen("var p={}");
      for (var i2 = 0; i2 < mtype.fieldsArray.length; ++i2) {
        var field = mtype._fieldsArray[i2].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional)
          gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i2, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i2, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1)
              gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i2, ref);
        }
        if (field.optional)
          gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i2 = 0; i2 < keys.length; ++i2) {
            if (field.repeated && values[keys[i2]] === field.typeDefault)
              gen("default:");
            gen("case%j:", keys[i2])("case %i:", values[keys[i2]])("m%s=%j", prop, values[keys[i2]])("break");
          }
          gen("}");
        } else
          gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length)
        return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i2 = 0; i2 < fields.length; ++i2) {
        var field = fields[i2].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i2, prop + "[ks[i]]")("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i2, prop + "[i]")("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum))
            gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(gen, field, i2, prop);
          if (!(field.resolvedType instanceof Enum))
            gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else
          gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i2 = 0;
      for (; i2 < fields.length; ++i2)
        if (!fields[i2].partOf)
          (fields[i2].resolve().repeated ? repeatedFields : fields[i2].map ? mapFields : normalFields).push(fields[i2]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i2 = 0; i2 < repeatedFields.length; ++i2)
          gen("d%s=[]", util.safeProp(repeatedFields[i2].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i2 = 0; i2 < mapFields.length; ++i2)
          gen("d%s={}", util.safeProp(mapFields[i2].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i2 = 0; i2 < normalFields.length; ++i2) {
          var field = normalFields[i2], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum)
            gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long)
            gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else
            gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i2 = 0; i2 < fields.length; ++i2) {
        var field = fields[i2], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(gen, field, index, prop);
          if (field.partOf)
            gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name4 = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name4);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name4 = "";
        if (options && options.json && message.type_url && message.value) {
          name4 = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name4);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.substr(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name4 = prefix + messageName;
          object["@type"] = name4;
          return object;
        }
        return this.toObject(message, options);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer = require_writer();
    var util = require_util();
    var encoder2 = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name4, options) {
      Namespace.call(this, name4, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i2 = 0; i2 < names.length; ++i2) {
            var field = this.fields[names[i2]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i2 = 0;
          for (; i2 < this.fieldsArray.length; ++i2)
            this._fieldsArray[i2].resolve();
          var ctorProperties = {};
          for (i2 = 0; i2 < this.oneofsArray.length; ++i2)
            ctorProperties[this._oneofsArray[i2].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i2].oneof),
              set: util.oneOfSetter(this._oneofsArray[i2].oneof)
            };
          if (i2)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i2 = 0, field; i2 < mtype.fieldsArray.length; ++i2)
        if ((field = mtype._fieldsArray[i2]).map)
          gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated)
          gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON2(name4, json) {
      var type = new Type(name4, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i2 = 0;
      for (; i2 < names.length; ++i2)
        type.add((typeof json.fields[names[i2]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i2], json.fields[names[i2]]));
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i2 = 0; i2 < names.length; ++i2)
          type.add(OneOf.fromJSON(names[i2], json.oneofs[names[i2]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i2 = 0; i2 < names.length; ++i2) {
          var nested = json.nested[names[i2]];
          type.add((nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i2], nested));
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i2 = 0;
      while (i2 < fields.length)
        fields[i2++].resolve();
      var oneofs = this.oneofsArray;
      i2 = 0;
      while (i2 < oneofs.length)
        oneofs[i2++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name4) {
      return this.fields[name4] || this.oneofs && this.oneofs[name4] || this.nested && this.nested[name4] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name4) {
      return Namespace.isReservedName(this.reserved, name4);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types2 = [];
      for (var i2 = 0; i2 < this.fieldsArray.length; ++i2)
        types2.push(this._fieldsArray[i2].resolve().resolvedType);
      this.encode = encoder2(this)({
        Writer,
        types: types2,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types: types2,
        util
      });
      this.verify = verifier(this)({
        types: types2,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types: types2,
        util
      });
      this.toObject = converter.toObject(this)({
        types: types2,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options) {
      return this.setup().toObject(message, options);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root2;
    var Namespace = require_namespace();
    ((Root2.prototype = Object.create(Namespace.prototype)).constructor = Root2).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse3;
    var common;
    function Root2(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    Root2.fromJSON = function fromJSON2(json, root) {
      if (!root)
        root = new Root2();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root2.prototype.resolvePath = util.path.resolve;
    Root2.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root2.prototype.load = function load2(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load2, self2, filename, options);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common)
            return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse3.filename = filename2;
            var parsed = parse3(source, self2, options), resolved2, i3 = 0;
            if (parsed.imports) {
              for (; i3 < parsed.imports.length; ++i3)
                if (resolved2 = getBundledFileName(parsed.imports[i3]) || self2.resolvePath(filename2, parsed.imports[i3]))
                  fetch3(resolved2);
            }
            if (parsed.weakImports) {
              for (i3 = 0; i3 < parsed.weakImports.length; ++i3)
                if (resolved2 = getBundledFileName(parsed.weakImports[i3]) || self2.resolvePath(filename2, parsed.weakImports[i3]))
                  fetch3(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch3(filename2, weak) {
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i2 = 0, resolved; i2 < filename.length; ++i2)
        if (resolved = self2.resolvePath("", filename[i2]))
          fetch3(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root2.prototype.loadSync = function loadSync(filename, options) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC);
    };
    Root2.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root2.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0 && !object.extensionField) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i2 = 0; i2 < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i2]))
              this.deferred.splice(i2, 1);
            else
              ++i2;
        for (var j = 0; j < object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root2.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0) {
          if (object.extensionField) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i2 = 0; i2 < object.nestedArray.length; ++i2)
          this._handleRemove(object._nestedArray[i2]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root2._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse3 = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key2 = array[index++], val = array[index++];
        if (val !== void 0)
          object[key2] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name4) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name4);
    };
    util.safeProp = function safeProp2(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path2, value) {
      function setProp(dst2, path3, value2) {
        var part = path3.shift();
        if (path3.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path3, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path2)
        throw TypeError("path must be specified");
      path2 = path2.split(".");
      return setProp(dst, path2, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root2;
    function ReflectionObject(name4, options) {
      if (!util.isString(name4))
        throw TypeError("name must be a string");
      if (options && !util.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name4;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      fullName: {
        get: function() {
          var path2 = [this.name], ptr = this.parent;
          while (ptr) {
            path2.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path2.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root2)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root2)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root2)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name4) {
      if (this.options)
        return this.options[name4];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name4, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name4] === void 0)
        (this.options || (this.options = {}))[name4] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name4, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name4);
        });
        if (opt) {
          var newValue = opt[name4];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name4] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name4] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i2 = 0; i2 < keys.length; ++i2)
          this.setOption(keys[i2], options[keys[i2]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root2 = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util();
    function Enum(name4, values, options, comment, comments) {
      ReflectionObject.call(this, name4, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i2 = 0; i2 < keys.length; ++i2)
          if (typeof values[keys[i2]] === "number")
            this.valuesById[this.values[keys[i2]] = values[keys[i2]]] = keys[i2];
      }
    }
    Enum.fromJSON = function fromJSON2(name4, json) {
      var enm = new Enum(name4, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name4, id, comment) {
      if (!util.isString(name4))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name4] !== void 0)
        throw Error("duplicate name '" + name4 + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name4))
        throw Error("name '" + name4 + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name4] = id;
      } else
        this.valuesById[this.values[name4] = id] = name4;
      this.comments[name4] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name4) {
      if (!util.isString(name4))
        throw TypeError("name must be a string");
      var val = this.values[name4];
      if (val == null)
        throw Error("name '" + name4 + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name4];
      delete this.comments[name4];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name4) {
      return Namespace.isReservedName(this.reserved, name4);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder2;
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder2(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i2, ref;
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      for (var i2 = 0; i2 < fields.length; ++i2) {
        var field = fields[i2].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types2.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types2.mapKey[field.keyType], field.keyType);
          if (wireType === void 0)
            gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else
            gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types2.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else
              gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional)
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else
            gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load2(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load2;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, commentType = null, commentText = null, commentLine = 0, commentLineEmpty = false, commentIsLeading = false;
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            commentLineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i2 = 0; i2 < lines.length; ++i2)
          lines[i2] = lines[i2].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        commentText = lines.join("\n").trim();
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === void 0) {
          if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
            ret = commentIsLeading ? commentText : null;
          }
        } else {
          if (commentLine < trailingLine) {
            peek();
          }
          if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
            ret = commentIsLeading ? null : commentText;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse3;
    parse3.filename = null;
    parse3.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root2 = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types2 = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse3(source, root, options) {
      if (!(root instanceof Root2)) {
        options = root;
        root = new Root2();
      }
      if (!options)
        options = parse3.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options.keepCase ? function(name4) {
        return name4;
      } : util.camelCase;
      function illegal(token2, name4, insideTryCatch) {
        var filename = parse3.filename;
        if (!insideTryCatch)
          parse3.filename = null;
        return Error("illegal " + (name4 || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(token2, true);
        } catch (e2) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
        } while (skip(",", true));
        skip(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse3.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name4 = next();
        if (!nameRe.test(name4))
          throw illegal(name4, "name");
        name4 = applyCase(name4);
        skip("=");
        var field = new Field(name4, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name4);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types2.packed[type] !== void 0 || types2.basic[type] === void 0))
          field.setOption("packed", false, true);
      }
      function parseGroup(parent, rule) {
        var name4 = next();
        if (!nameRe.test(name4))
          throw illegal(name4, "name");
        var fieldName = util.lcFirst(name4);
        if (name4 === fieldName)
          name4 = util.ucFirst(name4);
        skip("=");
        var id = parseId(next());
        var type = new Type(name4);
        type.group = true;
        var field = new Field(fieldName, id, name4, rule);
        field.filename = parse3.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types2.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name4 = next();
        if (!nameRe.test(name4))
          throw illegal(name4, "name");
        skip("=");
        var field = new MapField(applyCase(name4), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment);
      }
      function parseOption(parent, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name4 = token2;
        var option = name4;
        var propName;
        if (isCustom) {
          skip(")");
          name4 = "(" + name4 + ")";
          option = name4;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.substr(1);
            name4 += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name4);
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name4) {
        if (skip("{", true)) {
          var result = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next()))
              throw illegal(token, "name");
            var value;
            var propName = token;
            if (peek() === "{")
              value = parseOptionValue(parent, name4 + "." + token);
            else {
              skip(":");
              if (peek() === "{")
                value = parseOptionValue(parent, name4 + "." + token);
              else {
                value = readValue(true);
                setOption(parent, name4 + "." + token, value);
              }
            }
            var prevValue = result[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            result[propName] = value;
            skip(",", true);
          }
          return result;
        }
        var simpleValue = readValue(true);
        setOption(parent, name4, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name4, value) {
        if (parent.setOption)
          parent.setOption(name4, value);
      }
      function setParsedOption(parent, name4, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name4, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name4 = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name4, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse3.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name4, json) {
      if (!commonRe.test(name4)) {
        name4 = "google/protobuf/" + name4 + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name4] = json;
    }
    common("any", {
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      Timestamp: timeType
    });
    common("empty", {
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src2();
  }
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS({
  "node_modules/protobufjs/google/protobuf/descriptor.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                FileDescriptorSet: {
                  fields: {
                    file: {
                      rule: "repeated",
                      type: "FileDescriptorProto",
                      id: 1
                    }
                  }
                },
                FileDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    package: {
                      type: "string",
                      id: 2
                    },
                    dependency: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    publicDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 10,
                      options: {
                        packed: false
                      }
                    },
                    weakDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 11,
                      options: {
                        packed: false
                      }
                    },
                    messageType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 4
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 5
                    },
                    service: {
                      rule: "repeated",
                      type: "ServiceDescriptorProto",
                      id: 6
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 7
                    },
                    options: {
                      type: "FileOptions",
                      id: 8
                    },
                    sourceCodeInfo: {
                      type: "SourceCodeInfo",
                      id: 9
                    },
                    syntax: {
                      type: "string",
                      id: 12
                    }
                  }
                },
                DescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    field: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 2
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 6
                    },
                    nestedType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 3
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 4
                    },
                    extensionRange: {
                      rule: "repeated",
                      type: "ExtensionRange",
                      id: 5
                    },
                    oneofDecl: {
                      rule: "repeated",
                      type: "OneofDescriptorProto",
                      id: 8
                    },
                    options: {
                      type: "MessageOptions",
                      id: 7
                    },
                    reservedRange: {
                      rule: "repeated",
                      type: "ReservedRange",
                      id: 9
                    },
                    reservedName: {
                      rule: "repeated",
                      type: "string",
                      id: 10
                    }
                  },
                  nested: {
                    ExtensionRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    },
                    ReservedRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    }
                  }
                },
                FieldDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    label: {
                      type: "Label",
                      id: 4
                    },
                    type: {
                      type: "Type",
                      id: 5
                    },
                    typeName: {
                      type: "string",
                      id: 6
                    },
                    extendee: {
                      type: "string",
                      id: 2
                    },
                    defaultValue: {
                      type: "string",
                      id: 7
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    options: {
                      type: "FieldOptions",
                      id: 8
                    }
                  },
                  nested: {
                    Type: {
                      values: {
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Label: {
                      values: {
                        LABEL_OPTIONAL: 1,
                        LABEL_REQUIRED: 2,
                        LABEL_REPEATED: 3
                      }
                    }
                  }
                },
                OneofDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    options: {
                      type: "OneofOptions",
                      id: 2
                    }
                  }
                },
                EnumDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      rule: "repeated",
                      type: "EnumValueDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "EnumOptions",
                      id: 3
                    }
                  }
                },
                EnumValueDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      type: "EnumValueOptions",
                      id: 3
                    }
                  }
                },
                ServiceDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    method: {
                      rule: "repeated",
                      type: "MethodDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "ServiceOptions",
                      id: 3
                    }
                  }
                },
                MethodDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    inputType: {
                      type: "string",
                      id: 2
                    },
                    outputType: {
                      type: "string",
                      id: 3
                    },
                    options: {
                      type: "MethodOptions",
                      id: 4
                    },
                    clientStreaming: {
                      type: "bool",
                      id: 5
                    },
                    serverStreaming: {
                      type: "bool",
                      id: 6
                    }
                  }
                },
                FileOptions: {
                  fields: {
                    javaPackage: {
                      type: "string",
                      id: 1
                    },
                    javaOuterClassname: {
                      type: "string",
                      id: 8
                    },
                    javaMultipleFiles: {
                      type: "bool",
                      id: 10
                    },
                    javaGenerateEqualsAndHash: {
                      type: "bool",
                      id: 20,
                      options: {
                        deprecated: true
                      }
                    },
                    javaStringCheckUtf8: {
                      type: "bool",
                      id: 27
                    },
                    optimizeFor: {
                      type: "OptimizeMode",
                      id: 9,
                      options: {
                        default: "SPEED"
                      }
                    },
                    goPackage: {
                      type: "string",
                      id: 11
                    },
                    ccGenericServices: {
                      type: "bool",
                      id: 16
                    },
                    javaGenericServices: {
                      type: "bool",
                      id: 17
                    },
                    pyGenericServices: {
                      type: "bool",
                      id: 18
                    },
                    deprecated: {
                      type: "bool",
                      id: 23
                    },
                    ccEnableArenas: {
                      type: "bool",
                      id: 31
                    },
                    objcClassPrefix: {
                      type: "string",
                      id: 36
                    },
                    csharpNamespace: {
                      type: "string",
                      id: 37
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      38,
                      38
                    ]
                  ],
                  nested: {
                    OptimizeMode: {
                      values: {
                        SPEED: 1,
                        CODE_SIZE: 2,
                        LITE_RUNTIME: 3
                      }
                    }
                  }
                },
                MessageOptions: {
                  fields: {
                    messageSetWireFormat: {
                      type: "bool",
                      id: 1
                    },
                    noStandardDescriptorAccessor: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    mapEntry: {
                      type: "bool",
                      id: 7
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      8,
                      8
                    ]
                  ]
                },
                FieldOptions: {
                  fields: {
                    ctype: {
                      type: "CType",
                      id: 1,
                      options: {
                        default: "STRING"
                      }
                    },
                    packed: {
                      type: "bool",
                      id: 2
                    },
                    jstype: {
                      type: "JSType",
                      id: 6,
                      options: {
                        default: "JS_NORMAL"
                      }
                    },
                    lazy: {
                      type: "bool",
                      id: 5
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    weak: {
                      type: "bool",
                      id: 10
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      4,
                      4
                    ]
                  ],
                  nested: {
                    CType: {
                      values: {
                        STRING: 0,
                        CORD: 1,
                        STRING_PIECE: 2
                      }
                    },
                    JSType: {
                      values: {
                        JS_NORMAL: 0,
                        JS_STRING: 1,
                        JS_NUMBER: 2
                      }
                    }
                  }
                },
                OneofOptions: {
                  fields: {
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumOptions: {
                  fields: {
                    allowAlias: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumValueOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 1
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                ServiceOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                MethodOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                UninterpretedOption: {
                  fields: {
                    name: {
                      rule: "repeated",
                      type: "NamePart",
                      id: 2
                    },
                    identifierValue: {
                      type: "string",
                      id: 3
                    },
                    positiveIntValue: {
                      type: "uint64",
                      id: 4
                    },
                    negativeIntValue: {
                      type: "int64",
                      id: 5
                    },
                    doubleValue: {
                      type: "double",
                      id: 6
                    },
                    stringValue: {
                      type: "bytes",
                      id: 7
                    },
                    aggregateValue: {
                      type: "string",
                      id: 8
                    }
                  },
                  nested: {
                    NamePart: {
                      fields: {
                        namePart: {
                          rule: "required",
                          type: "string",
                          id: 1
                        },
                        isExtension: {
                          rule: "required",
                          type: "bool",
                          id: 2
                        }
                      }
                    }
                  }
                },
                SourceCodeInfo: {
                  fields: {
                    location: {
                      rule: "repeated",
                      type: "Location",
                      id: 1
                    }
                  },
                  nested: {
                    Location: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        span: {
                          rule: "repeated",
                          type: "int32",
                          id: 2
                        },
                        leadingComments: {
                          type: "string",
                          id: 3
                        },
                        trailingComments: {
                          type: "string",
                          id: 4
                        },
                        leadingDetachedComments: {
                          rule: "repeated",
                          type: "string",
                          id: 6
                        }
                      }
                    }
                  }
                },
                GeneratedCodeInfo: {
                  fields: {
                    annotation: {
                      rule: "repeated",
                      type: "Annotation",
                      id: 1
                    }
                  },
                  nested: {
                    Annotation: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        sourceFile: {
                          type: "string",
                          id: 2
                        },
                        begin: {
                          type: "int32",
                          id: 3
                        },
                        end: {
                          type: "int32",
                          id: 4
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS({
  "node_modules/protobufjs/ext/descriptor/index.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_protobufjs();
    module2.exports = exports2 = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
    var Namespace = $protobuf.Namespace;
    var Root2 = $protobuf.Root;
    var Enum = $protobuf.Enum;
    var Type = $protobuf.Type;
    var Field = $protobuf.Field;
    var MapField = $protobuf.MapField;
    var OneOf = $protobuf.OneOf;
    var Service = $protobuf.Service;
    var Method = $protobuf.Method;
    Root2.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.FileDescriptorSet.decode(descriptor);
      var root = new Root2();
      if (descriptor.file) {
        var fileDescriptor, filePackage;
        for (var j = 0, i2; j < descriptor.file.length; ++j) {
          filePackage = root;
          if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
            filePackage = root.define(fileDescriptor["package"]);
          if (fileDescriptor.name && fileDescriptor.name.length)
            root.files.push(filePackage.filename = fileDescriptor.name);
          if (fileDescriptor.messageType)
            for (i2 = 0; i2 < fileDescriptor.messageType.length; ++i2)
              filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i2], fileDescriptor.syntax));
          if (fileDescriptor.enumType)
            for (i2 = 0; i2 < fileDescriptor.enumType.length; ++i2)
              filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i2]));
          if (fileDescriptor.extension)
            for (i2 = 0; i2 < fileDescriptor.extension.length; ++i2)
              filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i2]));
          if (fileDescriptor.service)
            for (i2 = 0; i2 < fileDescriptor.service.length; ++i2)
              filePackage.add(Service.fromDescriptor(fileDescriptor.service[i2]));
          var opts = fromDescriptorOptions(fileDescriptor.options, exports2.FileOptions);
          if (opts) {
            var ks = Object.keys(opts);
            for (i2 = 0; i2 < ks.length; ++i2)
              filePackage.setOption(ks[i2], opts[ks[i2]]);
          }
        }
      }
      return root;
    };
    Root2.prototype.toDescriptor = function toDescriptor(syntax) {
      var set = exports2.FileDescriptorSet.create();
      Root_toDescriptorRecursive(this, set.file, syntax);
      return set;
    };
    function Root_toDescriptorRecursive(ns, files, syntax) {
      var file = exports2.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
      if (syntax)
        file.syntax = syntax;
      if (!(ns instanceof Root2))
        file["package"] = ns.fullName.substring(1);
      for (var i2 = 0, nested; i2 < ns.nestedArray.length; ++i2)
        if ((nested = ns._nestedArray[i2]) instanceof Type)
          file.messageType.push(nested.toDescriptor(syntax));
        else if (nested instanceof Enum)
          file.enumType.push(nested.toDescriptor());
        else if (nested instanceof Field)
          file.extension.push(nested.toDescriptor(syntax));
        else if (nested instanceof Service)
          file.service.push(nested.toDescriptor());
        else if (nested instanceof Namespace)
          Root_toDescriptorRecursive(nested, files, syntax);
      file.options = toDescriptorOptions(ns.options, exports2.FileOptions);
      if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
        files.push(file);
    }
    var unnamedMessageIndex = 0;
    Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports2.MessageOptions)), i2;
      if (descriptor.oneofDecl)
        for (i2 = 0; i2 < descriptor.oneofDecl.length; ++i2)
          type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i2]));
      if (descriptor.field)
        for (i2 = 0; i2 < descriptor.field.length; ++i2) {
          var field = Field.fromDescriptor(descriptor.field[i2], syntax);
          type.add(field);
          if (descriptor.field[i2].hasOwnProperty("oneofIndex"))
            type.oneofsArray[descriptor.field[i2].oneofIndex].add(field);
        }
      if (descriptor.extension)
        for (i2 = 0; i2 < descriptor.extension.length; ++i2)
          type.add(Field.fromDescriptor(descriptor.extension[i2], syntax));
      if (descriptor.nestedType)
        for (i2 = 0; i2 < descriptor.nestedType.length; ++i2) {
          type.add(Type.fromDescriptor(descriptor.nestedType[i2], syntax));
          if (descriptor.nestedType[i2].options && descriptor.nestedType[i2].options.mapEntry)
            type.setOption("map_entry", true);
        }
      if (descriptor.enumType)
        for (i2 = 0; i2 < descriptor.enumType.length; ++i2)
          type.add(Enum.fromDescriptor(descriptor.enumType[i2]));
      if (descriptor.extensionRange && descriptor.extensionRange.length) {
        type.extensions = [];
        for (i2 = 0; i2 < descriptor.extensionRange.length; ++i2)
          type.extensions.push([descriptor.extensionRange[i2].start, descriptor.extensionRange[i2].end]);
      }
      if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
        type.reserved = [];
        if (descriptor.reservedRange)
          for (i2 = 0; i2 < descriptor.reservedRange.length; ++i2)
            type.reserved.push([descriptor.reservedRange[i2].start, descriptor.reservedRange[i2].end]);
        if (descriptor.reservedName)
          for (i2 = 0; i2 < descriptor.reservedName.length; ++i2)
            type.reserved.push(descriptor.reservedName[i2]);
      }
      return type;
    };
    Type.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.DescriptorProto.create({ name: this.name }), i2;
      for (i2 = 0; i2 < this.fieldsArray.length; ++i2) {
        var fieldDescriptor;
        descriptor.field.push(fieldDescriptor = this._fieldsArray[i2].toDescriptor(syntax));
        if (this._fieldsArray[i2] instanceof MapField) {
          var keyType = toDescriptorType(this._fieldsArray[i2].keyType, this._fieldsArray[i2].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i2].type, this._fieldsArray[i2].resolvedType), valueTypeName = valueType === 11 || valueType === 14 ? this._fieldsArray[i2].resolvedType && shortname(this.parent, this._fieldsArray[i2].resolvedType) || this._fieldsArray[i2].type : void 0;
          descriptor.nestedType.push(exports2.DescriptorProto.create({
            name: fieldDescriptor.typeName,
            field: [
              exports2.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }),
              exports2.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
            ],
            options: exports2.MessageOptions.create({ mapEntry: true })
          }));
        }
      }
      for (i2 = 0; i2 < this.oneofsArray.length; ++i2)
        descriptor.oneofDecl.push(this._oneofsArray[i2].toDescriptor());
      for (i2 = 0; i2 < this.nestedArray.length; ++i2) {
        if (this._nestedArray[i2] instanceof Field)
          descriptor.field.push(this._nestedArray[i2].toDescriptor(syntax));
        else if (this._nestedArray[i2] instanceof Type)
          descriptor.nestedType.push(this._nestedArray[i2].toDescriptor(syntax));
        else if (this._nestedArray[i2] instanceof Enum)
          descriptor.enumType.push(this._nestedArray[i2].toDescriptor());
      }
      if (this.extensions)
        for (i2 = 0; i2 < this.extensions.length; ++i2)
          descriptor.extensionRange.push(exports2.DescriptorProto.ExtensionRange.create({ start: this.extensions[i2][0], end: this.extensions[i2][1] }));
      if (this.reserved)
        for (i2 = 0; i2 < this.reserved.length; ++i2)
          if (typeof this.reserved[i2] === "string")
            descriptor.reservedName.push(this.reserved[i2]);
          else
            descriptor.reservedRange.push(exports2.DescriptorProto.ReservedRange.create({ start: this.reserved[i2][0], end: this.reserved[i2][1] }));
      descriptor.options = toDescriptorOptions(this.options, exports2.MessageOptions);
      return descriptor;
    };
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      if (typeof descriptor.number !== "number")
        throw Error("missing field id");
      var fieldType;
      if (descriptor.typeName && descriptor.typeName.length)
        fieldType = descriptor.typeName;
      else
        fieldType = fromDescriptorType(descriptor.type);
      var fieldRule;
      switch (descriptor.label) {
        case 1:
          fieldRule = void 0;
          break;
        case 2:
          fieldRule = "required";
          break;
        case 3:
          fieldRule = "repeated";
          break;
        default:
          throw Error("illegal label: " + descriptor.label);
      }
      var extendee = descriptor.extendee;
      if (descriptor.extendee !== void 0) {
        extendee = extendee.length ? extendee : void 0;
      }
      var field = new Field(descriptor.name.length ? descriptor.name : "field" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);
      field.options = fromDescriptorOptions(descriptor.options, exports2.FieldOptions);
      if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
          case "true":
          case "TRUE":
            defaultValue = true;
            break;
          case "false":
          case "FALSE":
            defaultValue = false;
            break;
          default:
            var match = numberRe.exec(defaultValue);
            if (match)
              defaultValue = parseInt(defaultValue);
            break;
        }
        field.setOption("default", defaultValue);
      }
      if (packableDescriptorType(descriptor.type)) {
        if (syntax === "proto3") {
          if (descriptor.options && !descriptor.options.packed)
            field.setOption("packed", false);
        } else if (!(descriptor.options && descriptor.options.packed))
          field.setOption("packed", false);
      }
      return field;
    };
    Field.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.FieldDescriptorProto.create({ name: this.name, number: this.id });
      if (this.map) {
        descriptor.type = 11;
        descriptor.typeName = $protobuf.util.ucFirst(this.name);
        descriptor.label = 3;
      } else {
        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
          case 10:
          case 11:
          case 14:
            descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
            break;
        }
        switch (this.rule) {
          case "repeated":
            descriptor.label = 3;
            break;
          case "required":
            descriptor.label = 2;
            break;
          default:
            descriptor.label = 1;
            break;
        }
      }
      descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
      if (this.partOf) {
        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
          throw Error("missing oneof");
      }
      if (this.options) {
        descriptor.options = toDescriptorOptions(this.options, exports2.FieldOptions);
        if (this.options["default"] != null)
          descriptor.defaultValue = String(this.options["default"]);
      }
      if (syntax === "proto3") {
        if (!this.packed)
          (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = false;
      } else if (this.packed)
        (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = true;
      return descriptor;
    };
    var unnamedEnumIndex = 0;
    Enum.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.EnumDescriptorProto.decode(descriptor);
      var values = {};
      if (descriptor.value)
        for (var i2 = 0; i2 < descriptor.value.length; ++i2) {
          var name4 = descriptor.value[i2].name, value = descriptor.value[i2].number || 0;
          values[name4 && name4.length ? name4 : "NAME" + value] = value;
        }
      return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports2.EnumOptions));
    };
    Enum.prototype.toDescriptor = function toDescriptor() {
      var values = [];
      for (var i2 = 0, ks = Object.keys(this.values); i2 < ks.length; ++i2)
        values.push(exports2.EnumValueDescriptorProto.create({ name: ks[i2], number: this.values[ks[i2]] }));
      return exports2.EnumDescriptorProto.create({
        name: this.name,
        value: values,
        options: toDescriptorOptions(this.options, exports2.EnumOptions)
      });
    };
    var unnamedOneofIndex = 0;
    OneOf.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.OneofDescriptorProto.decode(descriptor);
      return new OneOf(descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++);
    };
    OneOf.prototype.toDescriptor = function toDescriptor() {
      return exports2.OneofDescriptorProto.create({
        name: this.name
      });
    };
    var unnamedServiceIndex = 0;
    Service.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.ServiceDescriptorProto.decode(descriptor);
      var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports2.ServiceOptions));
      if (descriptor.method)
        for (var i2 = 0; i2 < descriptor.method.length; ++i2)
          service.add(Method.fromDescriptor(descriptor.method[i2]));
      return service;
    };
    Service.prototype.toDescriptor = function toDescriptor() {
      var methods = [];
      for (var i2 = 0; i2 < this.methodsArray.length; ++i2)
        methods.push(this._methodsArray[i2].toDescriptor());
      return exports2.ServiceDescriptorProto.create({
        name: this.name,
        method: methods,
        options: toDescriptorOptions(this.options, exports2.ServiceOptions)
      });
    };
    var unnamedMethodIndex = 0;
    Method.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.MethodDescriptorProto.decode(descriptor);
      return new Method(descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++, "rpc", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports2.MethodOptions));
    };
    Method.prototype.toDescriptor = function toDescriptor() {
      return exports2.MethodDescriptorProto.create({
        name: this.name,
        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
        clientStreaming: this.requestStream,
        serverStreaming: this.responseStream,
        options: toDescriptorOptions(this.options, exports2.MethodOptions)
      });
    };
    function fromDescriptorType(type) {
      switch (type) {
        case 1:
          return "double";
        case 2:
          return "float";
        case 3:
          return "int64";
        case 4:
          return "uint64";
        case 5:
          return "int32";
        case 6:
          return "fixed64";
        case 7:
          return "fixed32";
        case 8:
          return "bool";
        case 9:
          return "string";
        case 12:
          return "bytes";
        case 13:
          return "uint32";
        case 15:
          return "sfixed32";
        case 16:
          return "sfixed64";
        case 17:
          return "sint32";
        case 18:
          return "sint64";
      }
      throw Error("illegal type: " + type);
    }
    function packableDescriptorType(type) {
      switch (type) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
          return true;
      }
      return false;
    }
    function toDescriptorType(type, resolvedType) {
      switch (type) {
        case "double":
          return 1;
        case "float":
          return 2;
        case "int64":
          return 3;
        case "uint64":
          return 4;
        case "int32":
          return 5;
        case "fixed64":
          return 6;
        case "fixed32":
          return 7;
        case "bool":
          return 8;
        case "string":
          return 9;
        case "bytes":
          return 12;
        case "uint32":
          return 13;
        case "sfixed32":
          return 15;
        case "sfixed64":
          return 16;
        case "sint32":
          return 17;
        case "sint64":
          return 18;
      }
      if (resolvedType instanceof Enum)
        return 14;
      if (resolvedType instanceof Type)
        return resolvedType.group ? 10 : 11;
      throw Error("illegal type: " + type);
    }
    function fromDescriptorOptions(options, type) {
      if (!options)
        return void 0;
      var out = [];
      for (var i2 = 0, field, key2, val; i2 < type.fieldsArray.length; ++i2)
        if ((key2 = (field = type._fieldsArray[i2]).name) !== "uninterpretedOption") {
          if (options.hasOwnProperty(key2)) {
            val = options[key2];
            if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== void 0)
              val = field.resolvedType.valuesById[val];
            out.push(underScore(key2), val);
          }
        }
      return out.length ? $protobuf.util.toObject(out) : void 0;
    }
    function toDescriptorOptions(options, type) {
      if (!options)
        return void 0;
      var out = [];
      for (var i2 = 0, ks = Object.keys(options), key2, val; i2 < ks.length; ++i2) {
        val = options[key2 = ks[i2]];
        if (key2 === "default")
          continue;
        var field = type.fields[key2];
        if (!field && !(field = type.fields[key2 = $protobuf.util.camelCase(key2)]))
          continue;
        out.push(key2, val);
      }
      return out.length ? type.fromObject($protobuf.util.toObject(out)) : void 0;
    }
    function shortname(from, to) {
      var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i2 = 0, j = 0, k = toPath.length - 1;
      if (!(from instanceof Root2) && to instanceof Namespace)
        while (i2 < fromPath.length && j < k && fromPath[i2] === toPath[j]) {
          var other = to.lookup(fromPath[i2++], true);
          if (other !== null && other !== to)
            break;
          ++j;
        }
      else
        for (; i2 < fromPath.length && j < k && fromPath[i2] === toPath[j]; ++i2, ++j)
          ;
      return toPath.slice(j).join(".");
    }
    function underScore(str) {
      return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
        return "_" + $1.toLowerCase();
      });
    }
  }
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api = __commonJS({
  "node_modules/protobufjs/google/protobuf/api.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Api: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    methods: {
                      rule: "repeated",
                      type: "Method",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    version: {
                      type: "string",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    mixins: {
                      rule: "repeated",
                      type: "Mixin",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Method: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    requestTypeUrl: {
                      type: "string",
                      id: 2
                    },
                    requestStreaming: {
                      type: "bool",
                      id: 3
                    },
                    responseTypeUrl: {
                      type: "string",
                      id: 4
                    },
                    responseStreaming: {
                      type: "bool",
                      id: 5
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Mixin: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    root: {
                      type: "string",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS({
  "node_modules/protobufjs/google/protobuf/source_context.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type2 = __commonJS({
  "node_modules/protobufjs/google/protobuf/type.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Type: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    fields: {
                      rule: "repeated",
                      type: "Field",
                      id: 2
                    },
                    oneofs: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    syntax: {
                      type: "Syntax",
                      id: 6
                    }
                  }
                },
                Field: {
                  fields: {
                    kind: {
                      type: "Kind",
                      id: 1
                    },
                    cardinality: {
                      type: "Cardinality",
                      id: 2
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    name: {
                      type: "string",
                      id: 4
                    },
                    typeUrl: {
                      type: "string",
                      id: 6
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 7
                    },
                    packed: {
                      type: "bool",
                      id: 8
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    defaultValue: {
                      type: "string",
                      id: 11
                    }
                  },
                  nested: {
                    Kind: {
                      values: {
                        TYPE_UNKNOWN: 0,
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Cardinality: {
                      values: {
                        CARDINALITY_UNKNOWN: 0,
                        CARDINALITY_OPTIONAL: 1,
                        CARDINALITY_REQUIRED: 2,
                        CARDINALITY_REPEATED: 3
                      }
                    }
                  }
                },
                Enum: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    enumvalue: {
                      rule: "repeated",
                      type: "EnumValue",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 4
                    },
                    syntax: {
                      type: "Syntax",
                      id: 5
                    }
                  }
                },
                EnumValue: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                },
                Any: {
                  fields: {
                    type_url: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "bytes",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util2 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require("fs");
    var path2 = require("path");
    var Protobuf = require_protobufjs();
    function addIncludePathResolver(root, includePaths) {
      const originalResolvePath = root.resolvePath;
      root.resolvePath = (origin, target) => {
        if (path2.isAbsolute(target)) {
          return target;
        }
        for (const directory of includePaths) {
          const fullPath = path2.join(directory, target);
          try {
            fs.accessSync(fullPath, fs.constants.R_OK);
            return fullPath;
          } catch (err) {
            continue;
          }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
      };
    }
    async function loadProtosWithOptions(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          return Promise.reject(new Error("The includeDirs option must be an array"));
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = await root.load(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptions = loadProtosWithOptions;
    function loadProtosWithOptionsSync(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          throw new Error("The includeDirs option must be an array");
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = root.loadSync(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
    function addCommonProtos() {
      const apiDescriptor = require_api();
      const descriptorDescriptor = require_descriptor();
      const sourceContextDescriptor = require_source_context();
      const typeDescriptor = require_type2();
      Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
    }
    exports2.addCommonProtos = addCommonProtos;
  }
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var camelCase = require_lodash();
    var Protobuf = require_protobufjs();
    var descriptor = require_descriptor2();
    var util_1 = require_util2();
    function isAnyExtension(obj) {
      return "@type" in obj && typeof obj["@type"] === "string";
    }
    exports2.isAnyExtension = isAnyExtension;
    var descriptorOptions = {
      longs: String,
      enums: String,
      bytes: String,
      defaults: true,
      oneofs: true,
      json: true
    };
    function joinName(baseName, name4) {
      if (baseName === "") {
        return name4;
      } else {
        return baseName + "." + name4;
      }
    }
    function isHandledReflectionObject(obj) {
      return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
    }
    function isNamespaceBase(obj) {
      return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
    }
    function getAllHandledReflectionObjects(obj, parentName) {
      const objName = joinName(parentName, obj.name);
      if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
      } else {
        if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
          return Object.keys(obj.nested).map((name4) => {
            return getAllHandledReflectionObjects(obj.nested[name4], objName);
          }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
      }
      return [];
    }
    function createDeserializer(cls, options) {
      return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options);
      };
    }
    function createSerializer(cls) {
      return function serialize(arg) {
        if (Array.isArray(arg)) {
          throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
        }
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
      };
    }
    function createMethodDefinition(method, serviceName, options, fileDescriptors) {
      const requestType = method.resolvedRequestType;
      const responseType = method.resolvedResponseType;
      return {
        path: "/" + serviceName + "/" + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options),
        originalName: camelCase(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors)
      };
    }
    function createServiceDefinition(service, name4, options, fileDescriptors) {
      const def = {};
      for (const method of service.methodsArray) {
        def[method.name] = createMethodDefinition(method, name4, options, fileDescriptors);
      }
      return def;
    }
    function createMessageDefinition(message, fileDescriptors) {
      const messageDescriptor = message.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 DescriptorProto",
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createEnumDefinition(enumType, fileDescriptors) {
      const enumDescriptor = enumType.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 EnumDescriptorProto",
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createDefinition(obj, name4, options, fileDescriptors) {
      if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name4, options, fileDescriptors);
      } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
      } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
      } else {
        throw new Error("Type mismatch in reflection object handling");
      }
    }
    function createPackageDefinition(root, options) {
      const def = {};
      root.resolveAll();
      const descriptorList = root.toDescriptor("proto3").file;
      const bufferList = descriptorList.map((value) => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
      for (const [name4, obj] of getAllHandledReflectionObjects(root, "")) {
        def[name4] = createDefinition(obj, name4, options, bufferList);
      }
      return def;
    }
    function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
      options = options || {};
      const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
      root.resolveAll();
      return createPackageDefinition(root, options);
    }
    function load2(filename, options) {
      return util_1.loadProtosWithOptions(filename, options).then((loadedRoot) => {
        return createPackageDefinition(loadedRoot, options);
      });
    }
    exports2.load = load2;
    function loadSync(filename, options) {
      const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options);
      return createPackageDefinition(loadedRoot, options);
    }
    exports2.loadSync = loadSync;
    function fromJSON2(json, options) {
      options = options || {};
      const loadedRoot = Protobuf.Root.fromJSON(json);
      loadedRoot.resolveAll();
      return createPackageDefinition(loadedRoot, options);
    }
    exports2.fromJSON = fromJSON2;
    function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    exports2.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
    function loadFileDescriptorSetFromObject(descriptorSet, options) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    exports2.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
    util_1.addCommonProtos();
  }
});

// node_modules/@grpc/grpc-js/build/src/channelz.js
var require_channelz = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channelz.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.getChannelzServiceDefinition = exports2.getChannelzHandlers = exports2.unregisterChannelzRef = exports2.registerChannelzSocket = exports2.registerChannelzServer = exports2.registerChannelzSubchannel = exports2.registerChannelzChannel = exports2.ChannelzCallTracker = exports2.ChannelzChildrenTracker = exports2.ChannelzTrace = void 0;
    var net_1 = require("net");
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var subchannel_address_1 = require_subchannel_address();
    var admin_1 = require_admin();
    var make_client_1 = require_make_client();
    function channelRefToMessage(ref) {
      return {
        channel_id: ref.id,
        name: ref.name
      };
    }
    function subchannelRefToMessage(ref) {
      return {
        subchannel_id: ref.id,
        name: ref.name
      };
    }
    function serverRefToMessage(ref) {
      return {
        server_id: ref.id
      };
    }
    function socketRefToMessage(ref) {
      return {
        socket_id: ref.id,
        name: ref.name
      };
    }
    var TARGET_RETAINED_TRACES = 32;
    var ChannelzTrace = class {
      constructor() {
        this.events = [];
        this.eventsLogged = 0;
        this.creationTimestamp = new Date();
      }
      addTrace(severity, description, child) {
        const timestamp = new Date();
        this.events.push({
          description,
          severity,
          timestamp,
          childChannel: (child === null || child === void 0 ? void 0 : child.kind) === "channel" ? child : void 0,
          childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === "subchannel" ? child : void 0
        });
        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
          this.events = this.events.slice(TARGET_RETAINED_TRACES);
        }
        this.eventsLogged += 1;
      }
      getTraceMessage() {
        return {
          creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
          num_events_logged: this.eventsLogged,
          events: this.events.map((event) => {
            return {
              description: event.description,
              severity: event.severity,
              timestamp: dateToProtoTimestamp(event.timestamp),
              channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
              subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
            };
          })
        };
      }
    };
    exports2.ChannelzTrace = ChannelzTrace;
    var ChannelzChildrenTracker = class {
      constructor() {
        this.channelChildren = new Map();
        this.subchannelChildren = new Map();
        this.socketChildren = new Map();
      }
      refChild(child) {
        var _a, _b, _c;
        switch (child.kind) {
          case "channel": {
            let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : { ref: child, count: 0 };
            trackedChild.count += 1;
            this.channelChildren.set(child.id, trackedChild);
            break;
          }
          case "subchannel": {
            let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : { ref: child, count: 0 };
            trackedChild.count += 1;
            this.subchannelChildren.set(child.id, trackedChild);
            break;
          }
          case "socket": {
            let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : { ref: child, count: 0 };
            trackedChild.count += 1;
            this.socketChildren.set(child.id, trackedChild);
            break;
          }
        }
      }
      unrefChild(child) {
        switch (child.kind) {
          case "channel": {
            let trackedChild = this.channelChildren.get(child.id);
            if (trackedChild !== void 0) {
              trackedChild.count -= 1;
              if (trackedChild.count === 0) {
                this.channelChildren.delete(child.id);
              } else {
                this.channelChildren.set(child.id, trackedChild);
              }
            }
            break;
          }
          case "subchannel": {
            let trackedChild = this.subchannelChildren.get(child.id);
            if (trackedChild !== void 0) {
              trackedChild.count -= 1;
              if (trackedChild.count === 0) {
                this.subchannelChildren.delete(child.id);
              } else {
                this.subchannelChildren.set(child.id, trackedChild);
              }
            }
            break;
          }
          case "socket": {
            let trackedChild = this.socketChildren.get(child.id);
            if (trackedChild !== void 0) {
              trackedChild.count -= 1;
              if (trackedChild.count === 0) {
                this.socketChildren.delete(child.id);
              } else {
                this.socketChildren.set(child.id, trackedChild);
              }
            }
            break;
          }
        }
      }
      getChildLists() {
        const channels2 = [];
        for (const { ref } of this.channelChildren.values()) {
          channels2.push(ref);
        }
        const subchannels2 = [];
        for (const { ref } of this.subchannelChildren.values()) {
          subchannels2.push(ref);
        }
        const sockets2 = [];
        for (const { ref } of this.socketChildren.values()) {
          sockets2.push(ref);
        }
        return { channels: channels2, subchannels: subchannels2, sockets: sockets2 };
      }
    };
    exports2.ChannelzChildrenTracker = ChannelzChildrenTracker;
    var ChannelzCallTracker = class {
      constructor() {
        this.callsStarted = 0;
        this.callsSucceeded = 0;
        this.callsFailed = 0;
        this.lastCallStartedTimestamp = null;
      }
      addCallStarted() {
        this.callsStarted += 1;
        this.lastCallStartedTimestamp = new Date();
      }
      addCallSucceeded() {
        this.callsSucceeded += 1;
      }
      addCallFailed() {
        this.callsFailed += 1;
      }
    };
    exports2.ChannelzCallTracker = ChannelzCallTracker;
    var nextId = 1;
    function getNextId() {
      return nextId++;
    }
    var channels = [];
    var subchannels = [];
    var servers = [];
    var sockets = [];
    function registerChannelzChannel(name4, getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, name: name4, kind: "channel" };
      if (channelzEnabled) {
        channels[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzChannel = registerChannelzChannel;
    function registerChannelzSubchannel(name4, getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, name: name4, kind: "subchannel" };
      if (channelzEnabled) {
        subchannels[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzSubchannel = registerChannelzSubchannel;
    function registerChannelzServer(getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, kind: "server" };
      if (channelzEnabled) {
        servers[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzServer = registerChannelzServer;
    function registerChannelzSocket(name4, getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, name: name4, kind: "socket" };
      if (channelzEnabled) {
        sockets[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzSocket = registerChannelzSocket;
    function unregisterChannelzRef(ref) {
      switch (ref.kind) {
        case "channel":
          delete channels[ref.id];
          return;
        case "subchannel":
          delete subchannels[ref.id];
          return;
        case "server":
          delete servers[ref.id];
          return;
        case "socket":
          delete sockets[ref.id];
          return;
      }
    }
    exports2.unregisterChannelzRef = unregisterChannelzRef;
    function parseIPv6Section(addressSection) {
      const numberValue = Number.parseInt(addressSection, 16);
      return [numberValue / 256 | 0, numberValue % 256];
    }
    function parseIPv6Chunk(addressChunk) {
      if (addressChunk === "") {
        return [];
      }
      const bytePairs = addressChunk.split(":").map((section) => parseIPv6Section(section));
      const result = [];
      return result.concat(...bytePairs);
    }
    function ipAddressStringToBuffer(ipAddress) {
      if (net_1.isIPv4(ipAddress)) {
        return Buffer.from(Uint8Array.from(ipAddress.split(".").map((segment) => Number.parseInt(segment))));
      } else if (net_1.isIPv6(ipAddress)) {
        let leftSection;
        let rightSection;
        const doubleColonIndex = ipAddress.indexOf("::");
        if (doubleColonIndex === -1) {
          leftSection = ipAddress;
          rightSection = "";
        } else {
          leftSection = ipAddress.substring(0, doubleColonIndex);
          rightSection = ipAddress.substring(doubleColonIndex + 2);
        }
        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
      } else {
        return null;
      }
    }
    function connectivityStateToMessage(state) {
      switch (state) {
        case connectivity_state_1.ConnectivityState.CONNECTING:
          return {
            state: "CONNECTING"
          };
        case connectivity_state_1.ConnectivityState.IDLE:
          return {
            state: "IDLE"
          };
        case connectivity_state_1.ConnectivityState.READY:
          return {
            state: "READY"
          };
        case connectivity_state_1.ConnectivityState.SHUTDOWN:
          return {
            state: "SHUTDOWN"
          };
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
          return {
            state: "TRANSIENT_FAILURE"
          };
        default:
          return {
            state: "UNKNOWN"
          };
      }
    }
    function dateToProtoTimestamp(date) {
      if (!date) {
        return null;
      }
      const millisSinceEpoch = date.getTime();
      return {
        seconds: millisSinceEpoch / 1e3 | 0,
        nanos: millisSinceEpoch % 1e3 * 1e6
      };
    }
    function getChannelMessage(channelEntry) {
      const resolvedInfo = channelEntry.getInfo();
      return {
        ref: channelRefToMessage(channelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        channel_ref: resolvedInfo.children.channels.map((ref) => channelRefToMessage(ref)),
        subchannel_ref: resolvedInfo.children.subchannels.map((ref) => subchannelRefToMessage(ref))
      };
    }
    function GetChannel(call, callback) {
      const channelId = Number.parseInt(call.request.channel_id);
      const channelEntry = channels[channelId];
      if (channelEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No channel data found for id " + channelId
        });
        return;
      }
      callback(null, { channel: getChannelMessage(channelEntry) });
    }
    function GetTopChannels(call, callback) {
      const maxResults = Number.parseInt(call.request.max_results);
      const resultList = [];
      let i2 = Number.parseInt(call.request.start_channel_id);
      for (; i2 < channels.length; i2++) {
        const channelEntry = channels[i2];
        if (channelEntry === void 0) {
          continue;
        }
        resultList.push(getChannelMessage(channelEntry));
        if (resultList.length >= maxResults) {
          break;
        }
      }
      callback(null, {
        channel: resultList,
        end: i2 >= servers.length
      });
    }
    function getServerMessage(serverEntry) {
      const resolvedInfo = serverEntry.getInfo();
      return {
        ref: serverRefToMessage(serverEntry.ref),
        data: {
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        listen_socket: resolvedInfo.listenerChildren.sockets.map((ref) => socketRefToMessage(ref))
      };
    }
    function GetServer(call, callback) {
      const serverId = Number.parseInt(call.request.server_id);
      const serverEntry = servers[serverId];
      if (serverEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No server data found for id " + serverId
        });
        return;
      }
      callback(null, { server: getServerMessage(serverEntry) });
    }
    function GetServers(call, callback) {
      const maxResults = Number.parseInt(call.request.max_results);
      const resultList = [];
      let i2 = Number.parseInt(call.request.start_server_id);
      for (; i2 < servers.length; i2++) {
        const serverEntry = servers[i2];
        if (serverEntry === void 0) {
          continue;
        }
        resultList.push(getServerMessage(serverEntry));
        if (resultList.length >= maxResults) {
          break;
        }
      }
      callback(null, {
        server: resultList,
        end: i2 >= servers.length
      });
    }
    function GetSubchannel(call, callback) {
      const subchannelId = Number.parseInt(call.request.subchannel_id);
      const subchannelEntry = subchannels[subchannelId];
      if (subchannelEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No subchannel data found for id " + subchannelId
        });
        return;
      }
      const resolvedInfo = subchannelEntry.getInfo();
      const subchannelMessage = {
        ref: subchannelRefToMessage(subchannelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        socket_ref: resolvedInfo.children.sockets.map((ref) => socketRefToMessage(ref))
      };
      callback(null, { subchannel: subchannelMessage });
    }
    function subchannelAddressToAddressMessage(subchannelAddress) {
      var _a;
      if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {
        return {
          address: "tcpip_address",
          tcpip_address: {
            ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : void 0,
            port: subchannelAddress.port
          }
        };
      } else {
        return {
          address: "uds_address",
          uds_address: {
            filename: subchannelAddress.path
          }
        };
      }
    }
    function GetSocket(call, callback) {
      var _a, _b, _c, _d, _e;
      const socketId = Number.parseInt(call.request.socket_id);
      const socketEntry = sockets[socketId];
      if (socketEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No socket data found for id " + socketId
        });
        return;
      }
      const resolvedInfo = socketEntry.getInfo();
      const securityMessage = resolvedInfo.security ? {
        model: "tls",
        tls: {
          cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? "standard_name" : "other_name",
          standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : void 0,
          other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : void 0,
          local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : void 0,
          remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : void 0
        }
      } : null;
      const socketMessage = {
        ref: socketRefToMessage(socketEntry.ref),
        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : void 0,
        security: securityMessage,
        data: {
          keep_alives_sent: resolvedInfo.keepAlivesSent,
          streams_started: resolvedInfo.streamsStarted,
          streams_succeeded: resolvedInfo.streamsSucceeded,
          streams_failed: resolvedInfo.streamsFailed,
          last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
          last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
          messages_received: resolvedInfo.messagesReceived,
          messages_sent: resolvedInfo.messagesSent,
          last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
          last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
          local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,
          remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null
        }
      };
      callback(null, { socket: socketMessage });
    }
    function GetServerSockets(call, callback) {
      const serverId = Number.parseInt(call.request.server_id);
      const serverEntry = servers[serverId];
      if (serverEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No server data found for id " + serverId
        });
        return;
      }
      const startId = Number.parseInt(call.request.start_socket_id);
      const maxResults = Number.parseInt(call.request.max_results);
      const resolvedInfo = serverEntry.getInfo();
      const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);
      const resultList = [];
      let i2 = 0;
      for (; i2 < allSockets.length; i2++) {
        if (allSockets[i2].id >= startId) {
          resultList.push(socketRefToMessage(allSockets[i2]));
          if (resultList.length >= maxResults) {
            break;
          }
        }
      }
      callback(null, {
        socket_ref: resultList,
        end: i2 >= allSockets.length
      });
    }
    function getChannelzHandlers() {
      return {
        GetChannel,
        GetTopChannels,
        GetServer,
        GetServers,
        GetSubchannel,
        GetSocket,
        GetServerSockets
      };
    }
    exports2.getChannelzHandlers = getChannelzHandlers;
    var loadedChannelzDefinition = null;
    function getChannelzServiceDefinition() {
      if (loadedChannelzDefinition) {
        return loadedChannelzDefinition;
      }
      const loaderLoadSync = require_src3().loadSync;
      const loadedProto = loaderLoadSync("channelz.proto", {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        includeDirs: [
          `${__dirname}/../../proto`
        ]
      });
      const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);
      loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
      return loadedChannelzDefinition;
    }
    exports2.getChannelzServiceDefinition = getChannelzServiceDefinition;
    function setup() {
      admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/package.json
var require_package = __commonJS({
  "node_modules/@grpc/grpc-js/package.json"(exports2, module2) {
    module2.exports = {
      name: "@grpc/grpc-js",
      version: "1.6.3",
      description: "gRPC Library for Node - pure JS implementation",
      homepage: "https://grpc.io/",
      repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
      main: "build/src/index.js",
      engines: {
        node: "^8.13.0 || >=10.10.0"
      },
      keywords: [],
      author: {
        name: "Google Inc."
      },
      types: "build/src/index.d.ts",
      license: "Apache-2.0",
      devDependencies: {
        "@types/gulp": "^4.0.6",
        "@types/gulp-mocha": "0.0.32",
        "@types/lodash": "^4.14.108",
        "@types/mocha": "^5.2.6",
        "@types/ncp": "^2.0.1",
        "@types/pify": "^3.0.2",
        "@types/semver": "^7.3.9",
        "clang-format": "^1.0.55",
        execa: "^2.0.3",
        gts: "^2.0.0",
        gulp: "^4.0.2",
        "gulp-mocha": "^6.0.0",
        lodash: "^4.17.4",
        madge: "^5.0.1",
        "mocha-jenkins-reporter": "^0.4.1",
        ncp: "^2.0.0",
        pify: "^4.0.1",
        rimraf: "^3.0.2",
        semver: "^7.3.5",
        "ts-node": "^8.3.0",
        typescript: "^3.7.2"
      },
      contributors: [
        {
          name: "Google Inc."
        }
      ],
      scripts: {
        build: "npm run compile",
        clean: "rimraf ./build",
        compile: "tsc -p .",
        format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
        lint: "npm run check",
        prepare: "npm run generate-types && npm run compile",
        test: "gulp test",
        check: "gts check src/**/*.ts",
        fix: "gts fix src/*.ts",
        pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
        posttest: "npm run check && madge -c ./build/src",
        "generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
        "generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
      },
      dependencies: {
        "@grpc/proto-loader": "^0.6.4",
        "@types/node": ">=12.12.47"
      },
      files: [
        "src/**/*.ts",
        "build/src/**/*.{js,d.ts,js.map}",
        "proto/*.proto",
        "LICENSE",
        "deps/envoy-api/envoy/api/v2/**/*.proto",
        "deps/envoy-api/envoy/config/**/*.proto",
        "deps/envoy-api/envoy/service/**/*.proto",
        "deps/envoy-api/envoy/type/**/*.proto",
        "deps/udpa/udpa/**/*.proto",
        "deps/googleapis/google/api/*.proto",
        "deps/googleapis/google/rpc/*.proto",
        "deps/protoc-gen-validate/validate/**/*.proto"
      ]
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Subchannel = void 0;
    var http22 = require("http2");
    var tls_1 = require("tls");
    var connectivity_state_1 = require_connectivity_state();
    var backoff_timeout_1 = require_backoff_timeout();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var constants_1 = require_constants();
    var http_proxy_1 = require_http_proxy();
    var net = require("net");
    var uri_parser_1 = require_uri_parser();
    var subchannel_address_1 = require_subchannel_address();
    var channelz_1 = require_channelz();
    var clientVersion = require_package().version;
    var TRACER_NAME = "subchannel";
    var FLOW_CONTROL_TRACER_NAME = "subchannel_flowctrl";
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http22.constants;
    var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
    var Subchannel = class {
      constructor(channelTarget, subchannelAddress, options, credentials2) {
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials2;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.session = null;
        this.continueConnecting = false;
        this.stateListeners = [];
        this.disconnectListeners = [];
        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        this.keepaliveWithoutCalls = false;
        this.callRefcount = 0;
        this.refcount = 0;
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.channelzSocketRef = null;
        this.remoteName = null;
        this.streamTracker = new channelz_1.ChannelzCallTracker();
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
        this.userAgent = [
          options["grpc.primary_user_agent"],
          `grpc-node-js/${clientVersion}`,
          options["grpc.secondary_user_agent"]
        ].filter((e2) => e2).join(" ");
        if ("grpc.keepalive_time_ms" in options) {
          this.keepaliveTimeMs = options["grpc.keepalive_time_ms"];
        }
        if ("grpc.keepalive_timeout_ms" in options) {
          this.keepaliveTimeoutMs = options["grpc.keepalive_timeout_ms"];
        }
        if ("grpc.keepalive_permit_without_calls" in options) {
          this.keepaliveWithoutCalls = options["grpc.keepalive_permit_without_calls"] === 1;
        } else {
          this.keepaliveWithoutCalls = false;
        }
        this.keepaliveIntervalId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveIntervalId);
        this.keepaliveTimeoutId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveTimeoutId);
        const backoffOptions = {
          initialDelay: options["grpc.initial_reconnect_backoff_ms"],
          maxDelay: options["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          this.handleBackoffTimer();
        }, backoffOptions);
        this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Subchannel created");
        }
        this.trace("Subchannel constructed with options " + JSON.stringify(options, void 0, 2));
      }
      getChannelzInfo() {
        return {
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists(),
          target: this.subchannelAddressString
        };
      }
      getChannelzSocketInfo() {
        var _a, _b, _c;
        if (this.session === null) {
          return null;
        }
        const sessionSocket = this.session.socket;
        const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
        const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;
        let tlsInfo;
        if (this.session.encrypted) {
          const tlsSocket = sessionSocket;
          const cipherInfo = tlsSocket.getCipher();
          const certificate = tlsSocket.getCertificate();
          const peerCertificate = tlsSocket.getPeerCertificate();
          tlsInfo = {
            cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
            cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
            localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
            remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
          };
        } else {
          tlsInfo = null;
        }
        const socketInfo = {
          remoteAddress,
          localAddress,
          security: tlsInfo,
          remoteName: this.remoteName,
          streamsStarted: this.streamTracker.callsStarted,
          streamsSucceeded: this.streamTracker.callsSucceeded,
          streamsFailed: this.streamTracker.callsFailed,
          messagesSent: this.messagesSent,
          messagesReceived: this.messagesReceived,
          keepAlivesSent: this.keepalivesSent,
          lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
          lastRemoteStreamCreatedTimestamp: null,
          lastMessageSentTimestamp: this.lastMessageSentTimestamp,
          lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
          localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
          remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null
        };
        return socketInfo;
      }
      resetChannelzSocketInfo() {
        if (!this.channelzEnabled) {
          return;
        }
        if (this.channelzSocketRef) {
          channelz_1.unregisterChannelzRef(this.channelzSocketRef);
          this.childrenTracker.unrefChild(this.channelzSocketRef);
          this.channelzSocketRef = null;
        }
        this.remoteName = null;
        this.streamTracker = new channelz_1.ChannelzCallTracker();
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      refTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      flowControlTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      internalsTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_internals", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      keepaliveTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      handleBackoffTimer() {
        if (this.continueConnecting) {
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
        } else {
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
        }
      }
      startBackoff() {
        this.backoffTimeout.runOnce();
      }
      stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
      }
      sendPing() {
        var _a, _b;
        if (this.channelzEnabled) {
          this.keepalivesSent += 1;
        }
        this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
        this.keepaliveTimeoutId = setTimeout(() => {
          this.keepaliveTrace("Ping timeout passed without response");
          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
        }, this.keepaliveTimeoutMs);
        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.session.ping((err, duration, payload) => {
          this.keepaliveTrace("Received ping response");
          clearTimeout(this.keepaliveTimeoutId);
        });
      }
      startKeepalivePings() {
        var _a, _b;
        this.keepaliveIntervalId = setInterval(() => {
          this.sendPing();
        }, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      stopKeepalivePings() {
        clearInterval(this.keepaliveIntervalId);
        clearTimeout(this.keepaliveTimeoutId);
      }
      createSession(proxyConnectionResult) {
        var _a, _b, _c;
        if (proxyConnectionResult.realTarget) {
          this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);
          this.trace("creating HTTP/2 session through proxy to " + proxyConnectionResult.realTarget);
        } else {
          this.remoteName = null;
          this.trace("creating HTTP/2 session");
        }
        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
        let connectionOptions = this.credentials._getConnectionOptions() || {};
        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
        if ("grpc-node.max_session_memory" in this.options) {
          connectionOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        } else {
          connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
        }
        let addressScheme = "http://";
        if ("secureContext" in connectionOptions) {
          addressScheme = "https://";
          if (this.options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : "localhost";
            connectionOptions.servername = authorityHostname;
          }
          if (proxyConnectionResult.socket) {
            connectionOptions.createConnection = (authority, option) => {
              return proxyConnectionResult.socket;
            };
          }
        } else {
          connectionOptions.createConnection = (authority, option) => {
            if (proxyConnectionResult.socket) {
              return proxyConnectionResult.socket;
            } else {
              return net.connect(this.subchannelAddress);
            }
          };
        }
        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);
        const session = http22.connect(addressScheme + targetAuthority, connectionOptions);
        this.session = session;
        this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.childrenTracker.refChild(this.channelzSocketRef);
        }
        session.unref();
        session.once("connect", () => {
          if (this.session === session) {
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);
          }
        });
        session.once("close", () => {
          if (this.session === session) {
            this.trace("connection closed");
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
          }
        });
        session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
          if (this.session === session) {
            if (errorCode === http22.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {
              this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);
              logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);
            }
            this.trace("connection closed by GOAWAY with code " + errorCode);
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
          }
        });
        session.once("error", (error2) => {
          this.trace("connection closed with error " + error2.message);
        });
        if (logging.isTracerEnabled(TRACER_NAME)) {
          session.on("remoteSettings", (settings) => {
            this.trace("new settings received" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
          session.on("localSettings", (settings) => {
            this.trace("local settings acknowledged by remote" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
        }
      }
      startConnectingInternal() {
        var _a, _b;
        const connectionOptions = this.credentials._getConnectionOptions() || {};
        if ("secureContext" in connectionOptions) {
          connectionOptions.ALPNProtocols = ["h2"];
          if (this.options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            if ("grpc.http_connect_target" in this.options) {
              const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options["grpc.http_connect_target"])) !== null && _a !== void 0 ? _a : {
                path: "localhost"
              });
              const hostPort = uri_parser_1.splitHostPort(targetPath);
              connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
            }
          }
        }
        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {
          this.createSession(result);
        }, (reason) => {
          this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
        });
      }
      transitionToState(oldStates, newState) {
        if (oldStates.indexOf(this.connectivityState) === -1) {
          return false;
        }
        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        }
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
          case connectivity_state_1.ConnectivityState.READY:
            this.stopBackoff();
            const session = this.session;
            session.socket.once("close", () => {
              if (this.session === session) {
                this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
                for (const listener of this.disconnectListeners) {
                  listener();
                }
              }
            });
            if (this.keepaliveWithoutCalls) {
              this.startKeepalivePings();
            }
            break;
          case connectivity_state_1.ConnectivityState.CONNECTING:
            this.startBackoff();
            this.startConnectingInternal();
            this.continueConnecting = false;
            break;
          case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
            if (this.session) {
              this.session.close();
            }
            this.session = null;
            this.resetChannelzSocketInfo();
            this.stopKeepalivePings();
            if (!this.backoffTimeout.isRunning()) {
              process.nextTick(() => {
                this.handleBackoffTimer();
              });
            }
            break;
          case connectivity_state_1.ConnectivityState.IDLE:
            if (this.session) {
              this.session.close();
            }
            this.session = null;
            this.resetChannelzSocketInfo();
            this.stopKeepalivePings();
            break;
          default:
            throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of [...this.stateListeners]) {
          listener(this, previousState, newState);
        }
        return true;
      }
      checkBothRefcounts() {
        if (this.callRefcount === 0 && this.refcount === 0) {
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Shutting down");
          }
          this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
          if (this.channelzEnabled) {
            channelz_1.unregisterChannelzRef(this.channelzRef);
          }
        }
      }
      callRef() {
        this.refTrace("callRefcount " + this.callRefcount + " -> " + (this.callRefcount + 1));
        if (this.callRefcount === 0) {
          if (this.session) {
            this.session.ref();
          }
          this.backoffTimeout.ref();
          if (!this.keepaliveWithoutCalls) {
            this.startKeepalivePings();
          }
        }
        this.callRefcount += 1;
      }
      callUnref() {
        this.refTrace("callRefcount " + this.callRefcount + " -> " + (this.callRefcount - 1));
        this.callRefcount -= 1;
        if (this.callRefcount === 0) {
          if (this.session) {
            this.session.unref();
          }
          this.backoffTimeout.unref();
          if (!this.keepaliveWithoutCalls) {
            clearInterval(this.keepaliveIntervalId);
          }
          this.checkBothRefcounts();
        }
      }
      ref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount + 1));
        this.refcount += 1;
      }
      unref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount - 1));
        this.refcount -= 1;
        this.checkBothRefcounts();
      }
      unrefIfOneRef() {
        if (this.refcount === 1) {
          this.unref();
          return true;
        }
        return false;
      }
      startCallStream(metadata, callStream, extraFilters) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
        headers[HTTP2_HEADER_METHOD] = "POST";
        headers[HTTP2_HEADER_PATH] = callStream.getMethod();
        headers[HTTP2_HEADER_TE] = "trailers";
        let http2Stream;
        try {
          http2Stream = this.session.request(headers);
        } catch (e2) {
          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
          throw e2;
        }
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        logging.trace(constants_1.LogVerbosity.DEBUG, "call_stream", "Starting stream [" + callStream.getCallNumber() + "] on subchannel (" + this.channelzRef.id + ") " + this.subchannelAddressString + " with headers\n" + headersString);
        this.flowControlTrace("local window size: " + this.session.state.localWindowSize + " remote window size: " + this.session.state.remoteWindowSize);
        const streamSession = this.session;
        this.internalsTrace("session.closed=" + streamSession.closed + " session.destroyed=" + streamSession.destroyed + " session.socket.destroyed=" + streamSession.socket.destroyed);
        let statsTracker;
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
          callStream.addStatusWatcher((status) => {
            if (status.code === constants_1.Status.OK) {
              this.callTracker.addCallSucceeded();
            } else {
              this.callTracker.addCallFailed();
            }
          });
          this.streamTracker.addCallStarted();
          callStream.addStreamEndWatcher((success) => {
            if (streamSession === this.session) {
              if (success) {
                this.streamTracker.addCallSucceeded();
              } else {
                this.streamTracker.addCallFailed();
              }
            }
          });
          statsTracker = {
            addMessageSent: () => {
              this.messagesSent += 1;
              this.lastMessageSentTimestamp = new Date();
            },
            addMessageReceived: () => {
              this.messagesReceived += 1;
            }
          };
        } else {
          statsTracker = {
            addMessageSent: () => {
            },
            addMessageReceived: () => {
            }
          };
        }
        callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);
      }
      startConnecting() {
        if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
          if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.continueConnecting = true;
          }
        }
      }
      getConnectivityState() {
        return this.connectivityState;
      }
      addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
      }
      removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.stateListeners.splice(listenerIndex, 1);
        }
      }
      addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
      }
      removeDisconnectListener(listener) {
        const listenerIndex = this.disconnectListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.disconnectListeners.splice(listenerIndex, 1);
        }
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
      }
      getAddress() {
        return this.subchannelAddressString;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      getRealSubchannel() {
        return this;
      }
    };
    exports2.Subchannel = Subchannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSubchannelPool = exports2.SubchannelPool = void 0;
    var channel_options_1 = require_channel_options();
    var subchannel_1 = require_subchannel();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var REF_CHECK_INTERVAL = 1e4;
    var SubchannelPool = class {
      constructor(global2) {
        this.global = global2;
        this.pool = Object.create(null);
        this.cleanupTimer = null;
      }
      unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        for (const channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
          if (refedSubchannels.length > 0) {
            allSubchannelsUnrefed = false;
          }
          this.pool[channelTarget] = refedSubchannels;
        }
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = null;
        }
      }
      ensureCleanupTask() {
        var _a, _b;
        if (this.global && this.cleanupTimer === null) {
          this.cleanupTimer = setInterval(() => {
            this.unrefUnusedSubchannels();
          }, REF_CHECK_INTERVAL);
          (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = uri_parser_1.uriToString(channelTargetUri);
        if (channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          for (const subchannelObj of subchannelObjArray) {
            if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
              return subchannelObj.subchannel;
            }
          }
        }
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);
        if (!(channelTarget in this.pool)) {
          this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
          subchannelAddress: subchannelTarget,
          channelArguments,
          channelCredentials,
          subchannel
        });
        if (this.global) {
          subchannel.ref();
        }
        return subchannel;
      }
    };
    exports2.SubchannelPool = SubchannelPool;
    var globalSubchannelPool = new SubchannelPool(true);
    function getSubchannelPool(global2) {
      if (global2) {
        return globalSubchannelPool;
      } else {
        return new SubchannelPool(false);
      }
    }
    exports2.getSubchannelPool = getSubchannelPool;
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter-stack.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilterStackFactory = exports2.FilterStack = void 0;
    var FilterStack = class {
      constructor(filters) {
        this.filters = filters;
      }
      sendMetadata(metadata) {
        let result = metadata;
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          result = this.filters[i2].sendMetadata(result);
        }
        return result;
      }
      receiveMetadata(metadata) {
        let result = metadata;
        for (let i2 = this.filters.length - 1; i2 >= 0; i2--) {
          result = this.filters[i2].receiveMetadata(result);
        }
        return result;
      }
      sendMessage(message) {
        let result = message;
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          result = this.filters[i2].sendMessage(result);
        }
        return result;
      }
      receiveMessage(message) {
        let result = message;
        for (let i2 = this.filters.length - 1; i2 >= 0; i2--) {
          result = this.filters[i2].receiveMessage(result);
        }
        return result;
      }
      receiveTrailers(status) {
        let result = status;
        for (let i2 = this.filters.length - 1; i2 >= 0; i2--) {
          result = this.filters[i2].receiveTrailers(result);
        }
        return result;
      }
      refresh() {
        for (const filter of this.filters) {
          filter.refresh();
        }
      }
      push(filters) {
        this.filters.unshift(...filters);
      }
      getFilters() {
        return this.filters;
      }
    };
    exports2.FilterStack = FilterStack;
    var FilterStackFactory = class {
      constructor(factories) {
        this.factories = factories;
      }
      push(filterFactories) {
        this.factories.unshift(...filterFactories);
      }
      createFilter(callStream) {
        return new FilterStack(this.factories.map((factory) => factory.createFilter(callStream)));
      }
    };
    exports2.FilterStackFactory = FilterStackFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseFilter = void 0;
    var BaseFilter = class {
      async sendMetadata(metadata) {
        return metadata;
      }
      receiveMetadata(metadata) {
        return metadata;
      }
      async sendMessage(message) {
        return message;
      }
      async receiveMessage(message) {
        return message;
      }
      receiveTrailers(status) {
        return status;
      }
      refresh() {
      }
    };
    exports2.BaseFilter = BaseFilter;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js
var require_call_credentials_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentialsFilterFactory = exports2.CallCredentialsFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var CallCredentialsFilter = class extends filter_1.BaseFilter {
      constructor(channel, stream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.stream = stream;
        this.channel = channel;
        this.stream = stream;
        const splitPath = stream.getMethod().split("/");
        let serviceName = "";
        if (splitPath.length >= 2) {
          serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : "localhost";
        this.serviceUrl = `https://${hostname}/${serviceName}`;
      }
      async sendMetadata(metadata) {
        const credentials2 = this.stream.getCredentials();
        const credsMetadata = credentials2.generateMetadata({
          service_url: this.serviceUrl
        });
        const resultMetadata = await metadata;
        try {
          resultMetadata.merge(await credsMetadata);
        } catch (error2) {
          this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error2.message}`);
          return Promise.reject("Failed to retrieve auth metadata");
        }
        if (resultMetadata.get("authorization").length > 1) {
          this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '"authorization" metadata cannot have multiple values');
          return Promise.reject('"authorization" metadata cannot have multiple values');
        }
        return resultMetadata;
      }
    };
    exports2.CallCredentialsFilter = CallCredentialsFilter;
    var CallCredentialsFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
        this.channel = channel;
      }
      createFilter(callStream) {
        return new CallCredentialsFilter(this.channel, callStream);
      }
    };
    exports2.CallCredentialsFilterFactory = CallCredentialsFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/deadline-filter.js
var require_deadline_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/deadline-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeadlineFilterFactory = exports2.DeadlineFilter = void 0;
    var constants_1 = require_constants();
    var filter_1 = require_filter();
    var units = [
      ["m", 1],
      ["S", 1e3],
      ["M", 60 * 1e3],
      ["H", 60 * 60 * 1e3]
    ];
    function getDeadline(deadline) {
      const now = new Date().getTime();
      const timeoutMs = Math.max(deadline - now, 0);
      for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
          return String(Math.ceil(amount)) + unit;
        }
      }
      throw new Error("Deadline is too far in the future");
    }
    var DeadlineFilter = class extends filter_1.BaseFilter {
      constructor(channel, callStream) {
        super();
        this.channel = channel;
        this.callStream = callStream;
        this.timer = null;
        this.deadline = Infinity;
        this.retreiveDeadline();
        this.runTimer();
      }
      retreiveDeadline() {
        const callDeadline = this.callStream.getDeadline();
        if (callDeadline instanceof Date) {
          this.deadline = callDeadline.getTime();
        } else {
          this.deadline = callDeadline;
        }
      }
      runTimer() {
        var _a, _b;
        if (this.timer) {
          clearTimeout(this.timer);
        }
        const now = new Date().getTime();
        const timeout = this.deadline - now;
        if (timeout <= 0) {
          process.nextTick(() => {
            this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          });
        } else if (this.deadline !== Infinity) {
          this.timer = setTimeout(() => {
            this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          }, timeout);
          (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      refresh() {
        this.retreiveDeadline();
        this.runTimer();
      }
      async sendMetadata(metadata) {
        if (this.deadline === Infinity) {
          return metadata;
        }
        const finalMetadata = await metadata;
        const timeoutString = getDeadline(this.deadline);
        finalMetadata.set("grpc-timeout", timeoutString);
        return finalMetadata;
      }
      receiveTrailers(status) {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        return status;
      }
    };
    exports2.DeadlineFilter = DeadlineFilter;
    var DeadlineFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
      }
      createFilter(callStream) {
        return new DeadlineFilter(this.channel, callStream);
      }
    };
    exports2.DeadlineFilterFactory = DeadlineFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-algorithms.js
var require_compression_algorithms = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-algorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionAlgorithms = void 0;
    var CompressionAlgorithms;
    (function(CompressionAlgorithms2) {
      CompressionAlgorithms2[CompressionAlgorithms2["identity"] = 0] = "identity";
      CompressionAlgorithms2[CompressionAlgorithms2["deflate"] = 1] = "deflate";
      CompressionAlgorithms2[CompressionAlgorithms2["gzip"] = 2] = "gzip";
    })(CompressionAlgorithms = exports2.CompressionAlgorithms || (exports2.CompressionAlgorithms = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionFilterFactory = exports2.CompressionFilter = void 0;
    var zlib2 = require("zlib");
    var compression_algorithms_1 = require_compression_algorithms();
    var constants_1 = require_constants();
    var filter_1 = require_filter();
    var logging = require_logging();
    var isCompressionAlgorithmKey = (key2) => {
      return typeof key2 === "number" && typeof compression_algorithms_1.CompressionAlgorithms[key2] === "string";
    };
    var CompressionHandler = class {
      async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
          messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
          messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
      }
    };
    var IdentityHandler = class extends CompressionHandler {
      async compressMessage(message) {
        return message;
      }
      async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
      }
      decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
      }
    };
    var DeflateHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.deflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.inflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
    };
    var GzipHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.gzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.unzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
    };
    var UnknownHandler = class extends CompressionHandler {
      constructor(compressionName) {
        super();
        this.compressionName = compressionName;
      }
      compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
      }
      decompressMessage(message) {
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
      }
    };
    function getCompressionHandler(compressionName) {
      switch (compressionName) {
        case "identity":
          return new IdentityHandler();
        case "deflate":
          return new DeflateHandler();
        case "gzip":
          return new GzipHandler();
        default:
          return new UnknownHandler(compressionName);
      }
    }
    var CompressionFilter = class extends filter_1.BaseFilter {
      constructor(channelOptions, sharedFilterConfig) {
        var _a;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = "identity";
        const compressionAlgorithmKey = channelOptions["grpc.default_compression_algorithm"];
        if (compressionAlgorithmKey !== void 0) {
          if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
            const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
            const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(",");
            if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {
              this.currentCompressionAlgorithm = clientSelectedEncoding;
              this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);
            }
          } else {
            logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
          }
        }
      }
      async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set("grpc-accept-encoding", "identity,deflate,gzip");
        headers.set("accept-encoding", "identity");
        if (this.currentCompressionAlgorithm === "identity") {
          headers.remove("grpc-encoding");
        } else {
          headers.set("grpc-encoding", this.currentCompressionAlgorithm);
        }
        return headers;
      }
      receiveMetadata(metadata) {
        const receiveEncoding = metadata.get("grpc-encoding");
        if (receiveEncoding.length > 0) {
          const encoding = receiveEncoding[0];
          if (typeof encoding === "string") {
            this.receiveCompression = getCompressionHandler(encoding);
          }
        }
        metadata.remove("grpc-encoding");
        const serverSupportedEncodingsHeader = metadata.get("grpc-accept-encoding")[0];
        if (serverSupportedEncodingsHeader) {
          this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
          const serverSupportedEncodings = serverSupportedEncodingsHeader.split(",");
          if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
            this.sendCompression = new IdentityHandler();
            this.currentCompressionAlgorithm = "identity";
          }
        }
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      async sendMessage(message) {
        var _a;
        const resolvedMessage = await message;
        let compress;
        if (this.sendCompression instanceof IdentityHandler) {
          compress = false;
        } else {
          compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2) === 0;
        }
        return {
          message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
          flags: resolvedMessage.flags
        };
      }
      async receiveMessage(message) {
        return this.receiveCompression.readMessage(await message);
      }
    };
    exports2.CompressionFilter = CompressionFilter;
    var CompressionFilterFactory = class {
      constructor(channel, options) {
        this.channel = channel;
        this.options = options;
        this.sharedFilterConfig = {};
      }
      createFilter(callStream) {
        return new CompressionFilter(this.options, this.sharedFilterConfig);
      }
    };
    exports2.CompressionFilterFactory = CompressionFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js
var require_max_message_size_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxMessageSizeFilterFactory = exports2.MaxMessageSizeFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var MaxMessageSizeFilter = class extends filter_1.BaseFilter {
      constructor(options, callStream) {
        super();
        this.options = options;
        this.callStream = callStream;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ("grpc.max_send_message_length" in options) {
          this.maxSendMessageSize = options["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options) {
          this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
        }
      }
      async sendMessage(message) {
        if (this.maxSendMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.message.length > this.maxSendMessageSize) {
            this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);
            return Promise.reject("Message too large");
          } else {
            return concreteMessage;
          }
        }
      }
      async receiveMessage(message) {
        if (this.maxReceiveMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.length > this.maxReceiveMessageSize) {
            this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);
            return Promise.reject("Message too large");
          } else {
            return concreteMessage;
          }
        }
      }
    };
    exports2.MaxMessageSizeFilter = MaxMessageSizeFilter;
    var MaxMessageSizeFilterFactory = class {
      constructor(options) {
        this.options = options;
      }
      createFilter(callStream) {
        return new MaxMessageSizeFilter(this.options, callStream);
      }
    };
    exports2.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelImplementation = void 0;
    var call_stream_1 = require_call_stream();
    var channel_credentials_1 = require_channel_credentials();
    var resolving_load_balancer_1 = require_resolving_load_balancer();
    var subchannel_pool_1 = require_subchannel_pool();
    var picker_1 = require_picker();
    var constants_1 = require_constants();
    var filter_stack_1 = require_filter_stack();
    var call_credentials_filter_1 = require_call_credentials_filter();
    var deadline_filter_1 = require_deadline_filter();
    var compression_filter_1 = require_compression_filter();
    var resolver_1 = require_resolver();
    var logging_1 = require_logging();
    var max_message_size_filter_1 = require_max_message_size_filter();
    var http_proxy_1 = require_http_proxy();
    var uri_parser_1 = require_uri_parser();
    var connectivity_state_1 = require_connectivity_state();
    var channelz_1 = require_channelz();
    var MAX_TIMEOUT_TIME = 2147483647;
    var nextCallNumber = 0;
    function getNewCallNumber() {
      const callNumber = nextCallNumber;
      nextCallNumber += 1;
      if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {
        nextCallNumber = 0;
      }
      return callNumber;
    }
    var ChannelImplementation = class {
      constructor(target, credentials2, options) {
        var _a, _b, _c, _d;
        this.credentials = credentials2;
        this.options = options;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials2 instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.originalTarget = target;
        const originalTargetUri = uri_parser_1.parseUri(target);
        if (originalTargetUri === null) {
          throw new Error(`Could not parse target name "${target}"`);
        }
        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
        if (defaultSchemeMapResult === null) {
          throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => {
        }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Channel created");
        }
        if (this.options["grpc.default_authority"]) {
          this.defaultAuthority = this.options["grpc.default_authority"];
        } else {
          this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
        }
        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options["grpc.use_local_subchannel_pool"]) !== null && _c !== void 0 ? _c : 0) === 0);
        const channelControlHelper = {
          createSubchannel: (subchannelAddress, subchannelArgs) => {
            const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
            if (this.channelzEnabled) {
              this.channelzTrace.addTrace("CT_INFO", "Created subchannel or used existing subchannel", subchannel.getChannelzRef());
            }
            return subchannel;
          },
          updateState: (connectivityState, picker) => {
            this.currentPicker = picker;
            const queueCopy = this.pickQueue.slice();
            this.pickQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {
              this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);
            }
            this.updateState(connectivityState);
          },
          requestReresolution: () => {
            throw new Error("Resolving load balancer should never call requestReresolution");
          },
          addChannelzChild: (child) => {
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(child);
            }
          },
          removeChannelzChild: (child) => {
            if (this.channelzEnabled) {
              this.childrenTracker.unrefChild(child);
            }
          }
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector) => {
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Address resolution succeeded");
          }
          this.configSelector = configSelector;
          process.nextTick(() => {
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata } of localQueue) {
              this.tryGetConfig(callStream, callMetadata);
            }
            this.configSelectionQueue = [];
          });
        }, (status) => {
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_WARNING", "Address resolution failed with code " + status.code + ' and details "' + status.details + '"');
          }
          if (this.configSelectionQueue.length > 0) {
            this.trace("Name resolution failed with calls queued for config selection");
          }
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          this.callRefTimerUnref();
          for (const { callStream, callMetadata } of localQueue) {
            if (callMetadata.getOptions().waitForReady) {
              this.callRefTimerRef();
              this.configSelectionQueue.push({ callStream, callMetadata });
            } else {
              callStream.cancelWithStatus(status.code, status.details);
            }
          }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
          new call_credentials_filter_1.CallCredentialsFilterFactory(this),
          new deadline_filter_1.DeadlineFilterFactory(this),
          new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
          new compression_filter_1.CompressionFilterFactory(this, this.options)
        ]);
        this.trace("Channel constructed with options " + JSON.stringify(options, void 0, 2));
        const error2 = new Error();
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel_stacktrace", "(" + this.channelzRef.id + ") Channel constructed \n" + ((_d = error2.stack) === null || _d === void 0 ? void 0 : _d.substring(error2.stack.indexOf("\n") + 1)));
      }
      getChannelzInfo() {
        return {
          target: this.originalTarget,
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists()
        };
      }
      trace(text, verbosityOverride) {
        logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, "channel", "(" + this.channelzRef.id + ") " + uri_parser_1.uriToString(this.target) + " " + text);
      }
      callRefTimerRef() {
        var _a, _b, _c, _d;
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
          this.trace("callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      }
      callRefTimerUnref() {
        var _a, _b;
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
          this.trace("callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      pushPick(callStream, callMetadata, callConfig, dynamicFilters) {
        this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });
        this.callRefTimerRef();
      }
      tryPick(callStream, callMetadata, callConfig, dynamicFilters) {
        var _a, _b;
        const pickResult = this.currentPicker.pick({
          metadata: callMetadata,
          extraPickInfo: callConfig.pickInformation
        });
        const subchannelString = pickResult.subchannel ? "(" + pickResult.subchannel.getChannelzRef().id + ") " + pickResult.subchannel.getAddress() : "" + pickResult.subchannel;
        this.trace("Pick result for call [" + callStream.getCallNumber() + "]: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + subchannelString + " status: " + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + " " + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));
        switch (pickResult.pickResultType) {
          case picker_1.PickResultType.COMPLETE:
            if (pickResult.subchannel === null) {
              callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Request dropped by load balancing policy");
            } else {
              if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {
                logging_1.log(constants_1.LogVerbosity.ERROR, "Error: COMPLETE pick result subchannel " + subchannelString + " has state " + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);
                this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);
                break;
              }
              callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then((finalMetadata) => {
                var _a2, _b2, _c;
                const subchannelState = pickResult.subchannel.getConnectivityState();
                if (subchannelState === connectivity_state_1.ConnectivityState.READY) {
                  try {
                    const pickExtraFilters = pickResult.extraFilterFactories.map((factory) => factory.createFilter(callStream));
                    (_a2 = pickResult.subchannel) === null || _a2 === void 0 ? void 0 : _a2.getRealSubchannel().startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);
                    (_b2 = callConfig.onCommitted) === null || _b2 === void 0 ? void 0 : _b2.call(callConfig);
                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);
                  } catch (error2) {
                    const errorCode = error2.code;
                    if (errorCode === "ERR_HTTP2_GOAWAY_SESSION" || errorCode === "ERR_HTTP2_INVALID_SESSION") {
                      this.trace("Failed to start call on picked subchannel " + subchannelString + " with error " + error2.message + ". Retrying pick", constants_1.LogVerbosity.INFO);
                      this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);
                    } else {
                      this.trace("Failed to start call on picked subchanel " + subchannelString + " with error " + error2.message + ". Ending call", constants_1.LogVerbosity.INFO);
                      callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error2.message}`);
                    }
                  }
                } else {
                  this.trace("Picked subchannel " + subchannelString + " has state " + connectivity_state_1.ConnectivityState[subchannelState] + " after metadata filters. Retrying pick", constants_1.LogVerbosity.INFO);
                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);
                }
              }, (error2) => {
                callStream.cancelWithStatus(typeof error2.code === "number" ? error2.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error2.message}`);
              });
            }
            break;
          case picker_1.PickResultType.QUEUE:
            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);
            break;
          case picker_1.PickResultType.TRANSIENT_FAILURE:
            if (callMetadata.getOptions().waitForReady) {
              this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);
            } else {
              callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
            }
            break;
          case picker_1.PickResultType.DROP:
            callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
            break;
          default:
            throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);
        }
      }
      removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
          this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
      }
      updateState(newState) {
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "connectivity_state", "(" + this.channelzRef.id + ") " + uri_parser_1.uriToString(this.target) + " " + connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        }
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
          if (newState !== watcherObject.currentState) {
            if (watcherObject.timer) {
              clearTimeout(watcherObject.timer);
            }
            this.removeConnectivityStateWatcher(watcherObject);
            watcherObject.callback();
          }
        }
      }
      tryGetConfig(stream, metadata) {
        if (stream.getStatus() !== null) {
          return;
        }
        if (this.configSelector === null) {
          this.resolvingLoadBalancer.exitIdle();
          this.configSelectionQueue.push({
            callStream: stream,
            callMetadata: metadata
          });
          this.callRefTimerRef();
        } else {
          const callConfig = this.configSelector(stream.getMethod(), metadata);
          if (callConfig.status === constants_1.Status.OK) {
            if (callConfig.methodConfig.timeout) {
              const deadline = new Date();
              deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);
              deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1e6);
              stream.setConfigDeadline(deadline);
              stream.filterStack.refresh();
            }
            if (callConfig.dynamicFilterFactories.length > 0) {
              const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);
              const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);
              dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then((filteredMetadata) => {
                this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());
              });
            } else {
              this.tryPick(stream, metadata, callConfig, []);
            }
          } else {
            stream.cancelWithStatus(callConfig.status, "Failed to route call to method " + stream.getMethod());
          }
        }
      }
      _startCallStream(stream, metadata) {
        this.tryGetConfig(stream, metadata.clone());
      }
      close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
        clearInterval(this.callRefTimer);
        if (this.channelzEnabled) {
          channelz_1.unregisterChannelzRef(this.channelzRef);
        }
        this.subchannelPool.unrefUnusedSubchannels();
      }
      getTarget() {
        return uri_parser_1.uriToString(this.target);
      }
      getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
          this.resolvingLoadBalancer.exitIdle();
        }
        return connectivityState;
      }
      watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        let timer = null;
        if (deadline !== Infinity) {
          const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
          const now = new Date();
          if (deadline === -Infinity || deadlineDate <= now) {
            process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
            return;
          }
          timer = setTimeout(() => {
            this.removeConnectivityStateWatcher(watcherObject);
            callback(new Error("Deadline passed without connectivity state change"));
          }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
          currentState,
          callback,
          timer
        };
        this.connectivityStateWatchers.push(watcherObject);
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        const callNumber = getNewCallNumber();
        this.trace("createCall [" + callNumber + '] method="' + method + '", deadline=' + deadline);
        const finalOptions = {
          deadline,
          flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
          host: host !== null && host !== void 0 ? host : this.defaultAuthority,
          parentCall
        };
        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
          stream.addStatusWatcher((status) => {
            if (status.code === constants_1.Status.OK) {
              this.callTracker.addCallSucceeded();
            } else {
              this.callTracker.addCallFailed();
            }
          });
        }
        return stream;
      }
    };
    exports2.ChannelImplementation = ChannelImplementation;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2ServerCallStream = exports2.ServerDuplexStreamImpl = exports2.ServerWritableStreamImpl = exports2.ServerReadableStreamImpl = exports2.ServerUnaryCallImpl = void 0;
    var events_1 = require("events");
    var http22 = require("http2");
    var stream_1 = require("stream");
    var zlib2 = require("zlib");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var TRACER_NAME = "server_call";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
    var GRPC_ENCODING_HEADER = "grpc-encoding";
    var GRPC_MESSAGE_HEADER = "grpc-message";
    var GRPC_STATUS_HEADER = "grpc-status";
    var GRPC_TIMEOUT_HEADER = "grpc-timeout";
    var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
    var deadlineUnitsToMs = {
      H: 36e5,
      M: 6e4,
      S: 1e3,
      m: 1,
      u: 1e-3,
      n: 1e-6
    };
    var defaultResponseHeaders = {
      [GRPC_ACCEPT_ENCODING_HEADER]: "identity,deflate,gzip",
      [GRPC_ENCODING_HEADER]: "identity",
      [http22.constants.HTTP2_HEADER_STATUS]: http22.constants.HTTP_STATUS_OK,
      [http22.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
    };
    var defaultResponseOptions = {
      waitForTrailers: true
    };
    var ServerUnaryCallImpl = class extends events_1.EventEmitter {
      constructor(call, metadata, request) {
        super();
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
    };
    exports2.ServerUnaryCallImpl = ServerUnaryCallImpl;
    var ServerReadableStreamImpl = class extends stream_1.Readable {
      constructor(call, metadata, deserialize, encoding) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this, encoding);
      }
      _read(size) {
        if (!this.call.consumeUnpushedMessages(this)) {
          return;
        }
        this.call.resume();
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
    };
    exports2.ServerReadableStreamImpl = ServerReadableStreamImpl;
    var ServerWritableStreamImpl = class extends stream_1.Writable {
      constructor(call, metadata, serialize, request) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.request = request;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      _write(chunk, encoding, callback) {
        try {
          const response = this.call.serializeMessage(chunk);
          if (!this.call.write(response)) {
            this.call.once("drain", callback);
            return;
          }
        } catch (err) {
          err.code = constants_1.Status.INTERNAL;
          this.emit("error", err);
        }
        callback();
      }
      _final(callback) {
        this.call.sendStatus({
          code: constants_1.Status.OK,
          details: "OK",
          metadata: this.trailingMetadata
        });
        callback(null);
      }
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports2.ServerWritableStreamImpl = ServerWritableStreamImpl;
    var ServerDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(call, metadata, serialize, deserialize, encoding) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this, encoding);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports2.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
    ServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;
    ServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;
    ServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;
    var Http2ServerCallStream = class extends events_1.EventEmitter {
      constructor(stream, handler, options) {
        super();
        this.stream = stream;
        this.handler = handler;
        this.options = options;
        this.cancelled = false;
        this.deadlineTimer = setTimeout(() => {
        }, 0);
        this.deadline = Infinity;
        this.wantTrailers = false;
        this.metadataSent = false;
        this.canPush = false;
        this.isPushPending = false;
        this.bufferedMessages = [];
        this.messagesToPush = [];
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.stream.once("error", (err) => {
        });
        this.stream.once("close", () => {
          var _a;
          trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " stream closed with rstCode " + this.stream.rstCode);
          this.cancelled = true;
          this.emit("cancelled", "cancelled");
          this.emit("streamEnd", false);
          this.sendStatus({ code: constants_1.Status.CANCELLED, details: "Cancelled by client", metadata: new metadata_1.Metadata() });
        });
        this.stream.on("drain", () => {
          this.emit("drain");
        });
        if ("grpc.max_send_message_length" in options) {
          this.maxSendMessageSize = options["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options) {
          this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
        }
        clearTimeout(this.deadlineTimer);
      }
      checkCancelled() {
        if (this.stream.destroyed || this.stream.closed) {
          this.cancelled = true;
        }
        return this.cancelled;
      }
      getDecompressedMessage(message, encoding) {
        switch (encoding) {
          case "deflate": {
            return new Promise((resolve2, reject) => {
              zlib2.inflate(message.slice(5), (err, output) => {
                if (err) {
                  this.sendError({
                    code: constants_1.Status.INTERNAL,
                    details: `Received "grpc-encoding" header "${encoding}" but ${encoding} decompression failed`
                  });
                  resolve2();
                } else {
                  resolve2(output);
                }
              });
            });
          }
          case "gzip": {
            return new Promise((resolve2, reject) => {
              zlib2.unzip(message.slice(5), (err, output) => {
                if (err) {
                  this.sendError({
                    code: constants_1.Status.INTERNAL,
                    details: `Received "grpc-encoding" header "${encoding}" but ${encoding} decompression failed`
                  });
                  resolve2();
                } else {
                  resolve2(output);
                }
              });
            });
          }
          case "identity": {
            return Promise.resolve(message.slice(5));
          }
          default: {
            this.sendError({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received message compressed with unsupported encoding "${encoding}"`
            });
            return Promise.resolve();
          }
        }
      }
      sendMetadata(customMetadata) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.metadataSent) {
          return;
        }
        this.metadataSent = true;
        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
        const headers = Object.assign({}, defaultResponseHeaders, custom);
        this.stream.respond(headers, defaultResponseOptions);
      }
      receiveMetadata(headers) {
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
          const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
          if (match === null) {
            const err = new Error("Invalid deadline");
            err.code = constants_1.Status.OUT_OF_RANGE;
            this.sendError(err);
            return metadata;
          }
          const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
          const now = new Date();
          this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
          this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
          metadata.remove(GRPC_TIMEOUT_HEADER);
        }
        metadata.remove(http22.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http22.constants.HTTP2_HEADER_TE);
        metadata.remove(http22.constants.HTTP2_HEADER_CONTENT_TYPE);
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      receiveUnaryMessage(encoding) {
        return new Promise((resolve2, reject) => {
          const stream = this.stream;
          const chunks = [];
          let totalLength = 0;
          stream.on("data", (data) => {
            chunks.push(data);
            totalLength += data.byteLength;
          });
          stream.once("end", async () => {
            try {
              const requestBytes = Buffer.concat(chunks, totalLength);
              if (this.maxReceiveMessageSize !== -1 && requestBytes.length > this.maxReceiveMessageSize) {
                this.sendError({
                  code: constants_1.Status.RESOURCE_EXHAUSTED,
                  details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`
                });
                resolve2();
              }
              this.emit("receiveMessage");
              const compressed = requestBytes.readUInt8(0) === 1;
              const compressedMessageEncoding = compressed ? encoding : "identity";
              const decompressedMessage = await this.getDecompressedMessage(requestBytes, compressedMessageEncoding);
              if (!decompressedMessage) {
                resolve2();
              } else {
                resolve2(this.deserializeMessage(decompressedMessage));
              }
            } catch (err) {
              err.code = constants_1.Status.INTERNAL;
              this.sendError(err);
              resolve2();
            }
          });
        });
      }
      serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      deserializeMessage(bytes) {
        return this.handler.deserialize(bytes);
      }
      async sendUnaryMessage(err, value, metadata, flags) {
        if (this.checkCancelled()) {
          return;
        }
        if (!metadata) {
          metadata = new metadata_1.Metadata();
        }
        if (err) {
          if (!Object.prototype.hasOwnProperty.call(err, "metadata")) {
            err.metadata = metadata;
          }
          this.sendError(err);
          return;
        }
        try {
          const response = this.serializeMessage(value);
          this.write(response);
          this.sendStatus({ code: constants_1.Status.OK, details: "OK", metadata });
        } catch (err2) {
          err2.code = constants_1.Status.INTERNAL;
          this.sendError(err2);
        }
      }
      sendStatus(statusObj) {
        var _a;
        this.emit("callEnd", statusObj.code);
        this.emit("streamEnd", statusObj.code === constants_1.Status.OK);
        if (this.checkCancelled()) {
          return;
        }
        trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " ended with status code: " + constants_1.Status[statusObj.code] + " details: " + statusObj.details);
        clearTimeout(this.deadlineTimer);
        if (!this.wantTrailers) {
          this.wantTrailers = true;
          this.stream.once("wantTrailers", () => {
            const trailersToSend = Object.assign({
              [GRPC_STATUS_HEADER]: statusObj.code,
              [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)
            }, statusObj.metadata.toHttp2Headers());
            this.stream.sendTrailers(trailersToSend);
          });
          this.sendMetadata();
          this.stream.end();
        }
      }
      sendError(error2) {
        const status = {
          code: constants_1.Status.UNKNOWN,
          details: "message" in error2 ? error2.message : "Unknown Error",
          metadata: "metadata" in error2 && error2.metadata !== void 0 ? error2.metadata : new metadata_1.Metadata()
        };
        if ("code" in error2 && typeof error2.code === "number" && Number.isInteger(error2.code)) {
          status.code = error2.code;
          if ("details" in error2 && typeof error2.details === "string") {
            status.details = error2.details;
          }
        }
        this.sendStatus(status);
      }
      write(chunk) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {
          this.sendError({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`
          });
          return;
        }
        this.sendMetadata();
        this.emit("sendMessage");
        return this.stream.write(chunk);
      }
      resume() {
        this.stream.resume();
      }
      setupSurfaceCall(call) {
        this.once("cancelled", (reason) => {
          call.cancelled = true;
          call.emit("cancelled", reason);
        });
      }
      setupReadable(readable2, encoding) {
        const decoder = new stream_decoder_1.StreamDecoder();
        let readsDone = false;
        let pendingMessageProcessing = false;
        let pushedEnd = false;
        const maybePushEnd = () => {
          if (!pushedEnd && readsDone && !pendingMessageProcessing) {
            pushedEnd = true;
            this.pushOrBufferMessage(readable2, null);
          }
        };
        this.stream.on("data", async (data) => {
          const messages = decoder.write(data);
          pendingMessageProcessing = true;
          this.stream.pause();
          for (const message of messages) {
            if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {
              this.sendError({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`
              });
              return;
            }
            this.emit("receiveMessage");
            const compressed = message.readUInt8(0) === 1;
            const compressedMessageEncoding = compressed ? encoding : "identity";
            const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);
            if (!decompressedMessage)
              return;
            this.pushOrBufferMessage(readable2, decompressedMessage);
          }
          pendingMessageProcessing = false;
          this.stream.resume();
          maybePushEnd();
        });
        this.stream.once("end", () => {
          readsDone = true;
          maybePushEnd();
        });
      }
      consumeUnpushedMessages(readable2) {
        this.canPush = true;
        while (this.messagesToPush.length > 0) {
          const nextMessage = this.messagesToPush.shift();
          const canPush = readable2.push(nextMessage);
          if (nextMessage === null || canPush === false) {
            this.canPush = false;
            break;
          }
        }
        return this.canPush;
      }
      pushOrBufferMessage(readable2, messageBytes) {
        if (this.isPushPending) {
          this.bufferedMessages.push(messageBytes);
        } else {
          this.pushMessage(readable2, messageBytes);
        }
      }
      async pushMessage(readable2, messageBytes) {
        if (messageBytes === null) {
          trace("Received end of stream");
          if (this.canPush) {
            readable2.push(null);
          } else {
            this.messagesToPush.push(null);
          }
          return;
        }
        trace("Received message of length " + messageBytes.length);
        this.isPushPending = true;
        try {
          const deserialized = await this.deserializeMessage(messageBytes);
          if (this.canPush) {
            if (!readable2.push(deserialized)) {
              this.canPush = false;
              this.stream.pause();
            }
          } else {
            this.messagesToPush.push(deserialized);
          }
        } catch (error2) {
          this.bufferedMessages.length = 0;
          if (!("code" in error2 && typeof error2.code === "number" && Number.isInteger(error2.code) && error2.code >= constants_1.Status.OK && error2.code <= constants_1.Status.UNAUTHENTICATED)) {
            error2.code = constants_1.Status.INTERNAL;
          }
          readable2.emit("error", error2);
        }
        this.isPushPending = false;
        if (this.bufferedMessages.length > 0) {
          this.pushMessage(readable2, this.bufferedMessages.shift());
        }
      }
      getPeer() {
        const socket = this.stream.session.socket;
        if (socket.remoteAddress) {
          if (socket.remotePort) {
            return `${socket.remoteAddress}:${socket.remotePort}`;
          } else {
            return socket.remoteAddress;
          }
        } else {
          return "unknown";
        }
      }
      getDeadline() {
        return this.deadline;
      }
    };
    exports2.Http2ServerCallStream = Http2ServerCallStream;
    function handleExpiredDeadline(call) {
      const err = new Error("Deadline exceeded");
      err.code = constants_1.Status.DEADLINE_EXCEEDED;
      call.sendError(err);
      call.cancelled = true;
      call.emit("cancelled", "deadline");
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerCredentials = void 0;
    var tls_helpers_1 = require_tls_helpers();
    var ServerCredentials = class {
      static createInsecure() {
        return new InsecureServerCredentials();
      }
      static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
          throw new TypeError("rootCerts must be null or a Buffer");
        }
        if (!Array.isArray(keyCertPairs)) {
          throw new TypeError("keyCertPairs must be an array");
        }
        if (typeof checkClientCertificate !== "boolean") {
          throw new TypeError("checkClientCertificate must be a boolean");
        }
        const cert = [];
        const key2 = [];
        for (let i2 = 0; i2 < keyCertPairs.length; i2++) {
          const pair = keyCertPairs[i2];
          if (pair === null || typeof pair !== "object") {
            throw new TypeError(`keyCertPair[${i2}] must be an object`);
          }
          if (!Buffer.isBuffer(pair.private_key)) {
            throw new TypeError(`keyCertPair[${i2}].private_key must be a Buffer`);
          }
          if (!Buffer.isBuffer(pair.cert_chain)) {
            throw new TypeError(`keyCertPair[${i2}].cert_chain must be a Buffer`);
          }
          cert.push(pair.cert_chain);
          key2.push(pair.private_key);
        }
        return new SecureServerCredentials({
          ca: rootCerts || tls_helpers_1.getDefaultRootsData() || void 0,
          cert,
          key: key2,
          requestCert: checkClientCertificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      }
    };
    exports2.ServerCredentials = ServerCredentials;
    var InsecureServerCredentials = class extends ServerCredentials {
      _isSecure() {
        return false;
      }
      _getSettings() {
        return null;
      }
    };
    var SecureServerCredentials = class extends ServerCredentials {
      constructor(options) {
        super();
        this.options = options;
      }
      _isSecure() {
        return true;
      }
      _getSettings() {
        return this.options;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var http22 = require("http2");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var server_call_1 = require_server_call();
    var server_credentials_1 = require_server_credentials();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var channelz_1 = require_channelz();
    var TRACER_NAME = "server";
    function noop3() {
    }
    function getUnimplementedStatusResponse(methodName) {
      return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`,
        metadata: new metadata_1.Metadata()
      };
    }
    function getDefaultHandler(handlerType, methodName) {
      const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
      switch (handlerType) {
        case "unary":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "clientStream":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "serverStream":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        case "bidi":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        default:
          throw new Error(`Invalid handlerType ${handlerType}`);
      }
    }
    var Server2 = class {
      constructor(options) {
        this.http2ServerList = [];
        this.handlers = new Map();
        this.sessions = new Map();
        this.started = false;
        this.channelzEnabled = true;
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.options = options !== null && options !== void 0 ? options : {};
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Server created");
        }
        this.trace("Server constructed");
      }
      getChannelzInfo() {
        return {
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          listenerChildren: this.listenerChildrenTracker.getChildLists(),
          sessionChildren: this.sessionChildrenTracker.getChildLists()
        };
      }
      getChannelzSessionInfoGetter(session) {
        return () => {
          var _a, _b, _c;
          const sessionInfo = this.sessions.get(session);
          const sessionSocket = session.socket;
          const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
          const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;
          let tlsInfo;
          if (session.encrypted) {
            const tlsSocket = sessionSocket;
            const cipherInfo = tlsSocket.getCipher();
            const certificate = tlsSocket.getCertificate();
            const peerCertificate = tlsSocket.getPeerCertificate();
            tlsInfo = {
              cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
              cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
              localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
              remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
            };
          } else {
            tlsInfo = null;
          }
          const socketInfo = {
            remoteAddress,
            localAddress,
            security: tlsInfo,
            remoteName: null,
            streamsStarted: sessionInfo.streamTracker.callsStarted,
            streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
            streamsFailed: sessionInfo.streamTracker.callsFailed,
            messagesSent: sessionInfo.messagesSent,
            messagesReceived: sessionInfo.messagesReceived,
            keepAlivesSent: 0,
            lastLocalStreamCreatedTimestamp: null,
            lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
            lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
            lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
            localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
            remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null
          };
          return socketInfo;
        };
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + text);
      }
      addProtoService() {
        throw new Error("Not implemented. Use addService() instead");
      }
      addService(service, implementation) {
        if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
          throw new Error("addService() requires two objects as arguments");
        }
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) {
          throw new Error("Cannot add an empty service to a server");
        }
        serviceKeys.forEach((name4) => {
          const attrs = service[name4];
          let methodType;
          if (attrs.requestStream) {
            if (attrs.responseStream) {
              methodType = "bidi";
            } else {
              methodType = "clientStream";
            }
          } else {
            if (attrs.responseStream) {
              methodType = "serverStream";
            } else {
              methodType = "unary";
            }
          }
          let implFn = implementation[name4];
          let impl;
          if (implFn === void 0 && typeof attrs.originalName === "string") {
            implFn = implementation[attrs.originalName];
          }
          if (implFn !== void 0) {
            impl = implFn.bind(implementation);
          } else {
            impl = getDefaultHandler(methodType, name4);
          }
          const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
          if (success === false) {
            throw new Error(`Method handler for ${attrs.path} already provided.`);
          }
        });
      }
      removeService(service) {
        if (service === null || typeof service !== "object") {
          throw new Error("removeService() requires object as argument");
        }
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name4) => {
          const attrs = service[name4];
          this.unregister(attrs.path);
        });
      }
      bind(port2, creds) {
        throw new Error("Not implemented. Use bindAsync() instead");
      }
      bindAsync(port2, creds, callback) {
        if (this.started === true) {
          throw new Error("server is already started");
        }
        if (typeof port2 !== "string") {
          throw new TypeError("port must be a string");
        }
        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
          throw new TypeError("creds must be a ServerCredentials object");
        }
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        const initialPortUri = uri_parser_1.parseUri(port2);
        if (initialPortUri === null) {
          throw new Error(`Could not parse port "${port2}"`);
        }
        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);
        if (portUri === null) {
          throw new Error(`Could not get a default scheme for port "${port2}"`);
        }
        const serverOptions = {
          maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
        };
        if ("grpc-node.max_session_memory" in this.options) {
          serverOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        }
        if ("grpc.max_concurrent_streams" in this.options) {
          serverOptions.settings = {
            maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
          };
        }
        const deferredCallback = (error2, port3) => {
          process.nextTick(() => callback(error2, port3));
        };
        const setupServer = () => {
          let http2Server;
          if (creds._isSecure()) {
            const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
            http2Server = http22.createSecureServer(secureServerOptions);
            http2Server.on("secureConnection", (socket) => {
              socket.on("error", (e2) => {
                this.trace("An incoming TLS connection closed with error: " + e2.message);
              });
            });
          } else {
            http2Server = http22.createServer(serverOptions);
          }
          http2Server.setTimeout(0, noop3);
          this._setupHandlers(http2Server);
          return http2Server;
        };
        const bindSpecificPort = (addressList, portNum, previousCount) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: portNum, count: previousCount });
          }
          return Promise.all(addressList.map((address) => {
            this.trace("Attempting to bind " + subchannel_address_1.subchannelAddressToString(address));
            let addr;
            if (subchannel_address_1.isTcpSubchannelAddress(address)) {
              addr = {
                host: address.host,
                port: portNum
              };
            } else {
              addr = address;
            }
            const http2Server = setupServer();
            return new Promise((resolve2, reject) => {
              const onError2 = (err) => {
                this.trace("Failed to bind " + subchannel_address_1.subchannelAddressToString(address) + " with error " + err.message);
                resolve2(err);
              };
              http2Server.once("error", onError2);
              http2Server.listen(addr, () => {
                const boundAddress = http2Server.address();
                let boundSubchannelAddress;
                if (typeof boundAddress === "string") {
                  boundSubchannelAddress = {
                    path: boundAddress
                  };
                } else {
                  boundSubchannelAddress = {
                    host: boundAddress.address,
                    port: boundAddress.port
                  };
                }
                let channelzRef;
                channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {
                  return {
                    localAddress: boundSubchannelAddress,
                    remoteAddress: null,
                    security: null,
                    remoteName: null,
                    streamsStarted: 0,
                    streamsSucceeded: 0,
                    streamsFailed: 0,
                    messagesSent: 0,
                    messagesReceived: 0,
                    keepAlivesSent: 0,
                    lastLocalStreamCreatedTimestamp: null,
                    lastRemoteStreamCreatedTimestamp: null,
                    lastMessageSentTimestamp: null,
                    lastMessageReceivedTimestamp: null,
                    localFlowControlWindow: null,
                    remoteFlowControlWindow: null
                  };
                }, this.channelzEnabled);
                if (this.channelzEnabled) {
                  this.listenerChildrenTracker.refChild(channelzRef);
                }
                this.http2ServerList.push({ server: http2Server, channelzRef });
                this.trace("Successfully bound " + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));
                resolve2("port" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);
                http2Server.removeListener("error", onError2);
              });
            });
          })).then((results) => {
            let count = 0;
            for (const result of results) {
              if (typeof result === "number") {
                count += 1;
                if (result !== portNum) {
                  throw new Error("Invalid state: multiple port numbers added from single address");
                }
              }
            }
            return {
              port: portNum,
              count: count + previousCount
            };
          });
        };
        const bindWildcardPort = (addressList) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: 0, count: 0 });
          }
          const address = addressList[0];
          const http2Server = setupServer();
          return new Promise((resolve2, reject) => {
            const onError2 = (err) => {
              this.trace("Failed to bind " + subchannel_address_1.subchannelAddressToString(address) + " with error " + err.message);
              resolve2(bindWildcardPort(addressList.slice(1)));
            };
            http2Server.once("error", onError2);
            http2Server.listen(address, () => {
              const boundAddress = http2Server.address();
              const boundSubchannelAddress = {
                host: boundAddress.address,
                port: boundAddress.port
              };
              let channelzRef;
              channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => {
                return {
                  localAddress: boundSubchannelAddress,
                  remoteAddress: null,
                  security: null,
                  remoteName: null,
                  streamsStarted: 0,
                  streamsSucceeded: 0,
                  streamsFailed: 0,
                  messagesSent: 0,
                  messagesReceived: 0,
                  keepAlivesSent: 0,
                  lastLocalStreamCreatedTimestamp: null,
                  lastRemoteStreamCreatedTimestamp: null,
                  lastMessageSentTimestamp: null,
                  lastMessageReceivedTimestamp: null,
                  localFlowControlWindow: null,
                  remoteFlowControlWindow: null
                };
              }, this.channelzEnabled);
              if (this.channelzEnabled) {
                this.listenerChildrenTracker.refChild(channelzRef);
              }
              this.http2ServerList.push({ server: http2Server, channelzRef });
              this.trace("Successfully bound " + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));
              resolve2(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));
              http2Server.removeListener("error", onError2);
            });
          });
        };
        const resolverListener = {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {
            resolverListener.onSuccessfulResolution = () => {
            };
            if (addressList.length === 0) {
              deferredCallback(new Error(`No addresses resolved for port ${port2}`), 0);
              return;
            }
            let bindResultPromise;
            if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {
              if (addressList[0].port === 0) {
                bindResultPromise = bindWildcardPort(addressList);
              } else {
                bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
              }
            } else {
              bindResultPromise = bindSpecificPort(addressList, 1, 0);
            }
            bindResultPromise.then((bindResult) => {
              if (bindResult.count === 0) {
                const errorString = `No address added out of total ${addressList.length} resolved`;
                logging.log(constants_1.LogVerbosity.ERROR, errorString);
                deferredCallback(new Error(errorString), 0);
              } else {
                if (bindResult.count < addressList.length) {
                  logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                }
                deferredCallback(null, bindResult.port);
              }
            }, (error2) => {
              const errorString = `No address added out of total ${addressList.length} resolved`;
              logging.log(constants_1.LogVerbosity.ERROR, errorString);
              deferredCallback(new Error(errorString), 0);
            });
          },
          onError: (error2) => {
            deferredCallback(new Error(error2.details), 0);
          }
        };
        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);
        resolver.updateResolution();
      }
      forceShutdown() {
        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {
          if (http2Server.listening) {
            http2Server.close(() => {
              if (this.channelzEnabled) {
                this.listenerChildrenTracker.unrefChild(ref);
                channelz_1.unregisterChannelzRef(ref);
              }
            });
          }
        }
        this.started = false;
        this.sessions.forEach((channelzInfo, session) => {
          session.destroy(http22.constants.NGHTTP2_CANCEL);
        });
        this.sessions.clear();
        if (this.channelzEnabled) {
          channelz_1.unregisterChannelzRef(this.channelzRef);
        }
      }
      register(name4, handler, serialize, deserialize, type) {
        if (this.handlers.has(name4)) {
          return false;
        }
        this.handlers.set(name4, {
          func: handler,
          serialize,
          deserialize,
          type,
          path: name4
        });
        return true;
      }
      unregister(name4) {
        return this.handlers.delete(name4);
      }
      start() {
        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server }) => http2Server.listening !== true)) {
          throw new Error("server must be bound in order to start");
        }
        if (this.started === true) {
          throw new Error("server is already started");
        }
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Starting");
        }
        this.started = true;
      }
      tryShutdown(callback) {
        const wrappedCallback = (error2) => {
          if (this.channelzEnabled) {
            channelz_1.unregisterChannelzRef(this.channelzRef);
          }
          callback(error2);
        };
        let pendingChecks = 0;
        function maybeCallback() {
          pendingChecks--;
          if (pendingChecks === 0) {
            wrappedCallback();
          }
        }
        this.started = false;
        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {
          if (http2Server.listening) {
            pendingChecks++;
            http2Server.close(() => {
              if (this.channelzEnabled) {
                this.listenerChildrenTracker.unrefChild(ref);
                channelz_1.unregisterChannelzRef(ref);
              }
              maybeCallback();
            });
          }
        }
        this.sessions.forEach((channelzInfo, session) => {
          if (!session.closed) {
            pendingChecks += 1;
            session.close(maybeCallback);
          }
        });
        if (pendingChecks === 0) {
          wrappedCallback();
        }
      }
      addHttp2Port() {
        throw new Error("Not yet implemented");
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      _setupHandlers(http2Server) {
        if (http2Server === null) {
          return;
        }
        http2Server.on("stream", (stream, headers) => {
          var _a;
          const channelzSessionInfo = this.sessions.get(stream.session);
          if (this.channelzEnabled) {
            this.callTracker.addCallStarted();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
          }
          const contentType = headers[http22.constants.HTTP2_HEADER_CONTENT_TYPE];
          if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
            stream.respond({
              [http22.constants.HTTP2_HEADER_STATUS]: http22.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
            }, { endStream: true });
            this.callTracker.addCallFailed();
            if (this.channelzEnabled) {
              channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            }
            return;
          }
          let call = null;
          try {
            const path2 = headers[http22.constants.HTTP2_HEADER_PATH];
            const serverAddress = http2Server.address();
            let serverAddressString = "null";
            if (serverAddress) {
              if (typeof serverAddress === "string") {
                serverAddressString = serverAddress;
              } else {
                serverAddressString = serverAddress.address + ":" + serverAddress.port;
              }
            }
            this.trace("Received call to method " + path2 + " at address " + serverAddressString);
            const handler = this.handlers.get(path2);
            if (handler === void 0) {
              this.trace("No handler registered for method " + path2 + ". Sending UNIMPLEMENTED status.");
              throw getUnimplementedStatusResponse(path2);
            }
            call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);
            call.once("callEnd", (code) => {
              if (code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
              } else {
                this.callTracker.addCallFailed();
              }
            });
            if (this.channelzEnabled && channelzSessionInfo) {
              call.once("streamEnd", (success) => {
                if (success) {
                  channelzSessionInfo.streamTracker.addCallSucceeded();
                } else {
                  channelzSessionInfo.streamTracker.addCallFailed();
                }
              });
              call.on("sendMessage", () => {
                channelzSessionInfo.messagesSent += 1;
                channelzSessionInfo.lastMessageSentTimestamp = new Date();
              });
              call.on("receiveMessage", () => {
                channelzSessionInfo.messagesReceived += 1;
                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
              });
            }
            const metadata = call.receiveMetadata(headers);
            const encoding = (_a = metadata.get("grpc-encoding")[0]) !== null && _a !== void 0 ? _a : "identity";
            metadata.remove("grpc-encoding");
            switch (handler.type) {
              case "unary":
                handleUnary(call, handler, metadata, encoding);
                break;
              case "clientStream":
                handleClientStreaming(call, handler, metadata, encoding);
                break;
              case "serverStream":
                handleServerStreaming(call, handler, metadata, encoding);
                break;
              case "bidi":
                handleBidiStreaming(call, handler, metadata, encoding);
                break;
              default:
                throw new Error(`Unknown handler type: ${handler.type}`);
            }
          } catch (err) {
            if (!call) {
              call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
              if (this.channelzEnabled) {
                this.callTracker.addCallFailed();
                channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
              }
            }
            if (err.code === void 0) {
              err.code = constants_1.Status.INTERNAL;
            }
            call.sendError(err);
          }
        });
        http2Server.on("session", (session) => {
          var _a;
          if (!this.started) {
            session.destroy();
            return;
          }
          let channelzRef;
          channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : "unknown", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);
          const channelzSessionInfo = {
            ref: channelzRef,
            streamTracker: new channelz_1.ChannelzCallTracker(),
            messagesSent: 0,
            messagesReceived: 0,
            lastMessageSentTimestamp: null,
            lastMessageReceivedTimestamp: null
          };
          this.sessions.set(session, channelzSessionInfo);
          const clientAddress = session.socket.remoteAddress;
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Connection established by client " + clientAddress);
            this.sessionChildrenTracker.refChild(channelzRef);
          }
          session.on("close", () => {
            if (this.channelzEnabled) {
              this.channelzTrace.addTrace("CT_INFO", "Connection dropped by client " + clientAddress);
              this.sessionChildrenTracker.unrefChild(channelzRef);
              channelz_1.unregisterChannelzRef(channelzRef);
            }
            this.sessions.delete(session);
          });
        });
      }
    };
    exports2.Server = Server2;
    async function handleUnary(call, handler, metadata, encoding) {
      const request = await call.receiveUnaryMessage(encoding);
      if (request === void 0 || call.cancelled) {
        return;
      }
      const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
      handler.func(emitter, (err, value, trailer, flags) => {
        call.sendUnaryMessage(err, value, trailer, flags);
      });
    }
    function handleClientStreaming(call, handler, metadata, encoding) {
      const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);
      function respond2(err, value, trailer, flags) {
        stream.destroy();
        call.sendUnaryMessage(err, value, trailer, flags);
      }
      if (call.cancelled) {
        return;
      }
      stream.on("error", respond2);
      handler.func(stream, respond2);
    }
    async function handleServerStreaming(call, handler, metadata, encoding) {
      const request = await call.receiveUnaryMessage(encoding);
      if (request === void 0 || call.cancelled) {
        return;
      }
      const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);
      handler.func(stream);
    }
    function handleBidiStreaming(call, handler, metadata, encoding) {
      const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);
      if (call.cancelled) {
        return;
      }
      handler.func(stream);
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/status-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StatusBuilder = void 0;
    var StatusBuilder = class {
      constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
      }
      withCode(code) {
        this.code = code;
        return this;
      }
      withDetails(details) {
        this.details = details;
        return this;
      }
      withMetadata(metadata) {
        this.metadata = metadata;
        return this;
      }
      build() {
        const status = {};
        if (this.code !== null) {
          status.code = this.code;
        }
        if (this.details !== null) {
          status.details = this.details;
        }
        if (this.metadata !== null) {
          status.metadata = this.metadata;
        }
        return status;
      }
    };
    exports2.StatusBuilder = StatusBuilder;
  }
});

// node_modules/@grpc/grpc-js/build/src/duration.js
var require_duration = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/duration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDuration = exports2.durationToMs = exports2.msToDuration = void 0;
    function msToDuration(millis) {
      return {
        seconds: millis / 1e3 | 0,
        nanos: millis % 1e3 * 1e6 | 0
      };
    }
    exports2.msToDuration = msToDuration;
    function durationToMs(duration) {
      return duration.seconds * 1e3 + duration.nanos / 1e6 | 0;
    }
    exports2.durationToMs = durationToMs;
    function isDuration(value) {
      return typeof value.seconds === "number" && typeof value.nanos === "number";
    }
    exports2.isDuration = isDuration;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-interface.js
var require_subchannel_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseSubchannelWrapper = void 0;
    var BaseSubchannelWrapper = class {
      constructor(child) {
        this.child = child;
      }
      getConnectivityState() {
        return this.child.getConnectivityState();
      }
      addConnectivityStateListener(listener) {
        this.child.addConnectivityStateListener(listener);
      }
      removeConnectivityStateListener(listener) {
        this.child.removeConnectivityStateListener(listener);
      }
      startConnecting() {
        this.child.startConnecting();
      }
      getAddress() {
        return this.child.getAddress();
      }
      ref() {
        this.child.ref();
      }
      unref() {
        this.child.unref();
      }
      getChannelzRef() {
        return this.child.getChannelzRef();
      }
      getRealSubchannel() {
        return this.child.getRealSubchannel();
      }
    };
    exports2.BaseSubchannelWrapper = BaseSubchannelWrapper;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js
var require_load_balancer_outlier_detection = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.OutlierDetectionLoadBalancer = exports2.OutlierDetectionLoadBalancingConfig = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var duration_1 = require_duration();
    var experimental_1 = require_experimental();
    var filter_1 = require_filter();
    var load_balancer_1 = require_load_balancer();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var subchannel_interface_1 = require_subchannel_interface();
    var TYPE_NAME = "outlier_detection";
    var OUTLIER_DETECTION_ENABLED = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION === "true";
    var defaultSuccessRateEjectionConfig = {
      stdev_factor: 1900,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 100
    };
    var defaultFailurePercentageEjectionConfig = {
      threshold: 85,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 50
    };
    function validateFieldType(obj, fieldName, expectedType, objectName) {
      if (fieldName in obj && typeof obj[fieldName] !== expectedType) {
        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
      }
    }
    function validatePositiveDuration(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      if (fieldName in obj) {
        if (!duration_1.isDuration(obj[fieldName])) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
        }
        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576e6 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
        }
      }
    }
    function validatePercentage(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      validateFieldType(obj, fieldName, "number", objectName);
      if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
      }
    }
    var OutlierDetectionLoadBalancingConfig = class {
      constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
        this.childPolicy = childPolicy;
        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 1e4;
        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 3e4;
        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 3e5;
        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      toJsonObject() {
        return {
          interval: duration_1.msToDuration(this.intervalMs),
          base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),
          max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),
          max_ejection_percent: this.maxEjectionPercent,
          success_rate_ejection: this.successRateEjection,
          failure_percentage_ejection: this.failurePercentageEjection,
          child_policy: this.childPolicy.map((policy) => policy.toJsonObject())
        };
      }
      getIntervalMs() {
        return this.intervalMs;
      }
      getBaseEjectionTimeMs() {
        return this.baseEjectionTimeMs;
      }
      getMaxEjectionTimeMs() {
        return this.maxEjectionTimeMs;
      }
      getMaxEjectionPercent() {
        return this.maxEjectionPercent;
      }
      getSuccessRateEjectionConfig() {
        return this.successRateEjection;
      }
      getFailurePercentageEjectionConfig() {
        return this.failurePercentageEjection;
      }
      getChildPolicy() {
        return this.childPolicy;
      }
      copyWithChildPolicy(childPolicy) {
        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);
      }
      static createFromJson(obj) {
        var _a;
        validatePositiveDuration(obj, "interval");
        validatePositiveDuration(obj, "base_ejection_time");
        validatePositiveDuration(obj, "max_ejection_time");
        validatePercentage(obj, "max_ejection_percent");
        if ("success_rate_ejection" in obj) {
          if (typeof obj.success_rate_ejection !== "object") {
            throw new Error("outlier detection config success_rate_ejection must be an object");
          }
          validateFieldType(obj.success_rate_ejection, "stdev_factor", "number", "success_rate_ejection");
          validatePercentage(obj.success_rate_ejection, "enforcement_percentage", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "minimum_hosts", "number", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "request_volume", "number", "success_rate_ejection");
        }
        if ("failure_percentage_ejection" in obj) {
          if (typeof obj.failure_percentage_ejection !== "object") {
            throw new Error("outlier detection config failure_percentage_ejection must be an object");
          }
          validatePercentage(obj.failure_percentage_ejection, "threshold", "failure_percentage_ejection");
          validatePercentage(obj.failure_percentage_ejection, "enforcement_percentage", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "minimum_hosts", "number", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "request_volume", "number", "failure_percentage_ejection");
        }
        return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));
      }
    };
    exports2.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
    var OutlierDetectionSubchannelWrapper = class extends subchannel_interface_1.BaseSubchannelWrapper {
      constructor(childSubchannel, mapEntry) {
        super(childSubchannel);
        this.mapEntry = mapEntry;
        this.childSubchannelState = connectivity_state_1.ConnectivityState.IDLE;
        this.stateListeners = [];
        this.ejected = false;
        this.refCount = 0;
        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {
          this.childSubchannelState = newState;
          if (!this.ejected) {
            for (const listener of this.stateListeners) {
              listener(this, previousState, newState);
            }
          }
        });
      }
      addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
      }
      removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.stateListeners.splice(listenerIndex, 1);
        }
      }
      ref() {
        this.child.ref();
        this.refCount += 1;
      }
      unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
          if (this.mapEntry) {
            const index = this.mapEntry.subchannelWrappers.indexOf(this);
            if (index >= 0) {
              this.mapEntry.subchannelWrappers.splice(index, 1);
            }
          }
        }
      }
      eject() {
        this.ejected = true;
        for (const listener of this.stateListeners) {
          listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
        }
      }
      uneject() {
        this.ejected = false;
        for (const listener of this.stateListeners) {
          listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);
        }
      }
      getMapEntry() {
        return this.mapEntry;
      }
      getWrappedSubchannel() {
        return this.child;
      }
    };
    function createEmptyBucket() {
      return {
        success: 0,
        failure: 0
      };
    }
    var CallCounter = class {
      constructor() {
        this.activeBucket = createEmptyBucket();
        this.inactiveBucket = createEmptyBucket();
      }
      addSuccess() {
        this.activeBucket.success += 1;
      }
      addFailure() {
        this.activeBucket.failure += 1;
      }
      switchBuckets() {
        this.inactiveBucket = this.activeBucket;
        this.activeBucket = createEmptyBucket();
      }
      getLastSuccesses() {
        return this.inactiveBucket.success;
      }
      getLastFailures() {
        return this.inactiveBucket.failure;
      }
    };
    var OutlierDetectionCounterFilter = class extends filter_1.BaseFilter {
      constructor(callCounter) {
        super();
        this.callCounter = callCounter;
      }
      receiveTrailers(status) {
        if (status.code === constants_1.Status.OK) {
          this.callCounter.addSuccess();
        } else {
          this.callCounter.addFailure();
        }
        return status;
      }
    };
    var OutlierDetectionCounterFilterFactory = class {
      constructor(callCounter) {
        this.callCounter = callCounter;
      }
      createFilter(callStream) {
        return new OutlierDetectionCounterFilter(this.callCounter);
      }
    };
    var OutlierDetectionPicker = class {
      constructor(wrappedPicker) {
        this.wrappedPicker = wrappedPicker;
      }
      pick(pickArgs) {
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
          const subchannelWrapper = wrappedPick.subchannel;
          const mapEntry = subchannelWrapper.getMapEntry();
          if (mapEntry) {
            return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), extraFilterFactories: [...wrappedPick.extraFilterFactories, new OutlierDetectionCounterFilterFactory(mapEntry.counter)] });
          } else {
            return wrappedPick;
          }
        } else {
          return wrappedPick;
        }
      }
    };
    var OutlierDetectionLoadBalancer = class {
      constructor(channelControlHelper) {
        this.addressMap = new Map();
        this.latestConfig = null;
        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {
          createSubchannel: (subchannelAddress, subchannelArgs) => {
            const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
            const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));
            const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
            mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
            return subchannelWrapper;
          },
          updateState: (connectivityState, picker) => {
            if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
              channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker));
            } else {
              channelControlHelper.updateState(connectivityState, picker);
            }
          }
        }));
        this.ejectionTimer = setInterval(() => {
        }, 0);
        clearInterval(this.ejectionTimer);
      }
      getCurrentEjectionPercent() {
        let ejectionCount = 0;
        for (const mapEntry of this.addressMap.values()) {
          if (mapEntry.currentEjectionTimestamp !== null) {
            ejectionCount += 1;
          }
        }
        return ejectionCount * 100 / this.addressMap.size;
      }
      runSuccessRateCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
        if (!successRateConfig) {
          return;
        }
        const targetRequestVolume = successRateConfig.request_volume;
        let addresesWithTargetVolume = 0;
        const successRates = [];
        for (const mapEntry of this.addressMap.values()) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures >= targetRequestVolume) {
            addresesWithTargetVolume += 1;
            successRates.push(successes / (successes + failures));
          }
        }
        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
          return;
        }
        const successRateMean = successRates.reduce((a, b) => a + b);
        let successRateVariance = 0;
        for (const rate of successRates) {
          const deviation = rate - successRateMean;
          successRateVariance += deviation * deviation;
        }
        const successRateStdev = Math.sqrt(successRateVariance);
        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1e3);
        for (const mapEntry of this.addressMap.values()) {
          if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures < targetRequestVolume) {
            continue;
          }
          const successRate = successes / (successes + failures);
          if (successRate < ejectionThreshold) {
            const randomNumber = Math.random() * 100;
            if (randomNumber < successRateConfig.enforcement_percentage) {
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      runFailurePercentageCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
        if (!failurePercentageConfig) {
          return;
        }
        if (this.addressMap.size < failurePercentageConfig.minimum_hosts) {
          return;
        }
        for (const mapEntry of this.addressMap.values()) {
          if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures < failurePercentageConfig.request_volume) {
            continue;
          }
          const failurePercentage = failures * 100 / (failures + successes);
          if (failurePercentage > failurePercentageConfig.threshold) {
            const randomNumber = Math.random() * 100;
            if (randomNumber < failurePercentageConfig.enforcement_percentage) {
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      eject(mapEntry, ejectionTimestamp) {
        mapEntry.currentEjectionTimestamp = new Date();
        mapEntry.ejectionTimeMultiplier += 1;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.eject();
        }
      }
      uneject(mapEntry) {
        mapEntry.currentEjectionTimestamp = null;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.uneject();
        }
      }
      runChecks() {
        const ejectionTimestamp = new Date();
        for (const mapEntry of this.addressMap.values()) {
          mapEntry.counter.switchBuckets();
        }
        if (!this.latestConfig) {
          return;
        }
        this.runSuccessRateCheck(ejectionTimestamp);
        this.runFailurePercentageCheck(ejectionTimestamp);
        for (const mapEntry of this.addressMap.values()) {
          if (mapEntry.currentEjectionTimestamp === null) {
            if (mapEntry.ejectionTimeMultiplier > 0) {
              mapEntry.ejectionTimeMultiplier -= 1;
            }
          } else {
            const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
            const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
            const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
            returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
            if (returnTime < new Date()) {
              this.uneject(mapEntry);
            }
          }
        }
      }
      updateAddressList(addressList, lbConfig, attributes) {
        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
          return;
        }
        const subchannelAddresses = new Set();
        for (const address of addressList) {
          subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));
        }
        for (const address of subchannelAddresses) {
          if (!this.addressMap.has(address)) {
            this.addressMap.set(address, {
              counter: new CallCounter(),
              currentEjectionTimestamp: null,
              ejectionTimeMultiplier: 0,
              subchannelWrappers: []
            });
          }
        }
        for (const key2 of this.addressMap.keys()) {
          if (!subchannelAddresses.has(key2)) {
            this.addressMap.delete(key2);
          }
        }
        const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);
        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);
        if (this.latestConfig === null || this.latestConfig.getIntervalMs() !== lbConfig.getIntervalMs()) {
          clearInterval(this.ejectionTimer);
          this.ejectionTimer = setInterval(() => this.runChecks(), lbConfig.getIntervalMs());
        }
        this.latestConfig = lbConfig;
      }
      exitIdle() {
        this.childBalancer.exitIdle();
      }
      resetBackoff() {
        this.childBalancer.resetBackoff();
      }
      destroy() {
        this.childBalancer.destroy();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
    function setup() {
      if (OUTLIER_DETECTION_ENABLED) {
        experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
      }
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/experimental.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var logging_1 = require_logging();
    Object.defineProperty(exports2, "trace", { enumerable: true, get: function() {
      return logging_1.trace;
    } });
    var resolver_1 = require_resolver();
    Object.defineProperty(exports2, "registerResolver", { enumerable: true, get: function() {
      return resolver_1.registerResolver;
    } });
    var uri_parser_1 = require_uri_parser();
    Object.defineProperty(exports2, "uriToString", { enumerable: true, get: function() {
      return uri_parser_1.uriToString;
    } });
    var duration_1 = require_duration();
    Object.defineProperty(exports2, "durationToMs", { enumerable: true, get: function() {
      return duration_1.durationToMs;
    } });
    var backoff_timeout_1 = require_backoff_timeout();
    Object.defineProperty(exports2, "BackoffTimeout", { enumerable: true, get: function() {
      return backoff_timeout_1.BackoffTimeout;
    } });
    var load_balancer_1 = require_load_balancer();
    Object.defineProperty(exports2, "createChildChannelControlHelper", { enumerable: true, get: function() {
      return load_balancer_1.createChildChannelControlHelper;
    } });
    Object.defineProperty(exports2, "registerLoadBalancerType", { enumerable: true, get: function() {
      return load_balancer_1.registerLoadBalancerType;
    } });
    Object.defineProperty(exports2, "getFirstUsableConfig", { enumerable: true, get: function() {
      return load_balancer_1.getFirstUsableConfig;
    } });
    Object.defineProperty(exports2, "validateLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_1.validateLoadBalancingConfig;
    } });
    var subchannel_address_1 = require_subchannel_address();
    Object.defineProperty(exports2, "subchannelAddressToString", { enumerable: true, get: function() {
      return subchannel_address_1.subchannelAddressToString;
    } });
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    Object.defineProperty(exports2, "ChildLoadBalancerHandler", { enumerable: true, get: function() {
      return load_balancer_child_handler_1.ChildLoadBalancerHandler;
    } });
    var picker_1 = require_picker();
    Object.defineProperty(exports2, "UnavailablePicker", { enumerable: true, get: function() {
      return picker_1.UnavailablePicker;
    } });
    Object.defineProperty(exports2, "QueuePicker", { enumerable: true, get: function() {
      return picker_1.QueuePicker;
    } });
    Object.defineProperty(exports2, "PickResultType", { enumerable: true, get: function() {
      return picker_1.PickResultType;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "BaseFilter", { enumerable: true, get: function() {
      return filter_1.BaseFilter;
    } });
    var filter_stack_1 = require_filter_stack();
    Object.defineProperty(exports2, "FilterStackFactory", { enumerable: true, get: function() {
      return filter_stack_1.FilterStackFactory;
    } });
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "registerAdminService", { enumerable: true, get: function() {
      return admin_1.registerAdminService;
    } });
    var subchannel_interface_1 = require_subchannel_interface();
    Object.defineProperty(exports2, "BaseSubchannelWrapper", { enumerable: true, get: function() {
      return subchannel_interface_1.BaseSubchannelWrapper;
    } });
    var load_balancer_outlier_detection_1 = require_load_balancer_outlier_detection();
    Object.defineProperty(exports2, "OutlierDetectionLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig;
    } });
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-dns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var dns = require("dns");
    var util = require("util");
    var service_config_1 = require_service_config();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var net_1 = require("net");
    var backoff_timeout_1 = require_backoff_timeout();
    var TRACER_NAME = "dns_resolver";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var DEFAULT_PORT = 443;
    var DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 3e4;
    var resolveTxtPromise = util.promisify(dns.resolveTxt);
    var dnsLookupPromise = util.promisify(dns.lookup);
    function mergeArrays(...arrays) {
      const result = [];
      for (let i2 = 0; i2 < Math.max.apply(null, arrays.map((array) => array.length)); i2++) {
        for (const array of arrays) {
          if (i2 < array.length) {
            result.push(array[i2]);
          }
        }
      }
      return result;
    }
    var DnsResolver = class {
      constructor(target, listener, channelOptions) {
        var _a, _b, _c;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.continueResolving = false;
        this.isNextResolutionTimerRunning = false;
        trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
        const hostPort = uri_parser_1.splitHostPort(target.path);
        if (hostPort === null) {
          this.ipResult = null;
          this.dnsHostname = null;
          this.port = null;
        } else {
          if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {
            this.ipResult = [
              {
                host: hostPort.host,
                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
              }
            ];
            this.dnsHostname = null;
            this.port = null;
          } else {
            this.ipResult = null;
            this.dnsHostname = hostPort.host;
            this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
          }
        }
        this.percentage = Math.random() * 100;
        this.defaultResolutionError = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,
          metadata: new metadata_1.Metadata()
        };
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, backoffOptions);
        this.backoff.unref();
        this.minTimeBetweenResolutionsMs = (_c = channelOptions["grpc.dns_min_time_between_resolutions_ms"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
        this.nextResolutionTimer = setTimeout(() => {
        }, 0);
        clearTimeout(this.nextResolutionTimer);
      }
      startResolution() {
        if (this.ipResult !== null) {
          trace("Returning IP address for target " + uri_parser_1.uriToString(this.target));
          setImmediate(() => {
            this.backoff.reset();
            this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
          });
          return;
        }
        if (this.dnsHostname === null) {
          trace("Failed to parse DNS address " + uri_parser_1.uriToString(this.target));
          setImmediate(() => {
            this.listener.onError({
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,
              metadata: new metadata_1.Metadata()
            });
          });
        } else {
          trace("Looking up DNS hostname " + this.dnsHostname);
          this.latestLookupResult = null;
          const hostname = this.dnsHostname;
          this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });
          this.pendingLookupPromise.then((addressList) => {
            this.pendingLookupPromise = null;
            this.backoff.reset();
            this.backoff.stop();
            const ip4Addresses = addressList.filter((addr) => addr.family === 4);
            const ip6Addresses = addressList.filter((addr) => addr.family === 6);
            this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));
            const allAddressesString = "[" + this.latestLookupResult.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
            trace("Resolved addresses for target " + uri_parser_1.uriToString(this.target) + ": " + allAddressesString);
            if (this.latestLookupResult.length === 0) {
              this.listener.onError(this.defaultResolutionError);
              return;
            }
            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
          }, (err) => {
            trace("Resolution error for target " + uri_parser_1.uriToString(this.target) + ": " + err.message);
            this.pendingLookupPromise = null;
            this.stopNextResolutionTimer();
            this.listener.onError(this.defaultResolutionError);
          });
          if (this.pendingTxtPromise === null) {
            this.pendingTxtPromise = resolveTxtPromise(hostname);
            this.pendingTxtPromise.then((txtRecord) => {
              this.pendingTxtPromise = null;
              try {
                this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);
              } catch (err) {
                this.latestServiceConfigError = {
                  code: constants_1.Status.UNAVAILABLE,
                  details: "Parsing service config failed",
                  metadata: new metadata_1.Metadata()
                };
              }
              if (this.latestLookupResult !== null) {
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
              }
            }, (err) => {
            });
          }
        }
      }
      startNextResolutionTimer() {
        var _a, _b;
        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {
          this.stopNextResolutionTimer();
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.isNextResolutionTimerRunning = true;
      }
      stopNextResolutionTimer() {
        clearTimeout(this.nextResolutionTimer);
        this.isNextResolutionTimerRunning = false;
      }
      startResolutionWithBackoff() {
        this.startResolution();
        this.backoff.runOnce();
        this.startNextResolutionTimer();
      }
      updateResolution() {
        if (this.pendingLookupPromise === null) {
          if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
            this.continueResolving = true;
          } else {
            this.startResolutionWithBackoff();
          }
        }
      }
      destroy() {
        this.continueResolving = false;
        this.backoff.stop();
        this.stopNextResolutionTimer();
      }
      static getDefaultAuthority(target) {
        return target.path;
      }
    };
    function setup() {
      resolver_1.registerResolver("dns", DnsResolver);
      resolver_1.registerDefaultScheme("dns");
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-uds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var UdsResolver = class {
      constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.addresses = [];
        let path2;
        if (target.authority === "") {
          path2 = "/" + target.path;
        } else {
          path2 = target.path;
        }
        this.addresses = [{ path: path2 }];
      }
      updateResolution() {
        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return "localhost";
      }
    };
    function setup() {
      resolver_1.registerResolver("unix", UdsResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-ip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var net_1 = require("net");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var resolver_1 = require_resolver();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var TRACER_NAME = "ip_resolver";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var IPV4_SCHEME = "ipv4";
    var IPV6_SCHEME = "ipv6";
    var DEFAULT_PORT = 443;
    var IpResolver = class {
      constructor(target, listener, channelOptions) {
        var _a;
        this.target = target;
        this.listener = listener;
        this.addresses = [];
        this.error = null;
        trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Unrecognized scheme ${target.scheme} in IP resolver`,
            metadata: new metadata_1.Metadata()
          };
          return;
        }
        const pathList = target.path.split(",");
        for (const path2 of pathList) {
          const hostPort = uri_parser_1.splitHostPort(path2);
          if (hostPort === null) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path2}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          if (target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host) || target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host)) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path2}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          addresses.push({
            host: hostPort.host,
            port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
          });
        }
        this.addresses = addresses;
        trace("Parsed " + target.scheme + " address list " + this.addresses);
      }
      updateResolution() {
        process.nextTick(() => {
          if (this.error) {
            this.listener.onError(this.error);
          } else {
            this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});
          }
        });
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return target.path.split(",")[0];
      }
    };
    function setup() {
      resolver_1.registerResolver(IPV4_SCHEME, IpResolver);
      resolver_1.registerResolver(IPV6_SCHEME, IpResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.PickFirstLoadBalancer = exports2.PickFirstLoadBalancingConfig = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "pick_first";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "pick_first";
    var CONNECTION_DELAY_INTERVAL_MS = 250;
    var PickFirstLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      static createFromJson(obj) {
        return new PickFirstLoadBalancingConfig();
      }
    };
    exports2.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
    var PickFirstPicker = class {
      constructor(subchannel) {
        this.subchannel = subchannel;
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: this.subchannel,
          status: null,
          extraFilterFactories: [],
          onCallStarted: null
        };
      }
    };
    var PickFirstLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestAddressList = [];
        this.subchannels = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentSubchannelIndex = 0;
        this.currentPick = null;
        this.triedAllSubchannels = false;
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.startNextSubchannelConnecting();
          }
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            return;
          } else {
            if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {
              this.resetSubchannelList();
              this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
              return;
            }
            if (this.currentPick === null) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = connectivity_state_1.ConnectivityState.IDLE;
                }
                if (newLBState !== this.currentState) {
                  if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                    this.updateState(newLBState, new picker_1.UnavailablePicker());
                  } else {
                    this.updateState(newLBState, new picker_1.QueuePicker(this));
                  }
                }
              } else {
                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            }
          }
        };
        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {
          if (newState !== connectivity_state_1.ConnectivityState.READY) {
            this.currentPick = null;
            subchannel.unref();
            subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
            if (this.subchannels.length > 0) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = connectivity_state_1.ConnectivityState.IDLE;
                }
                if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                  this.updateState(newLBState, new picker_1.UnavailablePicker());
                } else {
                  this.updateState(newLBState, new picker_1.QueuePicker(this));
                }
              } else {
                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            } else {
              this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
            }
          }
        };
        this.connectionDelayTimeout = setTimeout(() => {
        }, 0);
        clearTimeout(this.connectionDelayTimeout);
      }
      startNextSubchannelConnecting() {
        if (this.triedAllSubchannels) {
          return;
        }
        for (const [index, subchannel] of this.subchannels.entries()) {
          if (index > this.currentSubchannelIndex) {
            const subchannelState = subchannel.getConnectivityState();
            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
              this.startConnecting(index);
              return;
            }
          }
        }
        this.triedAllSubchannels = true;
      }
      startConnecting(subchannelIndex) {
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
          trace("Start connecting to subchannel with address " + this.subchannels[subchannelIndex].getAddress());
          process.nextTick(() => {
            this.subchannels[subchannelIndex].startConnecting();
          });
        }
        this.connectionDelayTimeout = setTimeout(() => {
          this.startNextSubchannelConnecting();
        }, CONNECTION_DELAY_INTERVAL_MS);
      }
      pickSubchannel(subchannel) {
        trace("Pick subchannel with address " + subchannel.getAddress());
        if (this.currentPick !== null) {
          this.currentPick.unref();
          this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
        this.currentPick = subchannel;
        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
        subchannel.ref();
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
      }
      updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
          this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
        }
        this.currentSubchannelIndex = 0;
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
        this.triedAllSubchannels = false;
      }
      connectToAddressList() {
        this.resetSubchannelList();
        trace("Connect to address list " + this.latestAddressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));
        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
          this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        }
        for (const subchannel of this.subchannels) {
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
          if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            this.resetSubchannelList();
            return;
          }
        }
        for (const [index, subchannel] of this.subchannels.entries()) {
          const subchannelState = subchannel.getConnectivityState();
          if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
            this.startConnecting(index);
            if (this.currentPick === null) {
              this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
            return;
          }
        }
        if (this.currentPick === null) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        }
      }
      updateAddressList(addressList, lbConfig) {
        if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index) => addressList[index] === value)) {
          this.latestAddressList = addressList;
          this.connectToAddressList();
        }
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          if (this.latestAddressList.length > 0) {
            this.connectToAddressList();
          }
        }
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {
          this.channelControlHelper.requestReresolution();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
        if (this.currentPick !== null) {
          const currentPick = this.currentPick;
          currentPick.unref();
          currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
          this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.PickFirstLoadBalancer = PickFirstLoadBalancer;
    function setup() {
      load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
      load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.RoundRobinLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "round_robin";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "round_robin";
    var RoundRobinLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig();
      }
    };
    var RoundRobinPicker = class {
      constructor(subchannelList, nextIndex = 0) {
        this.subchannelList = subchannelList;
        this.nextIndex = nextIndex;
      }
      pick(pickArgs) {
        const pickedSubchannel = this.subchannelList[this.nextIndex];
        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: pickedSubchannel,
          status: null,
          extraFilterFactories: [],
          onCallStarted: null
        };
      }
      peekNextSubchannel() {
        return this.subchannelList[this.nextIndex];
      }
    };
    var RoundRobinLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.subchannels = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          this.calculateAndUpdateState();
          if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {
            this.channelControlHelper.requestReresolution();
            subchannel.startConnecting();
          }
        };
      }
      calculateAndUpdateState() {
        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {
          const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
          let index = 0;
          if (this.currentReadyPicker !== null) {
            index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
            if (index < 0) {
              index = 0;
            }
          }
          this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));
        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        } else {
          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
      }
      updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (newState === connectivity_state_1.ConnectivityState.READY) {
          this.currentReadyPicker = picker;
        } else {
          this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
          this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
        }
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
      }
      updateAddressList(addressList, lbConfig) {
        this.resetSubchannelList();
        trace("Connect to address list " + addressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));
        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
          const subchannelState = subchannel.getConnectivityState();
          this.subchannelStateCounts[subchannelState] += 1;
          if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            subchannel.startConnecting();
          }
        }
        this.calculateAndUpdateState();
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
    function setup() {
      load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.experimental = exports2.StatusBuilder = exports2.getClientChannel = exports2.ServerCredentials = exports2.Server = exports2.setLogVerbosity = exports2.setLogger = exports2.load = exports2.loadObject = exports2.CallCredentials = exports2.ChannelCredentials = exports2.waitForClientReady = exports2.closeClient = exports2.Channel = exports2.makeGenericClientConstructor = exports2.makeClientConstructor = exports2.loadPackageDefinition = exports2.Client = exports2.compressionAlgorithms = exports2.propagate = exports2.connectivityState = exports2.status = exports2.logVerbosity = exports2.Metadata = exports2.credentials = void 0;
    var call_credentials_1 = require_call_credentials();
    Object.defineProperty(exports2, "CallCredentials", { enumerable: true, get: function() {
      return call_credentials_1.CallCredentials;
    } });
    var channel_1 = require_channel();
    Object.defineProperty(exports2, "Channel", { enumerable: true, get: function() {
      return channel_1.ChannelImplementation;
    } });
    var compression_algorithms_1 = require_compression_algorithms();
    Object.defineProperty(exports2, "compressionAlgorithms", { enumerable: true, get: function() {
      return compression_algorithms_1.CompressionAlgorithms;
    } });
    var connectivity_state_1 = require_connectivity_state();
    Object.defineProperty(exports2, "connectivityState", { enumerable: true, get: function() {
      return connectivity_state_1.ConnectivityState;
    } });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports2, "ChannelCredentials", { enumerable: true, get: function() {
      return channel_credentials_1.ChannelCredentials;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports2, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports2, "logVerbosity", { enumerable: true, get: function() {
      return constants_1.LogVerbosity;
    } });
    Object.defineProperty(exports2, "status", { enumerable: true, get: function() {
      return constants_1.Status;
    } });
    Object.defineProperty(exports2, "propagate", { enumerable: true, get: function() {
      return constants_1.Propagate;
    } });
    var logging = require_logging();
    var make_client_1 = require_make_client();
    Object.defineProperty(exports2, "loadPackageDefinition", { enumerable: true, get: function() {
      return make_client_1.loadPackageDefinition;
    } });
    Object.defineProperty(exports2, "makeClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    Object.defineProperty(exports2, "makeGenericClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    var metadata_1 = require_metadata();
    Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
      return metadata_1.Metadata;
    } });
    var server_1 = require_server();
    Object.defineProperty(exports2, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports2, "ServerCredentials", { enumerable: true, get: function() {
      return server_credentials_1.ServerCredentials;
    } });
    var status_builder_1 = require_status_builder();
    Object.defineProperty(exports2, "StatusBuilder", { enumerable: true, get: function() {
      return status_builder_1.StatusBuilder;
    } });
    exports2.credentials = {
      combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
      },
      combineCallCredentials: (first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
      },
      createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
      createSsl: channel_credentials_1.ChannelCredentials.createSsl,
      createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
      createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
      createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
      createEmpty: call_credentials_1.CallCredentials.createEmpty
    };
    exports2.closeClient = (client) => client.close();
    exports2.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
    exports2.loadObject = (value, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.load = (filename, format2, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.setLogger = (logger2) => {
      logging.setLogger(logger2);
    };
    exports2.setLogVerbosity = (verbosity) => {
      logging.setLoggerVerbosity(verbosity);
    };
    exports2.getClientChannel = (client) => {
      return client_1.Client.prototype.getChannel.call(client);
    };
    var client_interceptors_1 = require_client_interceptors();
    Object.defineProperty(exports2, "ListenerBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.ListenerBuilder;
    } });
    Object.defineProperty(exports2, "RequesterBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.RequesterBuilder;
    } });
    Object.defineProperty(exports2, "InterceptingCall", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptingCall;
    } });
    Object.defineProperty(exports2, "InterceptorConfigurationError", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptorConfigurationError;
    } });
    var channelz_1 = require_channelz();
    Object.defineProperty(exports2, "getChannelzServiceDefinition", { enumerable: true, get: function() {
      return channelz_1.getChannelzServiceDefinition;
    } });
    Object.defineProperty(exports2, "getChannelzHandlers", { enumerable: true, get: function() {
      return channelz_1.getChannelzHandlers;
    } });
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "addAdminServicesToServer", { enumerable: true, get: function() {
      return admin_1.addAdminServicesToServer;
    } });
    var experimental = require_experimental();
    exports2.experimental = experimental;
    var resolver_dns = require_resolver_dns();
    var resolver_uds = require_resolver_uds();
    var resolver_ip = require_resolver_ip();
    var load_balancer_pick_first = require_load_balancer_pick_first();
    var load_balancer_round_robin = require_load_balancer_round_robin();
    var load_balancer_outlier_detection = require_load_balancer_outlier_detection();
    var channelz = require_channelz();
    var clientVersion = require_package().version;
    (() => {
      logging.trace(constants_1.LogVerbosity.DEBUG, "index", "Loading @grpc/grpc-js version " + clientVersion);
      resolver_dns.setup();
      resolver_uds.setup();
      resolver_ip.setup();
      load_balancer_pick_first.setup();
      load_balancer_round_robin.setup();
      load_balancer_outlier_detection.setup();
      channelz.setup();
    })();
  }
});

// node_modules/@firebase/firestore/dist/index.node.mjs
function setSDKVersion(version4) {
  SDK_VERSION2 = version4;
}
function formatJSON(value) {
  return (0, import_util4.inspect)(value, { depth: 100 });
}
function logDebug(msg, ...obj) {
  if (logClient.logLevel <= LogLevel.DEBUG) {
    const args = obj.map(argToString);
    logClient.debug(`Firestore (${SDK_VERSION2}): ${msg}`, ...args);
  }
}
function logError(msg, ...obj) {
  if (logClient.logLevel <= LogLevel.ERROR) {
    const args = obj.map(argToString);
    logClient.error(`Firestore (${SDK_VERSION2}): ${msg}`, ...args);
  }
}
function argToString(obj) {
  if (typeof obj === "string") {
    return obj;
  } else {
    try {
      return formatJSON(obj);
    } catch (e2) {
      return obj;
    }
  }
}
function fail(failure = "Unexpected state") {
  const message = `FIRESTORE (${SDK_VERSION2}) INTERNAL ASSERTION FAILED: ` + failure;
  logError(message);
  throw new Error(message);
}
function hardAssert(assertion, message) {
  if (!assertion) {
    fail();
  }
}
function makeAuthCredentialsProvider(credentials2) {
  if (!credentials2) {
    return new EmptyAuthCredentialsProvider();
  }
  switch (credentials2["type"]) {
    case "gapi":
      const client = credentials2["client"];
      hardAssert(!!(typeof client === "object" && client !== null && client["auth"] && client["auth"]["getAuthHeaderValueForFirstParty"]));
      return new FirstPartyAuthCredentialsProvider(client, credentials2["sessionIndex"] || "0", credentials2["iamToken"] || null);
    case "provider":
      return credentials2["client"];
    default:
      throw new FirestoreError(Code.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
  }
}
function isIndexedDbTransactionError(e2) {
  return e2.name === "IndexedDbTransactionError";
}
function randomBytes(nBytes) {
  return (0, import_crypto.randomBytes)(nBytes);
}
function primitiveComparator(left, right) {
  if (left < right) {
    return -1;
  }
  if (left > right) {
    return 1;
  }
  return 0;
}
function decodeBase64(encoded) {
  return Buffer.from(encoded, "base64").toString("binary");
}
function encodeBase64(raw) {
  return Buffer.from(raw, "binary").toString("base64");
}
function binaryStringFromUint8Array(array) {
  let binaryString = "";
  for (let i2 = 0; i2 < array.length; ++i2) {
    binaryString += String.fromCharCode(array[i2]);
  }
  return binaryString;
}
function uint8ArrayFromBinaryString(binaryString) {
  const buffer = new Uint8Array(binaryString.length);
  for (let i2 = 0; i2 < binaryString.length; i2++) {
    buffer[i2] = binaryString.charCodeAt(i2);
  }
  return buffer;
}
function normalizeNumber(value) {
  if (typeof value === "number") {
    return value;
  } else if (typeof value === "string") {
    return Number(value);
  } else {
    return 0;
  }
}
function normalizeByteString(blob) {
  if (typeof blob === "string") {
    return ByteString.fromBase64String(blob);
  } else {
    return ByteString.fromUint8Array(blob);
  }
}
function isNegativeZero(value) {
  return value === 0 && 1 / value === 1 / -0;
}
function isMaxValue(value) {
  return (((value.mapValue || {}).fields || {})["__type__"] || {}).stringValue === MAX_VALUE_TYPE;
}
function wrapInUserErrorIfRecoverable(e2, msg) {
  logError(LOG_TAG$4, `${msg}: ${e2}`);
  if (isIndexedDbTransactionError(e2)) {
    return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e2}`);
  } else {
    throw e2;
  }
}
function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {
  if (argument1 === true && argument2 === true) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);
  }
}
function removeComponents(firestore) {
  const datastore = datastoreInstances.get(firestore);
  if (datastore) {
    logDebug(LOG_TAG$1, "Removing Datastore");
    datastoreInstances.delete(firestore);
    datastore.terminate();
  }
}
function makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {
  return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, settings.useFetchStreams);
}
function databaseIdFromApp(app2) {
  if (!Object.prototype.hasOwnProperty.apply(app2.options, ["projectId"])) {
    throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
  }
  return new DatabaseId(app2.options.projectId);
}
function newAsyncQueue() {
  return new AsyncQueueImpl();
}
function getMessageOrStack(error2) {
  let message = error2.message || "";
  if (error2.stack) {
    if (error2.stack.includes(error2.message)) {
      message = error2.stack;
    } else {
      message = error2.message + "\n" + error2.stack;
    }
  }
  return message;
}
function getFirestore(app2 = getApp()) {
  return _getProvider(app2, "firestore").getImmediate();
}
function configureFirestore(firestore) {
  var _a;
  const settings = firestore._freezeSettings();
  const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || "", firestore._persistenceKey, settings);
  firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo);
}
function registerFirestore(variant, useFetchStreams = true) {
  setSDKVersion(SDK_VERSION);
  _registerComponent(new Component("firestore", (container, { options: settings }) => {
    const app2 = container.getProvider("app").getImmediate();
    const firestoreInstance = new Firestore(app2, new FirebaseAuthCredentialsProvider(container.getProvider("auth-internal")), new FirebaseAppCheckTokenProvider(container.getProvider("app-check-internal")));
    settings = Object.assign({ useFetchStreams }, settings);
    firestoreInstance._setSettings(settings);
    return firestoreInstance;
  }, "PUBLIC"));
  registerVersion(name3, version$12, variant);
  registerVersion(name3, version$12, "esm2017");
}
var import_util4, import_crypto, grpc, protoLoader, name3, version$12, User, version3, SDK_VERSION2, logClient, Code, FirestoreError, Deferred2, OAuthToken, EmptyAuthCredentialsProvider, FirebaseAuthCredentialsProvider, FirstPartyToken, FirstPartyAuthCredentialsProvider, AppCheckToken, FirebaseAppCheckTokenProvider, ListenSequence, BasePath, ResourcePath, DbRemoteDocumentStore$1, DbPrimaryClientStore, DbMutationQueueStore, DbMutationBatchStore, DbDocumentMutationStore, DbRemoteDocumentStore, DbRemoteDocumentGlobalStore, DbTargetStore, DbTargetDocumentStore, DbTargetGlobalStore, DbCollectionParentStore, DbClientMetadataStore, DbBundleStore, DbNamedQueryStore, DbIndexConfigurationStore, DbIndexStateStore, DbIndexEntryStore, DbDocumentOverlayStore, V1_STORES, V3_STORES, V4_STORES, V6_STORES, V8_STORES, V11_STORES, V12_STORES, V13_STORES, V14_STORES, AutoId, ByteString, ISO_TIMESTAMP_REG_EXP, DatabaseInfo, DEFAULT_DATABASE_NAME, DatabaseId, DocumentKey, MAX_VALUE_TYPE, FieldIndex, SortedMap, SortedMapIterator, LLRBNode, LLRBEmptyNode, SortedSet, SortedSetIterator, EMPTY_MUTABLE_DOCUMENT_MAP, EMPTY_DOCUMENT_MAP, EMPTY_DOCUMENT_VERSION_MAP, EMPTY_DOCUMENT_KEY_SET, EMPTY_TARGET_ID_SET, RpcCode, DIRECTIONS, OPERATORS, INDEX_TYPE_NULL, INDEX_TYPE_BOOLEAN, INDEX_TYPE_NAN, INDEX_TYPE_NUMBER, INDEX_TYPE_TIMESTAMP, INDEX_TYPE_STRING, INDEX_TYPE_BLOB, INDEX_TYPE_REFERENCE, INDEX_TYPE_GEOPOINT, INDEX_TYPE_ARRAY, INDEX_TYPE_MAP, INDEX_TYPE_REFERENCE_SEGMENT, NOT_TRUNCATED, FirestoreIndexValueWriter, EMPTY_VALUE, LRU_COLLECTION_DISABLED, LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams, LRU_MINIMUM_CACHE_SIZE_BYTES, INITIAL_GC_DELAY_MS, REGULAR_GC_DELAY_MS, MAX_CLIENT_AGE_MS, RESUME_TOKEN_MAX_AGE_MICROS, grpcVersion, X_GOOG_API_CLIENT_VALUE, LOG_TAG$8, DEFAULT_BACKOFF_INITIAL_DELAY_MS, DEFAULT_BACKOFF_FACTOR, DEFAULT_BACKOFF_MAX_DELAY_MS, ExponentialBackoff, IDLE_TIMEOUT_MS, HEALTHY_TIMEOUT_MS, ONLINE_STATE_TIMEOUT_MS, LOG_TAG$4, DelayedOperation, LOG_TAG$2, MAX_CONCURRENT_LIMBO_RESOLUTIONS, FirestoreClient, LOG_TAG$1, datastoreInstances, DEFAULT_HOST, DEFAULT_SSL, FirestoreSettingsImpl, Firestore$1, LOG_TAG, AsyncQueueImpl, Firestore, FIELD_PATH_RESERVED;
var init_index_node = __esm({
  "node_modules/@firebase/firestore/dist/index.node.mjs"() {
    init_index_esm20173();
    init_index_esm2017();
    init_index_esm20172();
    import_util4 = __toModule(require("util"));
    init_index_node_esm();
    import_crypto = __toModule(require("crypto"));
    grpc = __toModule(require_src4());
    protoLoader = __toModule(require_src3());
    name3 = "@firebase/firestore";
    version$12 = "3.4.7";
    User = class {
      constructor(uid) {
        this.uid = uid;
      }
      isAuthenticated() {
        return this.uid != null;
      }
      toKey() {
        if (this.isAuthenticated()) {
          return "uid:" + this.uid;
        } else {
          return "anonymous-user";
        }
      }
      isEqual(otherUser) {
        return otherUser.uid === this.uid;
      }
    };
    User.UNAUTHENTICATED = new User(null);
    User.GOOGLE_CREDENTIALS = new User("google-credentials-uid");
    User.FIRST_PARTY = new User("first-party-uid");
    User.MOCK_USER = new User("mock-user");
    version3 = "9.6.10";
    SDK_VERSION2 = version3;
    logClient = new Logger("@firebase/firestore");
    Code = {
      OK: "ok",
      CANCELLED: "cancelled",
      UNKNOWN: "unknown",
      INVALID_ARGUMENT: "invalid-argument",
      DEADLINE_EXCEEDED: "deadline-exceeded",
      NOT_FOUND: "not-found",
      ALREADY_EXISTS: "already-exists",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      RESOURCE_EXHAUSTED: "resource-exhausted",
      FAILED_PRECONDITION: "failed-precondition",
      ABORTED: "aborted",
      OUT_OF_RANGE: "out-of-range",
      UNIMPLEMENTED: "unimplemented",
      INTERNAL: "internal",
      UNAVAILABLE: "unavailable",
      DATA_LOSS: "data-loss"
    };
    FirestoreError = class extends FirebaseError {
      constructor(code, message) {
        super(code, message);
        this.code = code;
        this.message = message;
        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
      }
    };
    Deferred2 = class {
      constructor() {
        this.promise = new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
        });
      }
    };
    OAuthToken = class {
      constructor(value, user) {
        this.user = user;
        this.type = "OAuth";
        this.headers = new Map();
        this.headers.set("Authorization", `Bearer ${value}`);
      }
    };
    EmptyAuthCredentialsProvider = class {
      getToken() {
        return Promise.resolve(null);
      }
      invalidateToken() {
      }
      start(asyncQueue, changeListener) {
        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));
      }
      shutdown() {
      }
    };
    FirebaseAuthCredentialsProvider = class {
      constructor(authProvider) {
        this.authProvider = authProvider;
        this.currentUser = User.UNAUTHENTICATED;
        this.tokenCounter = 0;
        this.forceRefresh = false;
        this.auth = null;
      }
      start(asyncQueue, changeListener) {
        let lastTokenId = this.tokenCounter;
        const guardedChangeListener = (user) => {
          if (this.tokenCounter !== lastTokenId) {
            lastTokenId = this.tokenCounter;
            return changeListener(user);
          } else {
            return Promise.resolve();
          }
        };
        let nextToken = new Deferred2();
        this.tokenListener = () => {
          this.tokenCounter++;
          this.currentUser = this.getUser();
          nextToken.resolve();
          nextToken = new Deferred2();
          asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));
        };
        const awaitNextToken = () => {
          const currentTokenAttempt = nextToken;
          asyncQueue.enqueueRetryable(async () => {
            await currentTokenAttempt.promise;
            await guardedChangeListener(this.currentUser);
          });
        };
        const registerAuth = (auth) => {
          logDebug("FirebaseAuthCredentialsProvider", "Auth detected");
          this.auth = auth;
          this.auth.addAuthTokenListener(this.tokenListener);
          awaitNextToken();
        };
        this.authProvider.onInit((auth) => registerAuth(auth));
        setTimeout(() => {
          if (!this.auth) {
            const auth = this.authProvider.getImmediate({ optional: true });
            if (auth) {
              registerAuth(auth);
            } else {
              logDebug("FirebaseAuthCredentialsProvider", "Auth not yet detected");
              nextToken.resolve();
              nextToken = new Deferred2();
            }
          }
        }, 0);
        awaitNextToken();
      }
      getToken() {
        const initialTokenCounter = this.tokenCounter;
        const forceRefresh = this.forceRefresh;
        this.forceRefresh = false;
        if (!this.auth) {
          return Promise.resolve(null);
        }
        return this.auth.getToken(forceRefresh).then((tokenData) => {
          if (this.tokenCounter !== initialTokenCounter) {
            logDebug("FirebaseAuthCredentialsProvider", "getToken aborted due to token change.");
            return this.getToken();
          } else {
            if (tokenData) {
              hardAssert(typeof tokenData.accessToken === "string");
              return new OAuthToken(tokenData.accessToken, this.currentUser);
            } else {
              return null;
            }
          }
        });
      }
      invalidateToken() {
        this.forceRefresh = true;
      }
      shutdown() {
        if (this.auth) {
          this.auth.removeAuthTokenListener(this.tokenListener);
        }
      }
      getUser() {
        const currentUid = this.auth && this.auth.getUid();
        hardAssert(currentUid === null || typeof currentUid === "string");
        return new User(currentUid);
      }
    };
    FirstPartyToken = class {
      constructor(gapi, sessionIndex, iamToken) {
        this.type = "FirstParty";
        this.user = User.FIRST_PARTY;
        this.headers = new Map();
        this.headers.set("X-Goog-AuthUser", sessionIndex);
        const authHeader = gapi["auth"]["getAuthHeaderValueForFirstParty"]([]);
        if (authHeader) {
          this.headers.set("Authorization", authHeader);
        }
        if (iamToken) {
          this.headers.set("X-Goog-Iam-Authorization-Token", iamToken);
        }
      }
    };
    FirstPartyAuthCredentialsProvider = class {
      constructor(gapi, sessionIndex, iamToken) {
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
      }
      getToken() {
        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex, this.iamToken));
      }
      start(asyncQueue, changeListener) {
        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));
      }
      shutdown() {
      }
      invalidateToken() {
      }
    };
    AppCheckToken = class {
      constructor(value) {
        this.value = value;
        this.type = "AppCheck";
        this.headers = new Map();
        if (value && value.length > 0) {
          this.headers.set("x-firebase-appcheck", this.value);
        }
      }
    };
    FirebaseAppCheckTokenProvider = class {
      constructor(appCheckProvider) {
        this.appCheckProvider = appCheckProvider;
        this.forceRefresh = false;
        this.appCheck = null;
        this.latestAppCheckToken = null;
      }
      start(asyncQueue, changeListener) {
        const onTokenChanged = (tokenResult) => {
          if (tokenResult.error != null) {
            logDebug("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);
          }
          const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;
          this.latestAppCheckToken = tokenResult.token;
          logDebug("FirebaseAppCheckTokenProvider", `Received ${tokenUpdated ? "new" : "existing"} token.`);
          return tokenUpdated ? changeListener(tokenResult.token) : Promise.resolve();
        };
        this.tokenListener = (tokenResult) => {
          asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));
        };
        const registerAppCheck = (appCheck) => {
          logDebug("FirebaseAppCheckTokenProvider", "AppCheck detected");
          this.appCheck = appCheck;
          this.appCheck.addTokenListener(this.tokenListener);
        };
        this.appCheckProvider.onInit((appCheck) => registerAppCheck(appCheck));
        setTimeout(() => {
          if (!this.appCheck) {
            const appCheck = this.appCheckProvider.getImmediate({ optional: true });
            if (appCheck) {
              registerAppCheck(appCheck);
            } else {
              logDebug("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
            }
          }
        }, 0);
      }
      getToken() {
        const forceRefresh = this.forceRefresh;
        this.forceRefresh = false;
        if (!this.appCheck) {
          return Promise.resolve(null);
        }
        return this.appCheck.getToken(forceRefresh).then((tokenResult) => {
          if (tokenResult) {
            hardAssert(typeof tokenResult.token === "string");
            this.latestAppCheckToken = tokenResult.token;
            return new AppCheckToken(tokenResult.token);
          } else {
            return null;
          }
        });
      }
      invalidateToken() {
        this.forceRefresh = true;
      }
      shutdown() {
        if (this.appCheck) {
          this.appCheck.removeTokenListener(this.tokenListener);
        }
      }
    };
    ListenSequence = class {
      constructor(previousValue, sequenceNumberSyncer) {
        this.previousValue = previousValue;
        if (sequenceNumberSyncer) {
          sequenceNumberSyncer.sequenceNumberHandler = (sequenceNumber) => this.setPreviousValue(sequenceNumber);
          this.writeNewSequenceNumber = (sequenceNumber) => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);
        }
      }
      setPreviousValue(externalPreviousValue) {
        this.previousValue = Math.max(externalPreviousValue, this.previousValue);
        return this.previousValue;
      }
      next() {
        const nextValue = ++this.previousValue;
        if (this.writeNewSequenceNumber) {
          this.writeNewSequenceNumber(nextValue);
        }
        return nextValue;
      }
    };
    ListenSequence.INVALID = -1;
    BasePath = class {
      constructor(segments, offset, length) {
        if (offset === void 0) {
          offset = 0;
        } else if (offset > segments.length) {
          fail();
        }
        if (length === void 0) {
          length = segments.length - offset;
        } else if (length > segments.length - offset) {
          fail();
        }
        this.segments = segments;
        this.offset = offset;
        this.len = length;
      }
      get length() {
        return this.len;
      }
      isEqual(other) {
        return BasePath.comparator(this, other) === 0;
      }
      child(nameOrPath) {
        const segments = this.segments.slice(this.offset, this.limit());
        if (nameOrPath instanceof BasePath) {
          nameOrPath.forEach((segment) => {
            segments.push(segment);
          });
        } else {
          segments.push(nameOrPath);
        }
        return this.construct(segments);
      }
      limit() {
        return this.offset + this.length;
      }
      popFirst(size) {
        size = size === void 0 ? 1 : size;
        return this.construct(this.segments, this.offset + size, this.length - size);
      }
      popLast() {
        return this.construct(this.segments, this.offset, this.length - 1);
      }
      firstSegment() {
        return this.segments[this.offset];
      }
      lastSegment() {
        return this.get(this.length - 1);
      }
      get(index) {
        return this.segments[this.offset + index];
      }
      isEmpty() {
        return this.length === 0;
      }
      isPrefixOf(other) {
        if (other.length < this.length) {
          return false;
        }
        for (let i2 = 0; i2 < this.length; i2++) {
          if (this.get(i2) !== other.get(i2)) {
            return false;
          }
        }
        return true;
      }
      isImmediateParentOf(potentialChild) {
        if (this.length + 1 !== potentialChild.length) {
          return false;
        }
        for (let i2 = 0; i2 < this.length; i2++) {
          if (this.get(i2) !== potentialChild.get(i2)) {
            return false;
          }
        }
        return true;
      }
      forEach(fn) {
        for (let i2 = this.offset, end = this.limit(); i2 < end; i2++) {
          fn(this.segments[i2]);
        }
      }
      toArray() {
        return this.segments.slice(this.offset, this.limit());
      }
      static comparator(p1, p2) {
        const len = Math.min(p1.length, p2.length);
        for (let i2 = 0; i2 < len; i2++) {
          const left = p1.get(i2);
          const right = p2.get(i2);
          if (left < right) {
            return -1;
          }
          if (left > right) {
            return 1;
          }
        }
        if (p1.length < p2.length) {
          return -1;
        }
        if (p1.length > p2.length) {
          return 1;
        }
        return 0;
      }
    };
    ResourcePath = class extends BasePath {
      construct(segments, offset, length) {
        return new ResourcePath(segments, offset, length);
      }
      canonicalString() {
        return this.toArray().join("/");
      }
      toString() {
        return this.canonicalString();
      }
      static fromString(...pathComponents) {
        const segments = [];
        for (const path2 of pathComponents) {
          if (path2.indexOf("//") >= 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path2}). Paths must not contain // in them.`);
          }
          segments.push(...path2.split("/").filter((segment) => segment.length > 0));
        }
        return new ResourcePath(segments);
      }
      static emptyPath() {
        return new ResourcePath([]);
      }
    };
    DbRemoteDocumentStore$1 = "remoteDocuments";
    DbPrimaryClientStore = "owner";
    DbMutationQueueStore = "mutationQueues";
    DbMutationBatchStore = "mutations";
    DbDocumentMutationStore = "documentMutations";
    DbRemoteDocumentStore = "remoteDocumentsV14";
    DbRemoteDocumentGlobalStore = "remoteDocumentGlobal";
    DbTargetStore = "targets";
    DbTargetDocumentStore = "targetDocuments";
    DbTargetGlobalStore = "targetGlobal";
    DbCollectionParentStore = "collectionParents";
    DbClientMetadataStore = "clientMetadata";
    DbBundleStore = "bundles";
    DbNamedQueryStore = "namedQueries";
    DbIndexConfigurationStore = "indexConfiguration";
    DbIndexStateStore = "indexState";
    DbIndexEntryStore = "indexEntries";
    DbDocumentOverlayStore = "documentOverlays";
    V1_STORES = [
      DbMutationQueueStore,
      DbMutationBatchStore,
      DbDocumentMutationStore,
      DbRemoteDocumentStore$1,
      DbTargetStore,
      DbPrimaryClientStore,
      DbTargetGlobalStore,
      DbTargetDocumentStore
    ];
    V3_STORES = V1_STORES;
    V4_STORES = [...V3_STORES, DbClientMetadataStore];
    V6_STORES = [...V4_STORES, DbRemoteDocumentGlobalStore];
    V8_STORES = [...V6_STORES, DbCollectionParentStore];
    V11_STORES = [...V8_STORES, DbBundleStore, DbNamedQueryStore];
    V12_STORES = [...V11_STORES, DbDocumentOverlayStore];
    V13_STORES = [
      DbMutationQueueStore,
      DbMutationBatchStore,
      DbDocumentMutationStore,
      DbRemoteDocumentStore,
      DbTargetStore,
      DbPrimaryClientStore,
      DbTargetGlobalStore,
      DbTargetDocumentStore,
      DbClientMetadataStore,
      DbRemoteDocumentGlobalStore,
      DbCollectionParentStore,
      DbBundleStore,
      DbNamedQueryStore,
      DbDocumentOverlayStore
    ];
    V14_STORES = [
      ...V13_STORES,
      DbIndexConfigurationStore,
      DbIndexStateStore,
      DbIndexEntryStore
    ];
    AutoId = class {
      static newId() {
        const chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        const maxMultiple = Math.floor(256 / chars2.length) * chars2.length;
        let autoId = "";
        const targetLength = 20;
        while (autoId.length < targetLength) {
          const bytes = randomBytes(40);
          for (let i2 = 0; i2 < bytes.length; ++i2) {
            if (autoId.length < targetLength && bytes[i2] < maxMultiple) {
              autoId += chars2.charAt(bytes[i2] % chars2.length);
            }
          }
        }
        return autoId;
      }
    };
    ByteString = class {
      constructor(binaryString) {
        this.binaryString = binaryString;
      }
      static fromBase64String(base643) {
        const binaryString = decodeBase64(base643);
        return new ByteString(binaryString);
      }
      static fromUint8Array(array) {
        const binaryString = binaryStringFromUint8Array(array);
        return new ByteString(binaryString);
      }
      [Symbol.iterator]() {
        let i2 = 0;
        return {
          next: () => {
            if (i2 < this.binaryString.length) {
              return { value: this.binaryString.charCodeAt(i2++), done: false };
            } else {
              return { value: void 0, done: true };
            }
          }
        };
      }
      toBase64() {
        return encodeBase64(this.binaryString);
      }
      toUint8Array() {
        return uint8ArrayFromBinaryString(this.binaryString);
      }
      approximateByteSize() {
        return this.binaryString.length * 2;
      }
      compareTo(other) {
        return primitiveComparator(this.binaryString, other.binaryString);
      }
      isEqual(other) {
        return this.binaryString === other.binaryString;
      }
    };
    ByteString.EMPTY_BYTE_STRING = new ByteString("");
    ISO_TIMESTAMP_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
    DatabaseInfo = class {
      constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, useFetchStreams) {
        this.databaseId = databaseId;
        this.appId = appId;
        this.persistenceKey = persistenceKey;
        this.host = host;
        this.ssl = ssl;
        this.forceLongPolling = forceLongPolling;
        this.autoDetectLongPolling = autoDetectLongPolling;
        this.useFetchStreams = useFetchStreams;
      }
    };
    DEFAULT_DATABASE_NAME = "(default)";
    DatabaseId = class {
      constructor(projectId, database) {
        this.projectId = projectId;
        this.database = database ? database : DEFAULT_DATABASE_NAME;
      }
      static empty() {
        return new DatabaseId("", "");
      }
      get isDefaultDatabase() {
        return this.database === DEFAULT_DATABASE_NAME;
      }
      isEqual(other) {
        return other instanceof DatabaseId && other.projectId === this.projectId && other.database === this.database;
      }
    };
    DocumentKey = class {
      constructor(path2) {
        this.path = path2;
      }
      static fromPath(path2) {
        return new DocumentKey(ResourcePath.fromString(path2));
      }
      static fromName(name4) {
        return new DocumentKey(ResourcePath.fromString(name4).popFirst(5));
      }
      static empty() {
        return new DocumentKey(ResourcePath.emptyPath());
      }
      get collectionGroup() {
        return this.path.popLast().lastSegment();
      }
      hasCollectionId(collectionId) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;
      }
      getCollectionGroup() {
        return this.path.get(this.path.length - 2);
      }
      getCollectionPath() {
        return this.path.popLast();
      }
      isEqual(other) {
        return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
      }
      toString() {
        return this.path.toString();
      }
      static comparator(k1, k2) {
        return ResourcePath.comparator(k1.path, k2.path);
      }
      static isDocumentKey(path2) {
        return path2.length % 2 === 0;
      }
      static fromSegments(segments) {
        return new DocumentKey(new ResourcePath(segments.slice()));
      }
    };
    MAX_VALUE_TYPE = "__max__";
    FieldIndex = class {
      constructor(indexId, collectionGroup, fields, indexState) {
        this.indexId = indexId;
        this.collectionGroup = collectionGroup;
        this.fields = fields;
        this.indexState = indexState;
      }
    };
    FieldIndex.UNKNOWN_ID = -1;
    SortedMap = class {
      constructor(comparator, root) {
        this.comparator = comparator;
        this.root = root ? root : LLRBNode.EMPTY;
      }
      insert(key2, value) {
        return new SortedMap(this.comparator, this.root.insert(key2, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      }
      remove(key2) {
        return new SortedMap(this.comparator, this.root.remove(key2, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      }
      get(key2) {
        let node = this.root;
        while (!node.isEmpty()) {
          const cmp = this.comparator(key2, node.key);
          if (cmp === 0) {
            return node.value;
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            node = node.right;
          }
        }
        return null;
      }
      indexOf(key2) {
        let prunedNodes = 0;
        let node = this.root;
        while (!node.isEmpty()) {
          const cmp = this.comparator(key2, node.key);
          if (cmp === 0) {
            return prunedNodes + node.left.size;
          } else if (cmp < 0) {
            node = node.left;
          } else {
            prunedNodes += node.left.size + 1;
            node = node.right;
          }
        }
        return -1;
      }
      isEmpty() {
        return this.root.isEmpty();
      }
      get size() {
        return this.root.size;
      }
      minKey() {
        return this.root.minKey();
      }
      maxKey() {
        return this.root.maxKey();
      }
      inorderTraversal(action) {
        return this.root.inorderTraversal(action);
      }
      forEach(fn) {
        this.inorderTraversal((k, v) => {
          fn(k, v);
          return false;
        });
      }
      toString() {
        const descriptions = [];
        this.inorderTraversal((k, v) => {
          descriptions.push(`${k}:${v}`);
          return false;
        });
        return `{${descriptions.join(", ")}}`;
      }
      reverseTraversal(action) {
        return this.root.reverseTraversal(action);
      }
      getIterator() {
        return new SortedMapIterator(this.root, null, this.comparator, false);
      }
      getIteratorFrom(key2) {
        return new SortedMapIterator(this.root, key2, this.comparator, false);
      }
      getReverseIterator() {
        return new SortedMapIterator(this.root, null, this.comparator, true);
      }
      getReverseIteratorFrom(key2) {
        return new SortedMapIterator(this.root, key2, this.comparator, true);
      }
    };
    SortedMapIterator = class {
      constructor(node, startKey, comparator, isReverse) {
        this.isReverse = isReverse;
        this.nodeStack = [];
        let cmp = 1;
        while (!node.isEmpty()) {
          cmp = startKey ? comparator(node.key, startKey) : 1;
          if (startKey && isReverse) {
            cmp *= -1;
          }
          if (cmp < 0) {
            if (this.isReverse) {
              node = node.left;
            } else {
              node = node.right;
            }
          } else if (cmp === 0) {
            this.nodeStack.push(node);
            break;
          } else {
            this.nodeStack.push(node);
            if (this.isReverse) {
              node = node.right;
            } else {
              node = node.left;
            }
          }
        }
      }
      getNext() {
        let node = this.nodeStack.pop();
        const result = { key: node.key, value: node.value };
        if (this.isReverse) {
          node = node.left;
          while (!node.isEmpty()) {
            this.nodeStack.push(node);
            node = node.right;
          }
        } else {
          node = node.right;
          while (!node.isEmpty()) {
            this.nodeStack.push(node);
            node = node.left;
          }
        }
        return result;
      }
      hasNext() {
        return this.nodeStack.length > 0;
      }
      peek() {
        if (this.nodeStack.length === 0) {
          return null;
        }
        const node = this.nodeStack[this.nodeStack.length - 1];
        return { key: node.key, value: node.value };
      }
    };
    LLRBNode = class {
      constructor(key2, value, color, left, right) {
        this.key = key2;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left = left != null ? left : LLRBNode.EMPTY;
        this.right = right != null ? right : LLRBNode.EMPTY;
        this.size = this.left.size + 1 + this.right.size;
      }
      copy(key2, value, color, left, right) {
        return new LLRBNode(key2 != null ? key2 : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
      }
      isEmpty() {
        return false;
      }
      inorderTraversal(action) {
        return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
      }
      reverseTraversal(action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
      }
      min() {
        if (this.left.isEmpty()) {
          return this;
        } else {
          return this.left.min();
        }
      }
      minKey() {
        return this.min().key;
      }
      maxKey() {
        if (this.right.isEmpty()) {
          return this.key;
        } else {
          return this.right.maxKey();
        }
      }
      insert(key2, value, comparator) {
        let n = this;
        const cmp = comparator(key2, n.key);
        if (cmp < 0) {
          n = n.copy(null, null, null, n.left.insert(key2, value, comparator), null);
        } else if (cmp === 0) {
          n = n.copy(null, value, null, null, null);
        } else {
          n = n.copy(null, null, null, null, n.right.insert(key2, value, comparator));
        }
        return n.fixUp();
      }
      removeMin() {
        if (this.left.isEmpty()) {
          return LLRBNode.EMPTY;
        }
        let n = this;
        if (!n.left.isRed() && !n.left.left.isRed()) {
          n = n.moveRedLeft();
        }
        n = n.copy(null, null, null, n.left.removeMin(), null);
        return n.fixUp();
      }
      remove(key2, comparator) {
        let smallest;
        let n = this;
        if (comparator(key2, n.key) < 0) {
          if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {
            n = n.moveRedLeft();
          }
          n = n.copy(null, null, null, n.left.remove(key2, comparator), null);
        } else {
          if (n.left.isRed()) {
            n = n.rotateRight();
          }
          if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {
            n = n.moveRedRight();
          }
          if (comparator(key2, n.key) === 0) {
            if (n.right.isEmpty()) {
              return LLRBNode.EMPTY;
            } else {
              smallest = n.right.min();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
            }
          }
          n = n.copy(null, null, null, null, n.right.remove(key2, comparator));
        }
        return n.fixUp();
      }
      isRed() {
        return this.color;
      }
      fixUp() {
        let n = this;
        if (n.right.isRed() && !n.left.isRed()) {
          n = n.rotateLeft();
        }
        if (n.left.isRed() && n.left.left.isRed()) {
          n = n.rotateRight();
        }
        if (n.left.isRed() && n.right.isRed()) {
          n = n.colorFlip();
        }
        return n;
      }
      moveRedLeft() {
        let n = this.colorFlip();
        if (n.right.left.isRed()) {
          n = n.copy(null, null, null, null, n.right.rotateRight());
          n = n.rotateLeft();
          n = n.colorFlip();
        }
        return n;
      }
      moveRedRight() {
        let n = this.colorFlip();
        if (n.left.left.isRed()) {
          n = n.rotateRight();
          n = n.colorFlip();
        }
        return n;
      }
      rotateLeft() {
        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
      }
      rotateRight() {
        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
      }
      colorFlip() {
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
      }
      checkMaxDepth() {
        const blackDepth = this.check();
        if (Math.pow(2, blackDepth) <= this.size + 1) {
          return true;
        } else {
          return false;
        }
      }
      check() {
        if (this.isRed() && this.left.isRed()) {
          throw fail();
        }
        if (this.right.isRed()) {
          throw fail();
        }
        const blackDepth = this.left.check();
        if (blackDepth !== this.right.check()) {
          throw fail();
        } else {
          return blackDepth + (this.isRed() ? 0 : 1);
        }
      }
    };
    LLRBNode.EMPTY = null;
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    LLRBEmptyNode = class {
      constructor() {
        this.size = 0;
      }
      get key() {
        throw fail();
      }
      get value() {
        throw fail();
      }
      get color() {
        throw fail();
      }
      get left() {
        throw fail();
      }
      get right() {
        throw fail();
      }
      copy(key2, value, color, left, right) {
        return this;
      }
      insert(key2, value, comparator) {
        return new LLRBNode(key2, value);
      }
      remove(key2, comparator) {
        return this;
      }
      isEmpty() {
        return true;
      }
      inorderTraversal(action) {
        return false;
      }
      reverseTraversal(action) {
        return false;
      }
      minKey() {
        return null;
      }
      maxKey() {
        return null;
      }
      isRed() {
        return false;
      }
      checkMaxDepth() {
        return true;
      }
      check() {
        return 0;
      }
    };
    LLRBNode.EMPTY = new LLRBEmptyNode();
    SortedSet = class {
      constructor(comparator) {
        this.comparator = comparator;
        this.data = new SortedMap(this.comparator);
      }
      has(elem) {
        return this.data.get(elem) !== null;
      }
      first() {
        return this.data.minKey();
      }
      last() {
        return this.data.maxKey();
      }
      get size() {
        return this.data.size;
      }
      indexOf(elem) {
        return this.data.indexOf(elem);
      }
      forEach(cb) {
        this.data.inorderTraversal((k, v) => {
          cb(k);
          return false;
        });
      }
      forEachInRange(range, cb) {
        const iter = this.data.getIteratorFrom(range[0]);
        while (iter.hasNext()) {
          const elem = iter.getNext();
          if (this.comparator(elem.key, range[1]) >= 0) {
            return;
          }
          cb(elem.key);
        }
      }
      forEachWhile(cb, start) {
        let iter;
        if (start !== void 0) {
          iter = this.data.getIteratorFrom(start);
        } else {
          iter = this.data.getIterator();
        }
        while (iter.hasNext()) {
          const elem = iter.getNext();
          const result = cb(elem.key);
          if (!result) {
            return;
          }
        }
      }
      firstAfterOrEqual(elem) {
        const iter = this.data.getIteratorFrom(elem);
        return iter.hasNext() ? iter.getNext().key : null;
      }
      getIterator() {
        return new SortedSetIterator(this.data.getIterator());
      }
      getIteratorFrom(key2) {
        return new SortedSetIterator(this.data.getIteratorFrom(key2));
      }
      add(elem) {
        return this.copy(this.data.remove(elem).insert(elem, true));
      }
      delete(elem) {
        if (!this.has(elem)) {
          return this;
        }
        return this.copy(this.data.remove(elem));
      }
      isEmpty() {
        return this.data.isEmpty();
      }
      unionWith(other) {
        let result = this;
        if (result.size < other.size) {
          result = other;
          other = this;
        }
        other.forEach((elem) => {
          result = result.add(elem);
        });
        return result;
      }
      isEqual(other) {
        if (!(other instanceof SortedSet)) {
          return false;
        }
        if (this.size !== other.size) {
          return false;
        }
        const thisIt = this.data.getIterator();
        const otherIt = other.data.getIterator();
        while (thisIt.hasNext()) {
          const thisElem = thisIt.getNext().key;
          const otherElem = otherIt.getNext().key;
          if (this.comparator(thisElem, otherElem) !== 0) {
            return false;
          }
        }
        return true;
      }
      toArray() {
        const res = [];
        this.forEach((targetId) => {
          res.push(targetId);
        });
        return res;
      }
      toString() {
        const result = [];
        this.forEach((elem) => result.push(elem));
        return "SortedSet(" + result.toString() + ")";
      }
      copy(data) {
        const result = new SortedSet(this.comparator);
        result.data = data;
        return result;
      }
    };
    SortedSetIterator = class {
      constructor(iter) {
        this.iter = iter;
      }
      getNext() {
        return this.iter.getNext().key;
      }
      hasNext() {
        return this.iter.hasNext();
      }
    };
    EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
    EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
    EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);
    EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);
    EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);
    (function(RpcCode2) {
      RpcCode2[RpcCode2["OK"] = 0] = "OK";
      RpcCode2[RpcCode2["CANCELLED"] = 1] = "CANCELLED";
      RpcCode2[RpcCode2["UNKNOWN"] = 2] = "UNKNOWN";
      RpcCode2[RpcCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      RpcCode2[RpcCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      RpcCode2[RpcCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
      RpcCode2[RpcCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      RpcCode2[RpcCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      RpcCode2[RpcCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
      RpcCode2[RpcCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      RpcCode2[RpcCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      RpcCode2[RpcCode2["ABORTED"] = 10] = "ABORTED";
      RpcCode2[RpcCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      RpcCode2[RpcCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      RpcCode2[RpcCode2["INTERNAL"] = 13] = "INTERNAL";
      RpcCode2[RpcCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      RpcCode2[RpcCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
    })(RpcCode || (RpcCode = {}));
    DIRECTIONS = (() => {
      const dirs = {};
      dirs["asc"] = "ASCENDING";
      dirs["desc"] = "DESCENDING";
      return dirs;
    })();
    OPERATORS = (() => {
      const ops = {};
      ops["<"] = "LESS_THAN";
      ops["<="] = "LESS_THAN_OR_EQUAL";
      ops[">"] = "GREATER_THAN";
      ops[">="] = "GREATER_THAN_OR_EQUAL";
      ops["=="] = "EQUAL";
      ops["!="] = "NOT_EQUAL";
      ops["array-contains"] = "ARRAY_CONTAINS";
      ops["in"] = "IN";
      ops["not-in"] = "NOT_IN";
      ops["array-contains-any"] = "ARRAY_CONTAINS_ANY";
      return ops;
    })();
    INDEX_TYPE_NULL = 5;
    INDEX_TYPE_BOOLEAN = 10;
    INDEX_TYPE_NAN = 13;
    INDEX_TYPE_NUMBER = 15;
    INDEX_TYPE_TIMESTAMP = 20;
    INDEX_TYPE_STRING = 25;
    INDEX_TYPE_BLOB = 30;
    INDEX_TYPE_REFERENCE = 37;
    INDEX_TYPE_GEOPOINT = 45;
    INDEX_TYPE_ARRAY = 50;
    INDEX_TYPE_MAP = 55;
    INDEX_TYPE_REFERENCE_SEGMENT = 60;
    NOT_TRUNCATED = 2;
    FirestoreIndexValueWriter = class {
      constructor() {
      }
      writeIndexValue(value, encoder2) {
        this.writeIndexValueAux(value, encoder2);
        encoder2.writeInfinity();
      }
      writeIndexValueAux(indexValue, encoder2) {
        if ("nullValue" in indexValue) {
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_NULL);
        } else if ("booleanValue" in indexValue) {
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_BOOLEAN);
          encoder2.writeNumber(indexValue.booleanValue ? 1 : 0);
        } else if ("integerValue" in indexValue) {
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_NUMBER);
          encoder2.writeNumber(normalizeNumber(indexValue.integerValue));
        } else if ("doubleValue" in indexValue) {
          const n = normalizeNumber(indexValue.doubleValue);
          if (isNaN(n)) {
            this.writeValueTypeLabel(encoder2, INDEX_TYPE_NAN);
          } else {
            this.writeValueTypeLabel(encoder2, INDEX_TYPE_NUMBER);
            if (isNegativeZero(n)) {
              encoder2.writeNumber(0);
            } else {
              encoder2.writeNumber(n);
            }
          }
        } else if ("timestampValue" in indexValue) {
          const timestamp = indexValue.timestampValue;
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_TIMESTAMP);
          if (typeof timestamp === "string") {
            encoder2.writeString(timestamp);
          } else {
            encoder2.writeString(`${timestamp.seconds || ""}`);
            encoder2.writeNumber(timestamp.nanos || 0);
          }
        } else if ("stringValue" in indexValue) {
          this.writeIndexString(indexValue.stringValue, encoder2);
          this.writeTruncationMarker(encoder2);
        } else if ("bytesValue" in indexValue) {
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_BLOB);
          encoder2.writeBytes(normalizeByteString(indexValue.bytesValue));
          this.writeTruncationMarker(encoder2);
        } else if ("referenceValue" in indexValue) {
          this.writeIndexEntityRef(indexValue.referenceValue, encoder2);
        } else if ("geoPointValue" in indexValue) {
          const geoPoint = indexValue.geoPointValue;
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_GEOPOINT);
          encoder2.writeNumber(geoPoint.latitude || 0);
          encoder2.writeNumber(geoPoint.longitude || 0);
        } else if ("mapValue" in indexValue) {
          if (isMaxValue(indexValue)) {
            this.writeValueTypeLabel(encoder2, Number.MAX_SAFE_INTEGER);
          } else {
            this.writeIndexMap(indexValue.mapValue, encoder2);
            this.writeTruncationMarker(encoder2);
          }
        } else if ("arrayValue" in indexValue) {
          this.writeIndexArray(indexValue.arrayValue, encoder2);
          this.writeTruncationMarker(encoder2);
        } else {
          fail();
        }
      }
      writeIndexString(stringIndexValue, encoder2) {
        this.writeValueTypeLabel(encoder2, INDEX_TYPE_STRING);
        this.writeUnlabeledIndexString(stringIndexValue, encoder2);
      }
      writeUnlabeledIndexString(stringIndexValue, encoder2) {
        encoder2.writeString(stringIndexValue);
      }
      writeIndexMap(mapIndexValue, encoder2) {
        const map = mapIndexValue.fields || {};
        this.writeValueTypeLabel(encoder2, INDEX_TYPE_MAP);
        for (const key2 of Object.keys(map)) {
          this.writeIndexString(key2, encoder2);
          this.writeIndexValueAux(map[key2], encoder2);
        }
      }
      writeIndexArray(arrayIndexValue, encoder2) {
        const values = arrayIndexValue.values || [];
        this.writeValueTypeLabel(encoder2, INDEX_TYPE_ARRAY);
        for (const element of values) {
          this.writeIndexValueAux(element, encoder2);
        }
      }
      writeIndexEntityRef(referenceValue, encoder2) {
        this.writeValueTypeLabel(encoder2, INDEX_TYPE_REFERENCE);
        const path2 = DocumentKey.fromName(referenceValue).path;
        path2.forEach((segment) => {
          this.writeValueTypeLabel(encoder2, INDEX_TYPE_REFERENCE_SEGMENT);
          this.writeUnlabeledIndexString(segment, encoder2);
        });
      }
      writeValueTypeLabel(encoder2, typeOrder) {
        encoder2.writeNumber(typeOrder);
      }
      writeTruncationMarker(encoder2) {
        encoder2.writeNumber(NOT_TRUNCATED);
      }
    };
    FirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();
    EMPTY_VALUE = new Uint8Array(0);
    LRU_COLLECTION_DISABLED = -1;
    LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;
    LruParams = class {
      constructor(cacheSizeCollectionThreshold, percentileToCollect, maximumSequenceNumbersToCollect) {
        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;
        this.percentileToCollect = percentileToCollect;
        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;
      }
      static withCacheSize(cacheSize) {
        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
      }
    };
    LruParams.DEFAULT_COLLECTION_PERCENTILE = 10;
    LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3;
    LruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
    LruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);
    LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;
    INITIAL_GC_DELAY_MS = 1 * 60 * 1e3;
    REGULAR_GC_DELAY_MS = 5 * 60 * 1e3;
    MAX_CLIENT_AGE_MS = 30 * 60 * 1e3;
    RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;
    grpcVersion = "1.3.7";
    X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION2} grpc/${grpcVersion}`;
    LOG_TAG$8 = "ExponentialBackoff";
    DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1e3;
    DEFAULT_BACKOFF_FACTOR = 1.5;
    DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1e3;
    ExponentialBackoff = class {
      constructor(queue, timerId, initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, backoffFactor = DEFAULT_BACKOFF_FACTOR, maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {
        this.queue = queue;
        this.timerId = timerId;
        this.initialDelayMs = initialDelayMs;
        this.backoffFactor = backoffFactor;
        this.maxDelayMs = maxDelayMs;
        this.currentBaseMs = 0;
        this.timerPromise = null;
        this.lastAttemptTime = Date.now();
        this.reset();
      }
      reset() {
        this.currentBaseMs = 0;
      }
      resetToMax() {
        this.currentBaseMs = this.maxDelayMs;
      }
      backoffAndRun(op) {
        this.cancel();
        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);
        if (remainingDelayMs > 0) {
          logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms (base delay: ${this.currentBaseMs} ms, delay with jitter: ${desiredDelayWithJitterMs} ms, last attempt: ${delaySoFarMs} ms ago)`);
        }
        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {
          this.lastAttemptTime = Date.now();
          return op();
        });
        this.currentBaseMs *= this.backoffFactor;
        if (this.currentBaseMs < this.initialDelayMs) {
          this.currentBaseMs = this.initialDelayMs;
        }
        if (this.currentBaseMs > this.maxDelayMs) {
          this.currentBaseMs = this.maxDelayMs;
        }
      }
      skipBackoff() {
        if (this.timerPromise !== null) {
          this.timerPromise.skipDelay();
          this.timerPromise = null;
        }
      }
      cancel() {
        if (this.timerPromise !== null) {
          this.timerPromise.cancel();
          this.timerPromise = null;
        }
      }
      jitterDelayMs() {
        return (Math.random() - 0.5) * this.currentBaseMs;
      }
    };
    IDLE_TIMEOUT_MS = 60 * 1e3;
    HEALTHY_TIMEOUT_MS = 10 * 1e3;
    ONLINE_STATE_TIMEOUT_MS = 10 * 1e3;
    LOG_TAG$4 = "AsyncQueue";
    DelayedOperation = class {
      constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
        this.asyncQueue = asyncQueue;
        this.timerId = timerId;
        this.targetTimeMs = targetTimeMs;
        this.op = op;
        this.removalCallback = removalCallback;
        this.deferred = new Deferred2();
        this.then = this.deferred.promise.then.bind(this.deferred.promise);
        this.deferred.promise.catch((err) => {
        });
      }
      static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {
        const targetTime = Date.now() + delayMs;
        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);
        delayedOp.start(delayMs);
        return delayedOp;
      }
      start(delayMs) {
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);
      }
      skipDelay() {
        return this.handleDelayElapsed();
      }
      cancel(reason) {
        if (this.timerHandle !== null) {
          this.clearTimeout();
          this.deferred.reject(new FirestoreError(Code.CANCELLED, "Operation cancelled" + (reason ? ": " + reason : "")));
        }
      }
      handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget(() => {
          if (this.timerHandle !== null) {
            this.clearTimeout();
            return this.op().then((result) => {
              return this.deferred.resolve(result);
            });
          } else {
            return Promise.resolve();
          }
        });
      }
      clearTimeout() {
        if (this.timerHandle !== null) {
          this.removalCallback(this);
          clearTimeout(this.timerHandle);
          this.timerHandle = null;
        }
      }
    };
    LOG_TAG$2 = "FirestoreClient";
    MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;
    FirestoreClient = class {
      constructor(authCredentials, appCheckCredentials, asyncQueue, databaseInfo) {
        this.authCredentials = authCredentials;
        this.appCheckCredentials = appCheckCredentials;
        this.asyncQueue = asyncQueue;
        this.databaseInfo = databaseInfo;
        this.user = User.UNAUTHENTICATED;
        this.clientId = AutoId.newId();
        this.authCredentialListener = () => Promise.resolve();
        this.appCheckCredentialListener = () => Promise.resolve();
        this.authCredentials.start(asyncQueue, async (user) => {
          logDebug(LOG_TAG$2, "Received user=", user.uid);
          await this.authCredentialListener(user);
          this.user = user;
        });
        this.appCheckCredentials.start(asyncQueue, (newAppCheckToken) => {
          logDebug(LOG_TAG$2, "Received new app check token=", newAppCheckToken);
          return this.appCheckCredentialListener(newAppCheckToken, this.user);
        });
      }
      async getConfiguration() {
        return {
          asyncQueue: this.asyncQueue,
          databaseInfo: this.databaseInfo,
          clientId: this.clientId,
          authCredentials: this.authCredentials,
          appCheckCredentials: this.appCheckCredentials,
          initialUser: this.user,
          maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS
        };
      }
      setCredentialChangeListener(listener) {
        this.authCredentialListener = listener;
      }
      setAppCheckTokenChangeListener(listener) {
        this.appCheckCredentialListener = listener;
      }
      verifyNotTerminated() {
        if (this.asyncQueue.isShuttingDown) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
        }
      }
      terminate() {
        this.asyncQueue.enterRestrictedMode();
        const deferred = new Deferred2();
        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
          try {
            if (this.onlineComponents) {
              await this.onlineComponents.terminate();
            }
            if (this.offlineComponents) {
              await this.offlineComponents.terminate();
            }
            this.authCredentials.shutdown();
            this.appCheckCredentials.shutdown();
            deferred.resolve();
          } catch (e2) {
            const firestoreError = wrapInUserErrorIfRecoverable(e2, `Failed to shutdown persistence`);
            deferred.reject(firestoreError);
          }
        });
        return deferred.promise;
      }
    };
    LOG_TAG$1 = "ComponentProvider";
    datastoreInstances = new Map();
    DEFAULT_HOST = "firestore.googleapis.com";
    DEFAULT_SSL = true;
    FirestoreSettingsImpl = class {
      constructor(settings) {
        var _a;
        if (settings.host === void 0) {
          if (settings.ssl !== void 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
          }
          this.host = DEFAULT_HOST;
          this.ssl = DEFAULT_SSL;
        } else {
          this.host = settings.host;
          this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;
        }
        this.credentials = settings.credentials;
        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;
        if (settings.cacheSizeBytes === void 0) {
          this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;
        } else {
          if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED && settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);
          } else {
            this.cacheSizeBytes = settings.cacheSizeBytes;
          }
        }
        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;
        this.experimentalAutoDetectLongPolling = !!settings.experimentalAutoDetectLongPolling;
        this.useFetchStreams = !!settings.useFetchStreams;
        validateIsNotUsedTogether("experimentalForceLongPolling", settings.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", settings.experimentalAutoDetectLongPolling);
      }
      isEqual(other) {
        return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials && this.cacheSizeBytes === other.cacheSizeBytes && this.experimentalForceLongPolling === other.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === other.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === other.ignoreUndefinedProperties && this.useFetchStreams === other.useFetchStreams;
      }
    };
    Firestore$1 = class {
      constructor(databaseIdOrApp, _authCredentials, _appCheckCredentials) {
        this._authCredentials = _authCredentials;
        this._appCheckCredentials = _appCheckCredentials;
        this.type = "firestore-lite";
        this._persistenceKey = "(lite)";
        this._settings = new FirestoreSettingsImpl({});
        this._settingsFrozen = false;
        if (databaseIdOrApp instanceof DatabaseId) {
          this._databaseId = databaseIdOrApp;
        } else {
          this._app = databaseIdOrApp;
          this._databaseId = databaseIdFromApp(databaseIdOrApp);
        }
      }
      get app() {
        if (!this._app) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        }
        return this._app;
      }
      get _initialized() {
        return this._settingsFrozen;
      }
      get _terminated() {
        return this._terminateTask !== void 0;
      }
      _setSettings(settings) {
        if (this._settingsFrozen) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        }
        this._settings = new FirestoreSettingsImpl(settings);
        if (settings.credentials !== void 0) {
          this._authCredentials = makeAuthCredentialsProvider(settings.credentials);
        }
      }
      _getSettings() {
        return this._settings;
      }
      _freezeSettings() {
        this._settingsFrozen = true;
        return this._settings;
      }
      _delete() {
        if (!this._terminateTask) {
          this._terminateTask = this._terminate();
        }
        return this._terminateTask;
      }
      toJSON() {
        return {
          app: this._app,
          databaseId: this._databaseId,
          settings: this._settings
        };
      }
      _terminate() {
        removeComponents(this);
        return Promise.resolve();
      }
    };
    LOG_TAG = "AsyncQueue";
    AsyncQueueImpl = class {
      constructor() {
        this.tail = Promise.resolve();
        this.retryableOps = [];
        this._isShuttingDown = false;
        this.delayedOperations = [];
        this.failure = null;
        this.operationInProgress = false;
        this.skipNonRestrictedTasks = false;
        this.timerIdsToSkip = [];
        this.backoff = new ExponentialBackoff(this, "async_queue_retry");
        this.visibilityHandler = () => {
          this.backoff.skipBackoff();
        };
      }
      get isShuttingDown() {
        return this._isShuttingDown;
      }
      enqueueAndForget(op) {
        this.enqueue(op);
      }
      enqueueAndForgetEvenWhileRestricted(op) {
        this.verifyNotFailed();
        this.enqueueInternal(op);
      }
      enterRestrictedMode(purgeExistingTasks) {
        if (!this._isShuttingDown) {
          this._isShuttingDown = true;
          this.skipNonRestrictedTasks = purgeExistingTasks || false;
        }
      }
      enqueue(op) {
        this.verifyNotFailed();
        if (this._isShuttingDown) {
          return new Promise(() => {
          });
        }
        const task = new Deferred2();
        return this.enqueueInternal(() => {
          if (this._isShuttingDown && this.skipNonRestrictedTasks) {
            return Promise.resolve();
          }
          op().then(task.resolve, task.reject);
          return task.promise;
        }).then(() => task.promise);
      }
      enqueueRetryable(op) {
        this.enqueueAndForget(() => {
          this.retryableOps.push(op);
          return this.retryNextOp();
        });
      }
      async retryNextOp() {
        if (this.retryableOps.length === 0) {
          return;
        }
        try {
          await this.retryableOps[0]();
          this.retryableOps.shift();
          this.backoff.reset();
        } catch (e2) {
          if (isIndexedDbTransactionError(e2)) {
            logDebug(LOG_TAG, "Operation failed with retryable error: " + e2);
          } else {
            throw e2;
          }
        }
        if (this.retryableOps.length > 0) {
          this.backoff.backoffAndRun(() => this.retryNextOp());
        }
      }
      enqueueInternal(op) {
        const newTail = this.tail.then(() => {
          this.operationInProgress = true;
          return op().catch((error2) => {
            this.failure = error2;
            this.operationInProgress = false;
            const message = getMessageOrStack(error2);
            logError("INTERNAL UNHANDLED ERROR: ", message);
            throw error2;
          }).then((result) => {
            this.operationInProgress = false;
            return result;
          });
        });
        this.tail = newTail;
        return newTail;
      }
      enqueueAfterDelay(timerId, delayMs, op) {
        this.verifyNotFailed();
        if (this.timerIdsToSkip.indexOf(timerId) > -1) {
          delayMs = 0;
        }
        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, (removedOp) => this.removeDelayedOperation(removedOp));
        this.delayedOperations.push(delayedOp);
        return delayedOp;
      }
      verifyNotFailed() {
        if (this.failure) {
          fail();
        }
      }
      verifyOperationInProgress() {
      }
      async drain() {
        let currentTail;
        do {
          currentTail = this.tail;
          await currentTail;
        } while (currentTail !== this.tail);
      }
      containsDelayedOperation(timerId) {
        for (const op of this.delayedOperations) {
          if (op.timerId === timerId) {
            return true;
          }
        }
        return false;
      }
      runAllDelayedOperationsUntil(lastTimerId) {
        return this.drain().then(() => {
          this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);
          for (const op of this.delayedOperations) {
            op.skipDelay();
            if (lastTimerId !== "all" && op.timerId === lastTimerId) {
              break;
            }
          }
          return this.drain();
        });
      }
      skipDelaysForTimerId(timerId) {
        this.timerIdsToSkip.push(timerId);
      }
      removeDelayedOperation(op) {
        const index = this.delayedOperations.indexOf(op);
        this.delayedOperations.splice(index, 1);
      }
    };
    Firestore = class extends Firestore$1 {
      constructor(databaseIdOrApp, authCredentialsProvider, appCheckCredentialsProvider) {
        super(databaseIdOrApp, authCredentialsProvider, appCheckCredentialsProvider);
        this.type = "firestore";
        this._queue = newAsyncQueue();
        this._persistenceKey = "name" in databaseIdOrApp ? databaseIdOrApp.name : "[DEFAULT]";
      }
      _terminate() {
        if (!this._firestoreClient) {
          configureFirestore(this);
        }
        return this._firestoreClient.terminate();
      }
    };
    FIELD_PATH_RESERVED = new RegExp("[~\\*/\\[\\]]");
    registerFirestore("node");
  }
});

// node_modules/firebase/firestore/dist/index.mjs
var init_dist2 = __esm({
  "node_modules/firebase/firestore/dist/index.mjs"() {
    init_index_node();
  }
});

// .svelte-kit/output/server/entries/pages/index.svelte.js
var index_svelte_exports = {};
__export(index_svelte_exports, {
  default: () => Routes
});
var import_mapbox_gl, Search, Map2, LoginModal, ConfirmationModal, PlantingInstructions, Ui, Failure, Success, Routes;
var init_index_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/index.svelte.js"() {
    init_index_1e54ea6c();
    import_mapbox_gl = __toModule(require_mapbox_gl());
    init_dist();
    init_dist2();
    Search = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { map } = $$props;
      let searchValue = "";
      if ($$props.map === void 0 && $$bindings.map && map !== void 0)
        $$bindings.map(map);
      {
        {
          if (searchValue == void 0) {
            searchValue = "";
          }
          let strSearchValue = searchValue.toString();
          if (strSearchValue.length > 5) {
            searchValue = strSearchValue.substring(0, 5);
          }
        }
      }
      return `<div class="${"absolute top-60 right-0 bg-slate-400 blur-lg h-24 w-24"}"></div>
<div class="${"absolute top-60 right-2 "}"><label class="${"block"}" for="${"zipcode"}">Zip Code: </label> 
    <input type="${"number"}" class="${"block py-1 px-3 w-20 rounded text-sm"}" name="${"zipcode"}" max="${"99999"}" placeholder="${"zip code"}"${add_attribute("value", searchValue, 0)}>
    <button class="${"block bg-slate-100 py-1 px-4 my-1 rounded-full w-20"}">Search </button></div>`;
    });
    Map2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { pointLoc } = $$props;
      const firebaseConfig = {
        apiKey: "AIzaSyCgNGBk8nuH1EXZ_9Ks-91ug8WnAZgLMsI",
        authDomain: "greenifysd.firebaseapp.com",
        projectId: "greenifysd",
        storageBucket: "greenifysd.appspot.com",
        messagingSenderId: "30386930845",
        appId: "1:30386930845:web:936bec1bf3be9133c78074"
      };
      const app2 = initializeApp(firebaseConfig);
      getFirestore(app2);
      import_mapbox_gl.default.accessToken = "pk.eyJ1IjoiZGF4dG9uZ3V0ZSIsImEiOiJjbDFxc2F2OHQxcmdpM2NzOWZtNDU0emRrIn0.IUj4mbGb97G_5Il6Hs44FA";
      let map;
      if ($$props.pointLoc === void 0 && $$bindings.pointLoc && pointLoc !== void 0)
        $$bindings.pointLoc(pointLoc);
      return `${validate_component(Search, "Search").$$render($$result, { map }, {}, {})}

<div class="${"absolute top-0 -z-10"}" id="${"map"}" style="${"height:100%; width:100%"}"></div>`;
    });
    LoginModal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { modalVis } = $$props;
      let signUpResult = "";
      let email = "";
      if ($$props.modalVis === void 0 && $$bindings.modalVis && modalVis !== void 0)
        $$bindings.modalVis(modalVis);
      return `${modalVis ? `<div class="${"w-full h-full bg-blue-900 bg-opacity-50 absolute top-0"}"><div class="${"bg-slate-100 relative top-1/3 left-1/4 w-2/4 h-1/3 rounded-lg"}"><button class="${"text-4xl absolute right-2 top-2 hover:text-blue-700"}">X</button>
            <h1 class="${"text-center text-2xl pt-5"}">Login to Plant Trees </h1>

            <div class="${"mx-10 my-5"}" style="${"display: " + escape("block")}"><label for="${"email"}" class="${"block text-md"}">Email: </label>
                <input type="${"email"}" name="${"email"}" class="${"block w-full p-1"}"${add_attribute("value", email, 0)}>
                <button class="${"float-right bg-slate-500 rounded px-5 py-1 block rounded-t-none"}">Submit </button></div>

            <p class="${"text-red-500 mx-10 my-10"}">${escape(signUpResult)}</p></div></div>` : ``}`;
    });
    ConfirmationModal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { modalVis } = $$props;
      let { plantTree } = $$props;
      if ($$props.modalVis === void 0 && $$bindings.modalVis && modalVis !== void 0)
        $$bindings.modalVis(modalVis);
      if ($$props.plantTree === void 0 && $$bindings.plantTree && plantTree !== void 0)
        $$bindings.plantTree(plantTree);
      return `${modalVis ? `<div class="${"w-full h-full bg-blue-900 bg-opacity-50 absolute top-0"}"><div class="${"bg-slate-100 relative top-1/4 left-1/4 w-2/4 h-1/3 rounded-lg"}"><div class="${"p-5"}"><p class="${"text-2xl text-slate-900"}">Are you sure? </p>
                <p class="${"text-m text-slate-500"}">Once placed, you cannot change your submission. </p>
                <button class="${"text-xl bg-green-300 hover:bg-green-400 rounded-l absolute top-1/2 right-1/2 w-1/2 h-1/2 text-center"}">Yes</button>
                <button class="${"text-xl bg-red-300 hover:bg-red-400 rounded-r absolute top-1/2 left-1/2 w-1/2 h-1/2 text-center"}">No</button></div></div></div>` : ``}`;
    });
    PlantingInstructions = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { modalVis } = $$props;
      modalVis = false;
      if ($$props.modalVis === void 0 && $$bindings.modalVis && modalVis !== void 0)
        $$bindings.modalVis(modalVis);
      {
        {
          if (modalVis) {
            setTimeout(() => {
              modalVis = false;
            }, 5e3);
          }
        }
      }
      return `${modalVis ? `<div class="${"bg-red-200 absolute top-5 left-5 rounded-lg outline-4 outline-red-400"}"><p class="${"text-xl text-center text-red-900 pt-5 pb-0"}">Instructions </p>
        <div class="${"m-10 pt-0"}"><ol class="${"list-decimal"}"><li class="${"text-red-900"}">Click anywhere on the screen </li>
                <li class="${"text-red-900"}">Then select the green + button </li>
                <li class="${"text-red-900"}">Confirm your choice </li></ol>
            <p class="${"text-red-900"}"><strong>Note:</strong> Once confirming your choice, you cannot go back</p></div>
        <button class="${"text-4xl absolute right-2 top-2 hover:text-red-900 text-red-800"}">X</button></div>` : ``}`;
    });
    Ui = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { plantTree } = $$props;
      let loginModalDisplay = false;
      let confirmationModalDisplay = false;
      let plantTreeMode = false;
      if ($$props.plantTree === void 0 && $$bindings.plantTree && plantTree !== void 0)
        $$bindings.plantTree(plantTree);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `<img class="${"inline-flex absolute left-0 top-0 w-[10%]"}" src="${"./logo.png"}" alt="${"GreenifySD Logo"}"> 


${validate_component(LoginModal, "LoginModal").$$render($$result, { modalVis: loginModalDisplay }, {
          modalVis: ($$value) => {
            loginModalDisplay = $$value;
            $$settled = false;
          }
        }, {})}
${validate_component(ConfirmationModal, "ConfirmationModal").$$render($$result, {
          plantTree,
          modalVis: confirmationModalDisplay
        }, {
          modalVis: ($$value) => {
            confirmationModalDisplay = $$value;
            $$settled = false;
          }
        }, {})}
${validate_component(PlantingInstructions, "PlantingInstructionsModal").$$render($$result, { modalVis: plantTreeMode }, {}, {})}

${!loginModalDisplay && !confirmationModalDisplay ? `${`<div class="${"inline-flex items-center absolute bottom-10 left-1/2 -translate-x-1/2"}"><button class="${"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-10 rounded"}">Plant Your Own Tree</button></div>`}` : ``}`;
      } while (!$$settled);
      return $$rendered;
    });
    Failure = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { result } = $$props;
      if ($$props.result === void 0 && $$bindings.result && result !== void 0)
        $$bindings.result(result);
      return `<div class="${"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-56 h-30 bg-red-300 outline-double outline-2 outline-red-400"}"><p class="${"text-center text-red-900 text-4xl"}">Oops something went wrong :(</p>
    <p class="${"text-center text-red-900 text-xl"}">${escape(result)}</p></div>`;
    });
    Success = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { result } = $$props;
      if ($$props.result === void 0 && $$bindings.result && result !== void 0)
        $$bindings.result(result);
      return `<div class="${"w-full h-full bg-blue-900 bg-opacity-50 absolute top-0"}"><div class="${"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-56 h-30 bg-green-300 outline-double outline-2 outline-green-400"}"><p class="${"text-center text-green-900 text-4xl"}">Success!!</p>
        <p class="${"text-center text-green-900 text-xl"}">${escape(result)}</p></div></div>`;
    });
    Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let geoLocation = [0, 0];
      let resultVis = false;
      let backgroundVis = false;
      let success = false;
      let response = "";
      function plantTree() {
        let url = new URL(window.location.href);
        fetch("http://server-dot-greenifysd.wl.r.appspot.com/api/plantTree", {
          method: "POST",
          body: JSON.stringify({
            email: url.searchParams.get("email"),
            key: url.searchParams.get("key"),
            long: geoLocation[0],
            lat: geoLocation[1]
          }),
          headers: {
            "Content-type": "application/json; charset=UTF-8"
          }
        }).then((response2) => response2.json()).then((data) => {
          success = data["success"];
          response = data["response"];
          resultVis = true;
          setTimeout(() => {
            location.href = "./";
          }, 5e3);
        });
        backgroundVis = true;
      }
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(Map2, "Map").$$render($$result, { pointLoc: geoLocation }, {
          pointLoc: ($$value) => {
            geoLocation = $$value;
            $$settled = false;
          }
        }, {})}
${validate_component(Ui, "UI").$$render($$result, { plantTree }, {}, {})}

${backgroundVis ? `<div class="${"w-full h-full bg-blue-900 bg-opacity-50 absolute top-0"}">${resultVis ? `${success ? `${validate_component(Success, "Success").$$render($$result, { result: response }, {}, {})}` : `${validate_component(Failure, "Failure").$$render($$result, { result: response }, {}, {})}`}` : ``}</div>` : ``}`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  css: () => css4,
  entry: () => entry3,
  js: () => js3,
  module: () => index_svelte_exports
});
var entry3, js3, css4;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_index_svelte();
    entry3 = "pages/index.svelte-22de2354.js";
    js3 = ["pages/index.svelte-22de2354.js", "chunks/vendor-2dff75d7.js"];
    css4 = ["assets/pages/index.svelte-2d030089.css"];
  }
});

// node_modules/regexparam/dist/regexparam.js
var require_regexparam = __commonJS({
  "node_modules/regexparam/dist/regexparam.js"(exports2, module2) {
    module2.exports = function(str, loose) {
      if (str instanceof RegExp)
        return { keys: false, pattern: str };
      var c, o, tmp, ext, keys = [], pattern = "", arr = str.split("/");
      arr[0] || arr.shift();
      while (tmp = arr.shift()) {
        c = tmp[0];
        if (c === "*") {
          keys.push("wild");
          pattern += "/(.*)";
        } else if (c === ":") {
          o = tmp.indexOf("?", 1);
          ext = tmp.indexOf(".", 1);
          keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
          pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
          if (!!~ext)
            pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
        } else {
          pattern += "/" + tmp;
        }
      }
      return {
        keys,
        pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
      };
    };
  }
});

// node_modules/trouter/index.js
var require_trouter = __commonJS({
  "node_modules/trouter/index.js"(exports2, module2) {
    var parse3 = require_regexparam();
    module2.exports = class Trouter {
      constructor() {
        this.routes = [];
        this.all = this.add.bind(this, "");
        this.get = this.add.bind(this, "GET");
        this.head = this.add.bind(this, "HEAD");
        this.patch = this.add.bind(this, "PATCH");
        this.options = this.add.bind(this, "OPTIONS");
        this.connect = this.add.bind(this, "CONNECT");
        this.delete = this.add.bind(this, "DELETE");
        this.trace = this.add.bind(this, "TRACE");
        this.post = this.add.bind(this, "POST");
        this.put = this.add.bind(this, "PUT");
      }
      use(route, ...fns) {
        let handlers = [].concat.apply([], fns);
        let { keys, pattern } = parse3(route, true);
        this.routes.push({ keys, pattern, method: "", handlers });
        return this;
      }
      add(method, route, ...fns) {
        let { keys, pattern } = parse3(route);
        let handlers = [].concat.apply([], fns);
        this.routes.push({ keys, pattern, method, handlers });
        return this;
      }
      find(method, url) {
        let isHEAD = method === "HEAD";
        let i2 = 0, j = 0, k, tmp, arr = this.routes;
        let matches = [], params = {}, handlers = [];
        for (; i2 < arr.length; i2++) {
          tmp = arr[i2];
          if (tmp.method.length === 0 || tmp.method === method || isHEAD && tmp.method === "GET") {
            if (tmp.keys === false) {
              matches = tmp.pattern.exec(url);
              if (matches === null)
                continue;
              if (matches.groups !== void 0)
                for (k in matches.groups)
                  params[k] = matches.groups[k];
              tmp.handlers.length > 1 ? handlers = handlers.concat(tmp.handlers) : handlers.push(tmp.handlers[0]);
            } else if (tmp.keys.length > 0) {
              matches = tmp.pattern.exec(url);
              if (matches === null)
                continue;
              for (j = 0; j < tmp.keys.length; )
                params[tmp.keys[j]] = matches[++j];
              tmp.handlers.length > 1 ? handlers = handlers.concat(tmp.handlers) : handlers.push(tmp.handlers[0]);
            } else if (tmp.pattern.test(url)) {
              tmp.handlers.length > 1 ? handlers = handlers.concat(tmp.handlers) : handlers.push(tmp.handlers[0]);
            }
          }
        }
        return { params, handlers };
      }
    };
  }
});

// node_modules/totalist/sync/index.js
var require_sync = __commonJS({
  "node_modules/totalist/sync/index.js"(exports2) {
    var { join, resolve: resolve2 } = require("path");
    var { readdirSync, statSync } = require("fs");
    function totalist(dir, callback, pre = "") {
      dir = resolve2(".", dir);
      let arr = readdirSync(dir);
      let i2 = 0, abs, stats;
      for (; i2 < arr.length; i2++) {
        abs = join(dir, arr[i2]);
        stats = statSync(abs);
        stats.isDirectory() ? totalist(abs, callback, join(pre, arr[i2])) : callback(join(pre, arr[i2]), abs, stats);
      }
    }
    exports2.totalist = totalist;
  }
});

// node_modules/@polka/url/build.js
var require_build = __commonJS({
  "node_modules/@polka/url/build.js"(exports2) {
    var qs2 = require("querystring");
    function parse3(req) {
      let raw = req.url;
      if (raw == null)
        return;
      let prev = req._parsedUrl;
      if (prev && prev.raw === raw)
        return prev;
      let pathname = raw, search = "", query;
      if (raw.length > 1) {
        let idx = raw.indexOf("?", 1);
        if (idx !== -1) {
          search = raw.substring(idx);
          pathname = raw.substring(0, idx);
          if (search.length > 1) {
            query = qs2.parse(search.substring(1));
          }
        }
      }
      return req._parsedUrl = { pathname, search, query, raw };
    }
    exports2.parse = parse3;
  }
});

// node_modules/mrmime/index.js
var require_mrmime = __commonJS({
  "node_modules/mrmime/index.js"(exports2) {
    var mimes = {
      "ez": "application/andrew-inset",
      "aw": "application/applixware",
      "atom": "application/atom+xml",
      "atomcat": "application/atomcat+xml",
      "atomdeleted": "application/atomdeleted+xml",
      "atomsvc": "application/atomsvc+xml",
      "dwd": "application/atsc-dwd+xml",
      "held": "application/atsc-held+xml",
      "rsat": "application/atsc-rsat+xml",
      "bdoc": "application/bdoc",
      "xcs": "application/calendar+xml",
      "ccxml": "application/ccxml+xml",
      "cdfx": "application/cdfx+xml",
      "cdmia": "application/cdmi-capability",
      "cdmic": "application/cdmi-container",
      "cdmid": "application/cdmi-domain",
      "cdmio": "application/cdmi-object",
      "cdmiq": "application/cdmi-queue",
      "cu": "application/cu-seeme",
      "mpd": "application/dash+xml",
      "davmount": "application/davmount+xml",
      "dbk": "application/docbook+xml",
      "dssc": "application/dssc+der",
      "xdssc": "application/dssc+xml",
      "es": "application/ecmascript",
      "ecma": "application/ecmascript",
      "emma": "application/emma+xml",
      "emotionml": "application/emotionml+xml",
      "epub": "application/epub+zip",
      "exi": "application/exi",
      "fdt": "application/fdt+xml",
      "pfr": "application/font-tdpfr",
      "geojson": "application/geo+json",
      "gml": "application/gml+xml",
      "gpx": "application/gpx+xml",
      "gxf": "application/gxf",
      "gz": "application/gzip",
      "hjson": "application/hjson",
      "stk": "application/hyperstudio",
      "ink": "application/inkml+xml",
      "inkml": "application/inkml+xml",
      "ipfix": "application/ipfix",
      "its": "application/its+xml",
      "jar": "application/java-archive",
      "war": "application/java-archive",
      "ear": "application/java-archive",
      "ser": "application/java-serialized-object",
      "class": "application/java-vm",
      "js": "application/javascript",
      "mjs": "application/javascript",
      "json": "application/json",
      "map": "application/json",
      "json5": "application/json5",
      "jsonml": "application/jsonml+json",
      "jsonld": "application/ld+json",
      "lgr": "application/lgr+xml",
      "lostxml": "application/lost+xml",
      "hqx": "application/mac-binhex40",
      "cpt": "application/mac-compactpro",
      "mads": "application/mads+xml",
      "webmanifest": "application/manifest+json",
      "mrc": "application/marc",
      "mrcx": "application/marcxml+xml",
      "ma": "application/mathematica",
      "nb": "application/mathematica",
      "mb": "application/mathematica",
      "mathml": "application/mathml+xml",
      "mbox": "application/mbox",
      "mscml": "application/mediaservercontrol+xml",
      "metalink": "application/metalink+xml",
      "meta4": "application/metalink4+xml",
      "mets": "application/mets+xml",
      "maei": "application/mmt-aei+xml",
      "musd": "application/mmt-usd+xml",
      "mods": "application/mods+xml",
      "m21": "application/mp21",
      "mp21": "application/mp21",
      "mp4s": "application/mp4",
      "m4p": "application/mp4",
      "doc": "application/msword",
      "dot": "application/msword",
      "mxf": "application/mxf",
      "nq": "application/n-quads",
      "nt": "application/n-triples",
      "cjs": "application/node",
      "bin": "application/octet-stream",
      "dms": "application/octet-stream",
      "lrf": "application/octet-stream",
      "mar": "application/octet-stream",
      "so": "application/octet-stream",
      "dist": "application/octet-stream",
      "distz": "application/octet-stream",
      "pkg": "application/octet-stream",
      "bpk": "application/octet-stream",
      "dump": "application/octet-stream",
      "elc": "application/octet-stream",
      "deploy": "application/octet-stream",
      "exe": "application/octet-stream",
      "dll": "application/octet-stream",
      "deb": "application/octet-stream",
      "dmg": "application/octet-stream",
      "iso": "application/octet-stream",
      "img": "application/octet-stream",
      "msi": "application/octet-stream",
      "msp": "application/octet-stream",
      "msm": "application/octet-stream",
      "buffer": "application/octet-stream",
      "oda": "application/oda",
      "opf": "application/oebps-package+xml",
      "ogx": "application/ogg",
      "omdoc": "application/omdoc+xml",
      "onetoc": "application/onenote",
      "onetoc2": "application/onenote",
      "onetmp": "application/onenote",
      "onepkg": "application/onenote",
      "oxps": "application/oxps",
      "relo": "application/p2p-overlay+xml",
      "xer": "application/patch-ops-error+xml",
      "pdf": "application/pdf",
      "pgp": "application/pgp-encrypted",
      "asc": "application/pgp-signature",
      "sig": "application/pgp-signature",
      "prf": "application/pics-rules",
      "p10": "application/pkcs10",
      "p7m": "application/pkcs7-mime",
      "p7c": "application/pkcs7-mime",
      "p7s": "application/pkcs7-signature",
      "p8": "application/pkcs8",
      "ac": "application/pkix-attr-cert",
      "cer": "application/pkix-cert",
      "crl": "application/pkix-crl",
      "pkipath": "application/pkix-pkipath",
      "pki": "application/pkixcmp",
      "pls": "application/pls+xml",
      "ai": "application/postscript",
      "eps": "application/postscript",
      "ps": "application/postscript",
      "provx": "application/provenance+xml",
      "cww": "application/prs.cww",
      "pskcxml": "application/pskc+xml",
      "raml": "application/raml+yaml",
      "rdf": "application/rdf+xml",
      "owl": "application/rdf+xml",
      "rif": "application/reginfo+xml",
      "rnc": "application/relax-ng-compact-syntax",
      "rl": "application/resource-lists+xml",
      "rld": "application/resource-lists-diff+xml",
      "rs": "application/rls-services+xml",
      "rapd": "application/route-apd+xml",
      "sls": "application/route-s-tsid+xml",
      "rusd": "application/route-usd+xml",
      "gbr": "application/rpki-ghostbusters",
      "mft": "application/rpki-manifest",
      "roa": "application/rpki-roa",
      "rsd": "application/rsd+xml",
      "rss": "application/rss+xml",
      "rtf": "application/rtf",
      "sbml": "application/sbml+xml",
      "scq": "application/scvp-cv-request",
      "scs": "application/scvp-cv-response",
      "spq": "application/scvp-vp-request",
      "spp": "application/scvp-vp-response",
      "sdp": "application/sdp",
      "senmlx": "application/senml+xml",
      "sensmlx": "application/sensml+xml",
      "setpay": "application/set-payment-initiation",
      "setreg": "application/set-registration-initiation",
      "shf": "application/shf+xml",
      "siv": "application/sieve",
      "sieve": "application/sieve",
      "smi": "application/smil+xml",
      "smil": "application/smil+xml",
      "rq": "application/sparql-query",
      "srx": "application/sparql-results+xml",
      "gram": "application/srgs",
      "grxml": "application/srgs+xml",
      "sru": "application/sru+xml",
      "ssdl": "application/ssdl+xml",
      "ssml": "application/ssml+xml",
      "swidtag": "application/swid+xml",
      "tei": "application/tei+xml",
      "teicorpus": "application/tei+xml",
      "tfi": "application/thraud+xml",
      "tsd": "application/timestamped-data",
      "toml": "application/toml",
      "trig": "application/trig",
      "ttml": "application/ttml+xml",
      "ubj": "application/ubjson",
      "rsheet": "application/urc-ressheet+xml",
      "td": "application/urc-targetdesc+xml",
      "vxml": "application/voicexml+xml",
      "wasm": "application/wasm",
      "wgt": "application/widget",
      "hlp": "application/winhlp",
      "wsdl": "application/wsdl+xml",
      "wspolicy": "application/wspolicy+xml",
      "xaml": "application/xaml+xml",
      "xav": "application/xcap-att+xml",
      "xca": "application/xcap-caps+xml",
      "xdf": "application/xcap-diff+xml",
      "xel": "application/xcap-el+xml",
      "xns": "application/xcap-ns+xml",
      "xenc": "application/xenc+xml",
      "xhtml": "application/xhtml+xml",
      "xht": "application/xhtml+xml",
      "xlf": "application/xliff+xml",
      "xml": "application/xml",
      "xsl": "application/xml",
      "xsd": "application/xml",
      "rng": "application/xml",
      "dtd": "application/xml-dtd",
      "xop": "application/xop+xml",
      "xpl": "application/xproc+xml",
      "xslt": "application/xml",
      "xspf": "application/xspf+xml",
      "mxml": "application/xv+xml",
      "xhvml": "application/xv+xml",
      "xvml": "application/xv+xml",
      "xvm": "application/xv+xml",
      "yang": "application/yang",
      "yin": "application/yin+xml",
      "zip": "application/zip",
      "3gpp": "video/3gpp",
      "adp": "audio/adpcm",
      "amr": "audio/amr",
      "au": "audio/basic",
      "snd": "audio/basic",
      "mid": "audio/midi",
      "midi": "audio/midi",
      "kar": "audio/midi",
      "rmi": "audio/midi",
      "mxmf": "audio/mobile-xmf",
      "mp3": "audio/mpeg",
      "m4a": "audio/mp4",
      "mp4a": "audio/mp4",
      "mpga": "audio/mpeg",
      "mp2": "audio/mpeg",
      "mp2a": "audio/mpeg",
      "m2a": "audio/mpeg",
      "m3a": "audio/mpeg",
      "oga": "audio/ogg",
      "ogg": "audio/ogg",
      "spx": "audio/ogg",
      "opus": "audio/ogg",
      "s3m": "audio/s3m",
      "sil": "audio/silk",
      "wav": "audio/wav",
      "weba": "audio/webm",
      "xm": "audio/xm",
      "ttc": "font/collection",
      "otf": "font/otf",
      "ttf": "font/ttf",
      "woff": "font/woff",
      "woff2": "font/woff2",
      "exr": "image/aces",
      "apng": "image/apng",
      "avif": "image/avif",
      "bmp": "image/bmp",
      "cgm": "image/cgm",
      "drle": "image/dicom-rle",
      "emf": "image/emf",
      "fits": "image/fits",
      "g3": "image/g3fax",
      "gif": "image/gif",
      "heic": "image/heic",
      "heics": "image/heic-sequence",
      "heif": "image/heif",
      "heifs": "image/heif-sequence",
      "hej2": "image/hej2k",
      "hsj2": "image/hsj2",
      "ief": "image/ief",
      "jls": "image/jls",
      "jp2": "image/jp2",
      "jpg2": "image/jp2",
      "jpeg": "image/jpeg",
      "jpg": "image/jpeg",
      "jpe": "image/jpeg",
      "jph": "image/jph",
      "jhc": "image/jphc",
      "jpm": "image/jpm",
      "jpx": "image/jpx",
      "jpf": "image/jpx",
      "jxr": "image/jxr",
      "jxra": "image/jxra",
      "jxrs": "image/jxrs",
      "jxs": "image/jxs",
      "jxsc": "image/jxsc",
      "jxsi": "image/jxsi",
      "jxss": "image/jxss",
      "ktx": "image/ktx",
      "ktx2": "image/ktx2",
      "png": "image/png",
      "btif": "image/prs.btif",
      "pti": "image/prs.pti",
      "sgi": "image/sgi",
      "svg": "image/svg+xml",
      "svgz": "image/svg+xml",
      "t38": "image/t38",
      "tif": "image/tiff",
      "tiff": "image/tiff",
      "tfx": "image/tiff-fx",
      "webp": "image/webp",
      "wmf": "image/wmf",
      "disposition-notification": "message/disposition-notification",
      "u8msg": "message/global",
      "u8dsn": "message/global-delivery-status",
      "u8mdn": "message/global-disposition-notification",
      "u8hdr": "message/global-headers",
      "eml": "message/rfc822",
      "mime": "message/rfc822",
      "3mf": "model/3mf",
      "gltf": "model/gltf+json",
      "glb": "model/gltf-binary",
      "igs": "model/iges",
      "iges": "model/iges",
      "msh": "model/mesh",
      "mesh": "model/mesh",
      "silo": "model/mesh",
      "mtl": "model/mtl",
      "obj": "model/obj",
      "stpz": "model/step+zip",
      "stpxz": "model/step-xml+zip",
      "stl": "model/stl",
      "wrl": "model/vrml",
      "vrml": "model/vrml",
      "x3db": "model/x3d+fastinfoset",
      "x3dbz": "model/x3d+binary",
      "x3dv": "model/x3d-vrml",
      "x3dvz": "model/x3d+vrml",
      "x3d": "model/x3d+xml",
      "x3dz": "model/x3d+xml",
      "appcache": "text/cache-manifest",
      "manifest": "text/cache-manifest",
      "ics": "text/calendar",
      "ifb": "text/calendar",
      "coffee": "text/coffeescript",
      "litcoffee": "text/coffeescript",
      "css": "text/css",
      "csv": "text/csv",
      "html": "text/html",
      "htm": "text/html",
      "shtml": "text/html",
      "jade": "text/jade",
      "jsx": "text/jsx",
      "less": "text/less",
      "markdown": "text/markdown",
      "md": "text/markdown",
      "mml": "text/mathml",
      "mdx": "text/mdx",
      "n3": "text/n3",
      "txt": "text/plain",
      "text": "text/plain",
      "conf": "text/plain",
      "def": "text/plain",
      "list": "text/plain",
      "log": "text/plain",
      "in": "text/plain",
      "ini": "text/plain",
      "dsc": "text/prs.lines.tag",
      "rtx": "text/richtext",
      "sgml": "text/sgml",
      "sgm": "text/sgml",
      "shex": "text/shex",
      "slim": "text/slim",
      "slm": "text/slim",
      "spdx": "text/spdx",
      "stylus": "text/stylus",
      "styl": "text/stylus",
      "tsv": "text/tab-separated-values",
      "t": "text/troff",
      "tr": "text/troff",
      "roff": "text/troff",
      "man": "text/troff",
      "me": "text/troff",
      "ms": "text/troff",
      "ttl": "text/turtle",
      "uri": "text/uri-list",
      "uris": "text/uri-list",
      "urls": "text/uri-list",
      "vcard": "text/vcard",
      "vtt": "text/vtt",
      "yaml": "text/yaml",
      "yml": "text/yaml",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      "h261": "video/h261",
      "h263": "video/h263",
      "h264": "video/h264",
      "m4s": "video/iso.segment",
      "jpgv": "video/jpeg",
      "jpgm": "image/jpm",
      "mj2": "video/mj2",
      "mjp2": "video/mj2",
      "ts": "video/mp2t",
      "mp4": "video/mp4",
      "mp4v": "video/mp4",
      "mpg4": "video/mp4",
      "mpeg": "video/mpeg",
      "mpg": "video/mpeg",
      "mpe": "video/mpeg",
      "m1v": "video/mpeg",
      "m2v": "video/mpeg",
      "ogv": "video/ogg",
      "qt": "video/quicktime",
      "mov": "video/quicktime",
      "webm": "video/webm"
    };
    function lookup(extn) {
      let tmp = ("" + extn).trim().toLowerCase();
      let idx = tmp.lastIndexOf(".");
      return mimes[!~idx ? tmp : tmp.substring(++idx)];
    }
    exports2.lookup = lookup;
    exports2.mimes = mimes;
  }
});

// node_modules/sirv/build.js
var require_build2 = __commonJS({
  "node_modules/sirv/build.js"(exports2, module2) {
    var fs = require("fs");
    var { join, normalize: normalize2, resolve: resolve2 } = require("path");
    var { totalist } = require_sync();
    var { parse: parse3 } = require_build();
    var { lookup } = require_mrmime();
    var noop3 = () => {
    };
    function isMatch(uri, arr) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2].test(uri))
          return true;
      }
    }
    function toAssume(uri, extns) {
      let i2 = 0, x2, len = uri.length - 1;
      if (uri.charCodeAt(len) === 47) {
        uri = uri.substring(0, len);
      }
      let arr = [], tmp = `${uri}/index`;
      for (; i2 < extns.length; i2++) {
        x2 = extns[i2] ? `.${extns[i2]}` : "";
        if (uri)
          arr.push(uri + x2);
        arr.push(tmp + x2);
      }
      return arr;
    }
    function viaCache(cache, uri, extns) {
      let i2 = 0, data, arr = toAssume(uri, extns);
      for (; i2 < arr.length; i2++) {
        if (data = cache[arr[i2]])
          return data;
      }
    }
    function viaLocal(dir, isEtag, uri, extns) {
      let i2 = 0, arr = toAssume(uri, extns);
      let abs, stats, name4, headers;
      for (; i2 < arr.length; i2++) {
        abs = normalize2(join(dir, name4 = arr[i2]));
        if (abs.startsWith(dir) && fs.existsSync(abs)) {
          stats = fs.statSync(abs);
          if (stats.isDirectory())
            continue;
          headers = toHeaders(name4, stats, isEtag);
          headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
          return { abs, stats, headers };
        }
      }
    }
    function is404(req, res) {
      return res.statusCode = 404, res.end();
    }
    function send(req, res, file, stats, headers) {
      let code = 200, tmp, opts = {};
      headers = __spreadValues({}, headers);
      for (let key2 in headers) {
        tmp = res.getHeader(key2);
        if (tmp)
          headers[key2] = tmp;
      }
      if (tmp = res.getHeader("content-type")) {
        headers["Content-Type"] = tmp;
      }
      if (req.headers.range) {
        code = 206;
        let [x2, y] = req.headers.range.replace("bytes=", "").split("-");
        let end = opts.end = parseInt(y, 10) || stats.size - 1;
        let start = opts.start = parseInt(x2, 10) || 0;
        if (start >= stats.size || end >= stats.size) {
          res.setHeader("Content-Range", `bytes */${stats.size}`);
          res.statusCode = 416;
          return res.end();
        }
        headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
        headers["Content-Length"] = end - start + 1;
        headers["Accept-Ranges"] = "bytes";
      }
      res.writeHead(code, headers);
      fs.createReadStream(file, opts).pipe(res);
    }
    var ENCODING = {
      ".br": "br",
      ".gz": "gzip"
    };
    function toHeaders(name4, stats, isEtag) {
      let enc = ENCODING[name4.slice(-3)];
      let ctype = lookup(name4.slice(0, enc && -3)) || "";
      if (ctype === "text/html")
        ctype += ";charset=utf-8";
      let headers = {
        "Content-Length": stats.size,
        "Content-Type": ctype,
        "Last-Modified": stats.mtime.toUTCString()
      };
      if (enc)
        headers["Content-Encoding"] = enc;
      if (isEtag)
        headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
      return headers;
    }
    module2.exports = function(dir, opts = {}) {
      dir = resolve2(dir || ".");
      let isNotFound = opts.onNoMatch || is404;
      let setHeaders = opts.setHeaders || noop3;
      let extensions = opts.extensions || ["html", "htm"];
      let gzips = opts.gzip && extensions.map((x2) => `${x2}.gz`).concat("gz");
      let brots = opts.brotli && extensions.map((x2) => `${x2}.br`).concat("br");
      const FILES = {};
      let fallback = "/";
      let isEtag = !!opts.etag;
      let isSPA = !!opts.single;
      if (typeof opts.single === "string") {
        let idx = opts.single.lastIndexOf(".");
        fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
      }
      let ignores = [];
      if (opts.ignores !== false) {
        ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
        if (opts.dotfiles)
          ignores.push(/\/\.\w/);
        else
          ignores.push(/\/\.well-known/);
        [].concat(opts.ignores || []).forEach((x2) => {
          ignores.push(new RegExp(x2, "i"));
        });
      }
      let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
      if (cc && opts.immutable)
        cc += ",immutable";
      else if (cc && opts.maxAge === 0)
        cc += ",must-revalidate";
      if (!opts.dev) {
        totalist(dir, (name4, abs, stats) => {
          if (/\.well-known[\\+\/]/.test(name4)) {
          } else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name4))
            return;
          let headers = toHeaders(name4, stats, isEtag);
          if (cc)
            headers["Cache-Control"] = cc;
          FILES["/" + name4.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
        });
      }
      let lookup2 = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
      return function(req, res, next) {
        let extns = [""];
        let pathname = parse3(req).pathname;
        let val = req.headers["accept-encoding"] || "";
        if (gzips && val.includes("gzip"))
          extns.unshift(...gzips);
        if (brots && /(br|brotli)/i.test(val))
          extns.unshift(...brots);
        extns.push(...extensions);
        if (pathname.indexOf("%") !== -1) {
          try {
            pathname = decodeURIComponent(pathname);
          } catch (err) {
          }
        }
        let data = lookup2(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup2(fallback, extns);
        if (!data)
          return next ? next() : isNotFound(req, res);
        if (isEtag && req.headers["if-none-match"] === data.headers["ETag"]) {
          res.writeHead(304);
          return res.end();
        }
        if (gzips || brots) {
          res.setHeader("Vary", "Accept-Encoding");
        }
        setHeaders(res, pathname, data.stats);
        send(req, res, data.abs, data.stats, data.headers);
      };
    };
  }
});

// .svelte-kit/output/server/chunks/hooks-1c45ba0b.js
var hooks_1c45ba0b_exports = {};
__markAsModule(hooks_1c45ba0b_exports);
var init_hooks_1c45ba0b = __esm({
  ".svelte-kit/output/server/chunks/hooks-1c45ba0b.js"() {
  }
});

// .svelte-kit/appengine-tmp/entry.js
__export(exports, {
  server: () => server
});
var import_node_path2 = __toModule(require("node:path"));
init_install_fetch();

// node_modules/@sveltejs/kit/dist/node.js
var import_stream = __toModule(require("stream"));
function get_raw_body(req) {
  return new Promise((fulfil, reject) => {
    const h2 = req.headers;
    if (!h2["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h2["content-length"]);
    if (isNaN(length) && h2["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}
async function getRequest(base2, req) {
  let headers = req.headers;
  if (req.httpVersionMajor === 2) {
    headers = Object.assign({}, headers);
    delete headers[":method"];
    delete headers[":path"];
    delete headers[":authority"];
    delete headers[":scheme"];
  }
  return new Request(base2 + req.url, {
    method: req.method,
    headers,
    body: await get_raw_body(req)
  });
}
async function setResponse(res, response) {
  const headers = Object.fromEntries(response.headers);
  if (response.headers.has("set-cookie")) {
    headers["set-cookie"] = response.headers.raw()["set-cookie"];
  }
  res.writeHead(response.status, headers);
  if (response.body instanceof import_stream.Readable) {
    response.body.pipe(res);
  } else {
    if (response.body) {
      res.write(await response.arrayBuffer());
    }
    res.end();
  }
}

// .svelte-kit/appengine-tmp/entry.js
var import_compression = __toModule(require_compression());

// .svelte-kit/appengine-tmp/manifest.js
var manifest = {
  appDir: "_app",
  assets: new Set(["logo.png", "plantMarker.png", "treeMarker.png"]),
  mimeTypes: { ".png": "image/png" },
  _: {
    entry: { "file": "start-31d48d94.js", "js": ["start-31d48d94.js", "chunks/vendor-2dff75d7.js"], "css": [] },
    nodes: [
      () => Promise.resolve().then(() => (init__(), __exports)),
      () => Promise.resolve().then(() => (init__2(), __exports2)),
      () => Promise.resolve().then(() => (init__3(), __exports3))
    ],
    routes: [
      {
        type: "page",
        id: "",
        pattern: /^\/$/,
        names: [],
        types: [],
        path: "/",
        shadow: null,
        a: [0, 2],
        b: [1]
      }
    ],
    matchers: async () => {
      return {};
    }
  }
};

// node_modules/polka/build.mjs
var import_http = __toModule(require("http"));
var import_trouter = __toModule(require_trouter());

// node_modules/@polka/url/build.mjs
var qs = __toModule(require("querystring"));
function parse2(req) {
  let raw = req.url;
  if (raw == null)
    return;
  let prev = req._parsedUrl;
  if (prev && prev.raw === raw)
    return prev;
  let pathname = raw, search = "", query;
  if (raw.length > 1) {
    let idx = raw.indexOf("?", 1);
    if (idx !== -1) {
      search = raw.substring(idx);
      pathname = raw.substring(0, idx);
      if (search.length > 1) {
        query = qs.parse(search.substring(1));
      }
    }
  }
  return req._parsedUrl = { pathname, search, query, raw };
}

// node_modules/polka/build.mjs
function onError(err, req, res) {
  let code = typeof err.status === "number" && err.status;
  code = res.statusCode = code && code >= 100 ? code : 500;
  if (typeof err === "string" || Buffer.isBuffer(err))
    res.end(err);
  else
    res.end(err.message || import_http.default.STATUS_CODES[code]);
}
var mount = (fn) => fn instanceof Polka ? fn.attach : fn;
var Polka = class extends import_trouter.default {
  constructor(opts = {}) {
    super();
    this.parse = parse2;
    this.server = opts.server;
    this.handler = this.handler.bind(this);
    this.onError = opts.onError || onError;
    this.onNoMatch = opts.onNoMatch || this.onError.bind(null, { status: 404 });
    this.attach = (req, res) => setImmediate(this.handler, req, res);
  }
  use(base2, ...fns) {
    if (base2 === "/") {
      super.use(base2, fns.map(mount));
    } else if (typeof base2 === "function" || base2 instanceof Polka) {
      super.use("/", [base2, ...fns].map(mount));
    } else {
      super.use(base2, (req, _, next) => {
        if (typeof base2 === "string") {
          let len = base2.length;
          base2.startsWith("/") || len++;
          req.url = req.url.substring(len) || "/";
          req.path = req.path.substring(len) || "/";
        } else {
          req.url = req.url.replace(base2, "") || "/";
          req.path = req.path.replace(base2, "") || "/";
        }
        if (req.url.charAt(0) !== "/") {
          req.url = "/" + req.url;
        }
        next();
      }, fns.map(mount), (req, _, next) => {
        req.path = req._parsedUrl.pathname;
        req.url = req.path + req._parsedUrl.search;
        next();
      });
    }
    return this;
  }
  listen() {
    (this.server = this.server || import_http.default.createServer()).on("request", this.attach);
    this.server.listen.apply(this.server, arguments);
    return this;
  }
  handler(req, res, next) {
    let info = this.parse(req), path2 = info.pathname;
    let obj = this.find(req.method, req.path = path2);
    req.url = path2 + info.search;
    req.originalUrl = req.originalUrl || req.url;
    req.query = info.query || {};
    req.search = info.search;
    req.params = obj.params;
    if (path2.length > 1 && path2.indexOf("%", 1) !== -1) {
      for (let k in req.params) {
        try {
          req.params[k] = decodeURIComponent(req.params[k]);
        } catch (e2) {
        }
      }
    }
    let i2 = 0, arr = obj.handlers.concat(this.onNoMatch), len = arr.length;
    let loop = async () => res.finished || i2 < len && arr[i2++](req, res, next);
    (next = next || ((err) => err ? this.onError(err, req, res, next) : loop().catch(next)))();
  }
};
function build_default(opts) {
  return new Polka(opts);
}

// .svelte-kit/appengine-tmp/entry.js
var import_sirv = __toModule(require_build2());

// .svelte-kit/output/server/index.js
init_index_1e54ea6c();
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _use_hashes;
var _dev;
var _script_needs_csp;
var _style_needs_csp;
var _directives;
var _script_src;
var _style_src;
function afterUpdate() {
}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  {
    stores.page.set(page);
  }
  return `


${components[1] ? `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => {
      return `${components[2] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
        default: () => {
          return `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}`;
        }
      })}` : `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {})}`}`;
    }
  })}` : `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {})}`}

${``}`;
});
function to_headers(object) {
  const headers = new Headers();
  if (object) {
    for (const key2 in object) {
      const value = object[key2];
      if (!value)
        continue;
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          headers.append(key2, value2);
        });
      } else {
        headers.set(key2, value);
      }
    }
  }
  return headers;
}
function hash(value) {
  let hash2 = 5381;
  let i2 = value.length;
  if (typeof value === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key2 in obj) {
    clone2[key2.toLowerCase()] = obj[key2];
  }
  return clone2;
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = params[key2].replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
  }
  return params;
}
function is_pojo(body) {
  if (typeof body !== "object")
    return false;
  if (body) {
    if (body instanceof Uint8Array)
      return false;
    if (body._readableState && typeof body.pipe === "function")
      return false;
    if (typeof ReadableStream !== "undefined" && body instanceof ReadableStream)
      return false;
  }
  return true;
}
function normalize_request_method(event) {
  const method = event.request.method.toLowerCase();
  return method === "delete" ? "del" : method;
}
function error(body) {
  return new Response(body, {
    status: 500
  });
}
function is_string(s22) {
  return typeof s22 === "string" || s22 instanceof String;
}
var text_types = /* @__PURE__ */ new Set([
  "application/xml",
  "application/json",
  "application/x-www-form-urlencoded",
  "multipart/form-data"
]);
function is_text(content_type) {
  if (!content_type)
    return true;
  const type = content_type.split(";")[0].toLowerCase();
  return type.startsWith("text/") || type.endsWith("+xml") || text_types.has(type);
}
async function render_endpoint(event, mod2) {
  const method = normalize_request_method(event);
  let handler = mod2[method];
  if (!handler && method === "head") {
    handler = mod2.get;
  }
  if (!handler) {
    return event.request.headers.get("x-sveltekit-load") ? new Response(void 0, {
      status: 204
    }) : new Response("Method not allowed", {
      status: 405
    });
  }
  const response = await handler(event);
  const preface = `Invalid response from route ${event.url.pathname}`;
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  if (response.fallthrough) {
    throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
  }
  const { status = 200, body = {} } = response;
  const headers = response.headers instanceof Headers ? new Headers(response.headers) : to_headers(response.headers);
  const type = headers.get("content-type");
  if (!is_text(type) && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if (is_pojo(body) && (!type || type.startsWith("application/json"))) {
    headers.set("content-type", "application/json; charset=utf-8");
    normalized_body = JSON.stringify(body);
  } else {
    normalized_body = body;
  }
  if ((typeof normalized_body === "string" || normalized_body instanceof Uint8Array) && !headers.has("etag")) {
    const cache_control = headers.get("cache-control");
    if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
      headers.set("etag", `"${hash(normalized_body)}"`);
    }
  }
  return new Response(method !== "head" ? normalized_body : void 0, {
    status,
    headers
  });
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key2) {
            return walk(thing[key2]);
          });
      }
    }
  }
  walk(value);
  var names = /* @__PURE__ */ new Map();
  Array.from(counts).filter(function(entry4) {
    return entry4[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry4, i2) {
    names.set(entry4[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i2) {
          return i2 in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key2) {
          return safeKey(key2) + ":" + stringify(thing[key2]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name4, thing) {
      params_1.push(name4);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i2) {
            statements_1.push(name4 + "[" + i2 + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name4 + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name4 + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key2) {
            statements_1.push("" + name4 + safeProp(key2) + "=" + stringify(thing[key2]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name4 = "";
  do {
    name4 = chars$1[num % chars$1.length] + name4;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name4) ? name4 + "_" : name4;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped2[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escapeUnsafeChars(JSON.stringify(key2));
}
function safeProp(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? "." + key2 : "[" + escapeUnsafeChars(JSON.stringify(key2)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped2) {
      result += escaped2[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop2() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop2) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe };
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var render_json_payload_script_dict = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var render_json_payload_script_regex = new RegExp(`[${Object.keys(render_json_payload_script_dict).join("")}]`, "g");
function render_json_payload_script(attrs, payload) {
  const safe_payload = JSON.stringify(payload).replace(render_json_payload_script_regex, (match) => render_json_payload_script_dict[match]);
  let safe_attrs = "";
  for (const [key2, value] of Object.entries(attrs)) {
    if (value === void 0)
      continue;
    safe_attrs += ` sveltekit:data-${key2}=${escape_html_attr(value)}`;
  }
  return `<script type="application/json"${safe_attrs}>${safe_payload}<\/script>`;
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(`[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`, "g");
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var s2 = JSON.stringify;
function create_prerendering_url_proxy(url) {
  return new Proxy(url, {
    get: (target, prop, receiver) => {
      if (prop === "search" || prop === "searchParams") {
        throw new Error(`Cannot access url.${prop} on a page with prerendering enabled`);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
var encoder = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array = encode(data);
  for (let i2 = 0; i2 < array.length; i2 += 16) {
    const w = array.subarray(i2, i2 + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base642(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a = bytes[i2 + 0];
    const b = bytes[i2 + 1];
    const c = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c;
    bytes[i2 + 2] = b;
    bytes[i2 + 3] = a;
  }
}
function encode(str) {
  const encoded = encoder.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base642(bytes) {
  const l = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l; i2 += 3) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += chars[bytes[i2] & 63];
  }
  if (i2 === l + 1) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var csp_ready;
var generate_nonce;
var generate_hash;
if (typeof crypto !== "undefined") {
  const array = new Uint8Array(16);
  generate_nonce = () => {
    crypto.getRandomValues(array);
    return base642(array);
  };
  generate_hash = sha256;
} else {
  const name4 = "crypto";
  csp_ready = import(name4).then((crypto2) => {
    generate_nonce = () => {
      return crypto2.randomBytes(16).toString("base64");
    };
    generate_hash = (input) => {
      return crypto2.createHash("sha256").update(input, "utf-8").digest().toString("base64");
    };
  });
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var Csp = class {
  constructor({ mode, directives }, { dev, prerender, needs_nonce }) {
    __privateAdd(this, _use_hashes, void 0);
    __privateAdd(this, _dev, void 0);
    __privateAdd(this, _script_needs_csp, void 0);
    __privateAdd(this, _style_needs_csp, void 0);
    __privateAdd(this, _directives, void 0);
    __privateAdd(this, _script_src, void 0);
    __privateAdd(this, _style_src, void 0);
    __privateSet(this, _use_hashes, mode === "hash" || mode === "auto" && prerender);
    __privateSet(this, _directives, dev ? __spreadValues({}, directives) : directives);
    __privateSet(this, _dev, dev);
    const d = __privateGet(this, _directives);
    if (dev) {
      const effective_style_src2 = d["style-src"] || d["default-src"];
      if (effective_style_src2 && !effective_style_src2.includes("unsafe-inline")) {
        d["style-src"] = [...effective_style_src2, "unsafe-inline"];
      }
    }
    __privateSet(this, _script_src, []);
    __privateSet(this, _style_src, []);
    const effective_script_src = d["script-src"] || d["default-src"];
    const effective_style_src = d["style-src"] || d["default-src"];
    __privateSet(this, _script_needs_csp, !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0);
    __privateSet(this, _style_needs_csp, !dev && !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0);
    this.script_needs_nonce = __privateGet(this, _script_needs_csp) && !__privateGet(this, _use_hashes);
    this.style_needs_nonce = __privateGet(this, _style_needs_csp) && !__privateGet(this, _use_hashes);
    if (this.script_needs_nonce || this.style_needs_nonce || needs_nonce) {
      this.nonce = generate_nonce();
    }
  }
  add_script(content) {
    if (__privateGet(this, _script_needs_csp)) {
      if (__privateGet(this, _use_hashes)) {
        __privateGet(this, _script_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet(this, _script_src).length === 0) {
        __privateGet(this, _script_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  add_style(content) {
    if (__privateGet(this, _style_needs_csp)) {
      if (__privateGet(this, _use_hashes)) {
        __privateGet(this, _style_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet(this, _style_src).length === 0) {
        __privateGet(this, _style_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  get_header(is_meta = false) {
    const header = [];
    const directives = __spreadValues({}, __privateGet(this, _directives));
    if (__privateGet(this, _style_src).length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...__privateGet(this, _style_src)
      ];
    }
    if (__privateGet(this, _script_src).length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...__privateGet(this, _script_src)
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = directives[key2];
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
  get_meta() {
    const content = escape_html_attr(this.get_header(true));
    return `<meta http-equiv="content-security-policy" content=${content}>`;
  }
};
_use_hashes = new WeakMap();
_dev = new WeakMap();
_script_needs_csp = new WeakMap();
_style_needs_csp = new WeakMap();
_directives = new WeakMap();
_script_src = new WeakMap();
_style_src = new WeakMap();
var updated = __spreadProps(__spreadValues({}, readable(false)), {
  check: () => false
});
async function render_response({
  branch,
  options,
  state,
  $session,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  stuff
}) {
  if (state.prerender) {
    if (options.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options.template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %svelte.nonce%");
    }
  }
  const stylesheets = new Set(options.manifest._.entry.css);
  const modulepreloads = new Set(options.manifest._.entry.js);
  const styles = /* @__PURE__ */ new Map();
  const serialized_data = [];
  let shadow_props;
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options.get_stack(error2);
  }
  if (resolve_opts.ssr) {
    branch.forEach(({ node, props: props2, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => stylesheets.add(url));
      if (node.js)
        node.js.forEach((url) => modulepreloads.add(url));
      if (node.styles)
        Object.entries(node.styles).forEach(([k, v]) => styles.set(k, v));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (props2)
        shadow_props = props2;
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session,
        updated
      },
      page: {
        error: error2,
        params: event.params,
        routeId: event.routeId,
        status,
        stuff,
        url: state.prerender ? create_prerendering_url_proxy(event.url) : event.url
      },
      components: branch.map(({ node }) => node.module.default)
    };
    const print_error = (property, replacement) => {
      Object.defineProperty(props.page, property, {
        get: () => {
          throw new Error(`$page.${property} has been replaced by $page.url.${replacement}`);
        }
      });
    };
    print_error("origin", "origin");
    print_error("path", "pathname");
    print_error("query", "searchParams");
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let { head, html: body } = rendered;
  const inlined_style = Array.from(styles.values()).join("\n");
  await csp_ready;
  const csp = new Csp(options.csp, {
    dev: options.dev,
    prerender: !!state.prerender,
    needs_nonce: options.template_contains_nonce
  });
  const target = hash(body);
  const init_app = `
		import { start } from ${s2(options.prefix + options.manifest._.entry.file)};
		start({
			target: document.querySelector('[data-hydrate="${target}"]').parentNode,
			paths: ${s2(options.paths)},
			session: ${try_serialize($session, (error3) => {
    throw new Error(`Failed to serialize session data: ${error3.message}`);
  })},
			route: ${!!page_config.router},
			spa: ${!resolve_opts.ssr},
			trailing_slash: ${s2(options.trailing_slash)},
			hydrate: ${resolve_opts.ssr && page_config.hydrate ? `{
				status: ${status},
				error: ${serialize_error(error2)},
				nodes: [
					${(branch || []).map(({ node }) => `import(${s2(options.prefix + node.entry)})`).join(",\n						")}
				],
				params: ${devalue(event.params)},
				routeId: ${s2(event.routeId)}
			}` : "null"}
		});
	`;
  const init_service_worker = `
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('${options.service_worker}');
		}
	`;
  if (options.amp) {
    const styles2 = `${inlined_style}
${rendered.css.code}`;
    head += `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>

		<style amp-custom>${styles2}</style>`;
    if (options.service_worker) {
      head += '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>';
      body += `<amp-install-serviceworker src="${options.service_worker}" layout="nodisplay"></amp-install-serviceworker>`;
    }
  } else {
    if (inlined_style) {
      const attributes = [];
      if (options.dev)
        attributes.push(" data-svelte");
      if (csp.style_needs_nonce)
        attributes.push(` nonce="${csp.nonce}"`);
      csp.add_style(inlined_style);
      head += `
	<style${attributes.join("")}>${inlined_style}</style>`;
    }
    head += Array.from(stylesheets).map((dep) => {
      const attributes = [
        'rel="stylesheet"',
        `href="${options.prefix + dep}"`
      ];
      if (csp.style_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      if (styles.has(dep)) {
        attributes.push("disabled", 'media="(max-width: 0)"');
      }
      return `
	<link ${attributes.join(" ")}>`;
    }).join("");
    if (page_config.router || page_config.hydrate) {
      head += Array.from(modulepreloads).map((dep) => `
	<link rel="modulepreload" href="${options.prefix + dep}">`).join("");
      const attributes = ['type="module"', `data-hydrate="${target}"`];
      csp.add_script(init_app);
      if (csp.script_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      body += `
		<script ${attributes.join(" ")}>${init_app}<\/script>`;
      body += serialized_data.map(({ url, body: body2, response }) => render_json_payload_script({ type: "data", url, body: typeof body2 === "string" ? hash(body2) : void 0 }, response)).join("\n	");
      if (shadow_props) {
        body += render_json_payload_script({ type: "props" }, shadow_props);
      }
    }
    if (options.service_worker) {
      csp.add_script(init_service_worker);
      head += `
				<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_service_worker}<\/script>`;
    }
  }
  if (state.prerender && !options.amp) {
    const http_equiv = [];
    const csp_headers = csp.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (maxage) {
      http_equiv.push(`<meta http-equiv="cache-control" content="max-age=${maxage}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  }
  const segments = event.url.pathname.slice(options.paths.base.length).split("/").slice(2);
  const assets2 = options.paths.assets || (segments.length > 0 ? segments.map(() => "..").join("/") : ".");
  const html = await resolve_opts.transformPage({
    html: options.template({ head, body, assets: assets2, nonce: csp.nonce })
  });
  const headers = new Headers({
    "content-type": "text/html",
    etag: `"${hash(html)}"`
  });
  if (maxage) {
    headers.set("cache-control", `${is_private ? "private" : "public"}, max-age=${maxage}`);
  }
  if (!options.floc) {
    headers.set("permissions-policy", "interest-cohort=()");
  }
  if (!state.prerender) {
    const csp_header = csp.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
  }
  return new Response(html, {
    status,
    headers
  });
}
function try_serialize(data, fail2) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail2)
      fail2(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name: name4, message, stack } = error2;
    serialized = try_serialize(__spreadProps(__spreadValues({}, error2), { name: name4, message, stack }));
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var absolute = /^([a-z]+:)?\/?\//;
var scheme = /^[a-z]+:/;
function resolve(base2, path2) {
  if (scheme.test(path2))
    return path2;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path2);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path2.slice(path_match[0].length).split("/") : path2.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path2) {
  return path2[0] === "/" && path2[1] !== "/";
}
function normalize_path(path2, trailing_slash) {
  if (path2 === "/" || trailing_slash === "ignore")
    return path2;
  if (trailing_slash === "never") {
    return path2.endsWith("/") ? path2.slice(0, -1) : path2;
  } else if (trailing_slash === "always" && /\/[^./]+$/.test(path2)) {
    return path2 + "/";
  }
  return path2;
}
async function load_node({
  event,
  options,
  state,
  route,
  node,
  $session,
  stuff,
  is_error,
  is_leaf,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const shadow = is_leaf ? await load_shadow_data(route, event, options, !!state.prerender) : {};
  if (shadow.cookies) {
    set_cookie_headers.push(...shadow.cookies);
  }
  if (shadow.error) {
    loaded = {
      status: shadow.status,
      error: shadow.error
    };
  } else if (shadow.redirect) {
    loaded = {
      status: shadow.status,
      redirect: shadow.redirect
    };
  } else if (module2.load) {
    const load_input = {
      url: state.prerender ? create_prerendering_url_proxy(event.url) : event.url,
      params: event.params,
      props: shadow.body || {},
      routeId: event.routeId,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let requested;
        if (typeof resource === "string") {
          requested = resource;
        } else {
          requested = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        opts.headers = new Headers(opts.headers);
        for (const [key2, value] of event.request.headers) {
          if (key2 !== "authorization" && key2 !== "cookie" && key2 !== "host" && key2 !== "if-none-match" && !opts.headers.has(key2)) {
            opts.headers.set(key2, value);
          }
        }
        const resolved = resolve(event.url.pathname, requested.split("?")[0]);
        let response;
        let dependency;
        const prefix = options.paths.assets || options.paths.base;
        const filename = decodeURIComponent(resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = options.manifest.assets.has(filename);
        const is_asset_html = options.manifest.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (options.read) {
            const type = is_asset ? options.manifest.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            response = new Response(options.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else {
            response = await fetch(`${event.url.origin}/${file}`, opts);
          }
        } else if (is_root_relative(resolved)) {
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie = event.request.headers.get("cookie");
            const authorization = event.request.headers.get("authorization");
            if (cookie) {
              opts.headers.set("cookie", cookie);
            }
            if (authorization && !opts.headers.has("authorization")) {
              opts.headers.set("authorization", authorization);
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          response = await respond(new Request(new URL(requested, event.url).href, opts), options, {
            getClientAddress: state.getClientAddress,
            initiator: route,
            prerender: state.prerender
          });
          if (state.prerender) {
            dependency = { response, body: null };
            state.prerender.dependencies.set(resolved, dependency);
          }
        } else {
          if (resolved.startsWith("//")) {
            requested = event.url.protocol + requested;
          }
          if (`.${new URL(requested).hostname}`.endsWith(`.${event.url.hostname}`) && opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie = event.request.headers.get("cookie");
            if (cookie)
              opts.headers.set("cookie", cookie);
          }
          const external_request = new Request(requested, opts);
          response = await options.hooks.externalFetch.call(null, external_request);
        }
        const proxy = new Proxy(response, {
          get(response2, key2, _receiver) {
            async function text() {
              const body = await response2.text();
              const headers = {};
              for (const [key3, value] of response2.headers) {
                if (key3 === "set-cookie") {
                  set_cookie_headers = set_cookie_headers.concat(value);
                } else if (key3 !== "etag") {
                  headers[key3] = value;
                }
              }
              if (!opts.body || typeof opts.body === "string") {
                const status_number = Number(response2.status);
                if (isNaN(status_number)) {
                  throw new Error(`response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`);
                }
                fetched.push({
                  url: requested,
                  body: opts.body,
                  response: {
                    status: status_number,
                    statusText: response2.statusText,
                    headers,
                    body
                  }
                });
              }
              if (dependency) {
                dependency.body = body;
              }
              return body;
            }
            if (key2 === "arrayBuffer") {
              return async () => {
                const buffer = await response2.arrayBuffer();
                if (dependency) {
                  dependency.body = new Uint8Array(buffer);
                }
                return buffer;
              };
            }
            if (key2 === "text") {
              return text;
            }
            if (key2 === "json") {
              return async () => {
                return JSON.parse(await text());
              };
            }
            return Reflect.get(response2, key2, response2);
          }
        });
        return proxy;
      },
      stuff: __spreadValues({}, stuff)
    };
    if (options.dev) {
      Object.defineProperty(load_input, "page", {
        get: () => {
          throw new Error("`page` in `load` functions has been replaced by `url` and `params`");
        }
      });
    }
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
    if (!loaded) {
      throw new Error(`load function must return a value${options.dev ? ` (${node.entry})` : ""}`);
    }
    if (loaded.fallthrough) {
      throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
    }
  } else if (shadow.body) {
    loaded = {
      props: shadow.body
    };
  } else {
    loaded = {};
  }
  if (shadow.body && state.prerender) {
    const pathname = `${event.url.pathname.replace(/\/$/, "")}/__data.json`;
    const dependency = {
      response: new Response(void 0),
      body: JSON.stringify(shadow.body)
    };
    state.prerender.dependencies.set(pathname, dependency);
  }
  return {
    node,
    props: shadow.body,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function load_shadow_data(route, event, options, prerender) {
  if (!route.shadow)
    return {};
  try {
    const mod2 = await route.shadow();
    if (prerender && (mod2.post || mod2.put || mod2.del || mod2.patch)) {
      throw new Error("Cannot prerender pages that have endpoints with mutative methods");
    }
    const method = normalize_request_method(event);
    const is_get = method === "head" || method === "get";
    const handler = method === "head" ? mod2.head || mod2.get : mod2[method];
    if (!handler && !is_get) {
      return {
        status: 405,
        error: new Error(`${method} method not allowed`)
      };
    }
    const data = {
      status: 200,
      cookies: [],
      body: {}
    };
    if (!is_get) {
      const result = await handler(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      data.status = status;
      add_cookies(data.cookies, headers);
      if (status >= 300 && status < 400) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = body;
    }
    const get = method === "head" && mod2.head || mod2.get;
    if (get) {
      const result = await get(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      add_cookies(data.cookies, headers);
      data.status = status;
      if (status >= 400) {
        data.error = new Error("Failed to load data");
        return data;
      }
      if (status >= 300) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = __spreadValues(__spreadValues({}, body), data.body);
    }
    return data;
  } catch (e2) {
    const error2 = coalesce_to_error(e2);
    options.handle_error(error2, event);
    return {
      status: 500,
      error: error2
    };
  }
}
function add_cookies(target, headers) {
  const cookies = headers["set-cookie"];
  if (cookies) {
    if (Array.isArray(cookies)) {
      target.push(...cookies);
    } else {
      target.push(cookies);
    }
  }
}
function validate_shadow_output(result) {
  const { status = 200, body = {} } = result;
  let headers = result.headers || {};
  if (headers instanceof Headers) {
    if (headers.has("set-cookie")) {
      throw new Error("Endpoint request handler cannot use Headers interface with Set-Cookie headers");
    }
  } else {
    headers = lowercase_keys(headers);
  }
  if (!is_pojo(body)) {
    throw new Error("Body returned from endpoint request handler must be a plain object");
  }
  return { status, headers, body };
}
async function respond_with_error({
  event,
  options,
  state,
  $session,
  status,
  error: error2,
  resolve_opts
}) {
  try {
    const default_layout = await options.manifest._.nodes[0]();
    const default_error = await options.manifest._.nodes[1]();
    const layout_loaded = await load_node({
      event,
      options,
      state,
      route: null,
      node: default_layout,
      $session,
      stuff: {},
      is_error: false,
      is_leaf: false
    });
    const error_loaded = await load_node({
      event,
      options,
      state,
      route: null,
      node: default_error,
      $session,
      stuff: layout_loaded ? layout_loaded.stuff : {},
      is_error: true,
      is_leaf: false,
      status,
      error: error2
    });
    return await render_response({
      options,
      state,
      $session,
      page_config: {
        hydrate: options.hydrate,
        router: options.router
      },
      stuff: error_loaded.stuff,
      status,
      error: error2,
      branch: [layout_loaded, error_loaded],
      event,
      resolve_opts
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return new Response(error3.stack, {
      status: 500
    });
  }
}
async function respond$1(opts) {
  const { event, options, state, $session, route, resolve_opts } = opts;
  let nodes;
  if (!resolve_opts.ssr) {
    return await render_response(__spreadProps(__spreadValues({}, opts), {
      branch: [],
      page_config: {
        hydrate: true,
        router: true
      },
      status: 200,
      error: null,
      event,
      stuff: {}
    }));
  }
  try {
    nodes = await Promise.all(route.a.map((n) => options.manifest._.nodes[n] && options.manifest._.nodes[n]()));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return await respond_with_error({
      event,
      options,
      state,
      $session,
      status: 500,
      error: error3,
      resolve_opts
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options);
  if (state.prerender) {
    const should_prerender = leaf.prerender ?? state.prerender.default;
    if (!should_prerender) {
      return new Response(void 0, {
        status: 204
      });
    }
  }
  let branch = [];
  let status = 200;
  let error2 = null;
  let set_cookie_headers = [];
  let stuff = {};
  ssr:
    if (resolve_opts.ssr) {
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
              node,
              stuff,
              is_error: false,
              is_leaf: i2 === nodes.length - 1
            }));
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies(new Response(void 0, {
                status: loaded.loaded.status,
                headers: {
                  location: loaded.loaded.redirect
                }
              }), set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e2 = coalesce_to_error(err);
            options.handle_error(e2, event);
            status = 500;
            error2 = e2;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const error_node = await options.manifest._.nodes[route.b[i2]]();
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
                    node: error_node,
                    stuff: node_loaded.stuff,
                    is_error: true,
                    is_leaf: false,
                    status,
                    error: error2
                  }));
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  stuff = __spreadValues(__spreadValues({}, node_loaded.stuff), error_loaded.stuff);
                  break ssr;
                } catch (err) {
                  const e2 = coalesce_to_error(err);
                  options.handle_error(e2, event);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              event,
              options,
              state,
              $session,
              status,
              error: error2,
              resolve_opts
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = __spreadValues(__spreadValues({}, stuff), loaded.loaded.stuff);
        }
      }
    }
  try {
    return with_cookies(await render_response(__spreadProps(__spreadValues({}, opts), {
      stuff,
      event,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    })), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options.handle_error(error3, event);
    return with_cookies(await respond_with_error(__spreadProps(__spreadValues({}, opts), {
      status: 500,
      error: error3
    })), set_cookie_headers);
  }
}
function get_page_config(leaf, options) {
  if ("ssr" in leaf) {
    throw new Error("`export const ssr` has been removed \u2014 use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle");
  }
  return {
    router: "router" in leaf ? !!leaf.router : options.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    set_cookie_headers.forEach((value) => {
      response.headers.append("set-cookie", value);
    });
  }
  return response;
}
async function render_page(event, route, options, state, resolve_opts) {
  if (state.initiator === route) {
    return new Response(`Not found: ${event.url.pathname}`, {
      status: 404
    });
  }
  if (route.shadow) {
    const type = negotiate(event.request.headers.get("accept") || "text/html", [
      "text/html",
      "application/json"
    ]);
    if (type === "application/json") {
      return render_endpoint(event, await route.shadow());
    }
  }
  const $session = await options.hooks.getSession(event);
  return respond$1({
    event,
    options,
    state,
    $session,
    resolve_opts,
    route
  });
}
function negotiate(accept, types2) {
  const parts = accept.split(",").map((str, i2) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      return { type, subtype, q: +q, i: i2 };
    }
    throw new Error(`Invalid Accept header: ${accept}`);
  }).sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types2) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex((part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*"));
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function exec(match, names, types2, matchers) {
  const params = {};
  for (let i2 = 0; i2 < names.length; i2 += 1) {
    const name4 = names[i2];
    const type = types2[i2];
    const value = match[i2 + 1] || "";
    if (type) {
      const matcher = matchers[type];
      if (!matcher)
        throw new Error(`Missing "${type}" param matcher`);
      if (!matcher(value))
        return;
    }
    params[name4] = value;
  }
  return params;
}
var DATA_SUFFIX = "/__data.json";
var default_transform = ({ html }) => html;
async function respond(request, options, state) {
  var _a, _b, _c;
  let url = new URL(request.url);
  const normalized = normalize_path(url.pathname, options.trailing_slash);
  if (normalized !== url.pathname && !((_a = state.prerender) == null ? void 0 : _a.fallback)) {
    return new Response(void 0, {
      status: 301,
      headers: {
        location: normalized + (url.search === "?" ? "" : url.search)
      }
    });
  }
  const { parameter, allowed } = options.method_override;
  const method_override = (_b = url.searchParams.get(parameter)) == null ? void 0 : _b.toUpperCase();
  if (method_override) {
    if (request.method === "POST") {
      if (allowed.includes(method_override)) {
        request = new Proxy(request, {
          get: (target, property, _receiver) => {
            if (property === "method")
              return method_override;
            return Reflect.get(target, property, target);
          }
        });
      } else {
        const verb = allowed.length === 0 ? "enabled" : "allowed";
        const body = `${parameter}=${method_override} is not ${verb}. See https://kit.svelte.dev/docs/configuration#methodoverride`;
        return new Response(body, {
          status: 400
        });
      }
    } else {
      throw new Error(`${parameter}=${method_override} is only allowed with POST requests`);
    }
  }
  let decoded = decodeURI(url.pathname);
  let route = null;
  let params = {};
  if (options.paths.base && !((_c = state.prerender) == null ? void 0 : _c.fallback)) {
    if (!decoded.startsWith(options.paths.base)) {
      return new Response(void 0, { status: 404 });
    }
    decoded = decoded.slice(options.paths.base.length) || "/";
  }
  const is_data_request = decoded.endsWith(DATA_SUFFIX);
  if (is_data_request) {
    decoded = decoded.slice(0, -DATA_SUFFIX.length) || "/";
    const normalized2 = normalize_path(url.pathname.slice(0, -DATA_SUFFIX.length), options.trailing_slash);
    url = new URL(url.origin + normalized2 + url.search);
  }
  if (!state.prerender || !state.prerender.fallback) {
    const matchers = await options.manifest._.matchers();
    for (const candidate of options.manifest._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.names, candidate.types, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  const event = {
    get clientAddress() {
      if (!state.getClientAddress) {
        throw new Error(`${"appengine"} does not specify getClientAddress. Please raise an issue`);
      }
      Object.defineProperty(event, "clientAddress", {
        value: state.getClientAddress()
      });
      return event.clientAddress;
    },
    locals: {},
    params,
    platform: state.platform,
    request,
    routeId: route && route.id,
    url
  };
  const removed = (property, replacement, suffix = "") => ({
    get: () => {
      throw new Error(`event.${property} has been replaced by event.${replacement}` + suffix);
    }
  });
  const details = ". See https://github.com/sveltejs/kit/pull/3384 for details";
  const body_getter = {
    get: () => {
      throw new Error("To access the request body use the text/json/arrayBuffer/formData methods, e.g. `body = await request.json()`" + details);
    }
  };
  Object.defineProperties(event, {
    method: removed("method", "request.method", details),
    headers: removed("headers", "request.headers", details),
    origin: removed("origin", "url.origin"),
    path: removed("path", "url.pathname"),
    query: removed("query", "url.searchParams"),
    body: body_getter,
    rawBody: body_getter
  });
  let resolve_opts = {
    ssr: true,
    transformPage: default_transform
  };
  try {
    const response = await options.hooks.handle({
      event,
      resolve: async (event2, opts) => {
        if (opts) {
          resolve_opts = {
            ssr: opts.ssr !== false,
            transformPage: opts.transformPage || default_transform
          };
        }
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            event: event2,
            options,
            state,
            $session: await options.hooks.getSession(event2),
            page_config: { router: true, hydrate: true },
            stuff: {},
            status: 200,
            error: null,
            branch: [],
            resolve_opts: __spreadProps(__spreadValues({}, resolve_opts), {
              ssr: false
            })
          });
        }
        if (route) {
          let response2;
          if (is_data_request && route.type === "page" && route.shadow) {
            response2 = await render_endpoint(event2, await route.shadow());
            if (request.headers.has("x-sveltekit-load")) {
              if (response2.status >= 300 && response2.status < 400) {
                const location2 = response2.headers.get("location");
                if (location2) {
                  const headers = new Headers(response2.headers);
                  headers.set("x-sveltekit-location", location2);
                  response2 = new Response(void 0, {
                    status: 204,
                    headers
                  });
                }
              }
            }
          } else {
            response2 = route.type === "endpoint" ? await render_endpoint(event2, await route.load()) : await render_page(event2, route, options, state, resolve_opts);
          }
          if (response2) {
            if (response2.status === 200 && response2.headers.has("etag")) {
              let if_none_match_value = request.headers.get("if-none-match");
              if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                if_none_match_value = if_none_match_value.substring(2);
              }
              const etag = response2.headers.get("etag");
              if (if_none_match_value === etag) {
                const headers = new Headers({ etag });
                for (const key2 of [
                  "cache-control",
                  "content-location",
                  "date",
                  "expires",
                  "vary"
                ]) {
                  const value = response2.headers.get(key2);
                  if (value)
                    headers.set(key2, value);
                }
                return new Response(void 0, {
                  status: 304,
                  headers
                });
              }
            }
            return response2;
          }
        }
        if (!state.initiator) {
          const $session = await options.hooks.getSession(event2);
          return await respond_with_error({
            event: event2,
            options,
            state,
            $session,
            status: 404,
            error: new Error(`Not found: ${event2.url.pathname}`),
            resolve_opts
          });
        }
        if (state.prerender) {
          return new Response("not found", { status: 404 });
        }
        return await fetch(request);
      },
      get request() {
        throw new Error("request in handle has been replaced with event" + details);
      }
    });
    if (response && !(response instanceof Response)) {
      throw new Error("handle must return a Response object" + details);
    }
    return response;
  } catch (e2) {
    const error2 = coalesce_to_error(e2);
    options.handle_error(error2, event);
    try {
      const $session = await options.hooks.getSession(event);
      return await respond_with_error({
        event,
        options,
        state,
        $session,
        status: 500,
        error: error2,
        resolve_opts
      });
    } catch (e22) {
      const error3 = coalesce_to_error(e22);
      return new Response(options.dev ? error3.stack : error3.message, {
        status: 500
      });
    }
  }
}
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
var template = ({ head, body, assets: assets2, nonce }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<meta name="description" content="" />\n		<link rel="icon" href="' + assets2 + '/treeMarker.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		<link href="https://api.mapbox.com/mapbox-assembly/v0.23.2/assembly.min.css" rel="stylesheet"/>\n  		<script src="https://api.mapbox.com/mapbox-assembly/v0.23.2/assembly.js"><\/script>\n		' + head + "\n	</head>\n	<body>\n		<div>" + body + "</div>\n	</body>\n</html>\n";
var read = null;
set_paths({ "base": "", "assets": "" });
var Server = class {
  constructor(manifest2) {
    this.options = {
      amp: false,
      csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
      dev: false,
      floc: false,
      get_stack: (error2) => String(error2),
      handle_error: (error2, event) => {
        this.options.hooks.handleError({
          error: error2,
          event,
          get request() {
            throw new Error("request in handleError has been replaced with event. See https://github.com/sveltejs/kit/pull/3384 for details");
          }
        });
        error2.stack = this.options.get_stack(error2);
      },
      hooks: null,
      hydrate: true,
      manifest: manifest2,
      method_override: { "parameter": "_method", "allowed": [] },
      paths: { base, assets },
      prefix: assets + "/_app/",
      prerender: true,
      read,
      root: Root,
      service_worker: null,
      router: true,
      template,
      template_contains_nonce: false,
      trailing_slash: "never"
    };
  }
  async respond(request, options = {}) {
    if (!(request instanceof Request)) {
      throw new Error("The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details");
    }
    if (!this.options.hooks) {
      const module2 = await Promise.resolve().then(() => (init_hooks_1c45ba0b(), hooks_1c45ba0b_exports));
      this.options.hooks = {
        getSession: module2.getSession || (() => ({})),
        handle: module2.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
        handleError: module2.handleError || (({ error: error2 }) => console.error(error2.stack)),
        externalFetch: module2.externalFetch || fetch
      };
    }
    return respond(request, this.options, options);
  }
};

// .svelte-kit/appengine-tmp/entry.js
installFetch();
var app = new Server(manifest);
var staticServe = (0, import_sirv.default)(import_node_path2.default.join(__dirname, "storage"), {
  etag: true,
  maxAge: 0,
  immutable: false,
  gzip: true,
  brotli: true
});
function createKitMiddleware() {
  return async (request_, response) => {
    let request;
    try {
      request = await getRequest(getBase(request_.headers), request_);
    } catch (error2) {
      response.statusCode = error2.status || 400;
      return response.end(error2.reason || "Invalid request body");
    }
    setResponse(response, await app.respond(request));
  };
}
function getBase(headers) {
  const protocol = "https";
  const host = headers.host;
  return `${protocol}://${host}`;
}
var kitMiddleware = createKitMiddleware();
var server = build_default().use(staticServe).use((0, import_compression.default)({ threshold: 0 }), kitMiddleware);
var port = process.env.PORT || 8080;
var listenOptions = { port };
server.listen(listenOptions, () => {
  console.log(`Listening on ${port}`);
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  server
});
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * compressible
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Jeremiah Senkpiel
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * compression
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * on-headers
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law | agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
